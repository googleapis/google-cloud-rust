// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Hierarchical advanced settings for agent/flow/page/fulfillment/parameter.
/// Settings exposed at lower level overrides the settings exposed at higher
/// level. Overriding occurs at the sub-setting level. For example, the
/// playback_interruption_settings at fulfillment level only overrides the
/// playback_interruption_settings at the agent level, leaving other settings
/// at the agent level unchanged.
///
/// DTMF settings does not override each other. DTMF settings set at different
/// levels define DTMF detections running in parallel.
///
/// Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AdvancedSettings {
    /// If present, incoming audio is exported by Dialogflow to the configured
    /// Google Cloud Storage destination.
    /// Exposed at the following levels:
    ///
    /// - Agent level
    /// - Flow level
    pub audio_export_gcs_destination: std::option::Option<crate::model::GcsDestination>,

    /// Settings for speech to text detection.
    /// Exposed at the following levels:
    ///
    /// - Agent level
    /// - Flow level
    /// - Page level
    /// - Parameter level
    pub speech_settings: std::option::Option<crate::model::advanced_settings::SpeechSettings>,

    /// Settings for DTMF.
    /// Exposed at the following levels:
    ///
    /// - Agent level
    /// - Flow level
    /// - Page level
    /// - Parameter level.
    pub dtmf_settings: std::option::Option<crate::model::advanced_settings::DtmfSettings>,

    /// Settings for logging.
    /// Settings for Dialogflow History, Contact Center messages, StackDriver logs,
    /// and speech logging.
    /// Exposed at the following levels:
    ///
    /// - Agent level.
    pub logging_settings: std::option::Option<crate::model::advanced_settings::LoggingSettings>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl AdvancedSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audio_export_gcs_destination][crate::model::AdvancedSettings::audio_export_gcs_destination].
    pub fn set_audio_export_gcs_destination<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GcsDestination>,
    {
        self.audio_export_gcs_destination = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [audio_export_gcs_destination][crate::model::AdvancedSettings::audio_export_gcs_destination].
    pub fn set_or_clear_audio_export_gcs_destination<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GcsDestination>,
    {
        self.audio_export_gcs_destination = v.map(|x| x.into());
        self
    }

    /// Sets the value of [speech_settings][crate::model::AdvancedSettings::speech_settings].
    pub fn set_speech_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::advanced_settings::SpeechSettings>,
    {
        self.speech_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [speech_settings][crate::model::AdvancedSettings::speech_settings].
    pub fn set_or_clear_speech_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::advanced_settings::SpeechSettings>,
    {
        self.speech_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dtmf_settings][crate::model::AdvancedSettings::dtmf_settings].
    pub fn set_dtmf_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::advanced_settings::DtmfSettings>,
    {
        self.dtmf_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dtmf_settings][crate::model::AdvancedSettings::dtmf_settings].
    pub fn set_or_clear_dtmf_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::advanced_settings::DtmfSettings>,
    {
        self.dtmf_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logging_settings][crate::model::AdvancedSettings::logging_settings].
    pub fn set_logging_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::advanced_settings::LoggingSettings>,
    {
        self.logging_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_settings][crate::model::AdvancedSettings::logging_settings].
    pub fn set_or_clear_logging_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::advanced_settings::LoggingSettings>,
    {
        self.logging_settings = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl wkt::message::Message for AdvancedSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.AdvancedSettings"
    }
}

#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdvancedSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_export_gcs_destination,
            __speech_settings,
            __dtmf_settings,
            __logging_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdvancedSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioExportGcsDestination" => {
                                Ok(__FieldTag::__audio_export_gcs_destination)
                            }
                            "audio_export_gcs_destination" => {
                                Ok(__FieldTag::__audio_export_gcs_destination)
                            }
                            "speechSettings" => Ok(__FieldTag::__speech_settings),
                            "speech_settings" => Ok(__FieldTag::__speech_settings),
                            "dtmfSettings" => Ok(__FieldTag::__dtmf_settings),
                            "dtmf_settings" => Ok(__FieldTag::__dtmf_settings),
                            "loggingSettings" => Ok(__FieldTag::__logging_settings),
                            "logging_settings" => Ok(__FieldTag::__logging_settings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdvancedSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdvancedSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_export_gcs_destination => {
                            if !fields.insert(__FieldTag::__audio_export_gcs_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_export_gcs_destination",
                                ));
                            }
                            result.audio_export_gcs_destination = map
                                .next_value::<std::option::Option<crate::model::GcsDestination>>(
                                )?;
                        }
                        __FieldTag::__speech_settings => {
                            if !fields.insert(__FieldTag::__speech_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_settings",
                                ));
                            }
                            result.speech_settings = map.next_value::<std::option::Option<
                                crate::model::advanced_settings::SpeechSettings,
                            >>()?;
                        }
                        __FieldTag::__dtmf_settings => {
                            if !fields.insert(__FieldTag::__dtmf_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dtmf_settings",
                                ));
                            }
                            result.dtmf_settings = map.next_value::<std::option::Option<
                                crate::model::advanced_settings::DtmfSettings,
                            >>()?;
                        }
                        __FieldTag::__logging_settings => {
                            if !fields.insert(__FieldTag::__logging_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_settings",
                                ));
                            }
                            result.logging_settings = map.next_value::<std::option::Option<
                                crate::model::advanced_settings::LoggingSettings,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for AdvancedSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.audio_export_gcs_destination.is_some() {
            state.serialize_entry(
                "audioExportGcsDestination",
                &self.audio_export_gcs_destination,
            )?;
        }
        if self.speech_settings.is_some() {
            state.serialize_entry("speechSettings", &self.speech_settings)?;
        }
        if self.dtmf_settings.is_some() {
            state.serialize_entry("dtmfSettings", &self.dtmf_settings)?;
        }
        if self.logging_settings.is_some() {
            state.serialize_entry("loggingSettings", &self.logging_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AdvancedSettings].
#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
pub mod advanced_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Define behaviors of speech to text detection.
    #[cfg(any(
        feature = "agents",
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SpeechSettings {
        /// Sensitivity of the speech model that detects the end of speech.
        /// Scale from 0 to 100.
        pub endpointer_sensitivity: i32,

        /// Timeout before detecting no speech.
        pub no_speech_timeout: std::option::Option<wkt::Duration>,

        /// Use timeout based endpointing, interpreting endpointer sensitivity as
        /// seconds of timeout value.
        pub use_timeout_based_endpointing: bool,

        /// Mapping from language to Speech-to-Text model. The mapped Speech-to-Text
        /// model will be selected for requests from its corresponding language.
        /// For more information, see
        /// [Speech
        /// models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
        pub models: std::collections::HashMap<std::string::String, std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "agents",
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl SpeechSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [endpointer_sensitivity][crate::model::advanced_settings::SpeechSettings::endpointer_sensitivity].
        pub fn set_endpointer_sensitivity<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.endpointer_sensitivity = v.into();
            self
        }

        /// Sets the value of [no_speech_timeout][crate::model::advanced_settings::SpeechSettings::no_speech_timeout].
        pub fn set_no_speech_timeout<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.no_speech_timeout = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [no_speech_timeout][crate::model::advanced_settings::SpeechSettings::no_speech_timeout].
        pub fn set_or_clear_no_speech_timeout<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.no_speech_timeout = v.map(|x| x.into());
            self
        }

        /// Sets the value of [use_timeout_based_endpointing][crate::model::advanced_settings::SpeechSettings::use_timeout_based_endpointing].
        pub fn set_use_timeout_based_endpointing<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.use_timeout_based_endpointing = v.into();
            self
        }

        /// Sets the value of [models][crate::model::advanced_settings::SpeechSettings::models].
        pub fn set_models<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.models = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    #[cfg(any(
        feature = "agents",
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl wkt::message::Message for SpeechSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.AdvancedSettings.SpeechSettings"
        }
    }

    #[cfg(any(
        feature = "agents",
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SpeechSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __endpointer_sensitivity,
                __no_speech_timeout,
                __use_timeout_based_endpointing,
                __models,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SpeechSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "endpointerSensitivity" => Ok(__FieldTag::__endpointer_sensitivity),
                                "endpointer_sensitivity" => {
                                    Ok(__FieldTag::__endpointer_sensitivity)
                                }
                                "noSpeechTimeout" => Ok(__FieldTag::__no_speech_timeout),
                                "no_speech_timeout" => Ok(__FieldTag::__no_speech_timeout),
                                "useTimeoutBasedEndpointing" => {
                                    Ok(__FieldTag::__use_timeout_based_endpointing)
                                }
                                "use_timeout_based_endpointing" => {
                                    Ok(__FieldTag::__use_timeout_based_endpointing)
                                }
                                "models" => Ok(__FieldTag::__models),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SpeechSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SpeechSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__endpointer_sensitivity => {
                                if !fields.insert(__FieldTag::__endpointer_sensitivity) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for endpointer_sensitivity",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.endpointer_sensitivity =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__no_speech_timeout => {
                                if !fields.insert(__FieldTag::__no_speech_timeout) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for no_speech_timeout",
                                    ));
                                }
                                result.no_speech_timeout =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__use_timeout_based_endpointing => {
                                if !fields.insert(__FieldTag::__use_timeout_based_endpointing) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for use_timeout_based_endpointing",
                                    ));
                                }
                                result.use_timeout_based_endpointing = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__models => {
                                if !fields.insert(__FieldTag::__models) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for models",
                                    ));
                                }
                                result.models = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "agents",
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for SpeechSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.endpointer_sensitivity) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "endpointerSensitivity",
                    &__With(&self.endpointer_sensitivity),
                )?;
            }
            if self.no_speech_timeout.is_some() {
                state.serialize_entry("noSpeechTimeout", &self.no_speech_timeout)?;
            }
            if !wkt::internal::is_default(&self.use_timeout_based_endpointing) {
                state.serialize_entry(
                    "useTimeoutBasedEndpointing",
                    &self.use_timeout_based_endpointing,
                )?;
            }
            if !self.models.is_empty() {
                state.serialize_entry("models", &self.models)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Define behaviors for DTMF (dual tone multi frequency).
    #[cfg(any(
        feature = "agents",
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DtmfSettings {
        /// If true, incoming audio is processed for DTMF (dual tone multi frequency)
        /// events. For example, if the caller presses a button on their telephone
        /// keypad and DTMF processing is enabled, Dialogflow will detect the
        /// event (e.g. a "3" was pressed) in the incoming audio and pass the event
        /// to the bot to drive business logic (e.g. when 3 is pressed, return the
        /// account balance).
        pub enabled: bool,

        /// Max length of DTMF digits.
        pub max_digits: i32,

        /// The digit that terminates a DTMF digit sequence.
        pub finish_digit: std::string::String,

        /// Interdigit timeout setting for matching dtmf input to regex.
        pub interdigit_timeout_duration: std::option::Option<wkt::Duration>,

        /// Endpoint timeout setting for matching dtmf input to regex.
        pub endpointing_timeout_duration: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "agents",
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl DtmfSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::advanced_settings::DtmfSettings::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }

        /// Sets the value of [max_digits][crate::model::advanced_settings::DtmfSettings::max_digits].
        pub fn set_max_digits<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_digits = v.into();
            self
        }

        /// Sets the value of [finish_digit][crate::model::advanced_settings::DtmfSettings::finish_digit].
        pub fn set_finish_digit<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.finish_digit = v.into();
            self
        }

        /// Sets the value of [interdigit_timeout_duration][crate::model::advanced_settings::DtmfSettings::interdigit_timeout_duration].
        pub fn set_interdigit_timeout_duration<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.interdigit_timeout_duration = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [interdigit_timeout_duration][crate::model::advanced_settings::DtmfSettings::interdigit_timeout_duration].
        pub fn set_or_clear_interdigit_timeout_duration<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.interdigit_timeout_duration = v.map(|x| x.into());
            self
        }

        /// Sets the value of [endpointing_timeout_duration][crate::model::advanced_settings::DtmfSettings::endpointing_timeout_duration].
        pub fn set_endpointing_timeout_duration<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.endpointing_timeout_duration = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [endpointing_timeout_duration][crate::model::advanced_settings::DtmfSettings::endpointing_timeout_duration].
        pub fn set_or_clear_endpointing_timeout_duration<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.endpointing_timeout_duration = v.map(|x| x.into());
            self
        }
    }

    #[cfg(any(
        feature = "agents",
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl wkt::message::Message for DtmfSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.AdvancedSettings.DtmfSettings"
        }
    }

    #[cfg(any(
        feature = "agents",
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DtmfSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enabled,
                __max_digits,
                __finish_digit,
                __interdigit_timeout_duration,
                __endpointing_timeout_duration,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DtmfSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enabled" => Ok(__FieldTag::__enabled),
                                "maxDigits" => Ok(__FieldTag::__max_digits),
                                "max_digits" => Ok(__FieldTag::__max_digits),
                                "finishDigit" => Ok(__FieldTag::__finish_digit),
                                "finish_digit" => Ok(__FieldTag::__finish_digit),
                                "interdigitTimeoutDuration" => {
                                    Ok(__FieldTag::__interdigit_timeout_duration)
                                }
                                "interdigit_timeout_duration" => {
                                    Ok(__FieldTag::__interdigit_timeout_duration)
                                }
                                "endpointingTimeoutDuration" => {
                                    Ok(__FieldTag::__endpointing_timeout_duration)
                                }
                                "endpointing_timeout_duration" => {
                                    Ok(__FieldTag::__endpointing_timeout_duration)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DtmfSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DtmfSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enabled => {
                                if !fields.insert(__FieldTag::__enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enabled",
                                    ));
                                }
                                result.enabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__max_digits => {
                                if !fields.insert(__FieldTag::__max_digits) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_digits",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_digits =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__finish_digit => {
                                if !fields.insert(__FieldTag::__finish_digit) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for finish_digit",
                                    ));
                                }
                                result.finish_digit = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__interdigit_timeout_duration => {
                                if !fields.insert(__FieldTag::__interdigit_timeout_duration) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for interdigit_timeout_duration",
                                    ));
                                }
                                result.interdigit_timeout_duration =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__endpointing_timeout_duration => {
                                if !fields.insert(__FieldTag::__endpointing_timeout_duration) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for endpointing_timeout_duration",
                                    ));
                                }
                                result.endpointing_timeout_duration =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "agents",
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for DtmfSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.enabled) {
                state.serialize_entry("enabled", &self.enabled)?;
            }
            if !wkt::internal::is_default(&self.max_digits) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("maxDigits", &__With(&self.max_digits))?;
            }
            if !self.finish_digit.is_empty() {
                state.serialize_entry("finishDigit", &self.finish_digit)?;
            }
            if self.interdigit_timeout_duration.is_some() {
                state.serialize_entry(
                    "interdigitTimeoutDuration",
                    &self.interdigit_timeout_duration,
                )?;
            }
            if self.endpointing_timeout_duration.is_some() {
                state.serialize_entry(
                    "endpointingTimeoutDuration",
                    &self.endpointing_timeout_duration,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Define behaviors on logging.
    #[cfg(any(
        feature = "agents",
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LoggingSettings {
        /// Enables Google Cloud Logging.
        pub enable_stackdriver_logging: bool,

        /// Enables DF Interaction logging.
        pub enable_interaction_logging: bool,

        /// Enables consent-based end-user input redaction, if true, a pre-defined
        /// session parameter `$session.params.conversation-redaction` will be
        /// used to determine if the utterance should be redacted.
        pub enable_consent_based_redaction: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "agents",
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl LoggingSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enable_stackdriver_logging][crate::model::advanced_settings::LoggingSettings::enable_stackdriver_logging].
        pub fn set_enable_stackdriver_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_stackdriver_logging = v.into();
            self
        }

        /// Sets the value of [enable_interaction_logging][crate::model::advanced_settings::LoggingSettings::enable_interaction_logging].
        pub fn set_enable_interaction_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_interaction_logging = v.into();
            self
        }

        /// Sets the value of [enable_consent_based_redaction][crate::model::advanced_settings::LoggingSettings::enable_consent_based_redaction].
        pub fn set_enable_consent_based_redaction<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.enable_consent_based_redaction = v.into();
            self
        }
    }

    #[cfg(any(
        feature = "agents",
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl wkt::message::Message for LoggingSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.AdvancedSettings.LoggingSettings"
        }
    }

    #[cfg(any(
        feature = "agents",
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LoggingSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enable_stackdriver_logging,
                __enable_interaction_logging,
                __enable_consent_based_redaction,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LoggingSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enableStackdriverLogging" => {
                                    Ok(__FieldTag::__enable_stackdriver_logging)
                                }
                                "enable_stackdriver_logging" => {
                                    Ok(__FieldTag::__enable_stackdriver_logging)
                                }
                                "enableInteractionLogging" => {
                                    Ok(__FieldTag::__enable_interaction_logging)
                                }
                                "enable_interaction_logging" => {
                                    Ok(__FieldTag::__enable_interaction_logging)
                                }
                                "enableConsentBasedRedaction" => {
                                    Ok(__FieldTag::__enable_consent_based_redaction)
                                }
                                "enable_consent_based_redaction" => {
                                    Ok(__FieldTag::__enable_consent_based_redaction)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LoggingSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LoggingSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enable_stackdriver_logging => {
                                if !fields.insert(__FieldTag::__enable_stackdriver_logging) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_stackdriver_logging",
                                    ));
                                }
                                result.enable_stackdriver_logging = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__enable_interaction_logging => {
                                if !fields.insert(__FieldTag::__enable_interaction_logging) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_interaction_logging",
                                    ));
                                }
                                result.enable_interaction_logging = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__enable_consent_based_redaction => {
                                if !fields.insert(__FieldTag::__enable_consent_based_redaction) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_consent_based_redaction",
                                    ));
                                }
                                result.enable_consent_based_redaction = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "agents",
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for LoggingSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.enable_stackdriver_logging) {
                state.serialize_entry(
                    "enableStackdriverLogging",
                    &self.enable_stackdriver_logging,
                )?;
            }
            if !wkt::internal::is_default(&self.enable_interaction_logging) {
                state.serialize_entry(
                    "enableInteractionLogging",
                    &self.enable_interaction_logging,
                )?;
            }
            if !wkt::internal::is_default(&self.enable_consent_based_redaction) {
                state.serialize_entry(
                    "enableConsentBasedRedaction",
                    &self.enable_consent_based_redaction,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Settings related to speech recognition.
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SpeechToTextSettings {
    /// Whether to use speech adaptation for speech recognition.
    pub enable_speech_adaptation: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl SpeechToTextSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_speech_adaptation][crate::model::SpeechToTextSettings::enable_speech_adaptation].
    pub fn set_enable_speech_adaptation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_speech_adaptation = v.into();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for SpeechToTextSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.SpeechToTextSettings"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SpeechToTextSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_speech_adaptation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpeechToTextSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableSpeechAdaptation" => Ok(__FieldTag::__enable_speech_adaptation),
                            "enable_speech_adaptation" => {
                                Ok(__FieldTag::__enable_speech_adaptation)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SpeechToTextSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpeechToTextSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_speech_adaptation => {
                            if !fields.insert(__FieldTag::__enable_speech_adaptation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_speech_adaptation",
                                ));
                            }
                            result.enable_speech_adaptation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for SpeechToTextSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_speech_adaptation) {
            state.serialize_entry("enableSpeechAdaptation", &self.enable_speech_adaptation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Agents are best described as Natural Language Understanding (NLU) modules
/// that transform user requests into actionable data. You can include agents
/// in your app, product, or service to determine user intent and respond to the
/// user in a natural way.
///
/// After you create an agent, you can add
/// [Intents][google.cloud.dialogflow.cx.v3.Intent], [Entity
/// Types][google.cloud.dialogflow.cx.v3.EntityType],
/// [Flows][google.cloud.dialogflow.cx.v3.Flow],
/// [Fulfillments][google.cloud.dialogflow.cx.v3.Fulfillment],
/// [Webhooks][google.cloud.dialogflow.cx.v3.Webhook],
/// [TransitionRouteGroups][google.cloud.dialogflow.cx.v3.TransitionRouteGroup]
/// and so on to manage the conversation flows.
///
/// [google.cloud.dialogflow.cx.v3.EntityType]: crate::model::EntityType
/// [google.cloud.dialogflow.cx.v3.Flow]: crate::model::Flow
/// [google.cloud.dialogflow.cx.v3.Fulfillment]: crate::model::Fulfillment
/// [google.cloud.dialogflow.cx.v3.Intent]: crate::model::Intent
/// [google.cloud.dialogflow.cx.v3.TransitionRouteGroup]: crate::model::TransitionRouteGroup
/// [google.cloud.dialogflow.cx.v3.Webhook]: crate::model::Webhook
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Agent {
    /// The unique identifier of the agent.
    /// Required for the
    /// [Agents.UpdateAgent][google.cloud.dialogflow.cx.v3.Agents.UpdateAgent]
    /// method.
    /// [Agents.CreateAgent][google.cloud.dialogflow.cx.v3.Agents.CreateAgent]
    /// populates the name automatically.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Agents.CreateAgent]: crate::client::Agents::create_agent
    /// [google.cloud.dialogflow.cx.v3.Agents.UpdateAgent]: crate::client::Agents::update_agent
    pub name: std::string::String,

    /// Required. The human-readable name of the agent, unique within the location.
    pub display_name: std::string::String,

    /// Required. Immutable. The default language of the agent as a language tag.
    /// See [Language
    /// Support](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// for a list of the currently supported language codes.
    /// This field cannot be set by the
    /// [Agents.UpdateAgent][google.cloud.dialogflow.cx.v3.Agents.UpdateAgent]
    /// method.
    ///
    /// [google.cloud.dialogflow.cx.v3.Agents.UpdateAgent]: crate::client::Agents::update_agent
    pub default_language_code: std::string::String,

    /// The list of all languages supported by the agent (except for the
    /// `default_language_code`).
    pub supported_language_codes: std::vec::Vec<std::string::String>,

    /// Required. The time zone of the agent from the [time zone
    /// database](https://www.iana.org/time-zones), e.g., America/New_York,
    /// Europe/Paris.
    pub time_zone: std::string::String,

    /// The description of the agent. The maximum length is 500 characters. If
    /// exceeded, the request is rejected.
    pub description: std::string::String,

    /// The URI of the agent's avatar. Avatars are used throughout the Dialogflow
    /// console and in the self-hosted [Web
    /// Demo](https://cloud.google.com/dialogflow/docs/integrations/web-demo)
    /// integration.
    pub avatar_uri: std::string::String,

    /// Speech recognition related settings.
    pub speech_to_text_settings: std::option::Option<crate::model::SpeechToTextSettings>,

    /// Immutable. Name of the start flow in this agent. A start flow will be
    /// automatically created when the agent is created, and can only be deleted by
    /// deleting the agent. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>`.
    pub start_flow: std::string::String,

    /// Name of the
    /// [SecuritySettings][google.cloud.dialogflow.cx.v3.SecuritySettings]
    /// reference for the agent. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/securitySettings/<SecuritySettingsID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.SecuritySettings]: crate::model::SecuritySettings
    pub security_settings: std::string::String,

    /// Indicates if stackdriver logging is enabled for the agent.
    /// Please use
    /// [agent.advanced_settings][google.cloud.dialogflow.cx.v3.AdvancedSettings.LoggingSettings]
    /// instead.
    ///
    /// [google.cloud.dialogflow.cx.v3.AdvancedSettings.LoggingSettings]: crate::model::advanced_settings::LoggingSettings
    #[deprecated]
    pub enable_stackdriver_logging: bool,

    /// Indicates if automatic spell correction is enabled in detect intent
    /// requests.
    pub enable_spell_correction: bool,

    /// Optional. Enable training multi-lingual models for this agent. These models
    /// will be trained on all the languages supported by the agent.
    pub enable_multi_language_training: bool,

    /// Indicates whether the agent is locked for changes. If the agent is locked,
    /// modifications to the agent will be rejected except for [RestoreAgent][].
    pub locked: bool,

    /// Hierarchical advanced settings for this agent. The settings exposed at the
    /// lower level overrides the settings exposed at the higher level.
    pub advanced_settings: std::option::Option<crate::model::AdvancedSettings>,

    /// Git integration settings for this agent.
    pub git_integration_settings: std::option::Option<crate::model::agent::GitIntegrationSettings>,

    /// Settings on instructing the speech synthesizer on how to generate the
    /// output audio content.
    pub text_to_speech_settings: std::option::Option<crate::model::TextToSpeechSettings>,

    /// Gen App Builder-related agent-level settings.
    pub gen_app_builder_settings: std::option::Option<crate::model::agent::GenAppBuilderSettings>,

    /// Optional. Answer feedback collection settings.
    pub answer_feedback_settings: std::option::Option<crate::model::agent::AnswerFeedbackSettings>,

    /// Optional. Settings for end user personalization.
    pub personalization_settings: std::option::Option<crate::model::agent::PersonalizationSettings>,

    /// Optional. Settings for custom client certificates.
    pub client_certificate_settings:
        std::option::Option<crate::model::agent::ClientCertificateSettings>,

    /// Optional. Output only. A read only boolean field reflecting Zone Separation
    /// status of the agent.
    pub satisfies_pzs: std::option::Option<bool>,

    /// Optional. Output only. A read only boolean field reflecting Zone Isolation
    /// status of the agent.
    pub satisfies_pzi: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl Agent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Agent::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Agent::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [default_language_code][crate::model::Agent::default_language_code].
    pub fn set_default_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_language_code = v.into();
        self
    }

    /// Sets the value of [supported_language_codes][crate::model::Agent::supported_language_codes].
    pub fn set_supported_language_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.supported_language_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [time_zone][crate::model::Agent::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Agent::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [avatar_uri][crate::model::Agent::avatar_uri].
    pub fn set_avatar_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.avatar_uri = v.into();
        self
    }

    /// Sets the value of [speech_to_text_settings][crate::model::Agent::speech_to_text_settings].
    pub fn set_speech_to_text_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SpeechToTextSettings>,
    {
        self.speech_to_text_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [speech_to_text_settings][crate::model::Agent::speech_to_text_settings].
    pub fn set_or_clear_speech_to_text_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SpeechToTextSettings>,
    {
        self.speech_to_text_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_flow][crate::model::Agent::start_flow].
    pub fn set_start_flow<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.start_flow = v.into();
        self
    }

    /// Sets the value of [security_settings][crate::model::Agent::security_settings].
    pub fn set_security_settings<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.security_settings = v.into();
        self
    }

    /// Sets the value of [enable_stackdriver_logging][crate::model::Agent::enable_stackdriver_logging].
    #[deprecated]
    pub fn set_enable_stackdriver_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_stackdriver_logging = v.into();
        self
    }

    /// Sets the value of [enable_spell_correction][crate::model::Agent::enable_spell_correction].
    pub fn set_enable_spell_correction<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_spell_correction = v.into();
        self
    }

    /// Sets the value of [enable_multi_language_training][crate::model::Agent::enable_multi_language_training].
    pub fn set_enable_multi_language_training<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_multi_language_training = v.into();
        self
    }

    /// Sets the value of [locked][crate::model::Agent::locked].
    pub fn set_locked<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.locked = v.into();
        self
    }

    /// Sets the value of [advanced_settings][crate::model::Agent::advanced_settings].
    pub fn set_advanced_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedSettings>,
    {
        self.advanced_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [advanced_settings][crate::model::Agent::advanced_settings].
    pub fn set_or_clear_advanced_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedSettings>,
    {
        self.advanced_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [git_integration_settings][crate::model::Agent::git_integration_settings].
    pub fn set_git_integration_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::agent::GitIntegrationSettings>,
    {
        self.git_integration_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [git_integration_settings][crate::model::Agent::git_integration_settings].
    pub fn set_or_clear_git_integration_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::agent::GitIntegrationSettings>,
    {
        self.git_integration_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [text_to_speech_settings][crate::model::Agent::text_to_speech_settings].
    pub fn set_text_to_speech_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TextToSpeechSettings>,
    {
        self.text_to_speech_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [text_to_speech_settings][crate::model::Agent::text_to_speech_settings].
    pub fn set_or_clear_text_to_speech_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TextToSpeechSettings>,
    {
        self.text_to_speech_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gen_app_builder_settings][crate::model::Agent::gen_app_builder_settings].
    pub fn set_gen_app_builder_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::agent::GenAppBuilderSettings>,
    {
        self.gen_app_builder_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gen_app_builder_settings][crate::model::Agent::gen_app_builder_settings].
    pub fn set_or_clear_gen_app_builder_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::agent::GenAppBuilderSettings>,
    {
        self.gen_app_builder_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [answer_feedback_settings][crate::model::Agent::answer_feedback_settings].
    pub fn set_answer_feedback_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::agent::AnswerFeedbackSettings>,
    {
        self.answer_feedback_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [answer_feedback_settings][crate::model::Agent::answer_feedback_settings].
    pub fn set_or_clear_answer_feedback_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::agent::AnswerFeedbackSettings>,
    {
        self.answer_feedback_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [personalization_settings][crate::model::Agent::personalization_settings].
    pub fn set_personalization_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::agent::PersonalizationSettings>,
    {
        self.personalization_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [personalization_settings][crate::model::Agent::personalization_settings].
    pub fn set_or_clear_personalization_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::agent::PersonalizationSettings>,
    {
        self.personalization_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [client_certificate_settings][crate::model::Agent::client_certificate_settings].
    pub fn set_client_certificate_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::agent::ClientCertificateSettings>,
    {
        self.client_certificate_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_certificate_settings][crate::model::Agent::client_certificate_settings].
    pub fn set_or_clear_client_certificate_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::agent::ClientCertificateSettings>,
    {
        self.client_certificate_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Agent::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::Agent::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Agent::satisfies_pzi].
    pub fn set_satisfies_pzi<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzi][crate::model::Agent::satisfies_pzi].
    pub fn set_or_clear_satisfies_pzi<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for Agent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.Agent"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Agent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __default_language_code,
            __supported_language_codes,
            __time_zone,
            __description,
            __avatar_uri,
            __speech_to_text_settings,
            __start_flow,
            __security_settings,
            __enable_stackdriver_logging,
            __enable_spell_correction,
            __enable_multi_language_training,
            __locked,
            __advanced_settings,
            __git_integration_settings,
            __text_to_speech_settings,
            __gen_app_builder_settings,
            __answer_feedback_settings,
            __personalization_settings,
            __client_certificate_settings,
            __satisfies_pzs,
            __satisfies_pzi,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Agent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "defaultLanguageCode" => Ok(__FieldTag::__default_language_code),
                            "default_language_code" => Ok(__FieldTag::__default_language_code),
                            "supportedLanguageCodes" => Ok(__FieldTag::__supported_language_codes),
                            "supported_language_codes" => {
                                Ok(__FieldTag::__supported_language_codes)
                            }
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "description" => Ok(__FieldTag::__description),
                            "avatarUri" => Ok(__FieldTag::__avatar_uri),
                            "avatar_uri" => Ok(__FieldTag::__avatar_uri),
                            "speechToTextSettings" => Ok(__FieldTag::__speech_to_text_settings),
                            "speech_to_text_settings" => Ok(__FieldTag::__speech_to_text_settings),
                            "startFlow" => Ok(__FieldTag::__start_flow),
                            "start_flow" => Ok(__FieldTag::__start_flow),
                            "securitySettings" => Ok(__FieldTag::__security_settings),
                            "security_settings" => Ok(__FieldTag::__security_settings),
                            "enableStackdriverLogging" => {
                                Ok(__FieldTag::__enable_stackdriver_logging)
                            }
                            "enable_stackdriver_logging" => {
                                Ok(__FieldTag::__enable_stackdriver_logging)
                            }
                            "enableSpellCorrection" => Ok(__FieldTag::__enable_spell_correction),
                            "enable_spell_correction" => Ok(__FieldTag::__enable_spell_correction),
                            "enableMultiLanguageTraining" => {
                                Ok(__FieldTag::__enable_multi_language_training)
                            }
                            "enable_multi_language_training" => {
                                Ok(__FieldTag::__enable_multi_language_training)
                            }
                            "locked" => Ok(__FieldTag::__locked),
                            "advancedSettings" => Ok(__FieldTag::__advanced_settings),
                            "advanced_settings" => Ok(__FieldTag::__advanced_settings),
                            "gitIntegrationSettings" => Ok(__FieldTag::__git_integration_settings),
                            "git_integration_settings" => {
                                Ok(__FieldTag::__git_integration_settings)
                            }
                            "textToSpeechSettings" => Ok(__FieldTag::__text_to_speech_settings),
                            "text_to_speech_settings" => Ok(__FieldTag::__text_to_speech_settings),
                            "genAppBuilderSettings" => Ok(__FieldTag::__gen_app_builder_settings),
                            "gen_app_builder_settings" => {
                                Ok(__FieldTag::__gen_app_builder_settings)
                            }
                            "answerFeedbackSettings" => Ok(__FieldTag::__answer_feedback_settings),
                            "answer_feedback_settings" => {
                                Ok(__FieldTag::__answer_feedback_settings)
                            }
                            "personalizationSettings" => Ok(__FieldTag::__personalization_settings),
                            "personalization_settings" => {
                                Ok(__FieldTag::__personalization_settings)
                            }
                            "clientCertificateSettings" => {
                                Ok(__FieldTag::__client_certificate_settings)
                            }
                            "client_certificate_settings" => {
                                Ok(__FieldTag::__client_certificate_settings)
                            }
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Agent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Agent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_language_code => {
                            if !fields.insert(__FieldTag::__default_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_language_code",
                                ));
                            }
                            result.default_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__supported_language_codes => {
                            if !fields.insert(__FieldTag::__supported_language_codes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_language_codes",
                                ));
                            }
                            result.supported_language_codes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__avatar_uri => {
                            if !fields.insert(__FieldTag::__avatar_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for avatar_uri",
                                ));
                            }
                            result.avatar_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__speech_to_text_settings => {
                            if !fields.insert(__FieldTag::__speech_to_text_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_to_text_settings",
                                ));
                            }
                            result.speech_to_text_settings = map.next_value::<std::option::Option<crate::model::SpeechToTextSettings>>()?
                                ;
                        }
                        __FieldTag::__start_flow => {
                            if !fields.insert(__FieldTag::__start_flow) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_flow",
                                ));
                            }
                            result.start_flow = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__security_settings => {
                            if !fields.insert(__FieldTag::__security_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_settings",
                                ));
                            }
                            result.security_settings = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_stackdriver_logging => {
                            if !fields.insert(__FieldTag::__enable_stackdriver_logging) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_stackdriver_logging",
                                ));
                            }
                            result.enable_stackdriver_logging = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_spell_correction => {
                            if !fields.insert(__FieldTag::__enable_spell_correction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_spell_correction",
                                ));
                            }
                            result.enable_spell_correction = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_multi_language_training => {
                            if !fields.insert(__FieldTag::__enable_multi_language_training) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_multi_language_training",
                                ));
                            }
                            result.enable_multi_language_training = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__locked => {
                            if !fields.insert(__FieldTag::__locked) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locked",
                                ));
                            }
                            result.locked = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__advanced_settings => {
                            if !fields.insert(__FieldTag::__advanced_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advanced_settings",
                                ));
                            }
                            result.advanced_settings = map
                                .next_value::<std::option::Option<crate::model::AdvancedSettings>>(
                                )?;
                        }
                        __FieldTag::__git_integration_settings => {
                            if !fields.insert(__FieldTag::__git_integration_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_integration_settings",
                                ));
                            }
                            result.git_integration_settings =
                                map.next_value::<std::option::Option<
                                    crate::model::agent::GitIntegrationSettings,
                                >>()?;
                        }
                        __FieldTag::__text_to_speech_settings => {
                            if !fields.insert(__FieldTag::__text_to_speech_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text_to_speech_settings",
                                ));
                            }
                            result.text_to_speech_settings = map.next_value::<std::option::Option<crate::model::TextToSpeechSettings>>()?
                                ;
                        }
                        __FieldTag::__gen_app_builder_settings => {
                            if !fields.insert(__FieldTag::__gen_app_builder_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gen_app_builder_settings",
                                ));
                            }
                            result.gen_app_builder_settings = map.next_value::<std::option::Option<crate::model::agent::GenAppBuilderSettings>>()?
                                ;
                        }
                        __FieldTag::__answer_feedback_settings => {
                            if !fields.insert(__FieldTag::__answer_feedback_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_feedback_settings",
                                ));
                            }
                            result.answer_feedback_settings =
                                map.next_value::<std::option::Option<
                                    crate::model::agent::AnswerFeedbackSettings,
                                >>()?;
                        }
                        __FieldTag::__personalization_settings => {
                            if !fields.insert(__FieldTag::__personalization_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for personalization_settings",
                                ));
                            }
                            result.personalization_settings =
                                map.next_value::<std::option::Option<
                                    crate::model::agent::PersonalizationSettings,
                                >>()?;
                        }
                        __FieldTag::__client_certificate_settings => {
                            if !fields.insert(__FieldTag::__client_certificate_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_certificate_settings",
                                ));
                            }
                            result.client_certificate_settings = map
                                .next_value::<std::option::Option<
                                    crate::model::agent::ClientCertificateSettings,
                                >>()?;
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for Agent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.default_language_code.is_empty() {
            state.serialize_entry("defaultLanguageCode", &self.default_language_code)?;
        }
        if !self.supported_language_codes.is_empty() {
            state.serialize_entry("supportedLanguageCodes", &self.supported_language_codes)?;
        }
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.avatar_uri.is_empty() {
            state.serialize_entry("avatarUri", &self.avatar_uri)?;
        }
        if self.speech_to_text_settings.is_some() {
            state.serialize_entry("speechToTextSettings", &self.speech_to_text_settings)?;
        }
        if !self.start_flow.is_empty() {
            state.serialize_entry("startFlow", &self.start_flow)?;
        }
        if !self.security_settings.is_empty() {
            state.serialize_entry("securitySettings", &self.security_settings)?;
        }
        if !wkt::internal::is_default(&self.enable_stackdriver_logging) {
            state.serialize_entry("enableStackdriverLogging", &self.enable_stackdriver_logging)?;
        }
        if !wkt::internal::is_default(&self.enable_spell_correction) {
            state.serialize_entry("enableSpellCorrection", &self.enable_spell_correction)?;
        }
        if !wkt::internal::is_default(&self.enable_multi_language_training) {
            state.serialize_entry(
                "enableMultiLanguageTraining",
                &self.enable_multi_language_training,
            )?;
        }
        if !wkt::internal::is_default(&self.locked) {
            state.serialize_entry("locked", &self.locked)?;
        }
        if self.advanced_settings.is_some() {
            state.serialize_entry("advancedSettings", &self.advanced_settings)?;
        }
        if self.git_integration_settings.is_some() {
            state.serialize_entry("gitIntegrationSettings", &self.git_integration_settings)?;
        }
        if self.text_to_speech_settings.is_some() {
            state.serialize_entry("textToSpeechSettings", &self.text_to_speech_settings)?;
        }
        if self.gen_app_builder_settings.is_some() {
            state.serialize_entry("genAppBuilderSettings", &self.gen_app_builder_settings)?;
        }
        if self.answer_feedback_settings.is_some() {
            state.serialize_entry("answerFeedbackSettings", &self.answer_feedback_settings)?;
        }
        if self.personalization_settings.is_some() {
            state.serialize_entry("personalizationSettings", &self.personalization_settings)?;
        }
        if self.client_certificate_settings.is_some() {
            state.serialize_entry(
                "clientCertificateSettings",
                &self.client_certificate_settings,
            )?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Agent].
#[cfg(feature = "agents")]
pub mod agent {
    #[allow(unused_imports)]
    use super::*;

    /// Settings for connecting to Git repository for an agent.
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GitIntegrationSettings {
        /// The git settings to specific systems.
        pub git_settings:
            std::option::Option<crate::model::agent::git_integration_settings::GitSettings>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "agents")]
    impl GitIntegrationSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [git_settings][crate::model::agent::GitIntegrationSettings::git_settings].
        ///
        /// Note that all the setters affecting `git_settings` are mutually
        /// exclusive.
        pub fn set_git_settings<
            T: std::convert::Into<
                    std::option::Option<crate::model::agent::git_integration_settings::GitSettings>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.git_settings = v.into();
            self
        }

        /// The value of [git_settings][crate::model::agent::GitIntegrationSettings::git_settings]
        /// if it holds a `GithubSettings`, `None` if the field is not set or
        /// holds a different branch.
        pub fn github_settings(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::agent::git_integration_settings::GithubSettings>,
        > {
            #[allow(unreachable_patterns)]
            self.git_settings.as_ref().and_then(|v| match v {
                crate::model::agent::git_integration_settings::GitSettings::GithubSettings(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [git_settings][crate::model::agent::GitIntegrationSettings::git_settings]
        /// to hold a `GithubSettings`.
        ///
        /// Note that all the setters affecting `git_settings` are
        /// mutually exclusive.
        pub fn set_github_settings<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::agent::git_integration_settings::GithubSettings>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.git_settings = std::option::Option::Some(
                crate::model::agent::git_integration_settings::GitSettings::GithubSettings(
                    v.into(),
                ),
            );
            self
        }
    }

    #[cfg(feature = "agents")]
    impl wkt::message::Message for GitIntegrationSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Agent.GitIntegrationSettings"
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GitIntegrationSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __github_settings,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GitIntegrationSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "githubSettings" => Ok(__FieldTag::__github_settings),
                                "github_settings" => Ok(__FieldTag::__github_settings),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GitIntegrationSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GitIntegrationSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__github_settings => {
                                if !fields.insert(__FieldTag::__github_settings) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for github_settings",
                                    ));
                                }
                                if result.git_settings.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `git_settings`, a oneof with full ID .google.cloud.dialogflow.cx.v3.Agent.GitIntegrationSettings.github_settings, latest field was githubSettings",
                                    ));
                                }
                                result.git_settings = std::option::Option::Some(
                                    crate::model::agent::git_integration_settings::GitSettings::GithubSettings(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::agent::git_integration_settings::GithubSettings>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl serde::ser::Serialize for GitIntegrationSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.github_settings() {
                state.serialize_entry("githubSettings", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [GitIntegrationSettings].
    #[cfg(feature = "agents")]
    pub mod git_integration_settings {
        #[allow(unused_imports)]
        use super::*;

        /// Settings of integration with GitHub.
        #[cfg(feature = "agents")]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct GithubSettings {
            /// The unique repository display name for the GitHub repository.
            pub display_name: std::string::String,

            /// The GitHub repository URI related to the agent.
            pub repository_uri: std::string::String,

            /// The branch of the GitHub repository tracked for this agent.
            pub tracking_branch: std::string::String,

            /// The access token used to authenticate the access to the GitHub
            /// repository.
            pub access_token: std::string::String,

            /// A list of branches configured to be used from Dialogflow.
            pub branches: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "agents")]
        impl GithubSettings {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [display_name][crate::model::agent::git_integration_settings::GithubSettings::display_name].
            pub fn set_display_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.display_name = v.into();
                self
            }

            /// Sets the value of [repository_uri][crate::model::agent::git_integration_settings::GithubSettings::repository_uri].
            pub fn set_repository_uri<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.repository_uri = v.into();
                self
            }

            /// Sets the value of [tracking_branch][crate::model::agent::git_integration_settings::GithubSettings::tracking_branch].
            pub fn set_tracking_branch<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.tracking_branch = v.into();
                self
            }

            /// Sets the value of [access_token][crate::model::agent::git_integration_settings::GithubSettings::access_token].
            pub fn set_access_token<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.access_token = v.into();
                self
            }

            /// Sets the value of [branches][crate::model::agent::git_integration_settings::GithubSettings::branches].
            pub fn set_branches<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.branches = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(feature = "agents")]
        impl wkt::message::Message for GithubSettings {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.cx.v3.Agent.GitIntegrationSettings.GithubSettings"
            }
        }

        #[cfg(feature = "agents")]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for GithubSettings {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __display_name,
                    __repository_uri,
                    __tracking_branch,
                    __access_token,
                    __branches,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for GithubSettings")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "displayName" => Ok(__FieldTag::__display_name),
                                    "display_name" => Ok(__FieldTag::__display_name),
                                    "repositoryUri" => Ok(__FieldTag::__repository_uri),
                                    "repository_uri" => Ok(__FieldTag::__repository_uri),
                                    "trackingBranch" => Ok(__FieldTag::__tracking_branch),
                                    "tracking_branch" => Ok(__FieldTag::__tracking_branch),
                                    "accessToken" => Ok(__FieldTag::__access_token),
                                    "access_token" => Ok(__FieldTag::__access_token),
                                    "branches" => Ok(__FieldTag::__branches),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = GithubSettings;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct GithubSettings")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__display_name => {
                                    if !fields.insert(__FieldTag::__display_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for display_name",
                                            ),
                                        );
                                    }
                                    result.display_name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__repository_uri => {
                                    if !fields.insert(__FieldTag::__repository_uri) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for repository_uri",
                                            ),
                                        );
                                    }
                                    result.repository_uri = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__tracking_branch => {
                                    if !fields.insert(__FieldTag::__tracking_branch) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for tracking_branch",
                                            ),
                                        );
                                    }
                                    result.tracking_branch = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__access_token => {
                                    if !fields.insert(__FieldTag::__access_token) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for access_token",
                                            ),
                                        );
                                    }
                                    result.access_token = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__branches => {
                                    if !fields.insert(__FieldTag::__branches) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for branches",
                                            ),
                                        );
                                    }
                                    result.branches = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(feature = "agents")]
        #[doc(hidden)]
        impl serde::ser::Serialize for GithubSettings {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.display_name.is_empty() {
                    state.serialize_entry("displayName", &self.display_name)?;
                }
                if !self.repository_uri.is_empty() {
                    state.serialize_entry("repositoryUri", &self.repository_uri)?;
                }
                if !self.tracking_branch.is_empty() {
                    state.serialize_entry("trackingBranch", &self.tracking_branch)?;
                }
                if !self.access_token.is_empty() {
                    state.serialize_entry("accessToken", &self.access_token)?;
                }
                if !self.branches.is_empty() {
                    state.serialize_entry("branches", &self.branches)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The git settings to specific systems.
        #[cfg(feature = "agents")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum GitSettings {
            /// GitHub settings.
            GithubSettings(
                std::boxed::Box<crate::model::agent::git_integration_settings::GithubSettings>,
            ),
        }
    }

    /// Settings for Gen App Builder.
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GenAppBuilderSettings {
        /// Required. The full name of the Gen App Builder engine related to this
        /// agent if there is one. Format: `projects/{Project ID}/locations/{Location
        /// ID}/collections/{Collection ID}/engines/{Engine ID}`
        pub engine: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "agents")]
    impl GenAppBuilderSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [engine][crate::model::agent::GenAppBuilderSettings::engine].
        pub fn set_engine<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.engine = v.into();
            self
        }
    }

    #[cfg(feature = "agents")]
    impl wkt::message::Message for GenAppBuilderSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Agent.GenAppBuilderSettings"
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GenAppBuilderSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __engine,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GenAppBuilderSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "engine" => Ok(__FieldTag::__engine),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GenAppBuilderSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GenAppBuilderSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__engine => {
                                if !fields.insert(__FieldTag::__engine) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for engine",
                                    ));
                                }
                                result.engine = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl serde::ser::Serialize for GenAppBuilderSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.engine.is_empty() {
                state.serialize_entry("engine", &self.engine)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Settings for answer feedback collection.
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AnswerFeedbackSettings {
        /// Optional. If enabled, end users will be able to provide
        /// [answer feedback][google.cloud.dialogflow.cx.v3.AnswerFeedback] to
        /// Dialogflow responses. Feature works only if interaction logging is
        /// enabled in the Dialogflow agent.
        ///
        /// [google.cloud.dialogflow.cx.v3.AnswerFeedback]: crate::model::AnswerFeedback
        pub enable_answer_feedback: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "agents")]
    impl AnswerFeedbackSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enable_answer_feedback][crate::model::agent::AnswerFeedbackSettings::enable_answer_feedback].
        pub fn set_enable_answer_feedback<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_answer_feedback = v.into();
            self
        }
    }

    #[cfg(feature = "agents")]
    impl wkt::message::Message for AnswerFeedbackSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Agent.AnswerFeedbackSettings"
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AnswerFeedbackSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enable_answer_feedback,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AnswerFeedbackSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enableAnswerFeedback" => Ok(__FieldTag::__enable_answer_feedback),
                                "enable_answer_feedback" => {
                                    Ok(__FieldTag::__enable_answer_feedback)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AnswerFeedbackSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AnswerFeedbackSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enable_answer_feedback => {
                                if !fields.insert(__FieldTag::__enable_answer_feedback) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_answer_feedback",
                                    ));
                                }
                                result.enable_answer_feedback = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl serde::ser::Serialize for AnswerFeedbackSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.enable_answer_feedback) {
                state.serialize_entry("enableAnswerFeedback", &self.enable_answer_feedback)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Settings for end user personalization.
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PersonalizationSettings {
        /// Optional. Default end user metadata, used when processing DetectIntent
        /// requests. Recommended to be filled as a template instead of hard-coded
        /// value, for example { "age": "$session.params.age" }. The data will be
        /// merged with the
        /// [QueryParameters.end_user_metadata][google.cloud.dialogflow.cx.v3.QueryParameters.end_user_metadata]
        /// in
        /// [DetectIntentRequest.query_params][google.cloud.dialogflow.cx.v3.DetectIntentRequest.query_params]
        /// during query processing.
        ///
        /// [google.cloud.dialogflow.cx.v3.DetectIntentRequest.query_params]: crate::model::DetectIntentRequest::query_params
        /// [google.cloud.dialogflow.cx.v3.QueryParameters.end_user_metadata]: crate::model::QueryParameters::end_user_metadata
        pub default_end_user_metadata: std::option::Option<wkt::Struct>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "agents")]
    impl PersonalizationSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [default_end_user_metadata][crate::model::agent::PersonalizationSettings::default_end_user_metadata].
        pub fn set_default_end_user_metadata<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.default_end_user_metadata = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [default_end_user_metadata][crate::model::agent::PersonalizationSettings::default_end_user_metadata].
        pub fn set_or_clear_default_end_user_metadata<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.default_end_user_metadata = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "agents")]
    impl wkt::message::Message for PersonalizationSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Agent.PersonalizationSettings"
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PersonalizationSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __default_end_user_metadata,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PersonalizationSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "defaultEndUserMetadata" => {
                                    Ok(__FieldTag::__default_end_user_metadata)
                                }
                                "default_end_user_metadata" => {
                                    Ok(__FieldTag::__default_end_user_metadata)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PersonalizationSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PersonalizationSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__default_end_user_metadata => {
                                if !fields.insert(__FieldTag::__default_end_user_metadata) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for default_end_user_metadata",
                                    ));
                                }
                                result.default_end_user_metadata =
                                    map.next_value::<std::option::Option<wkt::Struct>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl serde::ser::Serialize for PersonalizationSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.default_end_user_metadata.is_some() {
                state.serialize_entry("defaultEndUserMetadata", &self.default_end_user_metadata)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Settings for custom client certificates.
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ClientCertificateSettings {
        /// Required. The ssl certificate encoded in PEM format. This string must
        /// include the begin header and end footer lines.
        pub ssl_certificate: std::string::String,

        /// Required. The name of the SecretManager secret version resource storing
        /// the private key encoded in PEM format. Format:
        /// `projects/{project}/secrets/{secret}/versions/{version}`
        pub private_key: std::string::String,

        /// Optional. The name of the SecretManager secret version resource storing
        /// the passphrase. 'passphrase' should be left unset if the private key is
        /// not encrypted.
        /// Format: `projects/{project}/secrets/{secret}/versions/{version}`
        pub passphrase: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "agents")]
    impl ClientCertificateSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ssl_certificate][crate::model::agent::ClientCertificateSettings::ssl_certificate].
        pub fn set_ssl_certificate<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.ssl_certificate = v.into();
            self
        }

        /// Sets the value of [private_key][crate::model::agent::ClientCertificateSettings::private_key].
        pub fn set_private_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.private_key = v.into();
            self
        }

        /// Sets the value of [passphrase][crate::model::agent::ClientCertificateSettings::passphrase].
        pub fn set_passphrase<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.passphrase = v.into();
            self
        }
    }

    #[cfg(feature = "agents")]
    impl wkt::message::Message for ClientCertificateSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Agent.ClientCertificateSettings"
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ClientCertificateSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __ssl_certificate,
                __private_key,
                __passphrase,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ClientCertificateSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sslCertificate" => Ok(__FieldTag::__ssl_certificate),
                                "ssl_certificate" => Ok(__FieldTag::__ssl_certificate),
                                "privateKey" => Ok(__FieldTag::__private_key),
                                "private_key" => Ok(__FieldTag::__private_key),
                                "passphrase" => Ok(__FieldTag::__passphrase),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ClientCertificateSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ClientCertificateSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__ssl_certificate => {
                                if !fields.insert(__FieldTag::__ssl_certificate) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ssl_certificate",
                                    ));
                                }
                                result.ssl_certificate = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__private_key => {
                                if !fields.insert(__FieldTag::__private_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for private_key",
                                    ));
                                }
                                result.private_key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__passphrase => {
                                if !fields.insert(__FieldTag::__passphrase) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for passphrase",
                                    ));
                                }
                                result.passphrase = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl serde::ser::Serialize for ClientCertificateSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.ssl_certificate.is_empty() {
                state.serialize_entry("sslCertificate", &self.ssl_certificate)?;
            }
            if !self.private_key.is_empty() {
                state.serialize_entry("privateKey", &self.private_key)?;
            }
            if !self.passphrase.is_empty() {
                state.serialize_entry("passphrase", &self.passphrase)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// The request message for
/// [Agents.ListAgents][google.cloud.dialogflow.cx.v3.Agents.ListAgents].
///
/// [google.cloud.dialogflow.cx.v3.Agents.ListAgents]: crate::client::Agents::list_agents
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAgentsRequest {
    /// Required. The location to list all agents for.
    /// Format: `projects/<ProjectID>/locations/<LocationID>`.
    pub parent: std::string::String,

    /// The maximum number of items to return in a single page. By default 100 and
    /// at most 1000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl ListAgentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAgentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAgentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAgentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for ListAgentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListAgentsRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAgentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAgentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAgentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAgentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for ListAgentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Agents.ListAgents][google.cloud.dialogflow.cx.v3.Agents.ListAgents].
///
/// [google.cloud.dialogflow.cx.v3.Agents.ListAgents]: crate::client::Agents::list_agents
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAgentsResponse {
    /// The list of agents. There will be a maximum number of items returned based
    /// on the page_size field in the request.
    pub agents: std::vec::Vec<crate::model::Agent>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl ListAgentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [agents][crate::model::ListAgentsResponse::agents].
    pub fn set_agents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Agent>,
    {
        use std::iter::Iterator;
        self.agents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAgentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for ListAgentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListAgentsResponse"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAgentsResponse {
    type PageItem = crate::model::Agent;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.agents
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAgentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agents,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAgentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agents" => Ok(__FieldTag::__agents),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAgentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAgentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agents => {
                            if !fields.insert(__FieldTag::__agents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agents",
                                ));
                            }
                            result.agents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Agent>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for ListAgentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.agents.is_empty() {
            state.serialize_entry("agents", &self.agents)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Agents.GetAgent][google.cloud.dialogflow.cx.v3.Agents.GetAgent].
///
/// [google.cloud.dialogflow.cx.v3.Agents.GetAgent]: crate::client::Agents::get_agent
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAgentRequest {
    /// Required. The name of the agent.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl GetAgentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAgentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for GetAgentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetAgentRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for GetAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Agents.CreateAgent][google.cloud.dialogflow.cx.v3.Agents.CreateAgent].
///
/// [google.cloud.dialogflow.cx.v3.Agents.CreateAgent]: crate::client::Agents::create_agent
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAgentRequest {
    /// Required. The location to create a agent for.
    /// Format: `projects/<ProjectID>/locations/<LocationID>`.
    pub parent: std::string::String,

    /// Required. The agent to create.
    pub agent: std::option::Option<crate::model::Agent>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl CreateAgentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAgentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [agent][crate::model::CreateAgentRequest::agent].
    pub fn set_agent<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Agent>,
    {
        self.agent = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [agent][crate::model::CreateAgentRequest::agent].
    pub fn set_or_clear_agent<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Agent>,
    {
        self.agent = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for CreateAgentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CreateAgentRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __agent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "agent" => Ok(__FieldTag::__agent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__agent => {
                            if !fields.insert(__FieldTag::__agent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent",
                                ));
                            }
                            result.agent =
                                map.next_value::<std::option::Option<crate::model::Agent>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.agent.is_some() {
            state.serialize_entry("agent", &self.agent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Agents.UpdateAgent][google.cloud.dialogflow.cx.v3.Agents.UpdateAgent].
///
/// [google.cloud.dialogflow.cx.v3.Agents.UpdateAgent]: crate::client::Agents::update_agent
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAgentRequest {
    /// Required. The agent to update.
    pub agent: std::option::Option<crate::model::Agent>,

    /// The mask to control which fields get updated. If the mask is not present,
    /// all fields will be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl UpdateAgentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [agent][crate::model::UpdateAgentRequest::agent].
    pub fn set_agent<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Agent>,
    {
        self.agent = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [agent][crate::model::UpdateAgentRequest::agent].
    pub fn set_or_clear_agent<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Agent>,
    {
        self.agent = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAgentRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAgentRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for UpdateAgentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.UpdateAgentRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agent,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agent" => Ok(__FieldTag::__agent),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agent => {
                            if !fields.insert(__FieldTag::__agent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent",
                                ));
                            }
                            result.agent =
                                map.next_value::<std::option::Option<crate::model::Agent>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.agent.is_some() {
            state.serialize_entry("agent", &self.agent)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Agents.DeleteAgent][google.cloud.dialogflow.cx.v3.Agents.DeleteAgent].
///
/// [google.cloud.dialogflow.cx.v3.Agents.DeleteAgent]: crate::client::Agents::delete_agent
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAgentRequest {
    /// Required. The name of the agent to delete.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl DeleteAgentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAgentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for DeleteAgentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DeleteAgentRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Agents.ExportAgent][google.cloud.dialogflow.cx.v3.Agents.ExportAgent].
///
/// [google.cloud.dialogflow.cx.v3.Agents.ExportAgent]: crate::client::Agents::export_agent
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportAgentRequest {
    /// Required. The name of the agent to export.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub name: std::string::String,

    /// Optional. The [Google Cloud
    /// Storage](https://cloud.google.com/storage/docs/) URI to export the agent
    /// to. The format of this URI must be `gs://<bucket-name>/<object-name>`. If
    /// left unspecified, the serialized agent is returned inline.
    ///
    /// Dialogflow performs a write operation for the Cloud Storage object
    /// on the caller's behalf, so your request authentication must
    /// have write permissions for the object. For more information, see
    /// [Dialogflow access
    /// control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
    pub agent_uri: std::string::String,

    /// Optional. The data format of the exported agent. If not specified, `BLOB`
    /// is assumed.
    pub data_format: crate::model::export_agent_request::DataFormat,

    /// Optional. Environment name. If not set, draft environment is assumed.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>`.
    pub environment: std::string::String,

    /// Optional. The Git branch to export the agent to.
    pub git_destination: std::option::Option<crate::model::export_agent_request::GitDestination>,

    /// Optional. Whether to include BigQuery Export setting.
    pub include_bigquery_export_settings: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl ExportAgentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExportAgentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [agent_uri][crate::model::ExportAgentRequest::agent_uri].
    pub fn set_agent_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.agent_uri = v.into();
        self
    }

    /// Sets the value of [data_format][crate::model::ExportAgentRequest::data_format].
    pub fn set_data_format<
        T: std::convert::Into<crate::model::export_agent_request::DataFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_format = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::ExportAgentRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [git_destination][crate::model::ExportAgentRequest::git_destination].
    pub fn set_git_destination<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::export_agent_request::GitDestination>,
    {
        self.git_destination = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [git_destination][crate::model::ExportAgentRequest::git_destination].
    pub fn set_or_clear_git_destination<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::export_agent_request::GitDestination>,
    {
        self.git_destination = v.map(|x| x.into());
        self
    }

    /// Sets the value of [include_bigquery_export_settings][crate::model::ExportAgentRequest::include_bigquery_export_settings].
    pub fn set_include_bigquery_export_settings<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.include_bigquery_export_settings = v.into();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for ExportAgentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ExportAgentRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __agent_uri,
            __data_format,
            __environment,
            __git_destination,
            __include_bigquery_export_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "agentUri" => Ok(__FieldTag::__agent_uri),
                            "agent_uri" => Ok(__FieldTag::__agent_uri),
                            "dataFormat" => Ok(__FieldTag::__data_format),
                            "data_format" => Ok(__FieldTag::__data_format),
                            "environment" => Ok(__FieldTag::__environment),
                            "gitDestination" => Ok(__FieldTag::__git_destination),
                            "git_destination" => Ok(__FieldTag::__git_destination),
                            "includeBigqueryExportSettings" => {
                                Ok(__FieldTag::__include_bigquery_export_settings)
                            }
                            "include_bigquery_export_settings" => {
                                Ok(__FieldTag::__include_bigquery_export_settings)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__agent_uri => {
                            if !fields.insert(__FieldTag::__agent_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_uri",
                                ));
                            }
                            result.agent_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_format => {
                            if !fields.insert(__FieldTag::__data_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_format",
                                ));
                            }
                            result.data_format =
                                map.next_value::<std::option::Option<
                                    crate::model::export_agent_request::DataFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__git_destination => {
                            if !fields.insert(__FieldTag::__git_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_destination",
                                ));
                            }
                            result.git_destination = map.next_value::<std::option::Option<
                                crate::model::export_agent_request::GitDestination,
                            >>()?;
                        }
                        __FieldTag::__include_bigquery_export_settings => {
                            if !fields.insert(__FieldTag::__include_bigquery_export_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_bigquery_export_settings",
                                ));
                            }
                            result.include_bigquery_export_settings = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for ExportAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.agent_uri.is_empty() {
            state.serialize_entry("agentUri", &self.agent_uri)?;
        }
        if !wkt::internal::is_default(&self.data_format) {
            state.serialize_entry("dataFormat", &self.data_format)?;
        }
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if self.git_destination.is_some() {
            state.serialize_entry("gitDestination", &self.git_destination)?;
        }
        if !wkt::internal::is_default(&self.include_bigquery_export_settings) {
            state.serialize_entry(
                "includeBigqueryExportSettings",
                &self.include_bigquery_export_settings,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExportAgentRequest].
#[cfg(feature = "agents")]
pub mod export_agent_request {
    #[allow(unused_imports)]
    use super::*;

    /// Settings for exporting to a git branch.
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GitDestination {
        /// Tracking branch for the git push.
        pub tracking_branch: std::string::String,

        /// Commit message for the git push.
        pub commit_message: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "agents")]
    impl GitDestination {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [tracking_branch][crate::model::export_agent_request::GitDestination::tracking_branch].
        pub fn set_tracking_branch<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.tracking_branch = v.into();
            self
        }

        /// Sets the value of [commit_message][crate::model::export_agent_request::GitDestination::commit_message].
        pub fn set_commit_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.commit_message = v.into();
            self
        }
    }

    #[cfg(feature = "agents")]
    impl wkt::message::Message for GitDestination {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.ExportAgentRequest.GitDestination"
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GitDestination {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __tracking_branch,
                __commit_message,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GitDestination")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "trackingBranch" => Ok(__FieldTag::__tracking_branch),
                                "tracking_branch" => Ok(__FieldTag::__tracking_branch),
                                "commitMessage" => Ok(__FieldTag::__commit_message),
                                "commit_message" => Ok(__FieldTag::__commit_message),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GitDestination;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GitDestination")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__tracking_branch => {
                                if !fields.insert(__FieldTag::__tracking_branch) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tracking_branch",
                                    ));
                                }
                                result.tracking_branch = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__commit_message => {
                                if !fields.insert(__FieldTag::__commit_message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for commit_message",
                                    ));
                                }
                                result.commit_message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl serde::ser::Serialize for GitDestination {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.tracking_branch.is_empty() {
                state.serialize_entry("trackingBranch", &self.tracking_branch)?;
            }
            if !self.commit_message.is_empty() {
                state.serialize_entry("commitMessage", &self.commit_message)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Data format of the exported agent.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataFormat {
        /// Unspecified format.
        Unspecified,
        /// Agent content will be exported as raw bytes.
        Blob,
        /// Agent content will be exported in JSON Package format.
        JsonPackage,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataFormat::value] or
        /// [DataFormat::name].
        UnknownValue(data_format::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "agents")]
    pub mod data_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "agents")]
    impl DataFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Blob => std::option::Option::Some(1),
                Self::JsonPackage => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_FORMAT_UNSPECIFIED"),
                Self::Blob => std::option::Option::Some("BLOB"),
                Self::JsonPackage => std::option::Option::Some("JSON_PACKAGE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl std::default::Default for DataFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "agents")]
    impl std::fmt::Display for DataFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "agents")]
    impl std::convert::From<i32> for DataFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Blob,
                4 => Self::JsonPackage,
                _ => Self::UnknownValue(data_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl std::convert::From<&str> for DataFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "BLOB" => Self::Blob,
                "JSON_PACKAGE" => Self::JsonPackage,
                _ => Self::UnknownValue(data_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl serde::ser::Serialize for DataFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Blob => serializer.serialize_i32(1),
                Self::JsonPackage => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl<'de> serde::de::Deserialize<'de> for DataFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataFormat>::new(
                ".google.cloud.dialogflow.cx.v3.ExportAgentRequest.DataFormat",
            ))
        }
    }
}

/// The response message for
/// [Agents.ExportAgent][google.cloud.dialogflow.cx.v3.Agents.ExportAgent].
///
/// [google.cloud.dialogflow.cx.v3.Agents.ExportAgent]: crate::client::Agents::export_agent
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportAgentResponse {
    /// The exported agent.
    pub agent: std::option::Option<crate::model::export_agent_response::Agent>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl ExportAgentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [agent][crate::model::ExportAgentResponse::agent].
    ///
    /// Note that all the setters affecting `agent` are mutually
    /// exclusive.
    pub fn set_agent<
        T: std::convert::Into<std::option::Option<crate::model::export_agent_response::Agent>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.agent = v.into();
        self
    }

    /// The value of [agent][crate::model::ExportAgentResponse::agent]
    /// if it holds a `AgentUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn agent_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.agent.as_ref().and_then(|v| match v {
            crate::model::export_agent_response::Agent::AgentUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [agent][crate::model::ExportAgentResponse::agent]
    /// to hold a `AgentUri`.
    ///
    /// Note that all the setters affecting `agent` are
    /// mutually exclusive.
    pub fn set_agent_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.agent = std::option::Option::Some(
            crate::model::export_agent_response::Agent::AgentUri(v.into()),
        );
        self
    }

    /// The value of [agent][crate::model::ExportAgentResponse::agent]
    /// if it holds a `AgentContent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn agent_content(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.agent.as_ref().and_then(|v| match v {
            crate::model::export_agent_response::Agent::AgentContent(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [agent][crate::model::ExportAgentResponse::agent]
    /// to hold a `AgentContent`.
    ///
    /// Note that all the setters affecting `agent` are
    /// mutually exclusive.
    pub fn set_agent_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.agent = std::option::Option::Some(
            crate::model::export_agent_response::Agent::AgentContent(v.into()),
        );
        self
    }

    /// The value of [agent][crate::model::ExportAgentResponse::agent]
    /// if it holds a `CommitSha`, `None` if the field is not set or
    /// holds a different branch.
    pub fn commit_sha(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.agent.as_ref().and_then(|v| match v {
            crate::model::export_agent_response::Agent::CommitSha(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [agent][crate::model::ExportAgentResponse::agent]
    /// to hold a `CommitSha`.
    ///
    /// Note that all the setters affecting `agent` are
    /// mutually exclusive.
    pub fn set_commit_sha<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.agent = std::option::Option::Some(
            crate::model::export_agent_response::Agent::CommitSha(v.into()),
        );
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for ExportAgentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ExportAgentResponse"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportAgentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agent_uri,
            __agent_content,
            __commit_sha,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportAgentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agentUri" => Ok(__FieldTag::__agent_uri),
                            "agent_uri" => Ok(__FieldTag::__agent_uri),
                            "agentContent" => Ok(__FieldTag::__agent_content),
                            "agent_content" => Ok(__FieldTag::__agent_content),
                            "commitSha" => Ok(__FieldTag::__commit_sha),
                            "commit_sha" => Ok(__FieldTag::__commit_sha),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportAgentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportAgentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agent_uri => {
                            if !fields.insert(__FieldTag::__agent_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_uri",
                                ));
                            }
                            if result.agent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ExportAgentResponse.agent_uri, latest field was agentUri",
                                ));
                            }
                            result.agent = std::option::Option::Some(
                                crate::model::export_agent_response::Agent::AgentUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__agent_content => {
                            if !fields.insert(__FieldTag::__agent_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.agent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ExportAgentResponse.agent_content, latest field was agentContent",
                                ));
                            }
                            result.agent = std::option::Option::Some(
                                crate::model::export_agent_response::Agent::AgentContent(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__commit_sha => {
                            if !fields.insert(__FieldTag::__commit_sha) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commit_sha",
                                ));
                            }
                            if result.agent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ExportAgentResponse.commit_sha, latest field was commitSha",
                                ));
                            }
                            result.agent = std::option::Option::Some(
                                crate::model::export_agent_response::Agent::CommitSha(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for ExportAgentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.agent_uri() {
            state.serialize_entry("agentUri", value)?;
        }
        if let Some(value) = self.agent_content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("agentContent", &__With(value))?;
        }
        if let Some(value) = self.commit_sha() {
            state.serialize_entry("commitSha", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExportAgentResponse].
#[cfg(feature = "agents")]
pub mod export_agent_response {
    #[allow(unused_imports)]
    use super::*;

    /// The exported agent.
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Agent {
        /// The URI to a file containing the exported agent. This field is populated
        /// if `agent_uri` is specified in
        /// [ExportAgentRequest][google.cloud.dialogflow.cx.v3.ExportAgentRequest].
        ///
        /// [google.cloud.dialogflow.cx.v3.ExportAgentRequest]: crate::model::ExportAgentRequest
        AgentUri(std::string::String),
        /// Uncompressed raw byte content for agent. This field is populated
        /// if none of `agent_uri` and `git_destination` are specified in
        /// [ExportAgentRequest][google.cloud.dialogflow.cx.v3.ExportAgentRequest].
        ///
        /// [google.cloud.dialogflow.cx.v3.ExportAgentRequest]: crate::model::ExportAgentRequest
        AgentContent(::bytes::Bytes),
        /// Commit SHA of the git push. This field is populated if
        /// `git_destination` is specified in
        /// [ExportAgentRequest][google.cloud.dialogflow.cx.v3.ExportAgentRequest].
        ///
        /// [google.cloud.dialogflow.cx.v3.ExportAgentRequest]: crate::model::ExportAgentRequest
        CommitSha(std::string::String),
    }
}

/// The request message for
/// [Agents.RestoreAgent][google.cloud.dialogflow.cx.v3.Agents.RestoreAgent].
///
/// [google.cloud.dialogflow.cx.v3.Agents.RestoreAgent]: crate::client::Agents::restore_agent
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreAgentRequest {
    /// Required. The name of the agent to restore into.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub name: std::string::String,

    /// Agent restore mode. If not specified, `KEEP` is assumed.
    pub restore_option: crate::model::restore_agent_request::RestoreOption,

    /// Required. The agent to restore.
    pub agent: std::option::Option<crate::model::restore_agent_request::Agent>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl RestoreAgentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestoreAgentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [restore_option][crate::model::RestoreAgentRequest::restore_option].
    pub fn set_restore_option<
        T: std::convert::Into<crate::model::restore_agent_request::RestoreOption>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.restore_option = v.into();
        self
    }

    /// Sets the value of [agent][crate::model::RestoreAgentRequest::agent].
    ///
    /// Note that all the setters affecting `agent` are mutually
    /// exclusive.
    pub fn set_agent<
        T: std::convert::Into<std::option::Option<crate::model::restore_agent_request::Agent>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.agent = v.into();
        self
    }

    /// The value of [agent][crate::model::RestoreAgentRequest::agent]
    /// if it holds a `AgentUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn agent_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.agent.as_ref().and_then(|v| match v {
            crate::model::restore_agent_request::Agent::AgentUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [agent][crate::model::RestoreAgentRequest::agent]
    /// to hold a `AgentUri`.
    ///
    /// Note that all the setters affecting `agent` are
    /// mutually exclusive.
    pub fn set_agent_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.agent = std::option::Option::Some(
            crate::model::restore_agent_request::Agent::AgentUri(v.into()),
        );
        self
    }

    /// The value of [agent][crate::model::RestoreAgentRequest::agent]
    /// if it holds a `AgentContent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn agent_content(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.agent.as_ref().and_then(|v| match v {
            crate::model::restore_agent_request::Agent::AgentContent(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [agent][crate::model::RestoreAgentRequest::agent]
    /// to hold a `AgentContent`.
    ///
    /// Note that all the setters affecting `agent` are
    /// mutually exclusive.
    pub fn set_agent_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.agent = std::option::Option::Some(
            crate::model::restore_agent_request::Agent::AgentContent(v.into()),
        );
        self
    }

    /// The value of [agent][crate::model::RestoreAgentRequest::agent]
    /// if it holds a `GitSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn git_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::restore_agent_request::GitSource>> {
        #[allow(unreachable_patterns)]
        self.agent.as_ref().and_then(|v| match v {
            crate::model::restore_agent_request::Agent::GitSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [agent][crate::model::RestoreAgentRequest::agent]
    /// to hold a `GitSource`.
    ///
    /// Note that all the setters affecting `agent` are
    /// mutually exclusive.
    pub fn set_git_source<
        T: std::convert::Into<std::boxed::Box<crate::model::restore_agent_request::GitSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.agent = std::option::Option::Some(
            crate::model::restore_agent_request::Agent::GitSource(v.into()),
        );
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for RestoreAgentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.RestoreAgentRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestoreAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __agent_uri,
            __agent_content,
            __git_source,
            __restore_option,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "agentUri" => Ok(__FieldTag::__agent_uri),
                            "agent_uri" => Ok(__FieldTag::__agent_uri),
                            "agentContent" => Ok(__FieldTag::__agent_content),
                            "agent_content" => Ok(__FieldTag::__agent_content),
                            "gitSource" => Ok(__FieldTag::__git_source),
                            "git_source" => Ok(__FieldTag::__git_source),
                            "restoreOption" => Ok(__FieldTag::__restore_option),
                            "restore_option" => Ok(__FieldTag::__restore_option),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestoreAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__agent_uri => {
                            if !fields.insert(__FieldTag::__agent_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_uri",
                                ));
                            }
                            if result.agent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent`, a oneof with full ID .google.cloud.dialogflow.cx.v3.RestoreAgentRequest.agent_uri, latest field was agentUri",
                                ));
                            }
                            result.agent = std::option::Option::Some(
                                crate::model::restore_agent_request::Agent::AgentUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__agent_content => {
                            if !fields.insert(__FieldTag::__agent_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.agent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent`, a oneof with full ID .google.cloud.dialogflow.cx.v3.RestoreAgentRequest.agent_content, latest field was agentContent",
                                ));
                            }
                            result.agent = std::option::Option::Some(
                                crate::model::restore_agent_request::Agent::AgentContent(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__git_source => {
                            if !fields.insert(__FieldTag::__git_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_source",
                                ));
                            }
                            if result.agent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent`, a oneof with full ID .google.cloud.dialogflow.cx.v3.RestoreAgentRequest.git_source, latest field was gitSource",
                                ));
                            }
                            result.agent = std::option::Option::Some(
                                crate::model::restore_agent_request::Agent::GitSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::restore_agent_request::GitSource,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__restore_option => {
                            if !fields.insert(__FieldTag::__restore_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_option",
                                ));
                            }
                            result.restore_option = map
                                .next_value::<std::option::Option<
                                    crate::model::restore_agent_request::RestoreOption,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for RestoreAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.agent_uri() {
            state.serialize_entry("agentUri", value)?;
        }
        if let Some(value) = self.agent_content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("agentContent", &__With(value))?;
        }
        if let Some(value) = self.git_source() {
            state.serialize_entry("gitSource", value)?;
        }
        if !wkt::internal::is_default(&self.restore_option) {
            state.serialize_entry("restoreOption", &self.restore_option)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RestoreAgentRequest].
#[cfg(feature = "agents")]
pub mod restore_agent_request {
    #[allow(unused_imports)]
    use super::*;

    /// Settings for restoring from a git branch
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GitSource {
        /// tracking branch for the git pull
        pub tracking_branch: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "agents")]
    impl GitSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [tracking_branch][crate::model::restore_agent_request::GitSource::tracking_branch].
        pub fn set_tracking_branch<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.tracking_branch = v.into();
            self
        }
    }

    #[cfg(feature = "agents")]
    impl wkt::message::Message for GitSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.RestoreAgentRequest.GitSource"
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GitSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __tracking_branch,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GitSource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "trackingBranch" => Ok(__FieldTag::__tracking_branch),
                                "tracking_branch" => Ok(__FieldTag::__tracking_branch),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GitSource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GitSource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__tracking_branch => {
                                if !fields.insert(__FieldTag::__tracking_branch) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tracking_branch",
                                    ));
                                }
                                result.tracking_branch = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl serde::ser::Serialize for GitSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.tracking_branch.is_empty() {
                state.serialize_entry("trackingBranch", &self.tracking_branch)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Restore option.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RestoreOption {
        /// Unspecified. Treated as KEEP.
        Unspecified,
        /// Always respect the settings from the exported agent file. It may cause
        /// a restoration failure if some settings (e.g. model type) are not
        /// supported in the target agent.
        Keep,
        /// Fallback to default settings if some settings are not supported in the
        /// target agent.
        Fallback,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RestoreOption::value] or
        /// [RestoreOption::name].
        UnknownValue(restore_option::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "agents")]
    pub mod restore_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "agents")]
    impl RestoreOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Keep => std::option::Option::Some(1),
                Self::Fallback => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESTORE_OPTION_UNSPECIFIED"),
                Self::Keep => std::option::Option::Some("KEEP"),
                Self::Fallback => std::option::Option::Some("FALLBACK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl std::default::Default for RestoreOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "agents")]
    impl std::fmt::Display for RestoreOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "agents")]
    impl std::convert::From<i32> for RestoreOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Keep,
                2 => Self::Fallback,
                _ => Self::UnknownValue(restore_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl std::convert::From<&str> for RestoreOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESTORE_OPTION_UNSPECIFIED" => Self::Unspecified,
                "KEEP" => Self::Keep,
                "FALLBACK" => Self::Fallback,
                _ => Self::UnknownValue(restore_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl serde::ser::Serialize for RestoreOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Keep => serializer.serialize_i32(1),
                Self::Fallback => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl<'de> serde::de::Deserialize<'de> for RestoreOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RestoreOption>::new(
                ".google.cloud.dialogflow.cx.v3.RestoreAgentRequest.RestoreOption",
            ))
        }
    }

    /// Required. The agent to restore.
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Agent {
        /// The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI
        /// to restore agent from. The format of this URI must be
        /// `gs://<bucket-name>/<object-name>`.
        ///
        /// Dialogflow performs a read operation for the Cloud Storage object
        /// on the caller's behalf, so your request authentication must
        /// have read permissions for the object. For more information, see
        /// [Dialogflow access
        /// control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
        AgentUri(std::string::String),
        /// Uncompressed raw byte content for agent.
        AgentContent(::bytes::Bytes),
        /// Setting for restoring from a git branch
        GitSource(std::boxed::Box<crate::model::restore_agent_request::GitSource>),
    }
}

/// The request message for
/// [Agents.ValidateAgent][google.cloud.dialogflow.cx.v3.Agents.ValidateAgent].
///
/// [google.cloud.dialogflow.cx.v3.Agents.ValidateAgent]: crate::client::Agents::validate_agent
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidateAgentRequest {
    /// Required. The agent to validate.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub name: std::string::String,

    /// If not specified, the agent's default language is used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl ValidateAgentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ValidateAgentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::ValidateAgentRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for ValidateAgentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ValidateAgentRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValidateAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValidateAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValidateAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValidateAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for ValidateAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Agents.GetAgentValidationResult][google.cloud.dialogflow.cx.v3.Agents.GetAgentValidationResult].
///
/// [google.cloud.dialogflow.cx.v3.Agents.GetAgentValidationResult]: crate::client::Agents::get_agent_validation_result
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAgentValidationResultRequest {
    /// Required. The agent name.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/validationResult`.
    pub name: std::string::String,

    /// If not specified, the agent's default language is used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl GetAgentValidationResultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAgentValidationResultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::GetAgentValidationResultRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for GetAgentValidationResultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetAgentValidationResultRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAgentValidationResultRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAgentValidationResultRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAgentValidationResultRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAgentValidationResultRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for GetAgentValidationResultRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Agents.GetAgentValidationResult][google.cloud.dialogflow.cx.v3.Agents.GetAgentValidationResult].
///
/// [google.cloud.dialogflow.cx.v3.Agents.GetAgentValidationResult]: crate::client::Agents::get_agent_validation_result
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AgentValidationResult {
    /// The unique identifier of the agent validation result.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/validationResult`.
    pub name: std::string::String,

    /// Contains all flow validation results.
    pub flow_validation_results: std::vec::Vec<crate::model::FlowValidationResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl AgentValidationResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AgentValidationResult::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [flow_validation_results][crate::model::AgentValidationResult::flow_validation_results].
    pub fn set_flow_validation_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FlowValidationResult>,
    {
        use std::iter::Iterator;
        self.flow_validation_results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for AgentValidationResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.AgentValidationResult"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AgentValidationResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __flow_validation_results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AgentValidationResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "flowValidationResults" => Ok(__FieldTag::__flow_validation_results),
                            "flow_validation_results" => Ok(__FieldTag::__flow_validation_results),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AgentValidationResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AgentValidationResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__flow_validation_results => {
                            if !fields.insert(__FieldTag::__flow_validation_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flow_validation_results",
                                ));
                            }
                            result.flow_validation_results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FlowValidationResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for AgentValidationResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.flow_validation_results.is_empty() {
            state.serialize_entry("flowValidationResults", &self.flow_validation_results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for
/// [GetGenerativeSettings][google.cloud.dialogflow.cx.v3.Agents.GetGenerativeSettings]
/// RPC.
///
/// [google.cloud.dialogflow.cx.v3.Agents.GetGenerativeSettings]: crate::client::Agents::get_generative_settings
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetGenerativeSettingsRequest {
    /// Required. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/generativeSettings`.
    pub name: std::string::String,

    /// Required. Language code of the generative settings.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl GetGenerativeSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGenerativeSettingsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::GetGenerativeSettingsRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for GetGenerativeSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetGenerativeSettingsRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetGenerativeSettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetGenerativeSettingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetGenerativeSettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetGenerativeSettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for GetGenerativeSettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for
/// [UpdateGenerativeSettings][google.cloud.dialogflow.cx.v3.Agents.UpdateGenerativeSettings]
/// RPC.
///
/// [google.cloud.dialogflow.cx.v3.Agents.UpdateGenerativeSettings]: crate::client::Agents::update_generative_settings
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateGenerativeSettingsRequest {
    /// Required. Generative settings to update.
    pub generative_settings: std::option::Option<crate::model::GenerativeSettings>,

    /// Optional. The mask to control which fields get updated. If the mask is not
    /// present, all fields will be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl UpdateGenerativeSettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generative_settings][crate::model::UpdateGenerativeSettingsRequest::generative_settings].
    pub fn set_generative_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GenerativeSettings>,
    {
        self.generative_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [generative_settings][crate::model::UpdateGenerativeSettingsRequest::generative_settings].
    pub fn set_or_clear_generative_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GenerativeSettings>,
    {
        self.generative_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateGenerativeSettingsRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateGenerativeSettingsRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for UpdateGenerativeSettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.UpdateGenerativeSettingsRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateGenerativeSettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generative_settings,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateGenerativeSettingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generativeSettings" => Ok(__FieldTag::__generative_settings),
                            "generative_settings" => Ok(__FieldTag::__generative_settings),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateGenerativeSettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateGenerativeSettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generative_settings => {
                            if !fields.insert(__FieldTag::__generative_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generative_settings",
                                ));
                            }
                            result.generative_settings = map.next_value::<std::option::Option<crate::model::GenerativeSettings>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateGenerativeSettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.generative_settings.is_some() {
            state.serialize_entry("generativeSettings", &self.generative_settings)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information for a word recognized by the speech recognizer.
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SpeechWordInfo {
    /// The word this info is for.
    pub word: std::string::String,

    /// Time offset relative to the beginning of the audio that corresponds to the
    /// start of the spoken word. This is an experimental feature and the accuracy
    /// of the time offset can vary.
    pub start_offset: std::option::Option<wkt::Duration>,

    /// Time offset relative to the beginning of the audio that corresponds to the
    /// end of the spoken word. This is an experimental feature and the accuracy of
    /// the time offset can vary.
    pub end_offset: std::option::Option<wkt::Duration>,

    /// The Speech confidence between 0.0 and 1.0 for this word. A higher number
    /// indicates an estimated greater likelihood that the recognized word is
    /// correct. The default of 0.0 is a sentinel value indicating that confidence
    /// was not set.
    ///
    /// This field is not guaranteed to be fully stable over time for the same
    /// audio input. Users should also not rely on it to always be provided.
    pub confidence: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl SpeechWordInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [word][crate::model::SpeechWordInfo::word].
    pub fn set_word<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.word = v.into();
        self
    }

    /// Sets the value of [start_offset][crate::model::SpeechWordInfo::start_offset].
    pub fn set_start_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.start_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_offset][crate::model::SpeechWordInfo::start_offset].
    pub fn set_or_clear_start_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.start_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_offset][crate::model::SpeechWordInfo::end_offset].
    pub fn set_end_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.end_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_offset][crate::model::SpeechWordInfo::end_offset].
    pub fn set_or_clear_end_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.end_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [confidence][crate::model::SpeechWordInfo::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for SpeechWordInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.SpeechWordInfo"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SpeechWordInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __word,
            __start_offset,
            __end_offset,
            __confidence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpeechWordInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "word" => Ok(__FieldTag::__word),
                            "startOffset" => Ok(__FieldTag::__start_offset),
                            "start_offset" => Ok(__FieldTag::__start_offset),
                            "endOffset" => Ok(__FieldTag::__end_offset),
                            "end_offset" => Ok(__FieldTag::__end_offset),
                            "confidence" => Ok(__FieldTag::__confidence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SpeechWordInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpeechWordInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__word => {
                            if !fields.insert(__FieldTag::__word) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for word",
                                ));
                            }
                            result.word = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_offset => {
                            if !fields.insert(__FieldTag::__start_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_offset",
                                ));
                            }
                            result.start_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__end_offset => {
                            if !fields.insert(__FieldTag::__end_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_offset",
                                ));
                            }
                            result.end_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for SpeechWordInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.word.is_empty() {
            state.serialize_entry("word", &self.word)?;
        }
        if self.start_offset.is_some() {
            state.serialize_entry("startOffset", &self.start_offset)?;
        }
        if self.end_offset.is_some() {
            state.serialize_entry("endOffset", &self.end_offset)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration of the barge-in behavior. Barge-in instructs the API to return
/// a detected utterance at a proper time while the client is playing back the
/// response audio from a previous request. When the client sees the
/// utterance, it should stop the playback and immediately get ready for
/// receiving the responses for the current request.
///
/// The barge-in handling requires the client to start streaming audio input
/// as soon as it starts playing back the audio from the previous response. The
/// playback is modeled into two phases:
///
/// * No barge-in phase: which goes first and during which speech detection
///   should not be carried out.
///
/// * Barge-in phase: which follows the no barge-in phase and during which
///   the API starts speech detection and may inform the client that an utterance
///   has been detected. Note that no-speech event is not expected in this
///   phase.
///
///
/// The client provides this configuration in terms of the durations of those
/// two phases. The durations are measured in terms of the audio length from the
/// start of the input audio.
///
/// No-speech event is a response with END_OF_UTTERANCE without any transcript
/// following up.
#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BargeInConfig {
    /// Duration that is not eligible for barge-in at the beginning of the input
    /// audio.
    pub no_barge_in_duration: std::option::Option<wkt::Duration>,

    /// Total duration for the playback at the beginning of the input audio.
    pub total_duration: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl BargeInConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [no_barge_in_duration][crate::model::BargeInConfig::no_barge_in_duration].
    pub fn set_no_barge_in_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.no_barge_in_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [no_barge_in_duration][crate::model::BargeInConfig::no_barge_in_duration].
    pub fn set_or_clear_no_barge_in_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.no_barge_in_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [total_duration][crate::model::BargeInConfig::total_duration].
    pub fn set_total_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.total_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [total_duration][crate::model::BargeInConfig::total_duration].
    pub fn set_or_clear_total_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.total_duration = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl wkt::message::Message for BargeInConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.BargeInConfig"
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BargeInConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __no_barge_in_duration,
            __total_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BargeInConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "noBargeInDuration" => Ok(__FieldTag::__no_barge_in_duration),
                            "no_barge_in_duration" => Ok(__FieldTag::__no_barge_in_duration),
                            "totalDuration" => Ok(__FieldTag::__total_duration),
                            "total_duration" => Ok(__FieldTag::__total_duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BargeInConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BargeInConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__no_barge_in_duration => {
                            if !fields.insert(__FieldTag::__no_barge_in_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for no_barge_in_duration",
                                ));
                            }
                            result.no_barge_in_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__total_duration => {
                            if !fields.insert(__FieldTag::__total_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_duration",
                                ));
                            }
                            result.total_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for BargeInConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.no_barge_in_duration.is_some() {
            state.serialize_entry("noBargeInDuration", &self.no_barge_in_duration)?;
        }
        if self.total_duration.is_some() {
            state.serialize_entry("totalDuration", &self.total_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instructs the speech recognizer on how to process the audio content.
#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InputAudioConfig {
    /// Required. Audio encoding of the audio content to process.
    pub audio_encoding: crate::model::AudioEncoding,

    /// Sample rate (in Hertz) of the audio content sent in the query.
    /// Refer to
    /// [Cloud Speech API
    /// documentation](https://cloud.google.com/speech-to-text/docs/basics) for
    /// more details.
    pub sample_rate_hertz: i32,

    /// Optional. If `true`, Dialogflow returns
    /// [SpeechWordInfo][google.cloud.dialogflow.cx.v3.SpeechWordInfo] in
    /// [StreamingRecognitionResult][google.cloud.dialogflow.cx.v3.StreamingRecognitionResult]
    /// with information about the recognized speech words, e.g. start and end time
    /// offsets. If false or unspecified, Speech doesn't return any word-level
    /// information.
    ///
    /// [google.cloud.dialogflow.cx.v3.SpeechWordInfo]: crate::model::SpeechWordInfo
    /// [google.cloud.dialogflow.cx.v3.StreamingRecognitionResult]: crate::model::StreamingRecognitionResult
    pub enable_word_info: bool,

    /// Optional. A list of strings containing words and phrases that the speech
    /// recognizer should recognize with higher likelihood.
    ///
    /// See [the Cloud Speech
    /// documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints)
    /// for more details.
    pub phrase_hints: std::vec::Vec<std::string::String>,

    /// Optional. Which Speech model to select for the given request.
    /// For more information, see
    /// [Speech
    /// models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
    pub model: std::string::String,

    /// Optional. Which variant of the [Speech
    /// model][google.cloud.dialogflow.cx.v3.InputAudioConfig.model] to use.
    ///
    /// [google.cloud.dialogflow.cx.v3.InputAudioConfig.model]: crate::model::InputAudioConfig::model
    pub model_variant: crate::model::SpeechModelVariant,

    /// Optional. If `false` (default), recognition does not cease until the
    /// client closes the stream.
    /// If `true`, the recognizer will detect a single spoken utterance in input
    /// audio. Recognition ceases when it detects the audio's voice has
    /// stopped or paused. In this case, once a detected intent is received, the
    /// client should close the stream and start a new request with a new stream as
    /// needed.
    /// Note: This setting is relevant only for streaming methods.
    pub single_utterance: bool,

    /// Configuration of barge-in behavior during the streaming of input audio.
    pub barge_in_config: std::option::Option<crate::model::BargeInConfig>,

    /// If `true`, the request will opt out for STT conformer model migration.
    /// This field will be deprecated once force migration takes place in June
    /// 2024. Please refer to [Dialogflow CX Speech model
    /// migration](https://cloud.google.com/dialogflow/cx/docs/concept/speech-model-migration).
    pub opt_out_conformer_model_migration: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl InputAudioConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audio_encoding][crate::model::InputAudioConfig::audio_encoding].
    pub fn set_audio_encoding<T: std::convert::Into<crate::model::AudioEncoding>>(
        mut self,
        v: T,
    ) -> Self {
        self.audio_encoding = v.into();
        self
    }

    /// Sets the value of [sample_rate_hertz][crate::model::InputAudioConfig::sample_rate_hertz].
    pub fn set_sample_rate_hertz<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.sample_rate_hertz = v.into();
        self
    }

    /// Sets the value of [enable_word_info][crate::model::InputAudioConfig::enable_word_info].
    pub fn set_enable_word_info<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_word_info = v.into();
        self
    }

    /// Sets the value of [phrase_hints][crate::model::InputAudioConfig::phrase_hints].
    pub fn set_phrase_hints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.phrase_hints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [model][crate::model::InputAudioConfig::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [model_variant][crate::model::InputAudioConfig::model_variant].
    pub fn set_model_variant<T: std::convert::Into<crate::model::SpeechModelVariant>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_variant = v.into();
        self
    }

    /// Sets the value of [single_utterance][crate::model::InputAudioConfig::single_utterance].
    pub fn set_single_utterance<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.single_utterance = v.into();
        self
    }

    /// Sets the value of [barge_in_config][crate::model::InputAudioConfig::barge_in_config].
    pub fn set_barge_in_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BargeInConfig>,
    {
        self.barge_in_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [barge_in_config][crate::model::InputAudioConfig::barge_in_config].
    pub fn set_or_clear_barge_in_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BargeInConfig>,
    {
        self.barge_in_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [opt_out_conformer_model_migration][crate::model::InputAudioConfig::opt_out_conformer_model_migration].
    pub fn set_opt_out_conformer_model_migration<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.opt_out_conformer_model_migration = v.into();
        self
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl wkt::message::Message for InputAudioConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.InputAudioConfig"
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InputAudioConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_encoding,
            __sample_rate_hertz,
            __enable_word_info,
            __phrase_hints,
            __model,
            __model_variant,
            __single_utterance,
            __barge_in_config,
            __opt_out_conformer_model_migration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InputAudioConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioEncoding" => Ok(__FieldTag::__audio_encoding),
                            "audio_encoding" => Ok(__FieldTag::__audio_encoding),
                            "sampleRateHertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "sample_rate_hertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "enableWordInfo" => Ok(__FieldTag::__enable_word_info),
                            "enable_word_info" => Ok(__FieldTag::__enable_word_info),
                            "phraseHints" => Ok(__FieldTag::__phrase_hints),
                            "phrase_hints" => Ok(__FieldTag::__phrase_hints),
                            "model" => Ok(__FieldTag::__model),
                            "modelVariant" => Ok(__FieldTag::__model_variant),
                            "model_variant" => Ok(__FieldTag::__model_variant),
                            "singleUtterance" => Ok(__FieldTag::__single_utterance),
                            "single_utterance" => Ok(__FieldTag::__single_utterance),
                            "bargeInConfig" => Ok(__FieldTag::__barge_in_config),
                            "barge_in_config" => Ok(__FieldTag::__barge_in_config),
                            "optOutConformerModelMigration" => {
                                Ok(__FieldTag::__opt_out_conformer_model_migration)
                            }
                            "opt_out_conformer_model_migration" => {
                                Ok(__FieldTag::__opt_out_conformer_model_migration)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InputAudioConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InputAudioConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_encoding => {
                            if !fields.insert(__FieldTag::__audio_encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_encoding",
                                ));
                            }
                            result.audio_encoding = map
                                .next_value::<std::option::Option<crate::model::AudioEncoding>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sample_rate_hertz => {
                            if !fields.insert(__FieldTag::__sample_rate_hertz) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_rate_hertz",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sample_rate_hertz =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__enable_word_info => {
                            if !fields.insert(__FieldTag::__enable_word_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_word_info",
                                ));
                            }
                            result.enable_word_info = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__phrase_hints => {
                            if !fields.insert(__FieldTag::__phrase_hints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrase_hints",
                                ));
                            }
                            result.phrase_hints = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_variant => {
                            if !fields.insert(__FieldTag::__model_variant) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_variant",
                                ));
                            }
                            result.model_variant = map.next_value::<std::option::Option<crate::model::SpeechModelVariant>>()?.unwrap_or_default();
                        }
                        __FieldTag::__single_utterance => {
                            if !fields.insert(__FieldTag::__single_utterance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_utterance",
                                ));
                            }
                            result.single_utterance = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__barge_in_config => {
                            if !fields.insert(__FieldTag::__barge_in_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for barge_in_config",
                                ));
                            }
                            result.barge_in_config = map
                                .next_value::<std::option::Option<crate::model::BargeInConfig>>()?;
                        }
                        __FieldTag::__opt_out_conformer_model_migration => {
                            if !fields.insert(__FieldTag::__opt_out_conformer_model_migration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for opt_out_conformer_model_migration",
                                ));
                            }
                            result.opt_out_conformer_model_migration = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for InputAudioConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.audio_encoding) {
            state.serialize_entry("audioEncoding", &self.audio_encoding)?;
        }
        if !wkt::internal::is_default(&self.sample_rate_hertz) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sampleRateHertz", &__With(&self.sample_rate_hertz))?;
        }
        if !wkt::internal::is_default(&self.enable_word_info) {
            state.serialize_entry("enableWordInfo", &self.enable_word_info)?;
        }
        if !self.phrase_hints.is_empty() {
            state.serialize_entry("phraseHints", &self.phrase_hints)?;
        }
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !wkt::internal::is_default(&self.model_variant) {
            state.serialize_entry("modelVariant", &self.model_variant)?;
        }
        if !wkt::internal::is_default(&self.single_utterance) {
            state.serialize_entry("singleUtterance", &self.single_utterance)?;
        }
        if self.barge_in_config.is_some() {
            state.serialize_entry("bargeInConfig", &self.barge_in_config)?;
        }
        if !wkt::internal::is_default(&self.opt_out_conformer_model_migration) {
            state.serialize_entry(
                "optOutConformerModelMigration",
                &self.opt_out_conformer_model_migration,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Description of which voice to use for speech synthesis.
#[cfg(any(feature = "agents", feature = "sessions",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VoiceSelectionParams {
    /// Optional. The name of the voice. If not set, the service will choose a
    /// voice based on the other parameters such as language_code and
    /// [ssml_gender][google.cloud.dialogflow.cx.v3.VoiceSelectionParams.ssml_gender].
    ///
    /// For the list of available voices, please refer to [Supported voices and
    /// languages](https://cloud.google.com/text-to-speech/docs/voices).
    ///
    /// [google.cloud.dialogflow.cx.v3.VoiceSelectionParams.ssml_gender]: crate::model::VoiceSelectionParams::ssml_gender
    pub name: std::string::String,

    /// Optional. The preferred gender of the voice. If not set, the service will
    /// choose a voice based on the other parameters such as language_code and
    /// [name][google.cloud.dialogflow.cx.v3.VoiceSelectionParams.name]. Note that
    /// this is only a preference, not requirement. If a voice of the appropriate
    /// gender is not available, the synthesizer substitutes a voice with a
    /// different gender rather than failing the request.
    ///
    /// [google.cloud.dialogflow.cx.v3.VoiceSelectionParams.name]: crate::model::VoiceSelectionParams::name
    pub ssml_gender: crate::model::SsmlVoiceGender,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "agents", feature = "sessions",))]
impl VoiceSelectionParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VoiceSelectionParams::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ssml_gender][crate::model::VoiceSelectionParams::ssml_gender].
    pub fn set_ssml_gender<T: std::convert::Into<crate::model::SsmlVoiceGender>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssml_gender = v.into();
        self
    }
}

#[cfg(any(feature = "agents", feature = "sessions",))]
impl wkt::message::Message for VoiceSelectionParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.VoiceSelectionParams"
    }
}

#[cfg(any(feature = "agents", feature = "sessions",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VoiceSelectionParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __ssml_gender,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VoiceSelectionParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "ssmlGender" => Ok(__FieldTag::__ssml_gender),
                            "ssml_gender" => Ok(__FieldTag::__ssml_gender),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VoiceSelectionParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VoiceSelectionParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssml_gender => {
                            if !fields.insert(__FieldTag::__ssml_gender) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssml_gender",
                                ));
                            }
                            result.ssml_gender = map
                                .next_value::<std::option::Option<crate::model::SsmlVoiceGender>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "agents", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for VoiceSelectionParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.ssml_gender) {
            state.serialize_entry("ssmlGender", &self.ssml_gender)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration of how speech should be synthesized.
#[cfg(any(feature = "agents", feature = "sessions",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SynthesizeSpeechConfig {
    /// Optional. Speaking rate/speed, in the range [0.25, 4.0]. 1.0 is the normal
    /// native speed supported by the specific voice. 2.0 is twice as fast, and
    /// 0.5 is half as fast. If unset(0.0), defaults to the native 1.0 speed. Any
    /// other values < 0.25 or > 4.0 will return an error.
    pub speaking_rate: f64,

    /// Optional. Speaking pitch, in the range [-20.0, 20.0]. 20 means increase 20
    /// semitones from the original pitch. -20 means decrease 20 semitones from the
    /// original pitch.
    pub pitch: f64,

    /// Optional. Volume gain (in dB) of the normal native volume supported by the
    /// specific voice, in the range [-96.0, 16.0]. If unset, or set to a value of
    /// 0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
    /// will play at approximately half the amplitude of the normal native signal
    /// amplitude. A value of +6.0 (dB) will play at approximately twice the
    /// amplitude of the normal native signal amplitude. We strongly recommend not
    /// to exceed +10 (dB) as there's usually no effective increase in loudness for
    /// any value greater than that.
    pub volume_gain_db: f64,

    /// Optional. An identifier which selects 'audio effects' profiles that are
    /// applied on (post synthesized) text to speech. Effects are applied on top of
    /// each other in the order they are given.
    pub effects_profile_id: std::vec::Vec<std::string::String>,

    /// Optional. The desired voice of the synthesized audio.
    pub voice: std::option::Option<crate::model::VoiceSelectionParams>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "agents", feature = "sessions",))]
impl SynthesizeSpeechConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [speaking_rate][crate::model::SynthesizeSpeechConfig::speaking_rate].
    pub fn set_speaking_rate<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.speaking_rate = v.into();
        self
    }

    /// Sets the value of [pitch][crate::model::SynthesizeSpeechConfig::pitch].
    pub fn set_pitch<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.pitch = v.into();
        self
    }

    /// Sets the value of [volume_gain_db][crate::model::SynthesizeSpeechConfig::volume_gain_db].
    pub fn set_volume_gain_db<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.volume_gain_db = v.into();
        self
    }

    /// Sets the value of [effects_profile_id][crate::model::SynthesizeSpeechConfig::effects_profile_id].
    pub fn set_effects_profile_id<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.effects_profile_id = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [voice][crate::model::SynthesizeSpeechConfig::voice].
    pub fn set_voice<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VoiceSelectionParams>,
    {
        self.voice = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [voice][crate::model::SynthesizeSpeechConfig::voice].
    pub fn set_or_clear_voice<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VoiceSelectionParams>,
    {
        self.voice = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "agents", feature = "sessions",))]
impl wkt::message::Message for SynthesizeSpeechConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.SynthesizeSpeechConfig"
    }
}

#[cfg(any(feature = "agents", feature = "sessions",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SynthesizeSpeechConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __speaking_rate,
            __pitch,
            __volume_gain_db,
            __effects_profile_id,
            __voice,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SynthesizeSpeechConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "speakingRate" => Ok(__FieldTag::__speaking_rate),
                            "speaking_rate" => Ok(__FieldTag::__speaking_rate),
                            "pitch" => Ok(__FieldTag::__pitch),
                            "volumeGainDb" => Ok(__FieldTag::__volume_gain_db),
                            "volume_gain_db" => Ok(__FieldTag::__volume_gain_db),
                            "effectsProfileId" => Ok(__FieldTag::__effects_profile_id),
                            "effects_profile_id" => Ok(__FieldTag::__effects_profile_id),
                            "voice" => Ok(__FieldTag::__voice),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SynthesizeSpeechConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SynthesizeSpeechConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__speaking_rate => {
                            if !fields.insert(__FieldTag::__speaking_rate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speaking_rate",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.speaking_rate =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__pitch => {
                            if !fields.insert(__FieldTag::__pitch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pitch",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pitch = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__volume_gain_db => {
                            if !fields.insert(__FieldTag::__volume_gain_db) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_gain_db",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.volume_gain_db =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__effects_profile_id => {
                            if !fields.insert(__FieldTag::__effects_profile_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for effects_profile_id",
                                ));
                            }
                            result.effects_profile_id = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__voice => {
                            if !fields.insert(__FieldTag::__voice) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for voice",
                                ));
                            }
                            result.voice = map.next_value::<std::option::Option<crate::model::VoiceSelectionParams>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "agents", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for SynthesizeSpeechConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.speaking_rate) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("speakingRate", &__With(&self.speaking_rate))?;
        }
        if !wkt::internal::is_default(&self.pitch) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pitch", &__With(&self.pitch))?;
        }
        if !wkt::internal::is_default(&self.volume_gain_db) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("volumeGainDb", &__With(&self.volume_gain_db))?;
        }
        if !self.effects_profile_id.is_empty() {
            state.serialize_entry("effectsProfileId", &self.effects_profile_id)?;
        }
        if self.voice.is_some() {
            state.serialize_entry("voice", &self.voice)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instructs the speech synthesizer how to generate the output audio content.
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OutputAudioConfig {
    /// Required. Audio encoding of the synthesized audio content.
    pub audio_encoding: crate::model::OutputAudioEncoding,

    /// Optional. The synthesis sample rate (in hertz) for this audio. If not
    /// provided, then the synthesizer will use the default sample rate based on
    /// the audio encoding. If this is different from the voice's natural sample
    /// rate, then the synthesizer will honor this request by converting to the
    /// desired sample rate (which might result in worse audio quality).
    pub sample_rate_hertz: i32,

    /// Optional. Configuration of how speech should be synthesized.
    /// If not specified,
    /// [Agent.text_to_speech_settings][google.cloud.dialogflow.cx.v3.Agent.text_to_speech_settings]
    /// is applied.
    ///
    /// [google.cloud.dialogflow.cx.v3.Agent.text_to_speech_settings]: crate::model::Agent::text_to_speech_settings
    pub synthesize_speech_config: std::option::Option<crate::model::SynthesizeSpeechConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl OutputAudioConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audio_encoding][crate::model::OutputAudioConfig::audio_encoding].
    pub fn set_audio_encoding<T: std::convert::Into<crate::model::OutputAudioEncoding>>(
        mut self,
        v: T,
    ) -> Self {
        self.audio_encoding = v.into();
        self
    }

    /// Sets the value of [sample_rate_hertz][crate::model::OutputAudioConfig::sample_rate_hertz].
    pub fn set_sample_rate_hertz<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.sample_rate_hertz = v.into();
        self
    }

    /// Sets the value of [synthesize_speech_config][crate::model::OutputAudioConfig::synthesize_speech_config].
    pub fn set_synthesize_speech_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SynthesizeSpeechConfig>,
    {
        self.synthesize_speech_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [synthesize_speech_config][crate::model::OutputAudioConfig::synthesize_speech_config].
    pub fn set_or_clear_synthesize_speech_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SynthesizeSpeechConfig>,
    {
        self.synthesize_speech_config = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for OutputAudioConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.OutputAudioConfig"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OutputAudioConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_encoding,
            __sample_rate_hertz,
            __synthesize_speech_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OutputAudioConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioEncoding" => Ok(__FieldTag::__audio_encoding),
                            "audio_encoding" => Ok(__FieldTag::__audio_encoding),
                            "sampleRateHertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "sample_rate_hertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "synthesizeSpeechConfig" => Ok(__FieldTag::__synthesize_speech_config),
                            "synthesize_speech_config" => {
                                Ok(__FieldTag::__synthesize_speech_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OutputAudioConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OutputAudioConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_encoding => {
                            if !fields.insert(__FieldTag::__audio_encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_encoding",
                                ));
                            }
                            result.audio_encoding = map.next_value::<std::option::Option<crate::model::OutputAudioEncoding>>()?.unwrap_or_default();
                        }
                        __FieldTag::__sample_rate_hertz => {
                            if !fields.insert(__FieldTag::__sample_rate_hertz) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_rate_hertz",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sample_rate_hertz =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__synthesize_speech_config => {
                            if !fields.insert(__FieldTag::__synthesize_speech_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for synthesize_speech_config",
                                ));
                            }
                            result.synthesize_speech_config = map.next_value::<std::option::Option<crate::model::SynthesizeSpeechConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for OutputAudioConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.audio_encoding) {
            state.serialize_entry("audioEncoding", &self.audio_encoding)?;
        }
        if !wkt::internal::is_default(&self.sample_rate_hertz) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sampleRateHertz", &__With(&self.sample_rate_hertz))?;
        }
        if self.synthesize_speech_config.is_some() {
            state.serialize_entry("synthesizeSpeechConfig", &self.synthesize_speech_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Settings related to speech synthesizing.
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TextToSpeechSettings {
    /// Configuration of how speech should be synthesized, mapping from language
    /// (<https://cloud.google.com/dialogflow/cx/docs/reference/language>) to
    /// SynthesizeSpeechConfig.
    ///
    /// These settings affect:
    ///
    /// - The [phone
    ///   gateway](https://cloud.google.com/dialogflow/cx/docs/concept/integration/phone-gateway)
    ///   synthesize configuration set via
    ///   [Agent.text_to_speech_settings][google.cloud.dialogflow.cx.v3.Agent.text_to_speech_settings].
    ///
    /// - How speech is synthesized when invoking
    ///   [session][google.cloud.dialogflow.cx.v3.Sessions] APIs.
    ///   [Agent.text_to_speech_settings][google.cloud.dialogflow.cx.v3.Agent.text_to_speech_settings]
    ///   only applies if
    ///   [OutputAudioConfig.synthesize_speech_config][google.cloud.dialogflow.cx.v3.OutputAudioConfig.synthesize_speech_config]
    ///   is not specified.
    ///
    ///
    /// [google.cloud.dialogflow.cx.v3.Agent.text_to_speech_settings]: crate::model::Agent::text_to_speech_settings
    /// [google.cloud.dialogflow.cx.v3.OutputAudioConfig.synthesize_speech_config]: crate::model::OutputAudioConfig::synthesize_speech_config
    /// [google.cloud.dialogflow.cx.v3.Sessions]: crate::client::Sessions
    pub synthesize_speech_configs:
        std::collections::HashMap<std::string::String, crate::model::SynthesizeSpeechConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl TextToSpeechSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [synthesize_speech_configs][crate::model::TextToSpeechSettings::synthesize_speech_configs].
    pub fn set_synthesize_speech_configs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::SynthesizeSpeechConfig>,
    {
        use std::iter::Iterator;
        self.synthesize_speech_configs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for TextToSpeechSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.TextToSpeechSettings"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TextToSpeechSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __synthesize_speech_configs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TextToSpeechSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "synthesizeSpeechConfigs" => {
                                Ok(__FieldTag::__synthesize_speech_configs)
                            }
                            "synthesize_speech_configs" => {
                                Ok(__FieldTag::__synthesize_speech_configs)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TextToSpeechSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TextToSpeechSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__synthesize_speech_configs => {
                            if !fields.insert(__FieldTag::__synthesize_speech_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for synthesize_speech_configs",
                                ));
                            }
                            result.synthesize_speech_configs = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::SynthesizeSpeechConfig,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for TextToSpeechSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.synthesize_speech_configs.is_empty() {
            state.serialize_entry("synthesizeSpeechConfigs", &self.synthesize_speech_configs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Changelogs.ListChangelogs][google.cloud.dialogflow.cx.v3.Changelogs.ListChangelogs].
///
/// [google.cloud.dialogflow.cx.v3.Changelogs.ListChangelogs]: crate::client::Changelogs::list_changelogs
#[cfg(feature = "changelogs")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListChangelogsRequest {
    /// Required. The agent containing the changelogs.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// The filter string. Supports filter by user_email, resource, type and
    /// create_time. Some examples:
    ///
    /// . By user email:
    ///   user_email = "someone@google.com"
    /// . By resource name:
    ///   resource = "projects/123/locations/global/agents/456/flows/789"
    /// . By resource display name:
    ///   display_name = "my agent"
    /// . By action:
    ///   action = "Create"
    /// . By type:
    ///   type = "flows"
    /// . By create time. Currently predicates on `create_time` and
    ///   `create_time_epoch_seconds` are supported:
    ///   create_time_epoch_seconds > 1551790877 AND create_time <=
    ///   2017-01-15T01:30:15.01Z
    /// . Combination of above filters:
    ///   resource = "projects/123/locations/global/agents/456/flows/789"
    ///   AND user_email = "someone@google.com"
    ///   AND create_time <= 2017-01-15T01:30:15.01Z
    pub filter: std::string::String,

    /// The maximum number of items to return in a single page. By default 100 and
    /// at most 1000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "changelogs")]
impl ListChangelogsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListChangelogsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListChangelogsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListChangelogsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListChangelogsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "changelogs")]
impl wkt::message::Message for ListChangelogsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListChangelogsRequest"
    }
}

#[cfg(feature = "changelogs")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListChangelogsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListChangelogsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListChangelogsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListChangelogsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "changelogs")]
#[doc(hidden)]
impl serde::ser::Serialize for ListChangelogsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Changelogs.ListChangelogs][google.cloud.dialogflow.cx.v3.Changelogs.ListChangelogs].
///
/// [google.cloud.dialogflow.cx.v3.Changelogs.ListChangelogs]: crate::client::Changelogs::list_changelogs
#[cfg(feature = "changelogs")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListChangelogsResponse {
    /// The list of changelogs. There will be a maximum number of items returned
    /// based on the page_size field in the request. The changelogs will be ordered
    /// by timestamp.
    pub changelogs: std::vec::Vec<crate::model::Changelog>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "changelogs")]
impl ListChangelogsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [changelogs][crate::model::ListChangelogsResponse::changelogs].
    pub fn set_changelogs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Changelog>,
    {
        use std::iter::Iterator;
        self.changelogs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListChangelogsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "changelogs")]
impl wkt::message::Message for ListChangelogsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListChangelogsResponse"
    }
}

#[cfg(feature = "changelogs")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListChangelogsResponse {
    type PageItem = crate::model::Changelog;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.changelogs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "changelogs")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListChangelogsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __changelogs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListChangelogsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "changelogs" => Ok(__FieldTag::__changelogs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListChangelogsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListChangelogsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__changelogs => {
                            if !fields.insert(__FieldTag::__changelogs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for changelogs",
                                ));
                            }
                            result.changelogs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Changelog>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "changelogs")]
#[doc(hidden)]
impl serde::ser::Serialize for ListChangelogsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.changelogs.is_empty() {
            state.serialize_entry("changelogs", &self.changelogs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Changelogs.GetChangelog][google.cloud.dialogflow.cx.v3.Changelogs.GetChangelog].
///
/// [google.cloud.dialogflow.cx.v3.Changelogs.GetChangelog]: crate::client::Changelogs::get_changelog
#[cfg(feature = "changelogs")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetChangelogRequest {
    /// Required. The name of the changelog to get.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/changelogs/<ChangelogID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "changelogs")]
impl GetChangelogRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetChangelogRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "changelogs")]
impl wkt::message::Message for GetChangelogRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetChangelogRequest"
    }
}

#[cfg(feature = "changelogs")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetChangelogRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetChangelogRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetChangelogRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetChangelogRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "changelogs")]
#[doc(hidden)]
impl serde::ser::Serialize for GetChangelogRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Changelogs represents a change made to a given agent.
#[cfg(feature = "changelogs")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Changelog {
    /// The unique identifier of the changelog.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/changelogs/<ChangelogID>`.
    pub name: std::string::String,

    /// Email address of the authenticated user.
    pub user_email: std::string::String,

    /// The affected resource display name of the change.
    pub display_name: std::string::String,

    /// The action of the change.
    pub action: std::string::String,

    /// The affected resource type.
    pub r#type: std::string::String,

    /// The affected resource name of the change.
    pub resource: std::string::String,

    /// The timestamp of the change.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The affected language code of the change.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "changelogs")]
impl Changelog {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Changelog::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [user_email][crate::model::Changelog::user_email].
    pub fn set_user_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_email = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Changelog::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [action][crate::model::Changelog::action].
    pub fn set_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Changelog::type].
    pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::Changelog::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Changelog::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Changelog::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::Changelog::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "changelogs")]
impl wkt::message::Message for Changelog {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.Changelog"
    }
}

#[cfg(feature = "changelogs")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Changelog {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __user_email,
            __display_name,
            __action,
            __type,
            __resource,
            __create_time,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Changelog")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "userEmail" => Ok(__FieldTag::__user_email),
                            "user_email" => Ok(__FieldTag::__user_email),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "action" => Ok(__FieldTag::__action),
                            "type" => Ok(__FieldTag::__type),
                            "resource" => Ok(__FieldTag::__resource),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Changelog;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Changelog")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_email => {
                            if !fields.insert(__FieldTag::__user_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_email",
                                ));
                            }
                            result.user_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            result.action = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "changelogs")]
#[doc(hidden)]
impl serde::ser::Serialize for Changelog {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.user_email.is_empty() {
            state.serialize_entry("userEmail", &self.user_email)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.action.is_empty() {
            state.serialize_entry("action", &self.action)?;
        }
        if !self.r#type.is_empty() {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A data store connection. It represents a data store in Discovery Engine and
/// the type of the contents it contains.
#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataStoreConnection {
    /// The type of the connected data store.
    pub data_store_type: crate::model::DataStoreType,

    /// The full name of the referenced data store.
    /// Formats:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`
    /// `projects/{project}/locations/{location}/dataStores/{data_store}`
    pub data_store: std::string::String,

    /// The document processing mode for the data store connection. Should only be
    /// set for PUBLIC_WEB and UNSTRUCTURED data stores. If not set it is
    /// considered as DOCUMENTS, as this is the legacy mode.
    pub document_processing_mode: crate::model::DocumentProcessingMode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl DataStoreConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_store_type][crate::model::DataStoreConnection::data_store_type].
    pub fn set_data_store_type<T: std::convert::Into<crate::model::DataStoreType>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_store_type = v.into();
        self
    }

    /// Sets the value of [data_store][crate::model::DataStoreConnection::data_store].
    pub fn set_data_store<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.data_store = v.into();
        self
    }

    /// Sets the value of [document_processing_mode][crate::model::DataStoreConnection::document_processing_mode].
    pub fn set_document_processing_mode<
        T: std::convert::Into<crate::model::DocumentProcessingMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.document_processing_mode = v.into();
        self
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl wkt::message::Message for DataStoreConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DataStoreConnection"
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataStoreConnection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_store_type,
            __data_store,
            __document_processing_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataStoreConnection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataStoreType" => Ok(__FieldTag::__data_store_type),
                            "data_store_type" => Ok(__FieldTag::__data_store_type),
                            "dataStore" => Ok(__FieldTag::__data_store),
                            "data_store" => Ok(__FieldTag::__data_store),
                            "documentProcessingMode" => Ok(__FieldTag::__document_processing_mode),
                            "document_processing_mode" => {
                                Ok(__FieldTag::__document_processing_mode)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataStoreConnection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataStoreConnection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_store_type => {
                            if !fields.insert(__FieldTag::__data_store_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_store_type",
                                ));
                            }
                            result.data_store_type = map
                                .next_value::<std::option::Option<crate::model::DataStoreType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_store => {
                            if !fields.insert(__FieldTag::__data_store) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_store",
                                ));
                            }
                            result.data_store = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__document_processing_mode => {
                            if !fields.insert(__FieldTag::__document_processing_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_processing_mode",
                                ));
                            }
                            result.document_processing_mode = map.next_value::<std::option::Option<crate::model::DocumentProcessingMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
#[doc(hidden)]
impl serde::ser::Serialize for DataStoreConnection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.data_store_type) {
            state.serialize_entry("dataStoreType", &self.data_store_type)?;
        }
        if !self.data_store.is_empty() {
            state.serialize_entry("dataStore", &self.data_store)?;
        }
        if !wkt::internal::is_default(&self.document_processing_mode) {
            state.serialize_entry("documentProcessingMode", &self.document_processing_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Data store connection feature output signals.
/// Might be only partially field if processing stop before the final answer.
/// Reasons for this can be, but are not limited to: empty UCS search results,
/// positive RAI check outcome, grounding failure, ...
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataStoreConnectionSignals {
    /// Optional. Diagnostic info related to the rewriter model call.
    pub rewriter_model_call_signals:
        std::option::Option<crate::model::data_store_connection_signals::RewriterModelCallSignals>,

    /// Optional. Rewritten string query used for search.
    pub rewritten_query: std::string::String,

    /// Optional. Search snippets included in the answer generation prompt.
    pub search_snippets: std::vec::Vec<crate::model::data_store_connection_signals::SearchSnippet>,

    /// Optional. Diagnostic info related to the answer generation model call.
    pub answer_generation_model_call_signals: std::option::Option<
        crate::model::data_store_connection_signals::AnswerGenerationModelCallSignals,
    >,

    /// Optional. The final compiled answer.
    pub answer: std::string::String,

    /// Optional. Answer parts with relevant citations.
    /// Concatenation of texts should add up the `answer` (not counting
    /// whitespaces).
    pub answer_parts: std::vec::Vec<crate::model::data_store_connection_signals::AnswerPart>,

    /// Optional. Snippets cited by the answer generation model from the most to
    /// least relevant.
    pub cited_snippets: std::vec::Vec<crate::model::data_store_connection_signals::CitedSnippet>,

    /// Optional. Grounding signals.
    pub grounding_signals:
        std::option::Option<crate::model::data_store_connection_signals::GroundingSignals>,

    /// Optional. Safety check result.
    pub safety_signals:
        std::option::Option<crate::model::data_store_connection_signals::SafetySignals>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl DataStoreConnectionSignals {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rewriter_model_call_signals][crate::model::DataStoreConnectionSignals::rewriter_model_call_signals].
    pub fn set_rewriter_model_call_signals<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::data_store_connection_signals::RewriterModelCallSignals,
            >,
    {
        self.rewriter_model_call_signals = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rewriter_model_call_signals][crate::model::DataStoreConnectionSignals::rewriter_model_call_signals].
    pub fn set_or_clear_rewriter_model_call_signals<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::data_store_connection_signals::RewriterModelCallSignals,
            >,
    {
        self.rewriter_model_call_signals = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rewritten_query][crate::model::DataStoreConnectionSignals::rewritten_query].
    pub fn set_rewritten_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rewritten_query = v.into();
        self
    }

    /// Sets the value of [search_snippets][crate::model::DataStoreConnectionSignals::search_snippets].
    pub fn set_search_snippets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::data_store_connection_signals::SearchSnippet>,
    {
        use std::iter::Iterator;
        self.search_snippets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [answer_generation_model_call_signals][crate::model::DataStoreConnectionSignals::answer_generation_model_call_signals].
    pub fn set_answer_generation_model_call_signals<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::data_store_connection_signals::AnswerGenerationModelCallSignals,
            >,
    {
        self.answer_generation_model_call_signals = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [answer_generation_model_call_signals][crate::model::DataStoreConnectionSignals::answer_generation_model_call_signals].
    pub fn set_or_clear_answer_generation_model_call_signals<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<
                crate::model::data_store_connection_signals::AnswerGenerationModelCallSignals,
            >,
    {
        self.answer_generation_model_call_signals = v.map(|x| x.into());
        self
    }

    /// Sets the value of [answer][crate::model::DataStoreConnectionSignals::answer].
    pub fn set_answer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.answer = v.into();
        self
    }

    /// Sets the value of [answer_parts][crate::model::DataStoreConnectionSignals::answer_parts].
    pub fn set_answer_parts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::data_store_connection_signals::AnswerPart>,
    {
        use std::iter::Iterator;
        self.answer_parts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cited_snippets][crate::model::DataStoreConnectionSignals::cited_snippets].
    pub fn set_cited_snippets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::data_store_connection_signals::CitedSnippet>,
    {
        use std::iter::Iterator;
        self.cited_snippets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [grounding_signals][crate::model::DataStoreConnectionSignals::grounding_signals].
    pub fn set_grounding_signals<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::data_store_connection_signals::GroundingSignals>,
    {
        self.grounding_signals = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [grounding_signals][crate::model::DataStoreConnectionSignals::grounding_signals].
    pub fn set_or_clear_grounding_signals<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::data_store_connection_signals::GroundingSignals>,
    {
        self.grounding_signals = v.map(|x| x.into());
        self
    }

    /// Sets the value of [safety_signals][crate::model::DataStoreConnectionSignals::safety_signals].
    pub fn set_safety_signals<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::data_store_connection_signals::SafetySignals>,
    {
        self.safety_signals = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [safety_signals][crate::model::DataStoreConnectionSignals::safety_signals].
    pub fn set_or_clear_safety_signals<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::data_store_connection_signals::SafetySignals>,
    {
        self.safety_signals = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for DataStoreConnectionSignals {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DataStoreConnectionSignals"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataStoreConnectionSignals {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rewriter_model_call_signals,
            __rewritten_query,
            __search_snippets,
            __answer_generation_model_call_signals,
            __answer,
            __answer_parts,
            __cited_snippets,
            __grounding_signals,
            __safety_signals,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataStoreConnectionSignals")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rewriterModelCallSignals" => {
                                Ok(__FieldTag::__rewriter_model_call_signals)
                            }
                            "rewriter_model_call_signals" => {
                                Ok(__FieldTag::__rewriter_model_call_signals)
                            }
                            "rewrittenQuery" => Ok(__FieldTag::__rewritten_query),
                            "rewritten_query" => Ok(__FieldTag::__rewritten_query),
                            "searchSnippets" => Ok(__FieldTag::__search_snippets),
                            "search_snippets" => Ok(__FieldTag::__search_snippets),
                            "answerGenerationModelCallSignals" => {
                                Ok(__FieldTag::__answer_generation_model_call_signals)
                            }
                            "answer_generation_model_call_signals" => {
                                Ok(__FieldTag::__answer_generation_model_call_signals)
                            }
                            "answer" => Ok(__FieldTag::__answer),
                            "answerParts" => Ok(__FieldTag::__answer_parts),
                            "answer_parts" => Ok(__FieldTag::__answer_parts),
                            "citedSnippets" => Ok(__FieldTag::__cited_snippets),
                            "cited_snippets" => Ok(__FieldTag::__cited_snippets),
                            "groundingSignals" => Ok(__FieldTag::__grounding_signals),
                            "grounding_signals" => Ok(__FieldTag::__grounding_signals),
                            "safetySignals" => Ok(__FieldTag::__safety_signals),
                            "safety_signals" => Ok(__FieldTag::__safety_signals),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataStoreConnectionSignals;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataStoreConnectionSignals")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rewriter_model_call_signals => {
                            if !fields.insert(__FieldTag::__rewriter_model_call_signals) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rewriter_model_call_signals",
                                ));
                            }
                            result.rewriter_model_call_signals = map.next_value::<std::option::Option<crate::model::data_store_connection_signals::RewriterModelCallSignals>>()?
                                ;
                        }
                        __FieldTag::__rewritten_query => {
                            if !fields.insert(__FieldTag::__rewritten_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rewritten_query",
                                ));
                            }
                            result.rewritten_query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__search_snippets => {
                            if !fields.insert(__FieldTag::__search_snippets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for search_snippets",
                                ));
                            }
                            result.search_snippets = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::data_store_connection_signals::SearchSnippet,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__answer_generation_model_call_signals => {
                            if !fields.insert(__FieldTag::__answer_generation_model_call_signals) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_generation_model_call_signals",
                                ));
                            }
                            result.answer_generation_model_call_signals = map.next_value::<std::option::Option<crate::model::data_store_connection_signals::AnswerGenerationModelCallSignals>>()?
                                ;
                        }
                        __FieldTag::__answer => {
                            if !fields.insert(__FieldTag::__answer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer",
                                ));
                            }
                            result.answer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__answer_parts => {
                            if !fields.insert(__FieldTag::__answer_parts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_parts",
                                ));
                            }
                            result.answer_parts = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::data_store_connection_signals::AnswerPart,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cited_snippets => {
                            if !fields.insert(__FieldTag::__cited_snippets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cited_snippets",
                                ));
                            }
                            result.cited_snippets = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::data_store_connection_signals::CitedSnippet,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__grounding_signals => {
                            if !fields.insert(__FieldTag::__grounding_signals) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for grounding_signals",
                                ));
                            }
                            result.grounding_signals = map.next_value::<std::option::Option<
                                crate::model::data_store_connection_signals::GroundingSignals,
                            >>()?;
                        }
                        __FieldTag::__safety_signals => {
                            if !fields.insert(__FieldTag::__safety_signals) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for safety_signals",
                                ));
                            }
                            result.safety_signals = map.next_value::<std::option::Option<
                                crate::model::data_store_connection_signals::SafetySignals,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for DataStoreConnectionSignals {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.rewriter_model_call_signals.is_some() {
            state.serialize_entry(
                "rewriterModelCallSignals",
                &self.rewriter_model_call_signals,
            )?;
        }
        if !self.rewritten_query.is_empty() {
            state.serialize_entry("rewrittenQuery", &self.rewritten_query)?;
        }
        if !self.search_snippets.is_empty() {
            state.serialize_entry("searchSnippets", &self.search_snippets)?;
        }
        if self.answer_generation_model_call_signals.is_some() {
            state.serialize_entry(
                "answerGenerationModelCallSignals",
                &self.answer_generation_model_call_signals,
            )?;
        }
        if !self.answer.is_empty() {
            state.serialize_entry("answer", &self.answer)?;
        }
        if !self.answer_parts.is_empty() {
            state.serialize_entry("answerParts", &self.answer_parts)?;
        }
        if !self.cited_snippets.is_empty() {
            state.serialize_entry("citedSnippets", &self.cited_snippets)?;
        }
        if self.grounding_signals.is_some() {
            state.serialize_entry("groundingSignals", &self.grounding_signals)?;
        }
        if self.safety_signals.is_some() {
            state.serialize_entry("safetySignals", &self.safety_signals)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DataStoreConnectionSignals].
#[cfg(feature = "sessions")]
pub mod data_store_connection_signals {
    #[allow(unused_imports)]
    use super::*;

    /// Diagnostic info related to the rewriter model call.
    #[cfg(feature = "sessions")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RewriterModelCallSignals {
        /// Prompt as sent to the model.
        pub rendered_prompt: std::string::String,

        /// Output of the generative model.
        pub model_output: std::string::String,

        /// Name of the generative model. For example, "gemini-ultra", "gemini-pro",
        /// "gemini-1.5-flash" etc. Defaults to "Other" if the model is unknown.
        pub model: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "sessions")]
    impl RewriterModelCallSignals {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [rendered_prompt][crate::model::data_store_connection_signals::RewriterModelCallSignals::rendered_prompt].
        pub fn set_rendered_prompt<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.rendered_prompt = v.into();
            self
        }

        /// Sets the value of [model_output][crate::model::data_store_connection_signals::RewriterModelCallSignals::model_output].
        pub fn set_model_output<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.model_output = v.into();
            self
        }

        /// Sets the value of [model][crate::model::data_store_connection_signals::RewriterModelCallSignals::model].
        pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.model = v.into();
            self
        }
    }

    #[cfg(feature = "sessions")]
    impl wkt::message::Message for RewriterModelCallSignals {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.DataStoreConnectionSignals.RewriterModelCallSignals"
        }
    }

    #[cfg(feature = "sessions")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RewriterModelCallSignals {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __rendered_prompt,
                __model_output,
                __model,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RewriterModelCallSignals")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "renderedPrompt" => Ok(__FieldTag::__rendered_prompt),
                                "rendered_prompt" => Ok(__FieldTag::__rendered_prompt),
                                "modelOutput" => Ok(__FieldTag::__model_output),
                                "model_output" => Ok(__FieldTag::__model_output),
                                "model" => Ok(__FieldTag::__model),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RewriterModelCallSignals;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RewriterModelCallSignals")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__rendered_prompt => {
                                if !fields.insert(__FieldTag::__rendered_prompt) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for rendered_prompt",
                                    ));
                                }
                                result.rendered_prompt = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__model_output => {
                                if !fields.insert(__FieldTag::__model_output) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for model_output",
                                    ));
                                }
                                result.model_output = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__model => {
                                if !fields.insert(__FieldTag::__model) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for model",
                                    ));
                                }
                                result.model = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "sessions")]
    #[doc(hidden)]
    impl serde::ser::Serialize for RewriterModelCallSignals {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.rendered_prompt.is_empty() {
                state.serialize_entry("renderedPrompt", &self.rendered_prompt)?;
            }
            if !self.model_output.is_empty() {
                state.serialize_entry("modelOutput", &self.model_output)?;
            }
            if !self.model.is_empty() {
                state.serialize_entry("model", &self.model)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Search snippet details.
    #[cfg(feature = "sessions")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SearchSnippet {
        /// Title of the enclosing document.
        pub document_title: std::string::String,

        /// Uri for the document. Present if specified for the document.
        pub document_uri: std::string::String,

        /// Text included in the prompt.
        pub text: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "sessions")]
    impl SearchSnippet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [document_title][crate::model::data_store_connection_signals::SearchSnippet::document_title].
        pub fn set_document_title<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.document_title = v.into();
            self
        }

        /// Sets the value of [document_uri][crate::model::data_store_connection_signals::SearchSnippet::document_uri].
        pub fn set_document_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.document_uri = v.into();
            self
        }

        /// Sets the value of [text][crate::model::data_store_connection_signals::SearchSnippet::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }
    }

    #[cfg(feature = "sessions")]
    impl wkt::message::Message for SearchSnippet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.DataStoreConnectionSignals.SearchSnippet"
        }
    }

    #[cfg(feature = "sessions")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SearchSnippet {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __document_title,
                __document_uri,
                __text,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SearchSnippet")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "documentTitle" => Ok(__FieldTag::__document_title),
                                "document_title" => Ok(__FieldTag::__document_title),
                                "documentUri" => Ok(__FieldTag::__document_uri),
                                "document_uri" => Ok(__FieldTag::__document_uri),
                                "text" => Ok(__FieldTag::__text),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SearchSnippet;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SearchSnippet")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__document_title => {
                                if !fields.insert(__FieldTag::__document_title) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for document_title",
                                    ));
                                }
                                result.document_title = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__document_uri => {
                                if !fields.insert(__FieldTag::__document_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for document_uri",
                                    ));
                                }
                                result.document_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__text => {
                                if !fields.insert(__FieldTag::__text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text",
                                    ));
                                }
                                result.text = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "sessions")]
    #[doc(hidden)]
    impl serde::ser::Serialize for SearchSnippet {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.document_title.is_empty() {
                state.serialize_entry("documentTitle", &self.document_title)?;
            }
            if !self.document_uri.is_empty() {
                state.serialize_entry("documentUri", &self.document_uri)?;
            }
            if !self.text.is_empty() {
                state.serialize_entry("text", &self.text)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Diagnostic info related to the answer generation model call.
    #[cfg(feature = "sessions")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AnswerGenerationModelCallSignals {
        /// Prompt as sent to the model.
        pub rendered_prompt: std::string::String,

        /// Output of the generative model.
        pub model_output: std::string::String,

        /// Name of the generative model. For example, "gemini-ultra", "gemini-pro",
        /// "gemini-1.5-flash" etc. Defaults to "Other" if the model is unknown.
        pub model: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "sessions")]
    impl AnswerGenerationModelCallSignals {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [rendered_prompt][crate::model::data_store_connection_signals::AnswerGenerationModelCallSignals::rendered_prompt].
        pub fn set_rendered_prompt<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.rendered_prompt = v.into();
            self
        }

        /// Sets the value of [model_output][crate::model::data_store_connection_signals::AnswerGenerationModelCallSignals::model_output].
        pub fn set_model_output<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.model_output = v.into();
            self
        }

        /// Sets the value of [model][crate::model::data_store_connection_signals::AnswerGenerationModelCallSignals::model].
        pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.model = v.into();
            self
        }
    }

    #[cfg(feature = "sessions")]
    impl wkt::message::Message for AnswerGenerationModelCallSignals {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.DataStoreConnectionSignals.AnswerGenerationModelCallSignals"
        }
    }

    #[cfg(feature = "sessions")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AnswerGenerationModelCallSignals {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __rendered_prompt,
                __model_output,
                __model,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AnswerGenerationModelCallSignals")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "renderedPrompt" => Ok(__FieldTag::__rendered_prompt),
                                "rendered_prompt" => Ok(__FieldTag::__rendered_prompt),
                                "modelOutput" => Ok(__FieldTag::__model_output),
                                "model_output" => Ok(__FieldTag::__model_output),
                                "model" => Ok(__FieldTag::__model),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AnswerGenerationModelCallSignals;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AnswerGenerationModelCallSignals")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__rendered_prompt => {
                                if !fields.insert(__FieldTag::__rendered_prompt) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for rendered_prompt",
                                    ));
                                }
                                result.rendered_prompt = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__model_output => {
                                if !fields.insert(__FieldTag::__model_output) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for model_output",
                                    ));
                                }
                                result.model_output = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__model => {
                                if !fields.insert(__FieldTag::__model) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for model",
                                    ));
                                }
                                result.model = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "sessions")]
    #[doc(hidden)]
    impl serde::ser::Serialize for AnswerGenerationModelCallSignals {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.rendered_prompt.is_empty() {
                state.serialize_entry("renderedPrompt", &self.rendered_prompt)?;
            }
            if !self.model_output.is_empty() {
                state.serialize_entry("modelOutput", &self.model_output)?;
            }
            if !self.model.is_empty() {
                state.serialize_entry("model", &self.model)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Answer part with citation.
    #[cfg(feature = "sessions")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AnswerPart {
        /// Substring of the answer.
        pub text: std::string::String,

        /// Citations for this answer part. Indices of `search_snippets`.
        pub supporting_indices: std::vec::Vec<i32>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "sessions")]
    impl AnswerPart {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text][crate::model::data_store_connection_signals::AnswerPart::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }

        /// Sets the value of [supporting_indices][crate::model::data_store_connection_signals::AnswerPart::supporting_indices].
        pub fn set_supporting_indices<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<i32>,
        {
            use std::iter::Iterator;
            self.supporting_indices = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "sessions")]
    impl wkt::message::Message for AnswerPart {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.DataStoreConnectionSignals.AnswerPart"
        }
    }

    #[cfg(feature = "sessions")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AnswerPart {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __text,
                __supporting_indices,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AnswerPart")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "text" => Ok(__FieldTag::__text),
                                "supportingIndices" => Ok(__FieldTag::__supporting_indices),
                                "supporting_indices" => Ok(__FieldTag::__supporting_indices),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AnswerPart;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AnswerPart")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__text => {
                                if !fields.insert(__FieldTag::__text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text",
                                    ));
                                }
                                result.text = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__supporting_indices => {
                                if !fields.insert(__FieldTag::__supporting_indices) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for supporting_indices",
                                    ));
                                }
                                struct __With(std::option::Option<std::vec::Vec<i32>>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<std::vec::Vec<wkt::internal::I32>>,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.supporting_indices =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "sessions")]
    #[doc(hidden)]
    impl serde::ser::Serialize for AnswerPart {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.text.is_empty() {
                state.serialize_entry("text", &self.text)?;
            }
            if !self.supporting_indices.is_empty() {
                struct __With<'a>(&'a std::vec::Vec<i32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::vec::Vec<wkt::internal::I32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("supportingIndices", &__With(&self.supporting_indices))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Snippet cited by the answer generation model.
    #[cfg(feature = "sessions")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CitedSnippet {
        /// Details of the snippet.
        pub search_snippet:
            std::option::Option<crate::model::data_store_connection_signals::SearchSnippet>,

        /// Index of the snippet in `search_snippets` field.
        pub snippet_index: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "sessions")]
    impl CitedSnippet {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [search_snippet][crate::model::data_store_connection_signals::CitedSnippet::search_snippet].
        pub fn set_search_snippet<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::data_store_connection_signals::SearchSnippet>,
        {
            self.search_snippet = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [search_snippet][crate::model::data_store_connection_signals::CitedSnippet::search_snippet].
        pub fn set_or_clear_search_snippet<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::data_store_connection_signals::SearchSnippet>,
        {
            self.search_snippet = v.map(|x| x.into());
            self
        }

        /// Sets the value of [snippet_index][crate::model::data_store_connection_signals::CitedSnippet::snippet_index].
        pub fn set_snippet_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.snippet_index = v.into();
            self
        }
    }

    #[cfg(feature = "sessions")]
    impl wkt::message::Message for CitedSnippet {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.DataStoreConnectionSignals.CitedSnippet"
        }
    }

    #[cfg(feature = "sessions")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CitedSnippet {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __search_snippet,
                __snippet_index,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CitedSnippet")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "searchSnippet" => Ok(__FieldTag::__search_snippet),
                                "search_snippet" => Ok(__FieldTag::__search_snippet),
                                "snippetIndex" => Ok(__FieldTag::__snippet_index),
                                "snippet_index" => Ok(__FieldTag::__snippet_index),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CitedSnippet;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CitedSnippet")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__search_snippet => {
                                if !fields.insert(__FieldTag::__search_snippet) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for search_snippet",
                                    ));
                                }
                                result.search_snippet = map.next_value::<std::option::Option<
                                    crate::model::data_store_connection_signals::SearchSnippet,
                                >>()?;
                            }
                            __FieldTag::__snippet_index => {
                                if !fields.insert(__FieldTag::__snippet_index) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for snippet_index",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.snippet_index =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "sessions")]
    #[doc(hidden)]
    impl serde::ser::Serialize for CitedSnippet {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.search_snippet.is_some() {
                state.serialize_entry("searchSnippet", &self.search_snippet)?;
            }
            if !wkt::internal::is_default(&self.snippet_index) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("snippetIndex", &__With(&self.snippet_index))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Grounding signals.
    #[cfg(feature = "sessions")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GroundingSignals {
        /// Represents the decision of the grounding check.
        pub decision:
            crate::model::data_store_connection_signals::grounding_signals::GroundingDecision,

        /// Grounding score bucket setting.
        pub score:
            crate::model::data_store_connection_signals::grounding_signals::GroundingScoreBucket,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "sessions")]
    impl GroundingSignals {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [decision][crate::model::data_store_connection_signals::GroundingSignals::decision].
        pub fn set_decision<T: std::convert::Into<crate::model::data_store_connection_signals::grounding_signals::GroundingDecision>>(mut self, v: T) -> Self{
            self.decision = v.into();
            self
        }

        /// Sets the value of [score][crate::model::data_store_connection_signals::GroundingSignals::score].
        pub fn set_score<T: std::convert::Into<crate::model::data_store_connection_signals::grounding_signals::GroundingScoreBucket>>(mut self, v: T) -> Self{
            self.score = v.into();
            self
        }
    }

    #[cfg(feature = "sessions")]
    impl wkt::message::Message for GroundingSignals {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.DataStoreConnectionSignals.GroundingSignals"
        }
    }

    #[cfg(feature = "sessions")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GroundingSignals {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __decision,
                __score,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GroundingSignals")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "decision" => Ok(__FieldTag::__decision),
                                "score" => Ok(__FieldTag::__score),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GroundingSignals;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GroundingSignals")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__decision => {
                                if !fields.insert(__FieldTag::__decision) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for decision",
                                    ));
                                }
                                result.decision = map.next_value::<std::option::Option<crate::model::data_store_connection_signals::grounding_signals::GroundingDecision>>()?.unwrap_or_default();
                            }
                            __FieldTag::__score => {
                                if !fields.insert(__FieldTag::__score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for score",
                                    ));
                                }
                                result.score = map.next_value::<std::option::Option<crate::model::data_store_connection_signals::grounding_signals::GroundingScoreBucket>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "sessions")]
    #[doc(hidden)]
    impl serde::ser::Serialize for GroundingSignals {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.decision) {
                state.serialize_entry("decision", &self.decision)?;
            }
            if !wkt::internal::is_default(&self.score) {
                state.serialize_entry("score", &self.score)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [GroundingSignals].
    #[cfg(feature = "sessions")]
    pub mod grounding_signals {
        #[allow(unused_imports)]
        use super::*;

        /// Represents the decision of the grounding check.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "sessions")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum GroundingDecision {
            /// Decision not specified.
            Unspecified,
            /// Grounding have accepted the answer.
            AcceptedByGrounding,
            /// Grounding have rejected the answer.
            RejectedByGrounding,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [GroundingDecision::value] or
            /// [GroundingDecision::name].
            UnknownValue(grounding_decision::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "sessions")]
        pub mod grounding_decision {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "sessions")]
        impl GroundingDecision {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::AcceptedByGrounding => std::option::Option::Some(1),
                    Self::RejectedByGrounding => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("GROUNDING_DECISION_UNSPECIFIED")
                    }
                    Self::AcceptedByGrounding => std::option::Option::Some("ACCEPTED_BY_GROUNDING"),
                    Self::RejectedByGrounding => std::option::Option::Some("REJECTED_BY_GROUNDING"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "sessions")]
        impl std::default::Default for GroundingDecision {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "sessions")]
        impl std::fmt::Display for GroundingDecision {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "sessions")]
        impl std::convert::From<i32> for GroundingDecision {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::AcceptedByGrounding,
                    2 => Self::RejectedByGrounding,
                    _ => Self::UnknownValue(grounding_decision::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "sessions")]
        impl std::convert::From<&str> for GroundingDecision {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "GROUNDING_DECISION_UNSPECIFIED" => Self::Unspecified,
                    "ACCEPTED_BY_GROUNDING" => Self::AcceptedByGrounding,
                    "REJECTED_BY_GROUNDING" => Self::RejectedByGrounding,
                    _ => Self::UnknownValue(grounding_decision::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "sessions")]
        impl serde::ser::Serialize for GroundingDecision {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::AcceptedByGrounding => serializer.serialize_i32(1),
                    Self::RejectedByGrounding => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "sessions")]
        impl<'de> serde::de::Deserialize<'de> for GroundingDecision {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<GroundingDecision>::new(
                    ".google.cloud.dialogflow.cx.v3.DataStoreConnectionSignals.GroundingSignals.GroundingDecision"))
            }
        }

        /// Grounding score buckets.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "sessions")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum GroundingScoreBucket {
            /// Score not specified.
            Unspecified,
            /// We have very low confidence that the answer is grounded.
            VeryLow,
            /// We have low confidence that the answer is grounded.
            Low,
            /// We have medium confidence that the answer is grounded.
            Medium,
            /// We have high confidence that the answer is grounded.
            High,
            /// We have very high confidence that the answer is grounded.
            VeryHigh,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [GroundingScoreBucket::value] or
            /// [GroundingScoreBucket::name].
            UnknownValue(grounding_score_bucket::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "sessions")]
        pub mod grounding_score_bucket {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "sessions")]
        impl GroundingScoreBucket {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::VeryLow => std::option::Option::Some(1),
                    Self::Low => std::option::Option::Some(3),
                    Self::Medium => std::option::Option::Some(4),
                    Self::High => std::option::Option::Some(5),
                    Self::VeryHigh => std::option::Option::Some(6),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("GROUNDING_SCORE_BUCKET_UNSPECIFIED")
                    }
                    Self::VeryLow => std::option::Option::Some("VERY_LOW"),
                    Self::Low => std::option::Option::Some("LOW"),
                    Self::Medium => std::option::Option::Some("MEDIUM"),
                    Self::High => std::option::Option::Some("HIGH"),
                    Self::VeryHigh => std::option::Option::Some("VERY_HIGH"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "sessions")]
        impl std::default::Default for GroundingScoreBucket {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "sessions")]
        impl std::fmt::Display for GroundingScoreBucket {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "sessions")]
        impl std::convert::From<i32> for GroundingScoreBucket {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::VeryLow,
                    3 => Self::Low,
                    4 => Self::Medium,
                    5 => Self::High,
                    6 => Self::VeryHigh,
                    _ => Self::UnknownValue(grounding_score_bucket::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "sessions")]
        impl std::convert::From<&str> for GroundingScoreBucket {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "GROUNDING_SCORE_BUCKET_UNSPECIFIED" => Self::Unspecified,
                    "VERY_LOW" => Self::VeryLow,
                    "LOW" => Self::Low,
                    "MEDIUM" => Self::Medium,
                    "HIGH" => Self::High,
                    "VERY_HIGH" => Self::VeryHigh,
                    _ => Self::UnknownValue(grounding_score_bucket::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "sessions")]
        impl serde::ser::Serialize for GroundingScoreBucket {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::VeryLow => serializer.serialize_i32(1),
                    Self::Low => serializer.serialize_i32(3),
                    Self::Medium => serializer.serialize_i32(4),
                    Self::High => serializer.serialize_i32(5),
                    Self::VeryHigh => serializer.serialize_i32(6),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "sessions")]
        impl<'de> serde::de::Deserialize<'de> for GroundingScoreBucket {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<GroundingScoreBucket>::new(
                    ".google.cloud.dialogflow.cx.v3.DataStoreConnectionSignals.GroundingSignals.GroundingScoreBucket"))
            }
        }
    }

    /// Safety check results.
    #[cfg(feature = "sessions")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SafetySignals {
        /// Safety decision.
        pub decision: crate::model::data_store_connection_signals::safety_signals::SafetyDecision,

        /// Specifies banned phrase match subject.
        pub banned_phrase_match:
            crate::model::data_store_connection_signals::safety_signals::BannedPhraseMatch,

        /// The matched banned phrase if there was a match.
        pub matched_banned_phrase: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "sessions")]
    impl SafetySignals {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [decision][crate::model::data_store_connection_signals::SafetySignals::decision].
        pub fn set_decision<
            T: std::convert::Into<
                    crate::model::data_store_connection_signals::safety_signals::SafetyDecision,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.decision = v.into();
            self
        }

        /// Sets the value of [banned_phrase_match][crate::model::data_store_connection_signals::SafetySignals::banned_phrase_match].
        pub fn set_banned_phrase_match<
            T: std::convert::Into<
                    crate::model::data_store_connection_signals::safety_signals::BannedPhraseMatch,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.banned_phrase_match = v.into();
            self
        }

        /// Sets the value of [matched_banned_phrase][crate::model::data_store_connection_signals::SafetySignals::matched_banned_phrase].
        pub fn set_matched_banned_phrase<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.matched_banned_phrase = v.into();
            self
        }
    }

    #[cfg(feature = "sessions")]
    impl wkt::message::Message for SafetySignals {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.DataStoreConnectionSignals.SafetySignals"
        }
    }

    #[cfg(feature = "sessions")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SafetySignals {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __decision,
                __banned_phrase_match,
                __matched_banned_phrase,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SafetySignals")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "decision" => Ok(__FieldTag::__decision),
                                "bannedPhraseMatch" => Ok(__FieldTag::__banned_phrase_match),
                                "banned_phrase_match" => Ok(__FieldTag::__banned_phrase_match),
                                "matchedBannedPhrase" => Ok(__FieldTag::__matched_banned_phrase),
                                "matched_banned_phrase" => Ok(__FieldTag::__matched_banned_phrase),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SafetySignals;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SafetySignals")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__decision => {
                                if !fields.insert(__FieldTag::__decision) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for decision",
                                    ));
                                }
                                result.decision = map.next_value::<std::option::Option<crate::model::data_store_connection_signals::safety_signals::SafetyDecision>>()?.unwrap_or_default();
                            }
                            __FieldTag::__banned_phrase_match => {
                                if !fields.insert(__FieldTag::__banned_phrase_match) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for banned_phrase_match",
                                    ));
                                }
                                result.banned_phrase_match = map.next_value::<std::option::Option<crate::model::data_store_connection_signals::safety_signals::BannedPhraseMatch>>()?.unwrap_or_default();
                            }
                            __FieldTag::__matched_banned_phrase => {
                                if !fields.insert(__FieldTag::__matched_banned_phrase) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for matched_banned_phrase",
                                    ));
                                }
                                result.matched_banned_phrase = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "sessions")]
    #[doc(hidden)]
    impl serde::ser::Serialize for SafetySignals {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.decision) {
                state.serialize_entry("decision", &self.decision)?;
            }
            if !wkt::internal::is_default(&self.banned_phrase_match) {
                state.serialize_entry("bannedPhraseMatch", &self.banned_phrase_match)?;
            }
            if !self.matched_banned_phrase.is_empty() {
                state.serialize_entry("matchedBannedPhrase", &self.matched_banned_phrase)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [SafetySignals].
    #[cfg(feature = "sessions")]
    pub mod safety_signals {
        #[allow(unused_imports)]
        use super::*;

        /// Safety decision.
        /// All kinds of check are incorporated into this final decision, including
        /// banned phrases check.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "sessions")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SafetyDecision {
            /// Decision not specified.
            Unspecified,
            /// No manual or automatic safety check fired.
            AcceptedBySafetyCheck,
            /// One ore more safety checks fired.
            RejectedBySafetyCheck,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SafetyDecision::value] or
            /// [SafetyDecision::name].
            UnknownValue(safety_decision::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "sessions")]
        pub mod safety_decision {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "sessions")]
        impl SafetyDecision {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::AcceptedBySafetyCheck => std::option::Option::Some(1),
                    Self::RejectedBySafetyCheck => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SAFETY_DECISION_UNSPECIFIED"),
                    Self::AcceptedBySafetyCheck => {
                        std::option::Option::Some("ACCEPTED_BY_SAFETY_CHECK")
                    }
                    Self::RejectedBySafetyCheck => {
                        std::option::Option::Some("REJECTED_BY_SAFETY_CHECK")
                    }
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "sessions")]
        impl std::default::Default for SafetyDecision {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "sessions")]
        impl std::fmt::Display for SafetyDecision {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "sessions")]
        impl std::convert::From<i32> for SafetyDecision {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::AcceptedBySafetyCheck,
                    2 => Self::RejectedBySafetyCheck,
                    _ => Self::UnknownValue(safety_decision::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "sessions")]
        impl std::convert::From<&str> for SafetyDecision {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SAFETY_DECISION_UNSPECIFIED" => Self::Unspecified,
                    "ACCEPTED_BY_SAFETY_CHECK" => Self::AcceptedBySafetyCheck,
                    "REJECTED_BY_SAFETY_CHECK" => Self::RejectedBySafetyCheck,
                    _ => Self::UnknownValue(safety_decision::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "sessions")]
        impl serde::ser::Serialize for SafetyDecision {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::AcceptedBySafetyCheck => serializer.serialize_i32(1),
                    Self::RejectedBySafetyCheck => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "sessions")]
        impl<'de> serde::de::Deserialize<'de> for SafetyDecision {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SafetyDecision>::new(
                    ".google.cloud.dialogflow.cx.v3.DataStoreConnectionSignals.SafetySignals.SafetyDecision"))
            }
        }

        /// Specifies banned phrase match subject.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "sessions")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum BannedPhraseMatch {
            /// No banned phrase check was executed.
            Unspecified,
            /// All banned phrase checks led to no match.
            None,
            /// A banned phrase matched the query.
            Query,
            /// A banned phrase matched the response.
            Response,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [BannedPhraseMatch::value] or
            /// [BannedPhraseMatch::name].
            UnknownValue(banned_phrase_match::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "sessions")]
        pub mod banned_phrase_match {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "sessions")]
        impl BannedPhraseMatch {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::None => std::option::Option::Some(1),
                    Self::Query => std::option::Option::Some(2),
                    Self::Response => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("BANNED_PHRASE_MATCH_UNSPECIFIED")
                    }
                    Self::None => std::option::Option::Some("BANNED_PHRASE_MATCH_NONE"),
                    Self::Query => std::option::Option::Some("BANNED_PHRASE_MATCH_QUERY"),
                    Self::Response => std::option::Option::Some("BANNED_PHRASE_MATCH_RESPONSE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "sessions")]
        impl std::default::Default for BannedPhraseMatch {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "sessions")]
        impl std::fmt::Display for BannedPhraseMatch {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "sessions")]
        impl std::convert::From<i32> for BannedPhraseMatch {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::None,
                    2 => Self::Query,
                    3 => Self::Response,
                    _ => Self::UnknownValue(banned_phrase_match::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "sessions")]
        impl std::convert::From<&str> for BannedPhraseMatch {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "BANNED_PHRASE_MATCH_UNSPECIFIED" => Self::Unspecified,
                    "BANNED_PHRASE_MATCH_NONE" => Self::None,
                    "BANNED_PHRASE_MATCH_QUERY" => Self::Query,
                    "BANNED_PHRASE_MATCH_RESPONSE" => Self::Response,
                    _ => Self::UnknownValue(banned_phrase_match::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "sessions")]
        impl serde::ser::Serialize for BannedPhraseMatch {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::None => serializer.serialize_i32(1),
                    Self::Query => serializer.serialize_i32(2),
                    Self::Response => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "sessions")]
        impl<'de> serde::de::Deserialize<'de> for BannedPhraseMatch {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<BannedPhraseMatch>::new(
                    ".google.cloud.dialogflow.cx.v3.DataStoreConnectionSignals.SafetySignals.BannedPhraseMatch"))
            }
        }
    }
}

/// Represents a deployment in an environment. A deployment happens when a flow
/// version configured to be active in the environment. You can configure running
/// pre-deployment steps, e.g. running validation test cases, experiment
/// auto-rollout, etc.
#[cfg(feature = "deployments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Deployment {
    /// The name of the deployment.
    /// Format:
    /// projects/\<ProjectID\>/locations/\<LocationID\>/agents/\<AgentID\>/environments/\<EnvironmentID\>/deployments/\<DeploymentID\>.
    pub name: std::string::String,

    /// The name of the flow version for this deployment.
    /// Format:
    /// projects/\<ProjectID\>/locations/\<LocationID\>/agents/\<AgentID\>/flows/\<FlowID\>/versions/\<VerionID\>.
    pub flow_version: std::string::String,

    /// The current state of the deployment.
    pub state: crate::model::deployment::State,

    /// Result of the deployment.
    pub result: std::option::Option<crate::model::deployment::Result>,

    /// Start time of this deployment.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// End time of this deployment.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "deployments")]
impl Deployment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Deployment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [flow_version][crate::model::Deployment::flow_version].
    pub fn set_flow_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.flow_version = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Deployment::state].
    pub fn set_state<T: std::convert::Into<crate::model::deployment::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [result][crate::model::Deployment::result].
    pub fn set_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::deployment::Result>,
    {
        self.result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [result][crate::model::Deployment::result].
    pub fn set_or_clear_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::deployment::Result>,
    {
        self.result = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::Deployment::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Deployment::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::Deployment::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::Deployment::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "deployments")]
impl wkt::message::Message for Deployment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.Deployment"
    }
}

#[cfg(feature = "deployments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Deployment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __flow_version,
            __state,
            __result,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Deployment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "flowVersion" => Ok(__FieldTag::__flow_version),
                            "flow_version" => Ok(__FieldTag::__flow_version),
                            "state" => Ok(__FieldTag::__state),
                            "result" => Ok(__FieldTag::__result),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Deployment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Deployment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__flow_version => {
                            if !fields.insert(__FieldTag::__flow_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flow_version",
                                ));
                            }
                            result.flow_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::deployment::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__result => {
                            if !fields.insert(__FieldTag::__result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result",
                                ));
                            }
                            result.result = map.next_value::<std::option::Option<crate::model::deployment::Result>>()?
                                ;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "deployments")]
#[doc(hidden)]
impl serde::ser::Serialize for Deployment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.flow_version.is_empty() {
            state.serialize_entry("flowVersion", &self.flow_version)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.result.is_some() {
            state.serialize_entry("result", &self.result)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Deployment].
#[cfg(feature = "deployments")]
pub mod deployment {
    #[allow(unused_imports)]
    use super::*;

    /// Result of the deployment.
    #[cfg(feature = "deployments")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Result {
        /// Results of test cases running before the deployment.
        /// Format:
        /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/testCases/<TestCaseID>/results/<TestCaseResultID>`.
        pub deployment_test_results: std::vec::Vec<std::string::String>,

        /// The name of the experiment triggered by this deployment.
        /// Format:
        /// projects/\<ProjectID\>/locations/\<LocationID\>/agents/\<AgentID\>/environments/\<EnvironmentID\>/experiments/\<ExperimentID\>.
        pub experiment: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "deployments")]
    impl Result {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [deployment_test_results][crate::model::deployment::Result::deployment_test_results].
        pub fn set_deployment_test_results<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.deployment_test_results = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [experiment][crate::model::deployment::Result::experiment].
        pub fn set_experiment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.experiment = v.into();
            self
        }
    }

    #[cfg(feature = "deployments")]
    impl wkt::message::Message for Result {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Deployment.Result"
        }
    }

    #[cfg(feature = "deployments")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Result {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __deployment_test_results,
                __experiment,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Result")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "deploymentTestResults" => {
                                    Ok(__FieldTag::__deployment_test_results)
                                }
                                "deployment_test_results" => {
                                    Ok(__FieldTag::__deployment_test_results)
                                }
                                "experiment" => Ok(__FieldTag::__experiment),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Result;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Result")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__deployment_test_results => {
                                if !fields.insert(__FieldTag::__deployment_test_results) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for deployment_test_results",
                                    ));
                                }
                                result.deployment_test_results = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__experiment => {
                                if !fields.insert(__FieldTag::__experiment) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for experiment",
                                    ));
                                }
                                result.experiment = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "deployments")]
    #[doc(hidden)]
    impl serde::ser::Serialize for Result {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.deployment_test_results.is_empty() {
                state.serialize_entry("deploymentTestResults", &self.deployment_test_results)?;
            }
            if !self.experiment.is_empty() {
                state.serialize_entry("experiment", &self.experiment)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The state of the deployment.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "deployments")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State unspecified.
        Unspecified,
        /// The deployment is running.
        Running,
        /// The deployment succeeded.
        Succeeded,
        /// The deployment failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "deployments")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "deployments")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "deployments")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "deployments")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "deployments")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Succeeded,
                3 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "deployments")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "deployments")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "deployments")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dialogflow.cx.v3.Deployment.State",
            ))
        }
    }
}

/// The request message for
/// [Deployments.ListDeployments][google.cloud.dialogflow.cx.v3.Deployments.ListDeployments].
///
/// [google.cloud.dialogflow.cx.v3.Deployments.ListDeployments]: crate::client::Deployments::list_deployments
#[cfg(feature = "deployments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDeploymentsRequest {
    /// Required. The [Environment][google.cloud.dialogflow.cx.v3.Environment] to
    /// list all environments for. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Environment]: crate::model::Environment
    pub parent: std::string::String,

    /// The maximum number of items to return in a single page. By default 20 and
    /// at most 100.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "deployments")]
impl ListDeploymentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDeploymentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDeploymentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDeploymentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "deployments")]
impl wkt::message::Message for ListDeploymentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListDeploymentsRequest"
    }
}

#[cfg(feature = "deployments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDeploymentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDeploymentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDeploymentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDeploymentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "deployments")]
#[doc(hidden)]
impl serde::ser::Serialize for ListDeploymentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Deployments.ListDeployments][google.cloud.dialogflow.cx.v3.Deployments.ListDeployments].
///
/// [google.cloud.dialogflow.cx.v3.Deployments.ListDeployments]: crate::client::Deployments::list_deployments
#[cfg(feature = "deployments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDeploymentsResponse {
    /// The list of deployments. There will be a maximum number of items
    /// returned based on the page_size field in the request. The list may in some
    /// cases be empty or contain fewer entries than page_size even if this isn't
    /// the last page.
    pub deployments: std::vec::Vec<crate::model::Deployment>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "deployments")]
impl ListDeploymentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deployments][crate::model::ListDeploymentsResponse::deployments].
    pub fn set_deployments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Deployment>,
    {
        use std::iter::Iterator;
        self.deployments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDeploymentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "deployments")]
impl wkt::message::Message for ListDeploymentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListDeploymentsResponse"
    }
}

#[cfg(feature = "deployments")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDeploymentsResponse {
    type PageItem = crate::model::Deployment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.deployments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "deployments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDeploymentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __deployments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDeploymentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deployments" => Ok(__FieldTag::__deployments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDeploymentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDeploymentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__deployments => {
                            if !fields.insert(__FieldTag::__deployments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployments",
                                ));
                            }
                            result.deployments = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Deployment>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "deployments")]
#[doc(hidden)]
impl serde::ser::Serialize for ListDeploymentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.deployments.is_empty() {
            state.serialize_entry("deployments", &self.deployments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Deployments.GetDeployment][google.cloud.dialogflow.cx.v3.Deployments.GetDeployment].
///
/// [google.cloud.dialogflow.cx.v3.Deployments.GetDeployment]: crate::client::Deployments::get_deployment
#[cfg(feature = "deployments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDeploymentRequest {
    /// Required. The name of the
    /// [Deployment][google.cloud.dialogflow.cx.v3.Deployment]. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>/deployments/<DeploymentID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Deployment]: crate::model::Deployment
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "deployments")]
impl GetDeploymentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDeploymentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "deployments")]
impl wkt::message::Message for GetDeploymentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetDeploymentRequest"
    }
}

#[cfg(feature = "deployments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDeploymentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDeploymentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDeploymentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDeploymentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "deployments")]
#[doc(hidden)]
impl serde::ser::Serialize for GetDeploymentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Entities are extracted from user input and represent parameters that are
/// meaningful to your application. For example, a date range, a proper name
/// such as a geographic location or landmark, and so on. Entities represent
/// actionable data for your application.
///
/// When you define an entity, you can also include synonyms that all map to
/// that entity. For example, "soft drink", "soda", "pop", and so on.
///
/// There are three types of entities:
///
/// * **System** - entities that are defined by the Dialogflow API for common
///   data types such as date, time, currency, and so on. A system entity is
///   represented by the `EntityType` type.
///
/// * **Custom** - entities that are defined by you that represent
///   actionable data that is meaningful to your application. For example,
///   you could define a `pizza.sauce` entity for red or white pizza sauce,
///   a `pizza.cheese` entity for the different types of cheese on a pizza,
///   a `pizza.topping` entity for different toppings, and so on. A custom
///   entity is represented by the `EntityType` type.
///
/// * **User** - entities that are built for an individual user such as
///   favorites, preferences, playlists, and so on. A user entity is
///   represented by the
///   [SessionEntityType][google.cloud.dialogflow.cx.v3.SessionEntityType]
///   type.
///
///
/// For more information about entity types, see the [Dialogflow
/// documentation](https://cloud.google.com/dialogflow/docs/entities-overview).
///
/// [google.cloud.dialogflow.cx.v3.SessionEntityType]: crate::model::SessionEntityType
#[cfg(any(
    feature = "entity-types",
    feature = "session-entity-types",
    feature = "sessions",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EntityType {
    /// The unique identifier of the entity type.
    /// Required for
    /// [EntityTypes.UpdateEntityType][google.cloud.dialogflow.cx.v3.EntityTypes.UpdateEntityType].
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/entityTypes/<EntityTypeID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.EntityTypes.UpdateEntityType]: crate::client::EntityTypes::update_entity_type
    pub name: std::string::String,

    /// Required. The human-readable name of the entity type, unique within the
    /// agent.
    pub display_name: std::string::String,

    /// Required. Indicates the kind of entity type.
    pub kind: crate::model::entity_type::Kind,

    /// Indicates whether the entity type can be automatically expanded.
    pub auto_expansion_mode: crate::model::entity_type::AutoExpansionMode,

    /// The collection of entity entries associated with the entity type.
    pub entities: std::vec::Vec<crate::model::entity_type::Entity>,

    /// Collection of exceptional words and phrases that shouldn't be matched.
    /// For example, if you have a size entity type with entry `giant`(an
    /// adjective), you might consider adding `giants`(a noun) as an exclusion.
    /// If the kind of entity type is `KIND_MAP`, then the phrases specified by
    /// entities and excluded phrases should be mutually exclusive.
    pub excluded_phrases: std::vec::Vec<crate::model::entity_type::ExcludedPhrase>,

    /// Enables fuzzy entity extraction during classification.
    pub enable_fuzzy_extraction: bool,

    /// Indicates whether parameters of the entity type should be redacted in log.
    /// If redaction is enabled, page parameters and intent parameters referring to
    /// the entity type will be replaced by parameter name when logging.
    pub redact: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "entity-types",
    feature = "session-entity-types",
    feature = "sessions",
))]
impl EntityType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EntityType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::EntityType::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::EntityType::kind].
    pub fn set_kind<T: std::convert::Into<crate::model::entity_type::Kind>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [auto_expansion_mode][crate::model::EntityType::auto_expansion_mode].
    pub fn set_auto_expansion_mode<
        T: std::convert::Into<crate::model::entity_type::AutoExpansionMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.auto_expansion_mode = v.into();
        self
    }

    /// Sets the value of [entities][crate::model::EntityType::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::entity_type::Entity>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [excluded_phrases][crate::model::EntityType::excluded_phrases].
    pub fn set_excluded_phrases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::entity_type::ExcludedPhrase>,
    {
        use std::iter::Iterator;
        self.excluded_phrases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [enable_fuzzy_extraction][crate::model::EntityType::enable_fuzzy_extraction].
    pub fn set_enable_fuzzy_extraction<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_fuzzy_extraction = v.into();
        self
    }

    /// Sets the value of [redact][crate::model::EntityType::redact].
    pub fn set_redact<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.redact = v.into();
        self
    }
}

#[cfg(any(
    feature = "entity-types",
    feature = "session-entity-types",
    feature = "sessions",
))]
impl wkt::message::Message for EntityType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.EntityType"
    }
}

#[cfg(any(
    feature = "entity-types",
    feature = "session-entity-types",
    feature = "sessions",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EntityType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __kind,
            __auto_expansion_mode,
            __entities,
            __excluded_phrases,
            __enable_fuzzy_extraction,
            __redact,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntityType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "kind" => Ok(__FieldTag::__kind),
                            "autoExpansionMode" => Ok(__FieldTag::__auto_expansion_mode),
                            "auto_expansion_mode" => Ok(__FieldTag::__auto_expansion_mode),
                            "entities" => Ok(__FieldTag::__entities),
                            "excludedPhrases" => Ok(__FieldTag::__excluded_phrases),
                            "excluded_phrases" => Ok(__FieldTag::__excluded_phrases),
                            "enableFuzzyExtraction" => Ok(__FieldTag::__enable_fuzzy_extraction),
                            "enable_fuzzy_extraction" => Ok(__FieldTag::__enable_fuzzy_extraction),
                            "redact" => Ok(__FieldTag::__redact),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EntityType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntityType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<crate::model::entity_type::Kind>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auto_expansion_mode => {
                            if !fields.insert(__FieldTag::__auto_expansion_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_expansion_mode",
                                ));
                            }
                            result.auto_expansion_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::entity_type::AutoExpansionMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entities => {
                            if !fields.insert(__FieldTag::__entities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entities",
                                ));
                            }
                            result.entities = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::entity_type::Entity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__excluded_phrases => {
                            if !fields.insert(__FieldTag::__excluded_phrases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for excluded_phrases",
                                ));
                            }
                            result.excluded_phrases = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::entity_type::ExcludedPhrase>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_fuzzy_extraction => {
                            if !fields.insert(__FieldTag::__enable_fuzzy_extraction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_fuzzy_extraction",
                                ));
                            }
                            result.enable_fuzzy_extraction = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__redact => {
                            if !fields.insert(__FieldTag::__redact) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redact",
                                ));
                            }
                            result.redact = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "entity-types",
    feature = "session-entity-types",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for EntityType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.kind) {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !wkt::internal::is_default(&self.auto_expansion_mode) {
            state.serialize_entry("autoExpansionMode", &self.auto_expansion_mode)?;
        }
        if !self.entities.is_empty() {
            state.serialize_entry("entities", &self.entities)?;
        }
        if !self.excluded_phrases.is_empty() {
            state.serialize_entry("excludedPhrases", &self.excluded_phrases)?;
        }
        if !wkt::internal::is_default(&self.enable_fuzzy_extraction) {
            state.serialize_entry("enableFuzzyExtraction", &self.enable_fuzzy_extraction)?;
        }
        if !wkt::internal::is_default(&self.redact) {
            state.serialize_entry("redact", &self.redact)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EntityType].
#[cfg(any(
    feature = "entity-types",
    feature = "session-entity-types",
    feature = "sessions",
))]
pub mod entity_type {
    #[allow(unused_imports)]
    use super::*;

    /// An **entity entry** for an associated entity type.
    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Entity {
        /// Required. The primary value associated with this entity entry.
        /// For example, if the entity type is *vegetable*, the value could be
        /// *scallions*.
        ///
        /// For `KIND_MAP` entity types:
        ///
        /// * A canonical value to be used in place of synonyms.
        ///
        /// For `KIND_LIST` entity types:
        ///
        /// * A string that can contain references to other entity types (with or
        ///   without aliases).
        pub value: std::string::String,

        /// Required. A collection of value synonyms. For example, if the entity type
        /// is *vegetable*, and `value` is *scallions*, a synonym could be *green
        /// onions*.
        ///
        /// For `KIND_LIST` entity types:
        ///
        /// * This collection must contain exactly one synonym equal to `value`.
        pub synonyms: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl Entity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::entity_type::Entity::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }

        /// Sets the value of [synonyms][crate::model::entity_type::Entity::synonyms].
        pub fn set_synonyms<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.synonyms = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl wkt::message::Message for Entity {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.EntityType.Entity"
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Entity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __value,
                __synonyms,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Entity")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "value" => Ok(__FieldTag::__value),
                                "synonyms" => Ok(__FieldTag::__synonyms),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Entity;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Entity")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                result.value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__synonyms => {
                                if !fields.insert(__FieldTag::__synonyms) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for synonyms",
                                    ));
                                }
                                result.synonyms = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for Entity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.value.is_empty() {
                state.serialize_entry("value", &self.value)?;
            }
            if !self.synonyms.is_empty() {
                state.serialize_entry("synonyms", &self.synonyms)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// An excluded entity phrase that should not be matched.
    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ExcludedPhrase {
        /// Required. The word or phrase to be excluded.
        pub value: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl ExcludedPhrase {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::entity_type::ExcludedPhrase::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl wkt::message::Message for ExcludedPhrase {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.EntityType.ExcludedPhrase"
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ExcludedPhrase {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ExcludedPhrase")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "value" => Ok(__FieldTag::__value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ExcludedPhrase;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ExcludedPhrase")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                result.value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for ExcludedPhrase {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.value.is_empty() {
                state.serialize_entry("value", &self.value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Represents kinds of entities.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Kind {
        /// Not specified. This value should be never used.
        Unspecified,
        /// Map entity types allow mapping of a group of synonyms to a canonical
        /// value.
        Map,
        /// List entity types contain a set of entries that do not map to canonical
        /// values. However, list entity types can contain references to other entity
        /// types (with or without aliases).
        List,
        /// Regexp entity types allow to specify regular expressions in entries
        /// values.
        Regexp,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Kind::value] or
        /// [Kind::name].
        UnknownValue(kind::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    pub mod kind {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl Kind {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Map => std::option::Option::Some(1),
                Self::List => std::option::Option::Some(2),
                Self::Regexp => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("KIND_UNSPECIFIED"),
                Self::Map => std::option::Option::Some("KIND_MAP"),
                Self::List => std::option::Option::Some("KIND_LIST"),
                Self::Regexp => std::option::Option::Some("KIND_REGEXP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::default::Default for Kind {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::fmt::Display for Kind {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::convert::From<i32> for Kind {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Map,
                2 => Self::List,
                3 => Self::Regexp,
                _ => Self::UnknownValue(kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::convert::From<&str> for Kind {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KIND_UNSPECIFIED" => Self::Unspecified,
                "KIND_MAP" => Self::Map,
                "KIND_LIST" => Self::List,
                "KIND_REGEXP" => Self::Regexp,
                _ => Self::UnknownValue(kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl serde::ser::Serialize for Kind {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Map => serializer.serialize_i32(1),
                Self::List => serializer.serialize_i32(2),
                Self::Regexp => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Kind {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Kind>::new(
                ".google.cloud.dialogflow.cx.v3.EntityType.Kind",
            ))
        }
    }

    /// Represents different entity type expansion modes. Automated expansion
    /// allows an agent to recognize values that have not been explicitly listed in
    /// the entity (for example, new kinds of shopping list items).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AutoExpansionMode {
        /// Auto expansion disabled for the entity.
        Unspecified,
        /// Allows an agent to recognize values that have not been explicitly
        /// listed in the entity.
        Default,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AutoExpansionMode::value] or
        /// [AutoExpansionMode::name].
        UnknownValue(auto_expansion_mode::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    pub mod auto_expansion_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl AutoExpansionMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Default => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AUTO_EXPANSION_MODE_UNSPECIFIED"),
                Self::Default => std::option::Option::Some("AUTO_EXPANSION_MODE_DEFAULT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::default::Default for AutoExpansionMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::fmt::Display for AutoExpansionMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::convert::From<i32> for AutoExpansionMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Default,
                _ => Self::UnknownValue(auto_expansion_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::convert::From<&str> for AutoExpansionMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AUTO_EXPANSION_MODE_UNSPECIFIED" => Self::Unspecified,
                "AUTO_EXPANSION_MODE_DEFAULT" => Self::Default,
                _ => Self::UnknownValue(auto_expansion_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl serde::ser::Serialize for AutoExpansionMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Default => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl<'de> serde::de::Deserialize<'de> for AutoExpansionMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AutoExpansionMode>::new(
                ".google.cloud.dialogflow.cx.v3.EntityType.AutoExpansionMode",
            ))
        }
    }
}

/// The request message for
/// [EntityTypes.ExportEntityTypes][google.cloud.dialogflow.cx.v3.EntityTypes.ExportEntityTypes].
///
/// [google.cloud.dialogflow.cx.v3.EntityTypes.ExportEntityTypes]: crate::client::EntityTypes::export_entity_types
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportEntityTypesRequest {
    /// Required. The name of the parent agent to export entity types.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// Required. The name of the entity types to export.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/entityTypes/<EntityTypeID>`.
    pub entity_types: std::vec::Vec<std::string::String>,

    /// Optional. The data format of the exported entity types. If not specified,
    /// `BLOB` is assumed.
    pub data_format: crate::model::export_entity_types_request::DataFormat,

    /// Optional. The language to retrieve the entity type for. The following
    /// fields are language dependent:
    ///
    /// * `EntityType.entities.value`
    /// * `EntityType.entities.synonyms`
    /// * `EntityType.excluded_phrases.value`
    ///
    /// If not specified, all language dependent fields will be retrieved.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    /// The destination to export.
    pub destination: std::option::Option<crate::model::export_entity_types_request::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl ExportEntityTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ExportEntityTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entity_types][crate::model::ExportEntityTypesRequest::entity_types].
    pub fn set_entity_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.entity_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_format][crate::model::ExportEntityTypesRequest::data_format].
    pub fn set_data_format<
        T: std::convert::Into<crate::model::export_entity_types_request::DataFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_format = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::ExportEntityTypesRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ExportEntityTypesRequest::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<
                std::option::Option<crate::model::export_entity_types_request::Destination>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportEntityTypesRequest::destination]
    /// if it holds a `EntityTypesUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn entity_types_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_entity_types_request::Destination::EntityTypesUri(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportEntityTypesRequest::destination]
    /// to hold a `EntityTypesUri`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_entity_types_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_entity_types_request::Destination::EntityTypesUri(v.into()),
        );
        self
    }

    /// The value of [destination][crate::model::ExportEntityTypesRequest::destination]
    /// if it holds a `EntityTypesContentInline`, `None` if the field is not set or
    /// holds a different branch.
    pub fn entity_types_content_inline(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_entity_types_request::Destination::EntityTypesContentInline(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportEntityTypesRequest::destination]
    /// to hold a `EntityTypesContentInline`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_entity_types_content_inline<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_entity_types_request::Destination::EntityTypesContentInline(
                v.into(),
            ),
        );
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for ExportEntityTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ExportEntityTypesRequest"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportEntityTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entity_types,
            __entity_types_uri,
            __entity_types_content_inline,
            __data_format,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportEntityTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entityTypes" => Ok(__FieldTag::__entity_types),
                            "entity_types" => Ok(__FieldTag::__entity_types),
                            "entityTypesUri" => Ok(__FieldTag::__entity_types_uri),
                            "entity_types_uri" => Ok(__FieldTag::__entity_types_uri),
                            "entityTypesContentInline" => {
                                Ok(__FieldTag::__entity_types_content_inline)
                            }
                            "entity_types_content_inline" => {
                                Ok(__FieldTag::__entity_types_content_inline)
                            }
                            "dataFormat" => Ok(__FieldTag::__data_format),
                            "data_format" => Ok(__FieldTag::__data_format),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportEntityTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportEntityTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_types => {
                            if !fields.insert(__FieldTag::__entity_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_types",
                                ));
                            }
                            result.entity_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__entity_types_uri => {
                            if !fields.insert(__FieldTag::__entity_types_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_types_uri",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ExportEntityTypesRequest.entity_types_uri, latest field was entityTypesUri",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::export_entity_types_request::Destination::EntityTypesUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__entity_types_content_inline => {
                            if !fields.insert(__FieldTag::__entity_types_content_inline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_types_content_inline",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ExportEntityTypesRequest.entity_types_content_inline, latest field was entityTypesContentInline",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::export_entity_types_request::Destination::EntityTypesContentInline(
                                    map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__data_format => {
                            if !fields.insert(__FieldTag::__data_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_format",
                                ));
                            }
                            result.data_format = map
                                .next_value::<std::option::Option<
                                    crate::model::export_entity_types_request::DataFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for ExportEntityTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.entity_types.is_empty() {
            state.serialize_entry("entityTypes", &self.entity_types)?;
        }
        if let Some(value) = self.entity_types_uri() {
            state.serialize_entry("entityTypesUri", value)?;
        }
        if let Some(value) = self.entity_types_content_inline() {
            state.serialize_entry("entityTypesContentInline", value)?;
        }
        if !wkt::internal::is_default(&self.data_format) {
            state.serialize_entry("dataFormat", &self.data_format)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExportEntityTypesRequest].
#[cfg(feature = "entity-types")]
pub mod export_entity_types_request {
    #[allow(unused_imports)]
    use super::*;

    /// Data format of the exported entity types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "entity-types")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataFormat {
        /// Unspecified format. Treated as `BLOB`.
        Unspecified,
        /// EntityTypes will be exported as raw bytes.
        Blob,
        /// EntityTypes will be exported in JSON Package format.
        JsonPackage,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataFormat::value] or
        /// [DataFormat::name].
        UnknownValue(data_format::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "entity-types")]
    pub mod data_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "entity-types")]
    impl DataFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Blob => std::option::Option::Some(1),
                Self::JsonPackage => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_FORMAT_UNSPECIFIED"),
                Self::Blob => std::option::Option::Some("BLOB"),
                Self::JsonPackage => std::option::Option::Some("JSON_PACKAGE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "entity-types")]
    impl std::default::Default for DataFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "entity-types")]
    impl std::fmt::Display for DataFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "entity-types")]
    impl std::convert::From<i32> for DataFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Blob,
                5 => Self::JsonPackage,
                _ => Self::UnknownValue(data_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "entity-types")]
    impl std::convert::From<&str> for DataFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "BLOB" => Self::Blob,
                "JSON_PACKAGE" => Self::JsonPackage,
                _ => Self::UnknownValue(data_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "entity-types")]
    impl serde::ser::Serialize for DataFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Blob => serializer.serialize_i32(1),
                Self::JsonPackage => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "entity-types")]
    impl<'de> serde::de::Deserialize<'de> for DataFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataFormat>::new(
                ".google.cloud.dialogflow.cx.v3.ExportEntityTypesRequest.DataFormat",
            ))
        }
    }

    /// The destination to export.
    #[cfg(feature = "entity-types")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Optional. The [Google Cloud
        /// Storage](https://cloud.google.com/storage/docs/) URI to export the entity
        /// types to. The format of this URI must be
        /// `gs://<bucket-name>/<object-name>`.
        ///
        /// Dialogflow performs a write operation for the Cloud Storage object
        /// on the caller's behalf, so your request authentication must
        /// have write permissions for the object. For more information, see
        /// [Dialogflow access
        /// control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
        EntityTypesUri(std::string::String),
        /// Optional. The option to return the serialized entity types inline.
        EntityTypesContentInline(bool),
    }
}

/// The response message for
/// [EntityTypes.ExportEntityTypes][google.cloud.dialogflow.cx.v3.EntityTypes.ExportEntityTypes].
///
/// [google.cloud.dialogflow.cx.v3.EntityTypes.ExportEntityTypes]: crate::client::EntityTypes::export_entity_types
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportEntityTypesResponse {
    /// Exported entity types can be either in cloud storage or local download.
    pub exported_entity_types:
        std::option::Option<crate::model::export_entity_types_response::ExportedEntityTypes>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl ExportEntityTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [exported_entity_types][crate::model::ExportEntityTypesResponse::exported_entity_types].
    ///
    /// Note that all the setters affecting `exported_entity_types` are mutually
    /// exclusive.
    pub fn set_exported_entity_types<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::export_entity_types_response::ExportedEntityTypes,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.exported_entity_types = v.into();
        self
    }

    /// The value of [exported_entity_types][crate::model::ExportEntityTypesResponse::exported_entity_types]
    /// if it holds a `EntityTypesUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn entity_types_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.exported_entity_types.as_ref().and_then(|v| match v {
            crate::model::export_entity_types_response::ExportedEntityTypes::EntityTypesUri(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [exported_entity_types][crate::model::ExportEntityTypesResponse::exported_entity_types]
    /// to hold a `EntityTypesUri`.
    ///
    /// Note that all the setters affecting `exported_entity_types` are
    /// mutually exclusive.
    pub fn set_entity_types_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.exported_entity_types = std::option::Option::Some(
            crate::model::export_entity_types_response::ExportedEntityTypes::EntityTypesUri(
                v.into(),
            ),
        );
        self
    }

    /// The value of [exported_entity_types][crate::model::ExportEntityTypesResponse::exported_entity_types]
    /// if it holds a `EntityTypesContent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn entity_types_content(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InlineDestination>> {
        #[allow(unreachable_patterns)]
        self.exported_entity_types.as_ref().and_then(|v| match v {
            crate::model::export_entity_types_response::ExportedEntityTypes::EntityTypesContent(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [exported_entity_types][crate::model::ExportEntityTypesResponse::exported_entity_types]
    /// to hold a `EntityTypesContent`.
    ///
    /// Note that all the setters affecting `exported_entity_types` are
    /// mutually exclusive.
    pub fn set_entity_types_content<
        T: std::convert::Into<std::boxed::Box<crate::model::InlineDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.exported_entity_types = std::option::Option::Some(
            crate::model::export_entity_types_response::ExportedEntityTypes::EntityTypesContent(
                v.into(),
            ),
        );
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for ExportEntityTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ExportEntityTypesResponse"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportEntityTypesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity_types_uri,
            __entity_types_content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportEntityTypesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entityTypesUri" => Ok(__FieldTag::__entity_types_uri),
                            "entity_types_uri" => Ok(__FieldTag::__entity_types_uri),
                            "entityTypesContent" => Ok(__FieldTag::__entity_types_content),
                            "entity_types_content" => Ok(__FieldTag::__entity_types_content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportEntityTypesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportEntityTypesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity_types_uri => {
                            if !fields.insert(__FieldTag::__entity_types_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_types_uri",
                                ));
                            }
                            if result.exported_entity_types.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `exported_entity_types`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ExportEntityTypesResponse.entity_types_uri, latest field was entityTypesUri",
                                ));
                            }
                            result.exported_entity_types = std::option::Option::Some(
                                crate::model::export_entity_types_response::ExportedEntityTypes::EntityTypesUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__entity_types_content => {
                            if !fields.insert(__FieldTag::__entity_types_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_types_content",
                                ));
                            }
                            if result.exported_entity_types.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `exported_entity_types`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ExportEntityTypesResponse.entity_types_content, latest field was entityTypesContent",
                                ));
                            }
                            result.exported_entity_types = std::option::Option::Some(
                                crate::model::export_entity_types_response::ExportedEntityTypes::EntityTypesContent(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::InlineDestination>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for ExportEntityTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.entity_types_uri() {
            state.serialize_entry("entityTypesUri", value)?;
        }
        if let Some(value) = self.entity_types_content() {
            state.serialize_entry("entityTypesContent", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExportEntityTypesResponse].
#[cfg(feature = "entity-types")]
pub mod export_entity_types_response {
    #[allow(unused_imports)]
    use super::*;

    /// Exported entity types can be either in cloud storage or local download.
    #[cfg(feature = "entity-types")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExportedEntityTypes {
        /// The URI to a file containing the exported entity types. This field is
        /// populated only if `entity_types_uri` is specified in
        /// [ExportEntityTypesRequest][google.cloud.dialogflow.cx.v3.ExportEntityTypesRequest].
        ///
        /// [google.cloud.dialogflow.cx.v3.ExportEntityTypesRequest]: crate::model::ExportEntityTypesRequest
        EntityTypesUri(std::string::String),
        /// Uncompressed byte content for entity types. This field is populated only
        /// if `entity_types_content_inline` is set to true in
        /// [ExportEntityTypesRequest][google.cloud.dialogflow.cx.v3.ExportEntityTypesRequest].
        ///
        /// [google.cloud.dialogflow.cx.v3.ExportEntityTypesRequest]: crate::model::ExportEntityTypesRequest
        EntityTypesContent(std::boxed::Box<crate::model::InlineDestination>),
    }
}

/// Metadata returned for the
/// [EntityTypes.ExportEntityTypes][google.cloud.dialogflow.cx.v3.EntityTypes.ExportEntityTypes]
/// long running operation.
///
/// [google.cloud.dialogflow.cx.v3.EntityTypes.ExportEntityTypes]: crate::client::EntityTypes::export_entity_types
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportEntityTypesMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl ExportEntityTypesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for ExportEntityTypesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ExportEntityTypesMetadata"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportEntityTypesMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportEntityTypesMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportEntityTypesMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportEntityTypesMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for ExportEntityTypesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [EntityTypes.ImportEntityTypes][google.cloud.dialogflow.cx.v3.EntityTypes.ImportEntityTypes].
///
/// [google.cloud.dialogflow.cx.v3.EntityTypes.ImportEntityTypes]: crate::client::EntityTypes::import_entity_types
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportEntityTypesRequest {
    /// Required. The agent to import the entity types into.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// Required. Merge option for importing entity types.
    pub merge_option: crate::model::import_entity_types_request::MergeOption,

    /// Optional. The target entity type to import into.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/entity_types/<EntityTypeID>`.
    /// If set, there should be only one entity type included in
    /// [entity_types][google.cloud.dialogflow.cx.v3.ImportEntityTypesRequest.entity_types],
    /// of which the type should match the type of the target entity type. All
    /// [entities][google.cloud.dialogflow.cx.v3.EntityType.entities] in the
    /// imported entity type will be added to the target entity type.
    ///
    /// [google.cloud.dialogflow.cx.v3.EntityType.entities]: crate::model::EntityType::entities
    /// [google.cloud.dialogflow.cx.v3.ImportEntityTypesRequest.entity_types]: crate::model::ImportEntityTypesRequest::entity_types
    pub target_entity_type: std::string::String,

    /// Required. The entity types to import.
    pub entity_types: std::option::Option<crate::model::import_entity_types_request::EntityTypes>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl ImportEntityTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportEntityTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [merge_option][crate::model::ImportEntityTypesRequest::merge_option].
    pub fn set_merge_option<
        T: std::convert::Into<crate::model::import_entity_types_request::MergeOption>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.merge_option = v.into();
        self
    }

    /// Sets the value of [target_entity_type][crate::model::ImportEntityTypesRequest::target_entity_type].
    pub fn set_target_entity_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_entity_type = v.into();
        self
    }

    /// Sets the value of [entity_types][crate::model::ImportEntityTypesRequest::entity_types].
    ///
    /// Note that all the setters affecting `entity_types` are mutually
    /// exclusive.
    pub fn set_entity_types<
        T: std::convert::Into<
                std::option::Option<crate::model::import_entity_types_request::EntityTypes>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_types = v.into();
        self
    }

    /// The value of [entity_types][crate::model::ImportEntityTypesRequest::entity_types]
    /// if it holds a `EntityTypesUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn entity_types_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.entity_types.as_ref().and_then(|v| match v {
            crate::model::import_entity_types_request::EntityTypes::EntityTypesUri(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_types][crate::model::ImportEntityTypesRequest::entity_types]
    /// to hold a `EntityTypesUri`.
    ///
    /// Note that all the setters affecting `entity_types` are
    /// mutually exclusive.
    pub fn set_entity_types_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_types = std::option::Option::Some(
            crate::model::import_entity_types_request::EntityTypes::EntityTypesUri(v.into()),
        );
        self
    }

    /// The value of [entity_types][crate::model::ImportEntityTypesRequest::entity_types]
    /// if it holds a `EntityTypesContent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn entity_types_content(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InlineSource>> {
        #[allow(unreachable_patterns)]
        self.entity_types.as_ref().and_then(|v| match v {
            crate::model::import_entity_types_request::EntityTypes::EntityTypesContent(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_types][crate::model::ImportEntityTypesRequest::entity_types]
    /// to hold a `EntityTypesContent`.
    ///
    /// Note that all the setters affecting `entity_types` are
    /// mutually exclusive.
    pub fn set_entity_types_content<
        T: std::convert::Into<std::boxed::Box<crate::model::InlineSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_types = std::option::Option::Some(
            crate::model::import_entity_types_request::EntityTypes::EntityTypesContent(v.into()),
        );
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for ImportEntityTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ImportEntityTypesRequest"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportEntityTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entity_types_uri,
            __entity_types_content,
            __merge_option,
            __target_entity_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportEntityTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entityTypesUri" => Ok(__FieldTag::__entity_types_uri),
                            "entity_types_uri" => Ok(__FieldTag::__entity_types_uri),
                            "entityTypesContent" => Ok(__FieldTag::__entity_types_content),
                            "entity_types_content" => Ok(__FieldTag::__entity_types_content),
                            "mergeOption" => Ok(__FieldTag::__merge_option),
                            "merge_option" => Ok(__FieldTag::__merge_option),
                            "targetEntityType" => Ok(__FieldTag::__target_entity_type),
                            "target_entity_type" => Ok(__FieldTag::__target_entity_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportEntityTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportEntityTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_types_uri => {
                            if !fields.insert(__FieldTag::__entity_types_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_types_uri",
                                ));
                            }
                            if result.entity_types.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entity_types`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ImportEntityTypesRequest.entity_types_uri, latest field was entityTypesUri",
                                ));
                            }
                            result.entity_types = std::option::Option::Some(
                                crate::model::import_entity_types_request::EntityTypes::EntityTypesUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__entity_types_content => {
                            if !fields.insert(__FieldTag::__entity_types_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_types_content",
                                ));
                            }
                            if result.entity_types.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entity_types`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ImportEntityTypesRequest.entity_types_content, latest field was entityTypesContent",
                                ));
                            }
                            result.entity_types = std::option::Option::Some(
                                crate::model::import_entity_types_request::EntityTypes::EntityTypesContent(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::InlineSource>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__merge_option => {
                            if !fields.insert(__FieldTag::__merge_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for merge_option",
                                ));
                            }
                            result.merge_option = map
                                .next_value::<std::option::Option<
                                    crate::model::import_entity_types_request::MergeOption,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_entity_type => {
                            if !fields.insert(__FieldTag::__target_entity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_entity_type",
                                ));
                            }
                            result.target_entity_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for ImportEntityTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.entity_types_uri() {
            state.serialize_entry("entityTypesUri", value)?;
        }
        if let Some(value) = self.entity_types_content() {
            state.serialize_entry("entityTypesContent", value)?;
        }
        if !wkt::internal::is_default(&self.merge_option) {
            state.serialize_entry("mergeOption", &self.merge_option)?;
        }
        if !self.target_entity_type.is_empty() {
            state.serialize_entry("targetEntityType", &self.target_entity_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ImportEntityTypesRequest].
#[cfg(feature = "entity-types")]
pub mod import_entity_types_request {
    #[allow(unused_imports)]
    use super::*;

    /// Merge option when display name conflicts exist during import.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "entity-types")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MergeOption {
        /// Unspecified. If used, system uses REPORT_CONFLICT as default.
        Unspecified,
        /// Replace the original entity type in the agent with the new entity type
        /// when display name conflicts exist.
        Replace,
        /// Merge the original entity type with the new entity type when display name
        /// conflicts exist.
        Merge,
        /// Create new entity types with new display names to differentiate them from
        /// the existing entity types when display name conflicts exist.
        Rename,
        /// Report conflict information if display names conflict is detected.
        /// Otherwise, import entity types.
        ReportConflict,
        /// Keep the original entity type and discard the conflicting new entity type
        /// when display name conflicts exist.
        Keep,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MergeOption::value] or
        /// [MergeOption::name].
        UnknownValue(merge_option::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "entity-types")]
    pub mod merge_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "entity-types")]
    impl MergeOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Replace => std::option::Option::Some(1),
                Self::Merge => std::option::Option::Some(2),
                Self::Rename => std::option::Option::Some(3),
                Self::ReportConflict => std::option::Option::Some(4),
                Self::Keep => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MERGE_OPTION_UNSPECIFIED"),
                Self::Replace => std::option::Option::Some("REPLACE"),
                Self::Merge => std::option::Option::Some("MERGE"),
                Self::Rename => std::option::Option::Some("RENAME"),
                Self::ReportConflict => std::option::Option::Some("REPORT_CONFLICT"),
                Self::Keep => std::option::Option::Some("KEEP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "entity-types")]
    impl std::default::Default for MergeOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "entity-types")]
    impl std::fmt::Display for MergeOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "entity-types")]
    impl std::convert::From<i32> for MergeOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Replace,
                2 => Self::Merge,
                3 => Self::Rename,
                4 => Self::ReportConflict,
                5 => Self::Keep,
                _ => Self::UnknownValue(merge_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "entity-types")]
    impl std::convert::From<&str> for MergeOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MERGE_OPTION_UNSPECIFIED" => Self::Unspecified,
                "REPLACE" => Self::Replace,
                "MERGE" => Self::Merge,
                "RENAME" => Self::Rename,
                "REPORT_CONFLICT" => Self::ReportConflict,
                "KEEP" => Self::Keep,
                _ => Self::UnknownValue(merge_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "entity-types")]
    impl serde::ser::Serialize for MergeOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Replace => serializer.serialize_i32(1),
                Self::Merge => serializer.serialize_i32(2),
                Self::Rename => serializer.serialize_i32(3),
                Self::ReportConflict => serializer.serialize_i32(4),
                Self::Keep => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "entity-types")]
    impl<'de> serde::de::Deserialize<'de> for MergeOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MergeOption>::new(
                ".google.cloud.dialogflow.cx.v3.ImportEntityTypesRequest.MergeOption",
            ))
        }
    }

    /// Required. The entity types to import.
    #[cfg(feature = "entity-types")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EntityTypes {
        /// The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI
        /// to import entity types from. The format of this URI must be
        /// `gs://<bucket-name>/<object-name>`.
        ///
        /// Dialogflow performs a read operation for the Cloud Storage object
        /// on the caller's behalf, so your request authentication must
        /// have read permissions for the object. For more information, see
        /// [Dialogflow access
        /// control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
        EntityTypesUri(std::string::String),
        /// Uncompressed byte content of entity types.
        EntityTypesContent(std::boxed::Box<crate::model::InlineSource>),
    }
}

/// The response message for
/// [EntityTypes.ImportEntityTypes][google.cloud.dialogflow.cx.v3.EntityTypes.ImportEntityTypes].
///
/// [google.cloud.dialogflow.cx.v3.EntityTypes.ImportEntityTypes]: crate::client::EntityTypes::import_entity_types
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportEntityTypesResponse {
    /// The unique identifier of the imported entity types.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/entity_types/<EntityTypeID>`.
    pub entity_types: std::vec::Vec<std::string::String>,

    /// Info which resources have conflicts when
    /// [REPORT_CONFLICT][ImportEntityTypesResponse.REPORT_CONFLICT] merge_option
    /// is set in ImportEntityTypesRequest.
    pub conflicting_resources:
        std::option::Option<crate::model::import_entity_types_response::ConflictingResources>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl ImportEntityTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_types][crate::model::ImportEntityTypesResponse::entity_types].
    pub fn set_entity_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.entity_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [conflicting_resources][crate::model::ImportEntityTypesResponse::conflicting_resources].
    pub fn set_conflicting_resources<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::import_entity_types_response::ConflictingResources>,
    {
        self.conflicting_resources = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conflicting_resources][crate::model::ImportEntityTypesResponse::conflicting_resources].
    pub fn set_or_clear_conflicting_resources<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::import_entity_types_response::ConflictingResources>,
    {
        self.conflicting_resources = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for ImportEntityTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ImportEntityTypesResponse"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportEntityTypesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity_types,
            __conflicting_resources,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportEntityTypesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entityTypes" => Ok(__FieldTag::__entity_types),
                            "entity_types" => Ok(__FieldTag::__entity_types),
                            "conflictingResources" => Ok(__FieldTag::__conflicting_resources),
                            "conflicting_resources" => Ok(__FieldTag::__conflicting_resources),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportEntityTypesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportEntityTypesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity_types => {
                            if !fields.insert(__FieldTag::__entity_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_types",
                                ));
                            }
                            result.entity_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__conflicting_resources => {
                            if !fields.insert(__FieldTag::__conflicting_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conflicting_resources",
                                ));
                            }
                            result.conflicting_resources = map.next_value::<std::option::Option<
                                crate::model::import_entity_types_response::ConflictingResources,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for ImportEntityTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entity_types.is_empty() {
            state.serialize_entry("entityTypes", &self.entity_types)?;
        }
        if self.conflicting_resources.is_some() {
            state.serialize_entry("conflictingResources", &self.conflicting_resources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ImportEntityTypesResponse].
#[cfg(feature = "entity-types")]
pub mod import_entity_types_response {
    #[allow(unused_imports)]
    use super::*;

    /// Conflicting resources detected during the import process. Only filled when
    /// [REPORT_CONFLICT][ImportEntityTypesResponse.REPORT_CONFLICT] is set in the
    /// request and there are conflicts in the display names.
    #[cfg(feature = "entity-types")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConflictingResources {
        /// Display names of conflicting entity types.
        pub entity_type_display_names: std::vec::Vec<std::string::String>,

        /// Display names of conflicting entities.
        pub entity_display_names: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "entity-types")]
    impl ConflictingResources {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [entity_type_display_names][crate::model::import_entity_types_response::ConflictingResources::entity_type_display_names].
        pub fn set_entity_type_display_names<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.entity_type_display_names = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [entity_display_names][crate::model::import_entity_types_response::ConflictingResources::entity_display_names].
        pub fn set_entity_display_names<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.entity_display_names = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "entity-types")]
    impl wkt::message::Message for ConflictingResources {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.ImportEntityTypesResponse.ConflictingResources"
        }
    }

    #[cfg(feature = "entity-types")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConflictingResources {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __entity_type_display_names,
                __entity_display_names,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConflictingResources")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "entityTypeDisplayNames" => {
                                    Ok(__FieldTag::__entity_type_display_names)
                                }
                                "entity_type_display_names" => {
                                    Ok(__FieldTag::__entity_type_display_names)
                                }
                                "entityDisplayNames" => Ok(__FieldTag::__entity_display_names),
                                "entity_display_names" => Ok(__FieldTag::__entity_display_names),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConflictingResources;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConflictingResources")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__entity_type_display_names => {
                                if !fields.insert(__FieldTag::__entity_type_display_names) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for entity_type_display_names",
                                    ));
                                }
                                result.entity_type_display_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__entity_display_names => {
                                if !fields.insert(__FieldTag::__entity_display_names) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for entity_display_names",
                                    ));
                                }
                                result.entity_display_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "entity-types")]
    #[doc(hidden)]
    impl serde::ser::Serialize for ConflictingResources {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.entity_type_display_names.is_empty() {
                state.serialize_entry("entityTypeDisplayNames", &self.entity_type_display_names)?;
            }
            if !self.entity_display_names.is_empty() {
                state.serialize_entry("entityDisplayNames", &self.entity_display_names)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Metadata returned for the
/// [EntityTypes.ImportEntityTypes][google.cloud.dialogflow.cx.v3.EntityTypes.ImportEntityTypes]
/// long running operation.
///
/// [google.cloud.dialogflow.cx.v3.EntityTypes.ImportEntityTypes]: crate::client::EntityTypes::import_entity_types
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportEntityTypesMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl ImportEntityTypesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for ImportEntityTypesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ImportEntityTypesMetadata"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportEntityTypesMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportEntityTypesMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportEntityTypesMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportEntityTypesMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for ImportEntityTypesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [EntityTypes.ListEntityTypes][google.cloud.dialogflow.cx.v3.EntityTypes.ListEntityTypes].
///
/// [google.cloud.dialogflow.cx.v3.EntityTypes.ListEntityTypes]: crate::client::EntityTypes::list_entity_types
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntityTypesRequest {
    /// Required. The agent to list all entity types for.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// The language to list entity types for. The following fields are language
    /// dependent:
    ///
    /// * `EntityType.entities.value`
    /// * `EntityType.entities.synonyms`
    /// * `EntityType.excluded_phrases.value`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    /// The maximum number of items to return in a single page. By default 100 and
    /// at most 1000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl ListEntityTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntityTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::ListEntityTypesRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntityTypesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntityTypesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for ListEntityTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListEntityTypesRequest"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntityTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __language_code,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntityTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntityTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntityTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for ListEntityTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [EntityTypes.ListEntityTypes][google.cloud.dialogflow.cx.v3.EntityTypes.ListEntityTypes].
///
/// [google.cloud.dialogflow.cx.v3.EntityTypes.ListEntityTypes]: crate::client::EntityTypes::list_entity_types
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntityTypesResponse {
    /// The list of entity types. There will be a maximum number of items returned
    /// based on the page_size field in the request.
    pub entity_types: std::vec::Vec<crate::model::EntityType>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl ListEntityTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_types][crate::model::ListEntityTypesResponse::entity_types].
    pub fn set_entity_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityType>,
    {
        use std::iter::Iterator;
        self.entity_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEntityTypesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for ListEntityTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListEntityTypesResponse"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEntityTypesResponse {
    type PageItem = crate::model::EntityType;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entity_types
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntityTypesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity_types,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntityTypesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entityTypes" => Ok(__FieldTag::__entity_types),
                            "entity_types" => Ok(__FieldTag::__entity_types),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntityTypesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntityTypesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity_types => {
                            if !fields.insert(__FieldTag::__entity_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_types",
                                ));
                            }
                            result.entity_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EntityType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for ListEntityTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entity_types.is_empty() {
            state.serialize_entry("entityTypes", &self.entity_types)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [EntityTypes.GetEntityType][google.cloud.dialogflow.cx.v3.EntityTypes.GetEntityType].
///
/// [google.cloud.dialogflow.cx.v3.EntityTypes.GetEntityType]: crate::client::EntityTypes::get_entity_type
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEntityTypeRequest {
    /// Required. The name of the entity type.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/entityTypes/<EntityTypeID>`.
    pub name: std::string::String,

    /// The language to retrieve the entity type for. The following fields are
    /// language dependent:
    ///
    /// * `EntityType.entities.value`
    /// * `EntityType.entities.synonyms`
    /// * `EntityType.excluded_phrases.value`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl GetEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntityTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::GetEntityTypeRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for GetEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetEntityTypeRequest"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for GetEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [EntityTypes.CreateEntityType][google.cloud.dialogflow.cx.v3.EntityTypes.CreateEntityType].
///
/// [google.cloud.dialogflow.cx.v3.EntityTypes.CreateEntityType]: crate::client::EntityTypes::create_entity_type
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateEntityTypeRequest {
    /// Required. The agent to create a entity type for.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// Required. The entity type to create.
    pub entity_type: std::option::Option<crate::model::EntityType>,

    /// The language of the following fields in `entity_type`:
    ///
    /// * `EntityType.entities.value`
    /// * `EntityType.entities.synonyms`
    /// * `EntityType.excluded_phrases.value`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl CreateEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntityTypeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entity_type][crate::model::CreateEntityTypeRequest::entity_type].
    pub fn set_entity_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EntityType>,
    {
        self.entity_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entity_type][crate::model::CreateEntityTypeRequest::entity_type].
    pub fn set_or_clear_entity_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EntityType>,
    {
        self.entity_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::CreateEntityTypeRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for CreateEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CreateEntityTypeRequest"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entity_type,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entityType" => Ok(__FieldTag::__entity_type),
                            "entity_type" => Ok(__FieldTag::__entity_type),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_type => {
                            if !fields.insert(__FieldTag::__entity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_type",
                                ));
                            }
                            result.entity_type =
                                map.next_value::<std::option::Option<crate::model::EntityType>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.entity_type.is_some() {
            state.serialize_entry("entityType", &self.entity_type)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [EntityTypes.UpdateEntityType][google.cloud.dialogflow.cx.v3.EntityTypes.UpdateEntityType].
///
/// [google.cloud.dialogflow.cx.v3.EntityTypes.UpdateEntityType]: crate::client::EntityTypes::update_entity_type
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateEntityTypeRequest {
    /// Required. The entity type to update.
    pub entity_type: std::option::Option<crate::model::EntityType>,

    /// The language of the following fields in `entity_type`:
    ///
    /// * `EntityType.entities.value`
    /// * `EntityType.entities.synonyms`
    /// * `EntityType.excluded_phrases.value`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    /// The mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl UpdateEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_type][crate::model::UpdateEntityTypeRequest::entity_type].
    pub fn set_entity_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EntityType>,
    {
        self.entity_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entity_type][crate::model::UpdateEntityTypeRequest::entity_type].
    pub fn set_or_clear_entity_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EntityType>,
    {
        self.entity_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::UpdateEntityTypeRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEntityTypeRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEntityTypeRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for UpdateEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.UpdateEntityTypeRequest"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity_type,
            __language_code,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entityType" => Ok(__FieldTag::__entity_type),
                            "entity_type" => Ok(__FieldTag::__entity_type),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity_type => {
                            if !fields.insert(__FieldTag::__entity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_type",
                                ));
                            }
                            result.entity_type =
                                map.next_value::<std::option::Option<crate::model::EntityType>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.entity_type.is_some() {
            state.serialize_entry("entityType", &self.entity_type)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [EntityTypes.DeleteEntityType][google.cloud.dialogflow.cx.v3.EntityTypes.DeleteEntityType].
///
/// [google.cloud.dialogflow.cx.v3.EntityTypes.DeleteEntityType]: crate::client::EntityTypes::delete_entity_type
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteEntityTypeRequest {
    /// Required. The name of the entity type to delete.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/entityTypes/<EntityTypeID>`.
    pub name: std::string::String,

    /// This field has no effect for entity type not being used.
    /// For entity types that are used by intents or pages:
    ///
    /// * If `force` is set to false, an error will be returned with message
    ///   indicating the referencing resources.
    /// * If `force` is set to true, Dialogflow will remove the entity type, as
    ///   well as any references to the entity type (i.e. Page
    ///   [parameter][google.cloud.dialogflow.cx.v3.Form.Parameter] of the entity
    ///   type will be changed to
    ///   '@sys.any' and intent
    ///   [parameter][google.cloud.dialogflow.cx.v3.Intent.Parameter] of the
    ///   entity type will be removed).
    ///
    /// [google.cloud.dialogflow.cx.v3.Form.Parameter]: crate::model::form::Parameter
    /// [google.cloud.dialogflow.cx.v3.Intent.Parameter]: crate::model::intent::Parameter
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl DeleteEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntityTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteEntityTypeRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for DeleteEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DeleteEntityTypeRequest"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents an environment for an agent. You can create multiple versions
/// of your agent and publish them to separate environments. When you edit an
/// agent, you are editing the draft agent. At any point, you can save the draft
/// agent as an agent version, which is an immutable snapshot of your agent. When
/// you save the draft agent, it is published to the default environment. When
/// you create agent versions, you can publish them to custom environments. You
/// can create a variety of custom environments for testing, development,
/// production, etc.
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Environment {
    /// The name of the environment.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>`.
    pub name: std::string::String,

    /// Required. The human-readable name of the environment (unique in an agent).
    /// Limit of 64 characters.
    pub display_name: std::string::String,

    /// The human-readable description of the environment. The maximum length is
    /// 500 characters. If exceeded, the request is rejected.
    pub description: std::string::String,

    /// A list of configurations for flow versions. You should include version
    /// configs for all flows that are reachable from [`Start
    /// Flow`][Agent.start_flow] in the agent. Otherwise, an error will be
    /// returned.
    ///
    /// [Agent.start_flow]: crate::model::Agent::start_flow
    pub version_configs: std::vec::Vec<crate::model::environment::VersionConfig>,

    /// Output only. Update time of this environment.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The test cases config for continuous tests of this environment.
    pub test_cases_config: std::option::Option<crate::model::environment::TestCasesConfig>,

    /// The webhook configuration for this environment.
    pub webhook_config: std::option::Option<crate::model::environment::WebhookConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl Environment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Environment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Environment::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Environment::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [version_configs][crate::model::Environment::version_configs].
    pub fn set_version_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::environment::VersionConfig>,
    {
        use std::iter::Iterator;
        self.version_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [update_time][crate::model::Environment::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Environment::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [test_cases_config][crate::model::Environment::test_cases_config].
    pub fn set_test_cases_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::environment::TestCasesConfig>,
    {
        self.test_cases_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [test_cases_config][crate::model::Environment::test_cases_config].
    pub fn set_or_clear_test_cases_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::environment::TestCasesConfig>,
    {
        self.test_cases_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [webhook_config][crate::model::Environment::webhook_config].
    pub fn set_webhook_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::environment::WebhookConfig>,
    {
        self.webhook_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [webhook_config][crate::model::Environment::webhook_config].
    pub fn set_or_clear_webhook_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::environment::WebhookConfig>,
    {
        self.webhook_config = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for Environment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.Environment"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Environment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __version_configs,
            __update_time,
            __test_cases_config,
            __webhook_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Environment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "versionConfigs" => Ok(__FieldTag::__version_configs),
                            "version_configs" => Ok(__FieldTag::__version_configs),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "testCasesConfig" => Ok(__FieldTag::__test_cases_config),
                            "test_cases_config" => Ok(__FieldTag::__test_cases_config),
                            "webhookConfig" => Ok(__FieldTag::__webhook_config),
                            "webhook_config" => Ok(__FieldTag::__webhook_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Environment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Environment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version_configs => {
                            if !fields.insert(__FieldTag::__version_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_configs",
                                ));
                            }
                            result.version_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::environment::VersionConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__test_cases_config => {
                            if !fields.insert(__FieldTag::__test_cases_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_cases_config",
                                ));
                            }
                            result.test_cases_config = map.next_value::<std::option::Option<crate::model::environment::TestCasesConfig>>()?
                                ;
                        }
                        __FieldTag::__webhook_config => {
                            if !fields.insert(__FieldTag::__webhook_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_config",
                                ));
                            }
                            result.webhook_config = map.next_value::<std::option::Option<crate::model::environment::WebhookConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for Environment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.version_configs.is_empty() {
            state.serialize_entry("versionConfigs", &self.version_configs)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.test_cases_config.is_some() {
            state.serialize_entry("testCasesConfig", &self.test_cases_config)?;
        }
        if self.webhook_config.is_some() {
            state.serialize_entry("webhookConfig", &self.webhook_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Environment].
#[cfg(feature = "environments")]
pub mod environment {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for the version.
    #[cfg(feature = "environments")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct VersionConfig {
        /// Required. Both flow and playbook versions are supported.
        /// Format for flow version:
        /// projects/\<ProjectID\>/locations/\<LocationID\>/agents/\<AgentID\>/flows/\<FlowID\>/versions/\<VersionID\>.
        /// Format for playbook version:
        /// projects/\<ProjectID\>/locations/\<LocationID\>/agents/\<AgentID\>/playbooks/\<PlaybookID\>/versions/\<VersionID\>.
        pub version: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "environments")]
    impl VersionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [version][crate::model::environment::VersionConfig::version].
        pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.version = v.into();
            self
        }
    }

    #[cfg(feature = "environments")]
    impl wkt::message::Message for VersionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Environment.VersionConfig"
        }
    }

    #[cfg(feature = "environments")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for VersionConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __version,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for VersionConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "version" => Ok(__FieldTag::__version),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = VersionConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct VersionConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__version => {
                                if !fields.insert(__FieldTag::__version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for version",
                                    ));
                                }
                                result.version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "environments")]
    #[doc(hidden)]
    impl serde::ser::Serialize for VersionConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.version.is_empty() {
                state.serialize_entry("version", &self.version)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The configuration for continuous tests.
    #[cfg(feature = "environments")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TestCasesConfig {
        /// A list of test case names to run. They should be under the same agent.
        /// Format of each test case name:
        /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/testCases/<TestCaseID>`
        pub test_cases: std::vec::Vec<std::string::String>,

        /// Whether to run test cases in
        /// [TestCasesConfig.test_cases][google.cloud.dialogflow.cx.v3.Environment.TestCasesConfig.test_cases]
        /// periodically. Default false. If set to true, run once a day.
        ///
        /// [google.cloud.dialogflow.cx.v3.Environment.TestCasesConfig.test_cases]: crate::model::environment::TestCasesConfig::test_cases
        pub enable_continuous_run: bool,

        /// Whether to run test cases in
        /// [TestCasesConfig.test_cases][google.cloud.dialogflow.cx.v3.Environment.TestCasesConfig.test_cases]
        /// before deploying a flow version to the environment. Default false.
        ///
        /// [google.cloud.dialogflow.cx.v3.Environment.TestCasesConfig.test_cases]: crate::model::environment::TestCasesConfig::test_cases
        pub enable_predeployment_run: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "environments")]
    impl TestCasesConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [test_cases][crate::model::environment::TestCasesConfig::test_cases].
        pub fn set_test_cases<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.test_cases = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [enable_continuous_run][crate::model::environment::TestCasesConfig::enable_continuous_run].
        pub fn set_enable_continuous_run<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_continuous_run = v.into();
            self
        }

        /// Sets the value of [enable_predeployment_run][crate::model::environment::TestCasesConfig::enable_predeployment_run].
        pub fn set_enable_predeployment_run<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_predeployment_run = v.into();
            self
        }
    }

    #[cfg(feature = "environments")]
    impl wkt::message::Message for TestCasesConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Environment.TestCasesConfig"
        }
    }

    #[cfg(feature = "environments")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TestCasesConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __test_cases,
                __enable_continuous_run,
                __enable_predeployment_run,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TestCasesConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "testCases" => Ok(__FieldTag::__test_cases),
                                "test_cases" => Ok(__FieldTag::__test_cases),
                                "enableContinuousRun" => Ok(__FieldTag::__enable_continuous_run),
                                "enable_continuous_run" => Ok(__FieldTag::__enable_continuous_run),
                                "enablePredeploymentRun" => {
                                    Ok(__FieldTag::__enable_predeployment_run)
                                }
                                "enable_predeployment_run" => {
                                    Ok(__FieldTag::__enable_predeployment_run)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TestCasesConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TestCasesConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__test_cases => {
                                if !fields.insert(__FieldTag::__test_cases) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for test_cases",
                                    ));
                                }
                                result.test_cases = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__enable_continuous_run => {
                                if !fields.insert(__FieldTag::__enable_continuous_run) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_continuous_run",
                                    ));
                                }
                                result.enable_continuous_run = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__enable_predeployment_run => {
                                if !fields.insert(__FieldTag::__enable_predeployment_run) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_predeployment_run",
                                    ));
                                }
                                result.enable_predeployment_run = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "environments")]
    #[doc(hidden)]
    impl serde::ser::Serialize for TestCasesConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.test_cases.is_empty() {
                state.serialize_entry("testCases", &self.test_cases)?;
            }
            if !wkt::internal::is_default(&self.enable_continuous_run) {
                state.serialize_entry("enableContinuousRun", &self.enable_continuous_run)?;
            }
            if !wkt::internal::is_default(&self.enable_predeployment_run) {
                state.serialize_entry("enablePredeploymentRun", &self.enable_predeployment_run)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Configuration for webhooks.
    #[cfg(feature = "environments")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WebhookConfig {
        /// The list of webhooks to override for the agent environment. The webhook
        /// must exist in the agent. You can override fields in
        /// [`generic_web_service`][google.cloud.dialogflow.cx.v3.Webhook.generic_web_service]
        /// and
        /// [`service_directory`][google.cloud.dialogflow.cx.v3.Webhook.service_directory].
        ///
        /// [google.cloud.dialogflow.cx.v3.Webhook.generic_web_service]: crate::model::Webhook::webhook
        /// [google.cloud.dialogflow.cx.v3.Webhook.service_directory]: crate::model::Webhook::webhook
        pub webhook_overrides: std::vec::Vec<crate::model::Webhook>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "environments")]
    impl WebhookConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [webhook_overrides][crate::model::environment::WebhookConfig::webhook_overrides].
        pub fn set_webhook_overrides<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Webhook>,
        {
            use std::iter::Iterator;
            self.webhook_overrides = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "environments")]
    impl wkt::message::Message for WebhookConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Environment.WebhookConfig"
        }
    }

    #[cfg(feature = "environments")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for WebhookConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __webhook_overrides,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for WebhookConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "webhookOverrides" => Ok(__FieldTag::__webhook_overrides),
                                "webhook_overrides" => Ok(__FieldTag::__webhook_overrides),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = WebhookConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct WebhookConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__webhook_overrides => {
                                if !fields.insert(__FieldTag::__webhook_overrides) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for webhook_overrides",
                                    ));
                                }
                                result.webhook_overrides = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Webhook>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "environments")]
    #[doc(hidden)]
    impl serde::ser::Serialize for WebhookConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.webhook_overrides.is_empty() {
                state.serialize_entry("webhookOverrides", &self.webhook_overrides)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// The request message for
/// [Environments.ListEnvironments][google.cloud.dialogflow.cx.v3.Environments.ListEnvironments].
///
/// [google.cloud.dialogflow.cx.v3.Environments.ListEnvironments]: crate::client::Environments::list_environments
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEnvironmentsRequest {
    /// Required. The [Agent][google.cloud.dialogflow.cx.v3.Agent] to list all
    /// environments for. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Agent]: crate::model::Agent
    pub parent: std::string::String,

    /// The maximum number of items to return in a single page. By default 20 and
    /// at most 100.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl ListEnvironmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEnvironmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEnvironmentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEnvironmentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for ListEnvironmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListEnvironmentsRequest"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEnvironmentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEnvironmentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEnvironmentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEnvironmentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for ListEnvironmentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Environments.ListEnvironments][google.cloud.dialogflow.cx.v3.Environments.ListEnvironments].
///
/// [google.cloud.dialogflow.cx.v3.Environments.ListEnvironments]: crate::client::Environments::list_environments
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEnvironmentsResponse {
    /// The list of environments. There will be a maximum number of items
    /// returned based on the page_size field in the request. The list may in some
    /// cases be empty or contain fewer entries than page_size even if this isn't
    /// the last page.
    pub environments: std::vec::Vec<crate::model::Environment>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl ListEnvironmentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environments][crate::model::ListEnvironmentsResponse::environments].
    pub fn set_environments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Environment>,
    {
        use std::iter::Iterator;
        self.environments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEnvironmentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for ListEnvironmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListEnvironmentsResponse"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEnvironmentsResponse {
    type PageItem = crate::model::Environment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.environments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEnvironmentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEnvironmentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environments" => Ok(__FieldTag::__environments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEnvironmentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEnvironmentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environments => {
                            if !fields.insert(__FieldTag::__environments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environments",
                                ));
                            }
                            result.environments = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Environment>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for ListEnvironmentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environments.is_empty() {
            state.serialize_entry("environments", &self.environments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Environments.GetEnvironment][google.cloud.dialogflow.cx.v3.Environments.GetEnvironment].
///
/// [google.cloud.dialogflow.cx.v3.Environments.GetEnvironment]: crate::client::Environments::get_environment
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEnvironmentRequest {
    /// Required. The name of the
    /// [Environment][google.cloud.dialogflow.cx.v3.Environment]. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Environment]: crate::model::Environment
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl GetEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEnvironmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for GetEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetEnvironmentRequest"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for GetEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Environments.CreateEnvironment][google.cloud.dialogflow.cx.v3.Environments.CreateEnvironment].
///
/// [google.cloud.dialogflow.cx.v3.Environments.CreateEnvironment]: crate::client::Environments::create_environment
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateEnvironmentRequest {
    /// Required. The [Agent][google.cloud.dialogflow.cx.v3.Agent] to create an
    /// [Environment][google.cloud.dialogflow.cx.v3.Environment] for. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Agent]: crate::model::Agent
    /// [google.cloud.dialogflow.cx.v3.Environment]: crate::model::Environment
    pub parent: std::string::String,

    /// Required. The environment to create.
    pub environment: std::option::Option<crate::model::Environment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl CreateEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEnvironmentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::CreateEnvironmentRequest::environment].
    pub fn set_environment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Environment>,
    {
        self.environment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [environment][crate::model::CreateEnvironmentRequest::environment].
    pub fn set_or_clear_environment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Environment>,
    {
        self.environment = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for CreateEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CreateEnvironmentRequest"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __environment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "environment" => Ok(__FieldTag::__environment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment =
                                map.next_value::<std::option::Option<crate::model::Environment>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.environment.is_some() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Environments.UpdateEnvironment][google.cloud.dialogflow.cx.v3.Environments.UpdateEnvironment].
///
/// [google.cloud.dialogflow.cx.v3.Environments.UpdateEnvironment]: crate::client::Environments::update_environment
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateEnvironmentRequest {
    /// Required. The environment to update.
    pub environment: std::option::Option<crate::model::Environment>,

    /// Required. The mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl UpdateEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::UpdateEnvironmentRequest::environment].
    pub fn set_environment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Environment>,
    {
        self.environment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [environment][crate::model::UpdateEnvironmentRequest::environment].
    pub fn set_or_clear_environment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Environment>,
    {
        self.environment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEnvironmentRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEnvironmentRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for UpdateEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.UpdateEnvironmentRequest"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environment,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environment" => Ok(__FieldTag::__environment),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment =
                                map.next_value::<std::option::Option<crate::model::Environment>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.environment.is_some() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Environments.DeleteEnvironment][google.cloud.dialogflow.cx.v3.Environments.DeleteEnvironment].
///
/// [google.cloud.dialogflow.cx.v3.Environments.DeleteEnvironment]: crate::client::Environments::delete_environment
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteEnvironmentRequest {
    /// Required. The name of the
    /// [Environment][google.cloud.dialogflow.cx.v3.Environment] to delete. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Environment]: crate::model::Environment
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl DeleteEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEnvironmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for DeleteEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DeleteEnvironmentRequest"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Environments.LookupEnvironmentHistory][google.cloud.dialogflow.cx.v3.Environments.LookupEnvironmentHistory].
///
/// [google.cloud.dialogflow.cx.v3.Environments.LookupEnvironmentHistory]: crate::client::Environments::lookup_environment_history
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LookupEnvironmentHistoryRequest {
    /// Required. Resource name of the environment to look up the history for.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>`.
    pub name: std::string::String,

    /// The maximum number of items to return in a single page. By default 100 and
    /// at most 1000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl LookupEnvironmentHistoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LookupEnvironmentHistoryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::LookupEnvironmentHistoryRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::LookupEnvironmentHistoryRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for LookupEnvironmentHistoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.LookupEnvironmentHistoryRequest"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LookupEnvironmentHistoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LookupEnvironmentHistoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LookupEnvironmentHistoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LookupEnvironmentHistoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for LookupEnvironmentHistoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Environments.LookupEnvironmentHistory][google.cloud.dialogflow.cx.v3.Environments.LookupEnvironmentHistory].
///
/// [google.cloud.dialogflow.cx.v3.Environments.LookupEnvironmentHistory]: crate::client::Environments::lookup_environment_history
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LookupEnvironmentHistoryResponse {
    /// Represents a list of snapshots for an environment. Time of the snapshots is
    /// stored in
    /// [`update_time`][google.cloud.dialogflow.cx.v3.Environment.update_time].
    ///
    /// [google.cloud.dialogflow.cx.v3.Environment.update_time]: crate::model::Environment::update_time
    pub environments: std::vec::Vec<crate::model::Environment>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl LookupEnvironmentHistoryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environments][crate::model::LookupEnvironmentHistoryResponse::environments].
    pub fn set_environments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Environment>,
    {
        use std::iter::Iterator;
        self.environments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::LookupEnvironmentHistoryResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for LookupEnvironmentHistoryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.LookupEnvironmentHistoryResponse"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for LookupEnvironmentHistoryResponse {
    type PageItem = crate::model::Environment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.environments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LookupEnvironmentHistoryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LookupEnvironmentHistoryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environments" => Ok(__FieldTag::__environments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LookupEnvironmentHistoryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LookupEnvironmentHistoryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environments => {
                            if !fields.insert(__FieldTag::__environments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environments",
                                ));
                            }
                            result.environments = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Environment>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for LookupEnvironmentHistoryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environments.is_empty() {
            state.serialize_entry("environments", &self.environments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a result from running a test case in an agent environment.
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ContinuousTestResult {
    /// The resource name for the continuous test result. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>/continuousTestResults/<ContinuousTestResultID>`.
    pub name: std::string::String,

    /// The result of this continuous test run, i.e. whether all the tests in this
    /// continuous test run pass or not.
    pub result: crate::model::continuous_test_result::AggregatedTestResult,

    /// A list of individual test case results names in this continuous test run.
    pub test_case_results: std::vec::Vec<std::string::String>,

    /// Time when the continuous testing run starts.
    pub run_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl ContinuousTestResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ContinuousTestResult::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [result][crate::model::ContinuousTestResult::result].
    pub fn set_result<
        T: std::convert::Into<crate::model::continuous_test_result::AggregatedTestResult>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// Sets the value of [test_case_results][crate::model::ContinuousTestResult::test_case_results].
    pub fn set_test_case_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.test_case_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [run_time][crate::model::ContinuousTestResult::run_time].
    pub fn set_run_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.run_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [run_time][crate::model::ContinuousTestResult::run_time].
    pub fn set_or_clear_run_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.run_time = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for ContinuousTestResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ContinuousTestResult"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ContinuousTestResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __result,
            __test_case_results,
            __run_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ContinuousTestResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "result" => Ok(__FieldTag::__result),
                            "testCaseResults" => Ok(__FieldTag::__test_case_results),
                            "test_case_results" => Ok(__FieldTag::__test_case_results),
                            "runTime" => Ok(__FieldTag::__run_time),
                            "run_time" => Ok(__FieldTag::__run_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ContinuousTestResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ContinuousTestResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__result => {
                            if !fields.insert(__FieldTag::__result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result",
                                ));
                            }
                            result.result = map
                                .next_value::<std::option::Option<
                                    crate::model::continuous_test_result::AggregatedTestResult,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__test_case_results => {
                            if !fields.insert(__FieldTag::__test_case_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_case_results",
                                ));
                            }
                            result.test_case_results = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__run_time => {
                            if !fields.insert(__FieldTag::__run_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for run_time",
                                ));
                            }
                            result.run_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for ContinuousTestResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.result) {
            state.serialize_entry("result", &self.result)?;
        }
        if !self.test_case_results.is_empty() {
            state.serialize_entry("testCaseResults", &self.test_case_results)?;
        }
        if self.run_time.is_some() {
            state.serialize_entry("runTime", &self.run_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ContinuousTestResult].
#[cfg(feature = "environments")]
pub mod continuous_test_result {
    #[allow(unused_imports)]
    use super::*;

    /// The overall result for a continuous test run in an agent environment.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "environments")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AggregatedTestResult {
        /// Not specified. Should never be used.
        Unspecified,
        /// All the tests passed.
        Passed,
        /// At least one test did not pass.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AggregatedTestResult::value] or
        /// [AggregatedTestResult::name].
        UnknownValue(aggregated_test_result::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "environments")]
    pub mod aggregated_test_result {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "environments")]
    impl AggregatedTestResult {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Passed => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("AGGREGATED_TEST_RESULT_UNSPECIFIED")
                }
                Self::Passed => std::option::Option::Some("PASSED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "environments")]
    impl std::default::Default for AggregatedTestResult {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "environments")]
    impl std::fmt::Display for AggregatedTestResult {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "environments")]
    impl std::convert::From<i32> for AggregatedTestResult {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Passed,
                2 => Self::Failed,
                _ => Self::UnknownValue(aggregated_test_result::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "environments")]
    impl std::convert::From<&str> for AggregatedTestResult {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AGGREGATED_TEST_RESULT_UNSPECIFIED" => Self::Unspecified,
                "PASSED" => Self::Passed,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(aggregated_test_result::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "environments")]
    impl serde::ser::Serialize for AggregatedTestResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Passed => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "environments")]
    impl<'de> serde::de::Deserialize<'de> for AggregatedTestResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AggregatedTestResult>::new(
                ".google.cloud.dialogflow.cx.v3.ContinuousTestResult.AggregatedTestResult",
            ))
        }
    }
}

/// The request message for
/// [Environments.RunContinuousTest][google.cloud.dialogflow.cx.v3.Environments.RunContinuousTest].
///
/// [google.cloud.dialogflow.cx.v3.Environments.RunContinuousTest]: crate::client::Environments::run_continuous_test
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RunContinuousTestRequest {
    /// Required. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>`.
    pub environment: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl RunContinuousTestRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::RunContinuousTestRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for RunContinuousTestRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.RunContinuousTestRequest"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunContinuousTestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunContinuousTestRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environment" => Ok(__FieldTag::__environment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunContinuousTestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunContinuousTestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for RunContinuousTestRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Environments.RunContinuousTest][google.cloud.dialogflow.cx.v3.Environments.RunContinuousTest].
///
/// [google.cloud.dialogflow.cx.v3.Environments.RunContinuousTest]: crate::client::Environments::run_continuous_test
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RunContinuousTestResponse {
    /// The result for a continuous test run.
    pub continuous_test_result: std::option::Option<crate::model::ContinuousTestResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl RunContinuousTestResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [continuous_test_result][crate::model::RunContinuousTestResponse::continuous_test_result].
    pub fn set_continuous_test_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ContinuousTestResult>,
    {
        self.continuous_test_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [continuous_test_result][crate::model::RunContinuousTestResponse::continuous_test_result].
    pub fn set_or_clear_continuous_test_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ContinuousTestResult>,
    {
        self.continuous_test_result = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for RunContinuousTestResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.RunContinuousTestResponse"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunContinuousTestResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __continuous_test_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunContinuousTestResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "continuousTestResult" => Ok(__FieldTag::__continuous_test_result),
                            "continuous_test_result" => Ok(__FieldTag::__continuous_test_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunContinuousTestResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunContinuousTestResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__continuous_test_result => {
                            if !fields.insert(__FieldTag::__continuous_test_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for continuous_test_result",
                                ));
                            }
                            result.continuous_test_result = map.next_value::<std::option::Option<crate::model::ContinuousTestResult>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for RunContinuousTestResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.continuous_test_result.is_some() {
            state.serialize_entry("continuousTestResult", &self.continuous_test_result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata returned for the
/// [Environments.RunContinuousTest][google.cloud.dialogflow.cx.v3.Environments.RunContinuousTest]
/// long running operation.
///
/// [google.cloud.dialogflow.cx.v3.Environments.RunContinuousTest]: crate::client::Environments::run_continuous_test
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RunContinuousTestMetadata {
    /// The test errors.
    pub errors: std::vec::Vec<crate::model::TestError>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl RunContinuousTestMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [errors][crate::model::RunContinuousTestMetadata::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TestError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for RunContinuousTestMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.RunContinuousTestMetadata"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunContinuousTestMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunContinuousTestMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "errors" => Ok(__FieldTag::__errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunContinuousTestMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunContinuousTestMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TestError>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for RunContinuousTestMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Environments.ListContinuousTestResults][google.cloud.dialogflow.cx.v3.Environments.ListContinuousTestResults].
///
/// [google.cloud.dialogflow.cx.v3.Environments.ListContinuousTestResults]: crate::client::Environments::list_continuous_test_results
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListContinuousTestResultsRequest {
    /// Required. The environment to list results for.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>`.
    pub parent: std::string::String,

    /// The maximum number of items to return in a single page. By default 100 and
    /// at most 1000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl ListContinuousTestResultsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListContinuousTestResultsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListContinuousTestResultsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListContinuousTestResultsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for ListContinuousTestResultsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListContinuousTestResultsRequest"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListContinuousTestResultsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListContinuousTestResultsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListContinuousTestResultsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListContinuousTestResultsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for ListContinuousTestResultsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for [Environments.ListTestCaseResults][].
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListContinuousTestResultsResponse {
    /// The list of continuous test results.
    pub continuous_test_results: std::vec::Vec<crate::model::ContinuousTestResult>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl ListContinuousTestResultsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [continuous_test_results][crate::model::ListContinuousTestResultsResponse::continuous_test_results].
    pub fn set_continuous_test_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ContinuousTestResult>,
    {
        use std::iter::Iterator;
        self.continuous_test_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListContinuousTestResultsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for ListContinuousTestResultsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListContinuousTestResultsResponse"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListContinuousTestResultsResponse {
    type PageItem = crate::model::ContinuousTestResult;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.continuous_test_results
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListContinuousTestResultsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __continuous_test_results,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListContinuousTestResultsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "continuousTestResults" => Ok(__FieldTag::__continuous_test_results),
                            "continuous_test_results" => Ok(__FieldTag::__continuous_test_results),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListContinuousTestResultsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListContinuousTestResultsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__continuous_test_results => {
                            if !fields.insert(__FieldTag::__continuous_test_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for continuous_test_results",
                                ));
                            }
                            result.continuous_test_results = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ContinuousTestResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for ListContinuousTestResultsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.continuous_test_results.is_empty() {
            state.serialize_entry("continuousTestResults", &self.continuous_test_results)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Environments.DeployFlow][google.cloud.dialogflow.cx.v3.Environments.DeployFlow].
///
/// [google.cloud.dialogflow.cx.v3.Environments.DeployFlow]: crate::client::Environments::deploy_flow
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployFlowRequest {
    /// Required. The environment to deploy the flow to.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>`.
    pub environment: std::string::String,

    /// Required. The flow version to deploy.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/versions/<VersionID>`.
    pub flow_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl DeployFlowRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::DeployFlowRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [flow_version][crate::model::DeployFlowRequest::flow_version].
    pub fn set_flow_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.flow_version = v.into();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for DeployFlowRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DeployFlowRequest"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployFlowRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environment,
            __flow_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployFlowRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environment" => Ok(__FieldTag::__environment),
                            "flowVersion" => Ok(__FieldTag::__flow_version),
                            "flow_version" => Ok(__FieldTag::__flow_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployFlowRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployFlowRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__flow_version => {
                            if !fields.insert(__FieldTag::__flow_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flow_version",
                                ));
                            }
                            result.flow_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for DeployFlowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self.flow_version.is_empty() {
            state.serialize_entry("flowVersion", &self.flow_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Environments.DeployFlow][google.cloud.dialogflow.cx.v3.Environments.DeployFlow].
///
/// [google.cloud.dialogflow.cx.v3.Environments.DeployFlow]: crate::client::Environments::deploy_flow
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployFlowResponse {
    /// The updated environment where the flow is deployed.
    pub environment: std::option::Option<crate::model::Environment>,

    /// The name of the flow version
    /// [Deployment][google.cloud.dialogflow.cx.v3.Deployment]. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>/deployments/<DeploymentID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Deployment]: crate::model::Deployment
    pub deployment: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl DeployFlowResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::DeployFlowResponse::environment].
    pub fn set_environment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Environment>,
    {
        self.environment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [environment][crate::model::DeployFlowResponse::environment].
    pub fn set_or_clear_environment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Environment>,
    {
        self.environment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deployment][crate::model::DeployFlowResponse::deployment].
    pub fn set_deployment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.deployment = v.into();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for DeployFlowResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DeployFlowResponse"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployFlowResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environment,
            __deployment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployFlowResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environment" => Ok(__FieldTag::__environment),
                            "deployment" => Ok(__FieldTag::__deployment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployFlowResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployFlowResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment =
                                map.next_value::<std::option::Option<crate::model::Environment>>()?;
                        }
                        __FieldTag::__deployment => {
                            if !fields.insert(__FieldTag::__deployment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deployment",
                                ));
                            }
                            result.deployment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for DeployFlowResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.environment.is_some() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self.deployment.is_empty() {
            state.serialize_entry("deployment", &self.deployment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata returned for the
/// [Environments.DeployFlow][google.cloud.dialogflow.cx.v3.Environments.DeployFlow]
/// long running operation.
///
/// [google.cloud.dialogflow.cx.v3.Environments.DeployFlow]: crate::client::Environments::deploy_flow
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployFlowMetadata {
    /// Errors of running deployment tests.
    pub test_errors: std::vec::Vec<crate::model::TestError>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl DeployFlowMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [test_errors][crate::model::DeployFlowMetadata::test_errors].
    pub fn set_test_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TestError>,
    {
        use std::iter::Iterator;
        self.test_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for DeployFlowMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DeployFlowMetadata"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployFlowMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __test_errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployFlowMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "testErrors" => Ok(__FieldTag::__test_errors),
                            "test_errors" => Ok(__FieldTag::__test_errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployFlowMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployFlowMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__test_errors => {
                            if !fields.insert(__FieldTag::__test_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_errors",
                                ));
                            }
                            result.test_errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TestError>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for DeployFlowMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.test_errors.is_empty() {
            state.serialize_entry("testErrors", &self.test_errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents an experiment in an environment.
#[cfg(feature = "experiments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Experiment {
    /// The name of the experiment.
    /// Format:
    /// projects/\<ProjectID\>/locations/\<LocationID\>/agents/\<AgentID\>/environments/\<EnvironmentID\>/experiments/\<ExperimentID\>.
    pub name: std::string::String,

    /// Required. The human-readable name of the experiment (unique in an
    /// environment). Limit of 64 characters.
    pub display_name: std::string::String,

    /// The human-readable description of the experiment.
    pub description: std::string::String,

    /// The current state of the experiment.
    /// Transition triggered by Experiments.StartExperiment: DRAFT->RUNNING.
    /// Transition triggered by Experiments.CancelExperiment: DRAFT->DONE or
    /// RUNNING->DONE.
    pub state: crate::model::experiment::State,

    /// The definition of the experiment.
    pub definition: std::option::Option<crate::model::experiment::Definition>,

    /// The configuration for auto rollout. If set, there should be exactly two
    /// variants in the experiment (control variant being the default version of
    /// the flow), the traffic allocation for the non-control variant will
    /// gradually increase to 100% when conditions are met, and eventually
    /// replace the control variant to become the default version of the flow.
    pub rollout_config: std::option::Option<crate::model::RolloutConfig>,

    /// State of the auto rollout process.
    pub rollout_state: std::option::Option<crate::model::RolloutState>,

    /// The reason why rollout has failed. Should only be set when state is
    /// ROLLOUT_FAILED.
    pub rollout_failure_reason: std::string::String,

    /// Inference result of the experiment.
    pub result: std::option::Option<crate::model::experiment::Result>,

    /// Creation time of this experiment.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Start time of this experiment.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// End time of this experiment.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Last update time of this experiment.
    pub last_update_time: std::option::Option<wkt::Timestamp>,

    /// Maximum number of days to run the experiment/rollout. If auto-rollout is
    /// not enabled, default value and maximum will be 30 days. If auto-rollout is
    /// enabled, default value and maximum will be 6 days.
    pub experiment_length: std::option::Option<wkt::Duration>,

    /// The history of updates to the experiment variants.
    pub variants_history: std::vec::Vec<crate::model::VariantsHistory>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "experiments")]
impl Experiment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Experiment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Experiment::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Experiment::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Experiment::state].
    pub fn set_state<T: std::convert::Into<crate::model::experiment::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [definition][crate::model::Experiment::definition].
    pub fn set_definition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::experiment::Definition>,
    {
        self.definition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [definition][crate::model::Experiment::definition].
    pub fn set_or_clear_definition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::experiment::Definition>,
    {
        self.definition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rollout_config][crate::model::Experiment::rollout_config].
    pub fn set_rollout_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RolloutConfig>,
    {
        self.rollout_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollout_config][crate::model::Experiment::rollout_config].
    pub fn set_or_clear_rollout_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RolloutConfig>,
    {
        self.rollout_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rollout_state][crate::model::Experiment::rollout_state].
    pub fn set_rollout_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RolloutState>,
    {
        self.rollout_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollout_state][crate::model::Experiment::rollout_state].
    pub fn set_or_clear_rollout_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RolloutState>,
    {
        self.rollout_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rollout_failure_reason][crate::model::Experiment::rollout_failure_reason].
    pub fn set_rollout_failure_reason<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_failure_reason = v.into();
        self
    }

    /// Sets the value of [result][crate::model::Experiment::result].
    pub fn set_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::experiment::Result>,
    {
        self.result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [result][crate::model::Experiment::result].
    pub fn set_or_clear_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::experiment::Result>,
    {
        self.result = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::Experiment::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Experiment::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::Experiment::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Experiment::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::Experiment::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::Experiment::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_update_time][crate::model::Experiment::last_update_time].
    pub fn set_last_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_update_time][crate::model::Experiment::last_update_time].
    pub fn set_or_clear_last_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [experiment_length][crate::model::Experiment::experiment_length].
    pub fn set_experiment_length<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.experiment_length = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [experiment_length][crate::model::Experiment::experiment_length].
    pub fn set_or_clear_experiment_length<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.experiment_length = v.map(|x| x.into());
        self
    }

    /// Sets the value of [variants_history][crate::model::Experiment::variants_history].
    pub fn set_variants_history<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VariantsHistory>,
    {
        use std::iter::Iterator;
        self.variants_history = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "experiments")]
impl wkt::message::Message for Experiment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.Experiment"
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Experiment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __state,
            __definition,
            __rollout_config,
            __rollout_state,
            __rollout_failure_reason,
            __result,
            __create_time,
            __start_time,
            __end_time,
            __last_update_time,
            __experiment_length,
            __variants_history,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Experiment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "state" => Ok(__FieldTag::__state),
                            "definition" => Ok(__FieldTag::__definition),
                            "rolloutConfig" => Ok(__FieldTag::__rollout_config),
                            "rollout_config" => Ok(__FieldTag::__rollout_config),
                            "rolloutState" => Ok(__FieldTag::__rollout_state),
                            "rollout_state" => Ok(__FieldTag::__rollout_state),
                            "rolloutFailureReason" => Ok(__FieldTag::__rollout_failure_reason),
                            "rollout_failure_reason" => Ok(__FieldTag::__rollout_failure_reason),
                            "result" => Ok(__FieldTag::__result),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "lastUpdateTime" => Ok(__FieldTag::__last_update_time),
                            "last_update_time" => Ok(__FieldTag::__last_update_time),
                            "experimentLength" => Ok(__FieldTag::__experiment_length),
                            "experiment_length" => Ok(__FieldTag::__experiment_length),
                            "variantsHistory" => Ok(__FieldTag::__variants_history),
                            "variants_history" => Ok(__FieldTag::__variants_history),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Experiment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Experiment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::experiment::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__definition => {
                            if !fields.insert(__FieldTag::__definition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for definition",
                                ));
                            }
                            result.definition = map.next_value::<std::option::Option<crate::model::experiment::Definition>>()?
                                ;
                        }
                        __FieldTag::__rollout_config => {
                            if !fields.insert(__FieldTag::__rollout_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_config",
                                ));
                            }
                            result.rollout_config = map
                                .next_value::<std::option::Option<crate::model::RolloutConfig>>()?;
                        }
                        __FieldTag::__rollout_state => {
                            if !fields.insert(__FieldTag::__rollout_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_state",
                                ));
                            }
                            result.rollout_state = map
                                .next_value::<std::option::Option<crate::model::RolloutState>>()?;
                        }
                        __FieldTag::__rollout_failure_reason => {
                            if !fields.insert(__FieldTag::__rollout_failure_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_failure_reason",
                                ));
                            }
                            result.rollout_failure_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__result => {
                            if !fields.insert(__FieldTag::__result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result",
                                ));
                            }
                            result.result = map.next_value::<std::option::Option<crate::model::experiment::Result>>()?
                                ;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_update_time => {
                            if !fields.insert(__FieldTag::__last_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_update_time",
                                ));
                            }
                            result.last_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__experiment_length => {
                            if !fields.insert(__FieldTag::__experiment_length) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for experiment_length",
                                ));
                            }
                            result.experiment_length =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__variants_history => {
                            if !fields.insert(__FieldTag::__variants_history) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for variants_history",
                                ));
                            }
                            result.variants_history =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VariantsHistory>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for Experiment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.definition.is_some() {
            state.serialize_entry("definition", &self.definition)?;
        }
        if self.rollout_config.is_some() {
            state.serialize_entry("rolloutConfig", &self.rollout_config)?;
        }
        if self.rollout_state.is_some() {
            state.serialize_entry("rolloutState", &self.rollout_state)?;
        }
        if !self.rollout_failure_reason.is_empty() {
            state.serialize_entry("rolloutFailureReason", &self.rollout_failure_reason)?;
        }
        if self.result.is_some() {
            state.serialize_entry("result", &self.result)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.last_update_time.is_some() {
            state.serialize_entry("lastUpdateTime", &self.last_update_time)?;
        }
        if self.experiment_length.is_some() {
            state.serialize_entry("experimentLength", &self.experiment_length)?;
        }
        if !self.variants_history.is_empty() {
            state.serialize_entry("variantsHistory", &self.variants_history)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Experiment].
#[cfg(feature = "experiments")]
pub mod experiment {
    #[allow(unused_imports)]
    use super::*;

    /// Definition of the experiment.
    #[cfg(feature = "experiments")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Definition {
        /// The condition defines which subset of sessions are selected for
        /// this experiment. If not specified, all sessions are eligible. E.g.
        /// "query_input.language_code=en" See the [conditions
        /// reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
        pub condition: std::string::String,

        /// The variants of the experiment. We currently only support single variant
        /// experiment.
        pub variants: std::option::Option<crate::model::experiment::definition::Variants>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "experiments")]
    impl Definition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [condition][crate::model::experiment::Definition::condition].
        pub fn set_condition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.condition = v.into();
            self
        }

        /// Sets the value of [variants][crate::model::experiment::Definition::variants].
        ///
        /// Note that all the setters affecting `variants` are mutually
        /// exclusive.
        pub fn set_variants<
            T: std::convert::Into<std::option::Option<crate::model::experiment::definition::Variants>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.variants = v.into();
            self
        }

        /// The value of [variants][crate::model::experiment::Definition::variants]
        /// if it holds a `VersionVariants`, `None` if the field is not set or
        /// holds a different branch.
        pub fn version_variants(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::VersionVariants>> {
            #[allow(unreachable_patterns)]
            self.variants.as_ref().and_then(|v| match v {
                crate::model::experiment::definition::Variants::VersionVariants(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [variants][crate::model::experiment::Definition::variants]
        /// to hold a `VersionVariants`.
        ///
        /// Note that all the setters affecting `variants` are
        /// mutually exclusive.
        pub fn set_version_variants<
            T: std::convert::Into<std::boxed::Box<crate::model::VersionVariants>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.variants = std::option::Option::Some(
                crate::model::experiment::definition::Variants::VersionVariants(v.into()),
            );
            self
        }
    }

    #[cfg(feature = "experiments")]
    impl wkt::message::Message for Definition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Experiment.Definition"
        }
    }

    #[cfg(feature = "experiments")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Definition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __condition,
                __version_variants,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Definition")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "condition" => Ok(__FieldTag::__condition),
                                "versionVariants" => Ok(__FieldTag::__version_variants),
                                "version_variants" => Ok(__FieldTag::__version_variants),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Definition;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Definition")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__condition => {
                                if !fields.insert(__FieldTag::__condition) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for condition",
                                    ));
                                }
                                result.condition = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__version_variants => {
                                if !fields.insert(__FieldTag::__version_variants) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for version_variants",
                                    ));
                                }
                                if result.variants.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `variants`, a oneof with full ID .google.cloud.dialogflow.cx.v3.Experiment.Definition.version_variants, latest field was versionVariants",
                                    ));
                                }
                                result.variants = std::option::Option::Some(
                                    crate::model::experiment::definition::Variants::VersionVariants(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::VersionVariants>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "experiments")]
    #[doc(hidden)]
    impl serde::ser::Serialize for Definition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.condition.is_empty() {
                state.serialize_entry("condition", &self.condition)?;
            }
            if let Some(value) = self.version_variants() {
                state.serialize_entry("versionVariants", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Definition].
    #[cfg(feature = "experiments")]
    pub mod definition {
        #[allow(unused_imports)]
        use super::*;

        /// The variants of the experiment. We currently only support single variant
        /// experiment.
        #[cfg(feature = "experiments")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Variants {
            /// The flow versions as the variants of this experiment.
            VersionVariants(std::boxed::Box<crate::model::VersionVariants>),
        }
    }

    /// The inference result which includes an objective metric to optimize and the
    /// confidence interval.
    #[cfg(feature = "experiments")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Result {
        /// Version variants and metrics.
        pub version_metrics: std::vec::Vec<crate::model::experiment::result::VersionMetrics>,

        /// The last time the experiment's stats data was updated. Will have default
        /// value if stats have never been computed for this experiment.
        pub last_update_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "experiments")]
    impl Result {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [version_metrics][crate::model::experiment::Result::version_metrics].
        pub fn set_version_metrics<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::experiment::result::VersionMetrics>,
        {
            use std::iter::Iterator;
            self.version_metrics = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [last_update_time][crate::model::experiment::Result::last_update_time].
        pub fn set_last_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [last_update_time][crate::model::experiment::Result::last_update_time].
        pub fn set_or_clear_last_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.last_update_time = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "experiments")]
    impl wkt::message::Message for Result {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Experiment.Result"
        }
    }

    #[cfg(feature = "experiments")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Result {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __version_metrics,
                __last_update_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Result")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "versionMetrics" => Ok(__FieldTag::__version_metrics),
                                "version_metrics" => Ok(__FieldTag::__version_metrics),
                                "lastUpdateTime" => Ok(__FieldTag::__last_update_time),
                                "last_update_time" => Ok(__FieldTag::__last_update_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Result;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Result")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__version_metrics => {
                                if !fields.insert(__FieldTag::__version_metrics) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for version_metrics",
                                    ));
                                }
                                result.version_metrics = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::experiment::result::VersionMetrics,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__last_update_time => {
                                if !fields.insert(__FieldTag::__last_update_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for last_update_time",
                                    ));
                                }
                                result.last_update_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "experiments")]
    #[doc(hidden)]
    impl serde::ser::Serialize for Result {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.version_metrics.is_empty() {
                state.serialize_entry("versionMetrics", &self.version_metrics)?;
            }
            if self.last_update_time.is_some() {
                state.serialize_entry("lastUpdateTime", &self.last_update_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Result].
    #[cfg(feature = "experiments")]
    pub mod result {
        #[allow(unused_imports)]
        use super::*;

        /// A confidence interval is a range of possible values for the experiment
        /// objective you are trying to measure.
        #[cfg(feature = "experiments")]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ConfidenceInterval {
            /// The confidence level used to construct the interval, i.e. there is X%
            /// chance that the true value is within this interval.
            pub confidence_level: f64,

            /// The percent change between an experiment metric's value and the value
            /// for its control.
            pub ratio: f64,

            /// Lower bound of the interval.
            pub lower_bound: f64,

            /// Upper bound of the interval.
            pub upper_bound: f64,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "experiments")]
        impl ConfidenceInterval {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [confidence_level][crate::model::experiment::result::ConfidenceInterval::confidence_level].
            pub fn set_confidence_level<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.confidence_level = v.into();
                self
            }

            /// Sets the value of [ratio][crate::model::experiment::result::ConfidenceInterval::ratio].
            pub fn set_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.ratio = v.into();
                self
            }

            /// Sets the value of [lower_bound][crate::model::experiment::result::ConfidenceInterval::lower_bound].
            pub fn set_lower_bound<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.lower_bound = v.into();
                self
            }

            /// Sets the value of [upper_bound][crate::model::experiment::result::ConfidenceInterval::upper_bound].
            pub fn set_upper_bound<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.upper_bound = v.into();
                self
            }
        }

        #[cfg(feature = "experiments")]
        impl wkt::message::Message for ConfidenceInterval {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.cx.v3.Experiment.Result.ConfidenceInterval"
            }
        }

        #[cfg(feature = "experiments")]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ConfidenceInterval {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __confidence_level,
                    __ratio,
                    __lower_bound,
                    __upper_bound,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ConfidenceInterval")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "confidenceLevel" => Ok(__FieldTag::__confidence_level),
                                    "confidence_level" => Ok(__FieldTag::__confidence_level),
                                    "ratio" => Ok(__FieldTag::__ratio),
                                    "lowerBound" => Ok(__FieldTag::__lower_bound),
                                    "lower_bound" => Ok(__FieldTag::__lower_bound),
                                    "upperBound" => Ok(__FieldTag::__upper_bound),
                                    "upper_bound" => Ok(__FieldTag::__upper_bound),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ConfidenceInterval;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ConfidenceInterval")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__confidence_level => {
                                    if !fields.insert(__FieldTag::__confidence_level) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for confidence_level",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.confidence_level =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__ratio => {
                                    if !fields.insert(__FieldTag::__ratio) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for ratio"),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.ratio =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__lower_bound => {
                                    if !fields.insert(__FieldTag::__lower_bound) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for lower_bound",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.lower_bound =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__upper_bound => {
                                    if !fields.insert(__FieldTag::__upper_bound) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for upper_bound",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.upper_bound =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(feature = "experiments")]
        #[doc(hidden)]
        impl serde::ser::Serialize for ConfidenceInterval {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.confidence_level) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("confidenceLevel", &__With(&self.confidence_level))?;
                }
                if !wkt::internal::is_default(&self.ratio) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("ratio", &__With(&self.ratio))?;
                }
                if !wkt::internal::is_default(&self.lower_bound) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("lowerBound", &__With(&self.lower_bound))?;
                }
                if !wkt::internal::is_default(&self.upper_bound) {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("upperBound", &__With(&self.upper_bound))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Metric and corresponding confidence intervals.
        #[cfg(feature = "experiments")]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Metric {
            /// Ratio-based metric type. Only one of type or count_type is specified in
            /// each Metric.
            pub r#type: crate::model::experiment::result::MetricType,

            /// Count-based metric type. Only one of type or count_type is specified in
            /// each Metric.
            pub count_type: crate::model::experiment::result::CountType,

            /// The probability that the treatment is better than all other treatments
            /// in the experiment
            pub confidence_interval:
                std::option::Option<crate::model::experiment::result::ConfidenceInterval>,

            /// The actual value of the metric.
            pub value: std::option::Option<crate::model::experiment::result::metric::Value>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "experiments")]
        impl Metric {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [r#type][crate::model::experiment::result::Metric::type].
            pub fn set_type<T: std::convert::Into<crate::model::experiment::result::MetricType>>(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = v.into();
                self
            }

            /// Sets the value of [count_type][crate::model::experiment::result::Metric::count_type].
            pub fn set_count_type<
                T: std::convert::Into<crate::model::experiment::result::CountType>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.count_type = v.into();
                self
            }

            /// Sets the value of [confidence_interval][crate::model::experiment::result::Metric::confidence_interval].
            pub fn set_confidence_interval<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::experiment::result::ConfidenceInterval>,
            {
                self.confidence_interval = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [confidence_interval][crate::model::experiment::result::Metric::confidence_interval].
            pub fn set_or_clear_confidence_interval<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::experiment::result::ConfidenceInterval>,
            {
                self.confidence_interval = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::experiment::result::Metric::value].
            ///
            /// Note that all the setters affecting `value` are mutually
            /// exclusive.
            pub fn set_value<
                T: std::convert::Into<
                        std::option::Option<crate::model::experiment::result::metric::Value>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.value = v.into();
                self
            }

            /// The value of [value][crate::model::experiment::result::Metric::value]
            /// if it holds a `Ratio`, `None` if the field is not set or
            /// holds a different branch.
            pub fn ratio(&self) -> std::option::Option<&f64> {
                #[allow(unreachable_patterns)]
                self.value.as_ref().and_then(|v| match v {
                    crate::model::experiment::result::metric::Value::Ratio(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [value][crate::model::experiment::result::Metric::value]
            /// to hold a `Ratio`.
            ///
            /// Note that all the setters affecting `value` are
            /// mutually exclusive.
            pub fn set_ratio<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.value = std::option::Option::Some(
                    crate::model::experiment::result::metric::Value::Ratio(v.into()),
                );
                self
            }

            /// The value of [value][crate::model::experiment::result::Metric::value]
            /// if it holds a `Count`, `None` if the field is not set or
            /// holds a different branch.
            pub fn count(&self) -> std::option::Option<&f64> {
                #[allow(unreachable_patterns)]
                self.value.as_ref().and_then(|v| match v {
                    crate::model::experiment::result::metric::Value::Count(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [value][crate::model::experiment::result::Metric::value]
            /// to hold a `Count`.
            ///
            /// Note that all the setters affecting `value` are
            /// mutually exclusive.
            pub fn set_count<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
                self.value = std::option::Option::Some(
                    crate::model::experiment::result::metric::Value::Count(v.into()),
                );
                self
            }
        }

        #[cfg(feature = "experiments")]
        impl wkt::message::Message for Metric {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.cx.v3.Experiment.Result.Metric"
            }
        }

        #[cfg(feature = "experiments")]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Metric {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __type,
                    __count_type,
                    __ratio,
                    __count,
                    __confidence_interval,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Metric")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "type" => Ok(__FieldTag::__type),
                                    "countType" => Ok(__FieldTag::__count_type),
                                    "count_type" => Ok(__FieldTag::__count_type),
                                    "ratio" => Ok(__FieldTag::__ratio),
                                    "count" => Ok(__FieldTag::__count),
                                    "confidenceInterval" => Ok(__FieldTag::__confidence_interval),
                                    "confidence_interval" => Ok(__FieldTag::__confidence_interval),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Metric;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Metric")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__type => {
                                    if !fields.insert(__FieldTag::__type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for type"),
                                        );
                                    }
                                    result.r#type = map
                                        .next_value::<std::option::Option<
                                            crate::model::experiment::result::MetricType,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__count_type => {
                                    if !fields.insert(__FieldTag::__count_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for count_type",
                                            ),
                                        );
                                    }
                                    result.count_type = map
                                        .next_value::<std::option::Option<
                                            crate::model::experiment::result::CountType,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__ratio => {
                                    if !fields.insert(__FieldTag::__ratio) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for ratio"),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    if result.value.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `value`, a oneof with full ID .google.cloud.dialogflow.cx.v3.Experiment.Result.Metric.ratio, latest field was ratio",
                                            ),
                                        );
                                    }
                                    result.value = std::option::Option::Some(
                                        crate::model::experiment::result::metric::Value::Ratio(
                                            map.next_value::<__With>()?.0.unwrap_or_default(),
                                        ),
                                    );
                                }
                                __FieldTag::__count => {
                                    if !fields.insert(__FieldTag::__count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for count"),
                                        );
                                    }
                                    struct __With(std::option::Option<f64>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    if result.value.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `value`, a oneof with full ID .google.cloud.dialogflow.cx.v3.Experiment.Result.Metric.count, latest field was count",
                                            ),
                                        );
                                    }
                                    result.value = std::option::Option::Some(
                                        crate::model::experiment::result::metric::Value::Count(
                                            map.next_value::<__With>()?.0.unwrap_or_default(),
                                        ),
                                    );
                                }
                                __FieldTag::__confidence_interval => {
                                    if !fields.insert(__FieldTag::__confidence_interval) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for confidence_interval",
                                            ),
                                        );
                                    }
                                    result.confidence_interval = map
                                        .next_value::<std::option::Option<
                                            crate::model::experiment::result::ConfidenceInterval,
                                        >>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(feature = "experiments")]
        #[doc(hidden)]
        impl serde::ser::Serialize for Metric {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.r#type) {
                    state.serialize_entry("type", &self.r#type)?;
                }
                if !wkt::internal::is_default(&self.count_type) {
                    state.serialize_entry("countType", &self.count_type)?;
                }
                if let Some(value) = self.ratio() {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("ratio", &__With(value))?;
                }
                if let Some(value) = self.count() {
                    struct __With<'a>(&'a f64);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("count", &__With(value))?;
                }
                if self.confidence_interval.is_some() {
                    state.serialize_entry("confidenceInterval", &self.confidence_interval)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [Metric].
        #[cfg(feature = "experiments")]
        pub mod metric {
            #[allow(unused_imports)]
            use super::*;

            /// The actual value of the metric.
            #[cfg(feature = "experiments")]
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Value {
                /// Ratio value of a metric.
                Ratio(f64),
                /// Count value of a metric.
                Count(f64),
            }
        }

        /// Version variant and associated metrics.
        #[cfg(feature = "experiments")]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct VersionMetrics {
            /// The name of the flow [Version][google.cloud.dialogflow.cx.v3.Version].
            /// Format:
            /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/versions/<VersionID>`.
            ///
            /// [google.cloud.dialogflow.cx.v3.Version]: crate::model::Version
            pub version: std::string::String,

            /// The metrics and corresponding confidence intervals in the inference
            /// result.
            pub metrics: std::vec::Vec<crate::model::experiment::result::Metric>,

            /// Number of sessions that were allocated to this version.
            pub session_count: i32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "experiments")]
        impl VersionMetrics {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [version][crate::model::experiment::result::VersionMetrics::version].
            pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.version = v.into();
                self
            }

            /// Sets the value of [metrics][crate::model::experiment::result::VersionMetrics::metrics].
            pub fn set_metrics<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::experiment::result::Metric>,
            {
                use std::iter::Iterator;
                self.metrics = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [session_count][crate::model::experiment::result::VersionMetrics::session_count].
            pub fn set_session_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.session_count = v.into();
                self
            }
        }

        #[cfg(feature = "experiments")]
        impl wkt::message::Message for VersionMetrics {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.cx.v3.Experiment.Result.VersionMetrics"
            }
        }

        #[cfg(feature = "experiments")]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for VersionMetrics {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __version,
                    __metrics,
                    __session_count,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for VersionMetrics")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "version" => Ok(__FieldTag::__version),
                                    "metrics" => Ok(__FieldTag::__metrics),
                                    "sessionCount" => Ok(__FieldTag::__session_count),
                                    "session_count" => Ok(__FieldTag::__session_count),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = VersionMetrics;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct VersionMetrics")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__version => {
                                    if !fields.insert(__FieldTag::__version) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for version",
                                            ),
                                        );
                                    }
                                    result.version = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__metrics => {
                                    if !fields.insert(__FieldTag::__metrics) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for metrics",
                                            ),
                                        );
                                    }
                                    result.metrics = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<crate::model::experiment::result::Metric>,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__session_count => {
                                    if !fields.insert(__FieldTag::__session_count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for session_count",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.session_count =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(feature = "experiments")]
        #[doc(hidden)]
        impl serde::ser::Serialize for VersionMetrics {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.version.is_empty() {
                    state.serialize_entry("version", &self.version)?;
                }
                if !self.metrics.is_empty() {
                    state.serialize_entry("metrics", &self.metrics)?;
                }
                if !wkt::internal::is_default(&self.session_count) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("sessionCount", &__With(&self.session_count))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Types of ratio-based metric for Dialogflow experiment.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "experiments")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum MetricType {
            /// Metric unspecified.
            MetricUnspecified,
            /// Percentage of contained sessions without user calling back in 24 hours.
            ContainedSessionNoCallbackRate,
            /// Percentage of sessions that were handed to a human agent.
            LiveAgentHandoffRate,
            /// Percentage of sessions with the same user calling back.
            CallbackSessionRate,
            /// Percentage of sessions where user hung up.
            AbandonedSessionRate,
            /// Percentage of sessions reached Dialogflow 'END_PAGE' or
            /// 'END_SESSION'.
            SessionEndRate,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [MetricType::value] or
            /// [MetricType::name].
            UnknownValue(metric_type::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "experiments")]
        pub mod metric_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "experiments")]
        impl MetricType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::MetricUnspecified => std::option::Option::Some(0),
                    Self::ContainedSessionNoCallbackRate => std::option::Option::Some(1),
                    Self::LiveAgentHandoffRate => std::option::Option::Some(2),
                    Self::CallbackSessionRate => std::option::Option::Some(3),
                    Self::AbandonedSessionRate => std::option::Option::Some(4),
                    Self::SessionEndRate => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::MetricUnspecified => std::option::Option::Some("METRIC_UNSPECIFIED"),
                    Self::ContainedSessionNoCallbackRate => {
                        std::option::Option::Some("CONTAINED_SESSION_NO_CALLBACK_RATE")
                    }
                    Self::LiveAgentHandoffRate => {
                        std::option::Option::Some("LIVE_AGENT_HANDOFF_RATE")
                    }
                    Self::CallbackSessionRate => std::option::Option::Some("CALLBACK_SESSION_RATE"),
                    Self::AbandonedSessionRate => {
                        std::option::Option::Some("ABANDONED_SESSION_RATE")
                    }
                    Self::SessionEndRate => std::option::Option::Some("SESSION_END_RATE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "experiments")]
        impl std::default::Default for MetricType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "experiments")]
        impl std::fmt::Display for MetricType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "experiments")]
        impl std::convert::From<i32> for MetricType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::MetricUnspecified,
                    1 => Self::ContainedSessionNoCallbackRate,
                    2 => Self::LiveAgentHandoffRate,
                    3 => Self::CallbackSessionRate,
                    4 => Self::AbandonedSessionRate,
                    5 => Self::SessionEndRate,
                    _ => Self::UnknownValue(metric_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "experiments")]
        impl std::convert::From<&str> for MetricType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "METRIC_UNSPECIFIED" => Self::MetricUnspecified,
                    "CONTAINED_SESSION_NO_CALLBACK_RATE" => Self::ContainedSessionNoCallbackRate,
                    "LIVE_AGENT_HANDOFF_RATE" => Self::LiveAgentHandoffRate,
                    "CALLBACK_SESSION_RATE" => Self::CallbackSessionRate,
                    "ABANDONED_SESSION_RATE" => Self::AbandonedSessionRate,
                    "SESSION_END_RATE" => Self::SessionEndRate,
                    _ => Self::UnknownValue(metric_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "experiments")]
        impl serde::ser::Serialize for MetricType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::MetricUnspecified => serializer.serialize_i32(0),
                    Self::ContainedSessionNoCallbackRate => serializer.serialize_i32(1),
                    Self::LiveAgentHandoffRate => serializer.serialize_i32(2),
                    Self::CallbackSessionRate => serializer.serialize_i32(3),
                    Self::AbandonedSessionRate => serializer.serialize_i32(4),
                    Self::SessionEndRate => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "experiments")]
        impl<'de> serde::de::Deserialize<'de> for MetricType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<MetricType>::new(
                    ".google.cloud.dialogflow.cx.v3.Experiment.Result.MetricType",
                ))
            }
        }

        /// Types of count-based metric for Dialogflow experiment.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "experiments")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum CountType {
            /// Count type unspecified.
            Unspecified,
            /// Total number of occurrences of a 'NO_MATCH'.
            TotalNoMatchCount,
            /// Total number of turn counts.
            TotalTurnCount,
            /// Average turn count in a session.
            AverageTurnCount,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [CountType::value] or
            /// [CountType::name].
            UnknownValue(count_type::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "experiments")]
        pub mod count_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "experiments")]
        impl CountType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::TotalNoMatchCount => std::option::Option::Some(1),
                    Self::TotalTurnCount => std::option::Option::Some(2),
                    Self::AverageTurnCount => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("COUNT_TYPE_UNSPECIFIED"),
                    Self::TotalNoMatchCount => std::option::Option::Some("TOTAL_NO_MATCH_COUNT"),
                    Self::TotalTurnCount => std::option::Option::Some("TOTAL_TURN_COUNT"),
                    Self::AverageTurnCount => std::option::Option::Some("AVERAGE_TURN_COUNT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "experiments")]
        impl std::default::Default for CountType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "experiments")]
        impl std::fmt::Display for CountType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "experiments")]
        impl std::convert::From<i32> for CountType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::TotalNoMatchCount,
                    2 => Self::TotalTurnCount,
                    3 => Self::AverageTurnCount,
                    _ => Self::UnknownValue(count_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "experiments")]
        impl std::convert::From<&str> for CountType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "COUNT_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "TOTAL_NO_MATCH_COUNT" => Self::TotalNoMatchCount,
                    "TOTAL_TURN_COUNT" => Self::TotalTurnCount,
                    "AVERAGE_TURN_COUNT" => Self::AverageTurnCount,
                    _ => Self::UnknownValue(count_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "experiments")]
        impl serde::ser::Serialize for CountType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::TotalNoMatchCount => serializer.serialize_i32(1),
                    Self::TotalTurnCount => serializer.serialize_i32(2),
                    Self::AverageTurnCount => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "experiments")]
        impl<'de> serde::de::Deserialize<'de> for CountType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<CountType>::new(
                    ".google.cloud.dialogflow.cx.v3.Experiment.Result.CountType",
                ))
            }
        }
    }

    /// The state of the experiment.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "experiments")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State unspecified.
        Unspecified,
        /// The experiment is created but not started yet.
        Draft,
        /// The experiment is running.
        Running,
        /// The experiment is done.
        Done,
        /// The experiment with auto-rollout enabled has failed.
        RolloutFailed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "experiments")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "experiments")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Draft => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Done => std::option::Option::Some(3),
                Self::RolloutFailed => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Draft => std::option::Option::Some("DRAFT"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::RolloutFailed => std::option::Option::Some("ROLLOUT_FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "experiments")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "experiments")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "experiments")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Draft,
                2 => Self::Running,
                3 => Self::Done,
                4 => Self::RolloutFailed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "experiments")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "DRAFT" => Self::Draft,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                "ROLLOUT_FAILED" => Self::RolloutFailed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "experiments")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Draft => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Done => serializer.serialize_i32(3),
                Self::RolloutFailed => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "experiments")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dialogflow.cx.v3.Experiment.State",
            ))
        }
    }
}

/// A list of flow version variants.
#[cfg(feature = "experiments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VersionVariants {
    /// A list of flow version variants.
    pub variants: std::vec::Vec<crate::model::version_variants::Variant>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "experiments")]
impl VersionVariants {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [variants][crate::model::VersionVariants::variants].
    pub fn set_variants<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::version_variants::Variant>,
    {
        use std::iter::Iterator;
        self.variants = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "experiments")]
impl wkt::message::Message for VersionVariants {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.VersionVariants"
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VersionVariants {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __variants,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VersionVariants")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "variants" => Ok(__FieldTag::__variants),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VersionVariants;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VersionVariants")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__variants => {
                            if !fields.insert(__FieldTag::__variants) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for variants",
                                ));
                            }
                            result.variants = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::version_variants::Variant>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for VersionVariants {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.variants.is_empty() {
            state.serialize_entry("variants", &self.variants)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VersionVariants].
#[cfg(feature = "experiments")]
pub mod version_variants {
    #[allow(unused_imports)]
    use super::*;

    /// A single flow version with specified traffic allocation.
    #[cfg(feature = "experiments")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Variant {
        /// The name of the flow version.
        /// Format:
        /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/versions/<VersionID>`.
        pub version: std::string::String,

        /// Percentage of the traffic which should be routed to this
        /// version of flow. Traffic allocation for a single flow must sum up to 1.0.
        pub traffic_allocation: f32,

        /// Whether the variant is for the control group.
        pub is_control_group: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "experiments")]
    impl Variant {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [version][crate::model::version_variants::Variant::version].
        pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.version = v.into();
            self
        }

        /// Sets the value of [traffic_allocation][crate::model::version_variants::Variant::traffic_allocation].
        pub fn set_traffic_allocation<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.traffic_allocation = v.into();
            self
        }

        /// Sets the value of [is_control_group][crate::model::version_variants::Variant::is_control_group].
        pub fn set_is_control_group<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.is_control_group = v.into();
            self
        }
    }

    #[cfg(feature = "experiments")]
    impl wkt::message::Message for Variant {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.VersionVariants.Variant"
        }
    }

    #[cfg(feature = "experiments")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Variant {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __version,
                __traffic_allocation,
                __is_control_group,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Variant")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "version" => Ok(__FieldTag::__version),
                                "trafficAllocation" => Ok(__FieldTag::__traffic_allocation),
                                "traffic_allocation" => Ok(__FieldTag::__traffic_allocation),
                                "isControlGroup" => Ok(__FieldTag::__is_control_group),
                                "is_control_group" => Ok(__FieldTag::__is_control_group),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Variant;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Variant")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__version => {
                                if !fields.insert(__FieldTag::__version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for version",
                                    ));
                                }
                                result.version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__traffic_allocation => {
                                if !fields.insert(__FieldTag::__traffic_allocation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for traffic_allocation",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.traffic_allocation =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__is_control_group => {
                                if !fields.insert(__FieldTag::__is_control_group) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for is_control_group",
                                    ));
                                }
                                result.is_control_group = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "experiments")]
    #[doc(hidden)]
    impl serde::ser::Serialize for Variant {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.version.is_empty() {
                state.serialize_entry("version", &self.version)?;
            }
            if !wkt::internal::is_default(&self.traffic_allocation) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("trafficAllocation", &__With(&self.traffic_allocation))?;
            }
            if !wkt::internal::is_default(&self.is_control_group) {
                state.serialize_entry("isControlGroup", &self.is_control_group)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// The history of variants update.
#[cfg(feature = "experiments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VariantsHistory {
    /// Update time of the variants.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The variants updated. We currently only support single variant
    /// experiment.
    pub variants: std::option::Option<crate::model::variants_history::Variants>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "experiments")]
impl VariantsHistory {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_time][crate::model::VariantsHistory::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::VariantsHistory::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [variants][crate::model::VariantsHistory::variants].
    ///
    /// Note that all the setters affecting `variants` are mutually
    /// exclusive.
    pub fn set_variants<
        T: std::convert::Into<std::option::Option<crate::model::variants_history::Variants>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.variants = v.into();
        self
    }

    /// The value of [variants][crate::model::VariantsHistory::variants]
    /// if it holds a `VersionVariants`, `None` if the field is not set or
    /// holds a different branch.
    pub fn version_variants(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VersionVariants>> {
        #[allow(unreachable_patterns)]
        self.variants.as_ref().and_then(|v| match v {
            crate::model::variants_history::Variants::VersionVariants(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [variants][crate::model::VariantsHistory::variants]
    /// to hold a `VersionVariants`.
    ///
    /// Note that all the setters affecting `variants` are
    /// mutually exclusive.
    pub fn set_version_variants<
        T: std::convert::Into<std::boxed::Box<crate::model::VersionVariants>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.variants = std::option::Option::Some(
            crate::model::variants_history::Variants::VersionVariants(v.into()),
        );
        self
    }
}

#[cfg(feature = "experiments")]
impl wkt::message::Message for VariantsHistory {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.VariantsHistory"
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VariantsHistory {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version_variants,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VariantsHistory")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "versionVariants" => Ok(__FieldTag::__version_variants),
                            "version_variants" => Ok(__FieldTag::__version_variants),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VariantsHistory;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VariantsHistory")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version_variants => {
                            if !fields.insert(__FieldTag::__version_variants) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_variants",
                                ));
                            }
                            if result.variants.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `variants`, a oneof with full ID .google.cloud.dialogflow.cx.v3.VariantsHistory.version_variants, latest field was versionVariants",
                                ));
                            }
                            result.variants = std::option::Option::Some(
                                crate::model::variants_history::Variants::VersionVariants(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VersionVariants>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for VariantsHistory {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.version_variants() {
            state.serialize_entry("versionVariants", value)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VariantsHistory].
#[cfg(feature = "experiments")]
pub mod variants_history {
    #[allow(unused_imports)]
    use super::*;

    /// The variants updated. We currently only support single variant
    /// experiment.
    #[cfg(feature = "experiments")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Variants {
        /// The flow versions as the variants.
        VersionVariants(std::boxed::Box<crate::model::VersionVariants>),
    }
}

/// The configuration for auto rollout.
#[cfg(feature = "experiments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RolloutConfig {
    /// Steps to roll out a flow version. Steps should be sorted by percentage in
    /// ascending order.
    pub rollout_steps: std::vec::Vec<crate::model::rollout_config::RolloutStep>,

    /// The conditions that are used to evaluate the success of a rollout
    /// step. If not specified, all rollout steps will proceed to the next one
    /// unless failure conditions are met. E.g. "containment_rate > 60% AND
    /// callback_rate < 20%". See the [conditions
    /// reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
    pub rollout_condition: std::string::String,

    /// The conditions that are used to evaluate the failure of a rollout
    /// step. If not specified, no rollout steps will fail. E.g. "containment_rate
    /// < 10% OR average_turn_count < 3". See the [conditions
    /// reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
    pub failure_condition: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "experiments")]
impl RolloutConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollout_steps][crate::model::RolloutConfig::rollout_steps].
    pub fn set_rollout_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::rollout_config::RolloutStep>,
    {
        use std::iter::Iterator;
        self.rollout_steps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rollout_condition][crate::model::RolloutConfig::rollout_condition].
    pub fn set_rollout_condition<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_condition = v.into();
        self
    }

    /// Sets the value of [failure_condition][crate::model::RolloutConfig::failure_condition].
    pub fn set_failure_condition<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.failure_condition = v.into();
        self
    }
}

#[cfg(feature = "experiments")]
impl wkt::message::Message for RolloutConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.RolloutConfig"
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RolloutConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rollout_steps,
            __rollout_condition,
            __failure_condition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RolloutConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rolloutSteps" => Ok(__FieldTag::__rollout_steps),
                            "rollout_steps" => Ok(__FieldTag::__rollout_steps),
                            "rolloutCondition" => Ok(__FieldTag::__rollout_condition),
                            "rollout_condition" => Ok(__FieldTag::__rollout_condition),
                            "failureCondition" => Ok(__FieldTag::__failure_condition),
                            "failure_condition" => Ok(__FieldTag::__failure_condition),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RolloutConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RolloutConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rollout_steps => {
                            if !fields.insert(__FieldTag::__rollout_steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_steps",
                                ));
                            }
                            result.rollout_steps = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::rollout_config::RolloutStep>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout_condition => {
                            if !fields.insert(__FieldTag::__rollout_condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_condition",
                                ));
                            }
                            result.rollout_condition = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__failure_condition => {
                            if !fields.insert(__FieldTag::__failure_condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_condition",
                                ));
                            }
                            result.failure_condition = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for RolloutConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rollout_steps.is_empty() {
            state.serialize_entry("rolloutSteps", &self.rollout_steps)?;
        }
        if !self.rollout_condition.is_empty() {
            state.serialize_entry("rolloutCondition", &self.rollout_condition)?;
        }
        if !self.failure_condition.is_empty() {
            state.serialize_entry("failureCondition", &self.failure_condition)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RolloutConfig].
#[cfg(feature = "experiments")]
pub mod rollout_config {
    #[allow(unused_imports)]
    use super::*;

    /// A single rollout step with specified traffic allocation.
    #[cfg(feature = "experiments")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RolloutStep {
        /// The name of the rollout step;
        pub display_name: std::string::String,

        /// The percentage of traffic allocated to the flow version of this rollout
        /// step. (0%, 100%].
        pub traffic_percent: i32,

        /// The minimum time that this step should last. Should be longer than 1
        /// hour. If not set, the default minimum duration for each step will be 1
        /// hour.
        pub min_duration: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "experiments")]
    impl RolloutStep {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::rollout_config::RolloutStep::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [traffic_percent][crate::model::rollout_config::RolloutStep::traffic_percent].
        pub fn set_traffic_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.traffic_percent = v.into();
            self
        }

        /// Sets the value of [min_duration][crate::model::rollout_config::RolloutStep::min_duration].
        pub fn set_min_duration<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.min_duration = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [min_duration][crate::model::rollout_config::RolloutStep::min_duration].
        pub fn set_or_clear_min_duration<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.min_duration = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "experiments")]
    impl wkt::message::Message for RolloutStep {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.RolloutConfig.RolloutStep"
        }
    }

    #[cfg(feature = "experiments")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RolloutStep {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __display_name,
                __traffic_percent,
                __min_duration,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RolloutStep")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                "trafficPercent" => Ok(__FieldTag::__traffic_percent),
                                "traffic_percent" => Ok(__FieldTag::__traffic_percent),
                                "minDuration" => Ok(__FieldTag::__min_duration),
                                "min_duration" => Ok(__FieldTag::__min_duration),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RolloutStep;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RolloutStep")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__traffic_percent => {
                                if !fields.insert(__FieldTag::__traffic_percent) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for traffic_percent",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.traffic_percent =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__min_duration => {
                                if !fields.insert(__FieldTag::__min_duration) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min_duration",
                                    ));
                                }
                                result.min_duration =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "experiments")]
    #[doc(hidden)]
    impl serde::ser::Serialize for RolloutStep {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !wkt::internal::is_default(&self.traffic_percent) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("trafficPercent", &__With(&self.traffic_percent))?;
            }
            if self.min_duration.is_some() {
                state.serialize_entry("minDuration", &self.min_duration)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// State of the auto-rollout process.
#[cfg(feature = "experiments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RolloutState {
    /// Display name of the current auto rollout step.
    pub step: std::string::String,

    /// Index of the current step in the auto rollout steps list.
    pub step_index: i32,

    /// Start time of the current step.
    pub start_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "experiments")]
impl RolloutState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [step][crate::model::RolloutState::step].
    pub fn set_step<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.step = v.into();
        self
    }

    /// Sets the value of [step_index][crate::model::RolloutState::step_index].
    pub fn set_step_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.step_index = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::RolloutState::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::RolloutState::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "experiments")]
impl wkt::message::Message for RolloutState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.RolloutState"
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RolloutState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __step,
            __step_index,
            __start_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RolloutState")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "step" => Ok(__FieldTag::__step),
                            "stepIndex" => Ok(__FieldTag::__step_index),
                            "step_index" => Ok(__FieldTag::__step_index),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RolloutState;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RolloutState")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__step => {
                            if !fields.insert(__FieldTag::__step) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for step",
                                ));
                            }
                            result.step = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__step_index => {
                            if !fields.insert(__FieldTag::__step_index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for step_index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.step_index = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for RolloutState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.step.is_empty() {
            state.serialize_entry("step", &self.step)?;
        }
        if !wkt::internal::is_default(&self.step_index) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("stepIndex", &__With(&self.step_index))?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Experiments.ListExperiments][google.cloud.dialogflow.cx.v3.Experiments.ListExperiments].
///
/// [google.cloud.dialogflow.cx.v3.Experiments.ListExperiments]: crate::client::Experiments::list_experiments
#[cfg(feature = "experiments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListExperimentsRequest {
    /// Required. The [Environment][google.cloud.dialogflow.cx.v3.Environment] to
    /// list all environments for. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Environment]: crate::model::Environment
    pub parent: std::string::String,

    /// The maximum number of items to return in a single page. By default 20 and
    /// at most 100.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "experiments")]
impl ListExperimentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListExperimentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListExperimentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListExperimentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "experiments")]
impl wkt::message::Message for ListExperimentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListExperimentsRequest"
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListExperimentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListExperimentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListExperimentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListExperimentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for ListExperimentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Experiments.ListExperiments][google.cloud.dialogflow.cx.v3.Experiments.ListExperiments].
///
/// [google.cloud.dialogflow.cx.v3.Experiments.ListExperiments]: crate::client::Experiments::list_experiments
#[cfg(feature = "experiments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListExperimentsResponse {
    /// The list of experiments. There will be a maximum number of items
    /// returned based on the page_size field in the request. The list may in some
    /// cases be empty or contain fewer entries than page_size even if this isn't
    /// the last page.
    pub experiments: std::vec::Vec<crate::model::Experiment>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "experiments")]
impl ListExperimentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [experiments][crate::model::ListExperimentsResponse::experiments].
    pub fn set_experiments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Experiment>,
    {
        use std::iter::Iterator;
        self.experiments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListExperimentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "experiments")]
impl wkt::message::Message for ListExperimentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListExperimentsResponse"
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListExperimentsResponse {
    type PageItem = crate::model::Experiment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.experiments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListExperimentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __experiments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListExperimentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "experiments" => Ok(__FieldTag::__experiments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListExperimentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListExperimentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__experiments => {
                            if !fields.insert(__FieldTag::__experiments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for experiments",
                                ));
                            }
                            result.experiments = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Experiment>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for ListExperimentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.experiments.is_empty() {
            state.serialize_entry("experiments", &self.experiments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Experiments.GetExperiment][google.cloud.dialogflow.cx.v3.Experiments.GetExperiment].
///
/// [google.cloud.dialogflow.cx.v3.Experiments.GetExperiment]: crate::client::Experiments::get_experiment
#[cfg(feature = "experiments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetExperimentRequest {
    /// Required. The name of the
    /// [Environment][google.cloud.dialogflow.cx.v3.Environment]. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>/experiments/<ExperimentID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Environment]: crate::model::Environment
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "experiments")]
impl GetExperimentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetExperimentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "experiments")]
impl wkt::message::Message for GetExperimentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetExperimentRequest"
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetExperimentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetExperimentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetExperimentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetExperimentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for GetExperimentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Experiments.CreateExperiment][google.cloud.dialogflow.cx.v3.Experiments.CreateExperiment].
///
/// [google.cloud.dialogflow.cx.v3.Experiments.CreateExperiment]: crate::client::Experiments::create_experiment
#[cfg(feature = "experiments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateExperimentRequest {
    /// Required. The [Agent][google.cloud.dialogflow.cx.v3.Agent] to create an
    /// [Environment][google.cloud.dialogflow.cx.v3.Environment] for. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Agent]: crate::model::Agent
    /// [google.cloud.dialogflow.cx.v3.Environment]: crate::model::Environment
    pub parent: std::string::String,

    /// Required. The experiment to create.
    pub experiment: std::option::Option<crate::model::Experiment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "experiments")]
impl CreateExperimentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateExperimentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [experiment][crate::model::CreateExperimentRequest::experiment].
    pub fn set_experiment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Experiment>,
    {
        self.experiment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [experiment][crate::model::CreateExperimentRequest::experiment].
    pub fn set_or_clear_experiment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Experiment>,
    {
        self.experiment = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "experiments")]
impl wkt::message::Message for CreateExperimentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CreateExperimentRequest"
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateExperimentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __experiment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateExperimentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "experiment" => Ok(__FieldTag::__experiment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateExperimentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateExperimentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__experiment => {
                            if !fields.insert(__FieldTag::__experiment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for experiment",
                                ));
                            }
                            result.experiment =
                                map.next_value::<std::option::Option<crate::model::Experiment>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateExperimentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.experiment.is_some() {
            state.serialize_entry("experiment", &self.experiment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Experiments.UpdateExperiment][google.cloud.dialogflow.cx.v3.Experiments.UpdateExperiment].
///
/// [google.cloud.dialogflow.cx.v3.Experiments.UpdateExperiment]: crate::client::Experiments::update_experiment
#[cfg(feature = "experiments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateExperimentRequest {
    /// Required. The experiment to update.
    pub experiment: std::option::Option<crate::model::Experiment>,

    /// Required. The mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "experiments")]
impl UpdateExperimentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [experiment][crate::model::UpdateExperimentRequest::experiment].
    pub fn set_experiment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Experiment>,
    {
        self.experiment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [experiment][crate::model::UpdateExperimentRequest::experiment].
    pub fn set_or_clear_experiment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Experiment>,
    {
        self.experiment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateExperimentRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateExperimentRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "experiments")]
impl wkt::message::Message for UpdateExperimentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.UpdateExperimentRequest"
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateExperimentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __experiment,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateExperimentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "experiment" => Ok(__FieldTag::__experiment),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateExperimentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateExperimentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__experiment => {
                            if !fields.insert(__FieldTag::__experiment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for experiment",
                                ));
                            }
                            result.experiment =
                                map.next_value::<std::option::Option<crate::model::Experiment>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateExperimentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.experiment.is_some() {
            state.serialize_entry("experiment", &self.experiment)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Experiments.DeleteExperiment][google.cloud.dialogflow.cx.v3.Experiments.DeleteExperiment].
///
/// [google.cloud.dialogflow.cx.v3.Experiments.DeleteExperiment]: crate::client::Experiments::delete_experiment
#[cfg(feature = "experiments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteExperimentRequest {
    /// Required. The name of the
    /// [Environment][google.cloud.dialogflow.cx.v3.Environment] to delete. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>/experiments/<ExperimentID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Environment]: crate::model::Environment
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "experiments")]
impl DeleteExperimentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteExperimentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "experiments")]
impl wkt::message::Message for DeleteExperimentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DeleteExperimentRequest"
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteExperimentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteExperimentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteExperimentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteExperimentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteExperimentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Experiments.StartExperiment][google.cloud.dialogflow.cx.v3.Experiments.StartExperiment].
///
/// [google.cloud.dialogflow.cx.v3.Experiments.StartExperiment]: crate::client::Experiments::start_experiment
#[cfg(feature = "experiments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StartExperimentRequest {
    /// Required. Resource name of the experiment to start.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>/experiments/<ExperimentID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "experiments")]
impl StartExperimentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartExperimentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "experiments")]
impl wkt::message::Message for StartExperimentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.StartExperimentRequest"
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartExperimentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartExperimentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartExperimentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartExperimentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for StartExperimentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Experiments.StopExperiment][google.cloud.dialogflow.cx.v3.Experiments.StopExperiment].
///
/// [google.cloud.dialogflow.cx.v3.Experiments.StopExperiment]: crate::client::Experiments::stop_experiment
#[cfg(feature = "experiments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StopExperimentRequest {
    /// Required. Resource name of the experiment to stop.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>/experiments/<ExperimentID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "experiments")]
impl StopExperimentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopExperimentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "experiments")]
impl wkt::message::Message for StopExperimentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.StopExperimentRequest"
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StopExperimentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StopExperimentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StopExperimentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StopExperimentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "experiments")]
#[doc(hidden)]
impl serde::ser::Serialize for StopExperimentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Settings related to NLU.
#[cfg(any(
    feature = "flows",
    feature = "sessions",
    feature = "test-cases",
    feature = "versions",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NluSettings {
    /// Indicates the type of NLU model.
    pub model_type: crate::model::nlu_settings::ModelType,

    /// To filter out false positive results and still get variety in matched
    /// natural language inputs for your agent, you can tune the machine learning
    /// classification threshold. If the returned score value is less than the
    /// threshold value, then a no-match event will be triggered. The score values
    /// range from 0.0 (completely uncertain) to 1.0 (completely certain). If set
    /// to 0.0, the default of 0.3 is used. You can set a separate classification
    /// threshold for the flow in each language enabled for the agent.
    pub classification_threshold: f32,

    /// Indicates NLU model training mode.
    pub model_training_mode: crate::model::nlu_settings::ModelTrainingMode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "flows",
    feature = "sessions",
    feature = "test-cases",
    feature = "versions",
))]
impl NluSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model_type][crate::model::NluSettings::model_type].
    pub fn set_model_type<T: std::convert::Into<crate::model::nlu_settings::ModelType>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_type = v.into();
        self
    }

    /// Sets the value of [classification_threshold][crate::model::NluSettings::classification_threshold].
    pub fn set_classification_threshold<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.classification_threshold = v.into();
        self
    }

    /// Sets the value of [model_training_mode][crate::model::NluSettings::model_training_mode].
    pub fn set_model_training_mode<
        T: std::convert::Into<crate::model::nlu_settings::ModelTrainingMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_training_mode = v.into();
        self
    }
}

#[cfg(any(
    feature = "flows",
    feature = "sessions",
    feature = "test-cases",
    feature = "versions",
))]
impl wkt::message::Message for NluSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.NluSettings"
    }
}

#[cfg(any(
    feature = "flows",
    feature = "sessions",
    feature = "test-cases",
    feature = "versions",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NluSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __model_type,
            __classification_threshold,
            __model_training_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NluSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "modelType" => Ok(__FieldTag::__model_type),
                            "model_type" => Ok(__FieldTag::__model_type),
                            "classificationThreshold" => Ok(__FieldTag::__classification_threshold),
                            "classification_threshold" => {
                                Ok(__FieldTag::__classification_threshold)
                            }
                            "modelTrainingMode" => Ok(__FieldTag::__model_training_mode),
                            "model_training_mode" => Ok(__FieldTag::__model_training_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NluSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NluSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__model_type => {
                            if !fields.insert(__FieldTag::__model_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_type",
                                ));
                            }
                            result.model_type = map.next_value::<std::option::Option<crate::model::nlu_settings::ModelType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__classification_threshold => {
                            if !fields.insert(__FieldTag::__classification_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for classification_threshold",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.classification_threshold =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__model_training_mode => {
                            if !fields.insert(__FieldTag::__model_training_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_training_mode",
                                ));
                            }
                            result.model_training_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::nlu_settings::ModelTrainingMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "flows",
    feature = "sessions",
    feature = "test-cases",
    feature = "versions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for NluSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.model_type) {
            state.serialize_entry("modelType", &self.model_type)?;
        }
        if !wkt::internal::is_default(&self.classification_threshold) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "classificationThreshold",
                &__With(&self.classification_threshold),
            )?;
        }
        if !wkt::internal::is_default(&self.model_training_mode) {
            state.serialize_entry("modelTrainingMode", &self.model_training_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [NluSettings].
#[cfg(any(
    feature = "flows",
    feature = "sessions",
    feature = "test-cases",
    feature = "versions",
))]
pub mod nlu_settings {
    #[allow(unused_imports)]
    use super::*;

    /// NLU model type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "flows",
        feature = "sessions",
        feature = "test-cases",
        feature = "versions",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelType {
        /// Not specified. `MODEL_TYPE_STANDARD` will be used.
        Unspecified,
        /// Use standard NLU model.
        Standard,
        /// Use advanced NLU model.
        Advanced,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModelType::value] or
        /// [ModelType::name].
        UnknownValue(model_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "flows",
        feature = "sessions",
        feature = "test-cases",
        feature = "versions",
    ))]
    pub mod model_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "flows",
        feature = "sessions",
        feature = "test-cases",
        feature = "versions",
    ))]
    impl ModelType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Standard => std::option::Option::Some(1),
                Self::Advanced => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODEL_TYPE_UNSPECIFIED"),
                Self::Standard => std::option::Option::Some("MODEL_TYPE_STANDARD"),
                Self::Advanced => std::option::Option::Some("MODEL_TYPE_ADVANCED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "sessions",
        feature = "test-cases",
        feature = "versions",
    ))]
    impl std::default::Default for ModelType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "sessions",
        feature = "test-cases",
        feature = "versions",
    ))]
    impl std::fmt::Display for ModelType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "sessions",
        feature = "test-cases",
        feature = "versions",
    ))]
    impl std::convert::From<i32> for ModelType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Standard,
                3 => Self::Advanced,
                _ => Self::UnknownValue(model_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "sessions",
        feature = "test-cases",
        feature = "versions",
    ))]
    impl std::convert::From<&str> for ModelType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODEL_TYPE_UNSPECIFIED" => Self::Unspecified,
                "MODEL_TYPE_STANDARD" => Self::Standard,
                "MODEL_TYPE_ADVANCED" => Self::Advanced,
                _ => Self::UnknownValue(model_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "sessions",
        feature = "test-cases",
        feature = "versions",
    ))]
    impl serde::ser::Serialize for ModelType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Standard => serializer.serialize_i32(1),
                Self::Advanced => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "sessions",
        feature = "test-cases",
        feature = "versions",
    ))]
    impl<'de> serde::de::Deserialize<'de> for ModelType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelType>::new(
                ".google.cloud.dialogflow.cx.v3.NluSettings.ModelType",
            ))
        }
    }

    /// NLU model training mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "flows",
        feature = "sessions",
        feature = "test-cases",
        feature = "versions",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelTrainingMode {
        /// Not specified. `MODEL_TRAINING_MODE_AUTOMATIC` will be used.
        Unspecified,
        /// NLU model training is automatically triggered when a flow gets modified.
        /// User can also manually trigger model training in this mode.
        Automatic,
        /// User needs to manually trigger NLU model training. Best for large flows
        /// whose models take long time to train.
        Manual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModelTrainingMode::value] or
        /// [ModelTrainingMode::name].
        UnknownValue(model_training_mode::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "flows",
        feature = "sessions",
        feature = "test-cases",
        feature = "versions",
    ))]
    pub mod model_training_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "flows",
        feature = "sessions",
        feature = "test-cases",
        feature = "versions",
    ))]
    impl ModelTrainingMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automatic => std::option::Option::Some(1),
                Self::Manual => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODEL_TRAINING_MODE_UNSPECIFIED"),
                Self::Automatic => std::option::Option::Some("MODEL_TRAINING_MODE_AUTOMATIC"),
                Self::Manual => std::option::Option::Some("MODEL_TRAINING_MODE_MANUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "sessions",
        feature = "test-cases",
        feature = "versions",
    ))]
    impl std::default::Default for ModelTrainingMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "sessions",
        feature = "test-cases",
        feature = "versions",
    ))]
    impl std::fmt::Display for ModelTrainingMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "sessions",
        feature = "test-cases",
        feature = "versions",
    ))]
    impl std::convert::From<i32> for ModelTrainingMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automatic,
                2 => Self::Manual,
                _ => Self::UnknownValue(model_training_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "sessions",
        feature = "test-cases",
        feature = "versions",
    ))]
    impl std::convert::From<&str> for ModelTrainingMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODEL_TRAINING_MODE_UNSPECIFIED" => Self::Unspecified,
                "MODEL_TRAINING_MODE_AUTOMATIC" => Self::Automatic,
                "MODEL_TRAINING_MODE_MANUAL" => Self::Manual,
                _ => Self::UnknownValue(model_training_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "sessions",
        feature = "test-cases",
        feature = "versions",
    ))]
    impl serde::ser::Serialize for ModelTrainingMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automatic => serializer.serialize_i32(1),
                Self::Manual => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "sessions",
        feature = "test-cases",
        feature = "versions",
    ))]
    impl<'de> serde::de::Deserialize<'de> for ModelTrainingMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelTrainingMode>::new(
                ".google.cloud.dialogflow.cx.v3.NluSettings.ModelTrainingMode",
            ))
        }
    }
}

/// Flows represents the conversation flows when you build your chatbot agent.
///
/// A flow consists of many pages connected by the transition routes.
/// Conversations always start with the built-in Start Flow (with an all-0 ID).
/// Transition routes can direct the conversation session from the current flow
/// (parent flow) to another flow (sub flow). When the sub flow is finished,
/// Dialogflow will bring the session back to the parent flow, where the sub flow
/// is started.
///
/// Usually, when a transition route is followed by a matched intent, the intent
/// will be "consumed". This means the intent won't activate more transition
/// routes. However, when the followed transition route moves the conversation
/// session into a different flow, the matched intent can be carried over and to
/// be consumed in the target flow.
#[cfg(any(feature = "flows", feature = "sessions", feature = "test-cases",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Flow {
    /// The unique identifier of the flow.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>`.
    pub name: std::string::String,

    /// Required. The human-readable name of the flow.
    pub display_name: std::string::String,

    /// The description of the flow. The maximum length is 500 characters. If
    /// exceeded, the request is rejected.
    pub description: std::string::String,

    /// A flow's transition routes serve two purposes:
    ///
    /// * They are responsible for matching the user's first utterances in the
    ///   flow.
    /// * They are inherited by every page's [transition
    ///   routes][Page.transition_routes] and can support use cases such as the user
    ///   saying "help" or "can I talk to a human?", which can be handled in a common
    ///   way regardless of the current page. Transition routes defined in the page
    ///   have higher priority than those defined in the flow.
    ///
    /// TransitionRoutes are evaluated in the following order:
    ///
    /// * TransitionRoutes with intent specified.
    /// * TransitionRoutes with only condition specified.
    ///
    /// TransitionRoutes with intent specified are inherited by pages in the flow.
    ///
    /// [Page.transition_routes]: crate::model::Page::transition_routes
    pub transition_routes: std::vec::Vec<crate::model::TransitionRoute>,

    /// A flow's event handlers serve two purposes:
    ///
    /// * They are responsible for handling events (e.g. no match,
    ///   webhook errors) in the flow.
    /// * They are inherited by every page's [event
    ///   handlers][Page.event_handlers], which can be used to handle common events
    ///   regardless of the current page. Event handlers defined in the page
    ///   have higher priority than those defined in the flow.
    ///
    /// Unlike
    /// [transition_routes][google.cloud.dialogflow.cx.v3.Flow.transition_routes],
    /// these handlers are evaluated on a first-match basis. The first one that
    /// matches the event get executed, with the rest being ignored.
    ///
    /// [Page.event_handlers]: crate::model::Page::event_handlers
    /// [google.cloud.dialogflow.cx.v3.Flow.transition_routes]: crate::model::Flow::transition_routes
    pub event_handlers: std::vec::Vec<crate::model::EventHandler>,

    /// A flow's transition route group serve two purposes:
    ///
    /// * They are responsible for matching the user's first utterances in the
    ///   flow.
    /// * They are inherited by every page's [transition
    ///   route groups][Page.transition_route_groups]. Transition route groups
    ///   defined in the page have higher priority than those defined in the flow.
    ///
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/transitionRouteGroups/<TransitionRouteGroupID>`
    /// or
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/transitionRouteGroups/<TransitionRouteGroupID>`
    /// for agent-level groups.
    ///
    /// [Page.transition_route_groups]: crate::model::Page::transition_route_groups
    pub transition_route_groups: std::vec::Vec<std::string::String>,

    /// NLU related settings of the flow.
    pub nlu_settings: std::option::Option<crate::model::NluSettings>,

    /// Hierarchical advanced settings for this flow. The settings exposed at the
    /// lower level overrides the settings exposed at the higher level.
    pub advanced_settings: std::option::Option<crate::model::AdvancedSettings>,

    /// Optional. Knowledge connector configuration.
    pub knowledge_connector_settings: std::option::Option<crate::model::KnowledgeConnectorSettings>,

    /// Optional. Multi-lingual agent settings for this flow.
    pub multi_language_settings: std::option::Option<crate::model::flow::MultiLanguageSettings>,

    /// Indicates whether the flow is locked for changes. If the flow is locked,
    /// modifications to the flow will be rejected.
    pub locked: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "flows", feature = "sessions", feature = "test-cases",))]
impl Flow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Flow::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Flow::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Flow::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [transition_routes][crate::model::Flow::transition_routes].
    pub fn set_transition_routes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransitionRoute>,
    {
        use std::iter::Iterator;
        self.transition_routes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [event_handlers][crate::model::Flow::event_handlers].
    pub fn set_event_handlers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EventHandler>,
    {
        use std::iter::Iterator;
        self.event_handlers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [transition_route_groups][crate::model::Flow::transition_route_groups].
    pub fn set_transition_route_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.transition_route_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [nlu_settings][crate::model::Flow::nlu_settings].
    pub fn set_nlu_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NluSettings>,
    {
        self.nlu_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [nlu_settings][crate::model::Flow::nlu_settings].
    pub fn set_or_clear_nlu_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NluSettings>,
    {
        self.nlu_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [advanced_settings][crate::model::Flow::advanced_settings].
    pub fn set_advanced_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedSettings>,
    {
        self.advanced_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [advanced_settings][crate::model::Flow::advanced_settings].
    pub fn set_or_clear_advanced_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedSettings>,
    {
        self.advanced_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [knowledge_connector_settings][crate::model::Flow::knowledge_connector_settings].
    pub fn set_knowledge_connector_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KnowledgeConnectorSettings>,
    {
        self.knowledge_connector_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [knowledge_connector_settings][crate::model::Flow::knowledge_connector_settings].
    pub fn set_or_clear_knowledge_connector_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KnowledgeConnectorSettings>,
    {
        self.knowledge_connector_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [multi_language_settings][crate::model::Flow::multi_language_settings].
    pub fn set_multi_language_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::flow::MultiLanguageSettings>,
    {
        self.multi_language_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [multi_language_settings][crate::model::Flow::multi_language_settings].
    pub fn set_or_clear_multi_language_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::flow::MultiLanguageSettings>,
    {
        self.multi_language_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [locked][crate::model::Flow::locked].
    pub fn set_locked<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.locked = v.into();
        self
    }
}

#[cfg(any(feature = "flows", feature = "sessions", feature = "test-cases",))]
impl wkt::message::Message for Flow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.Flow"
    }
}

#[cfg(any(feature = "flows", feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Flow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __transition_routes,
            __event_handlers,
            __transition_route_groups,
            __nlu_settings,
            __advanced_settings,
            __knowledge_connector_settings,
            __multi_language_settings,
            __locked,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Flow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "transitionRoutes" => Ok(__FieldTag::__transition_routes),
                            "transition_routes" => Ok(__FieldTag::__transition_routes),
                            "eventHandlers" => Ok(__FieldTag::__event_handlers),
                            "event_handlers" => Ok(__FieldTag::__event_handlers),
                            "transitionRouteGroups" => Ok(__FieldTag::__transition_route_groups),
                            "transition_route_groups" => Ok(__FieldTag::__transition_route_groups),
                            "nluSettings" => Ok(__FieldTag::__nlu_settings),
                            "nlu_settings" => Ok(__FieldTag::__nlu_settings),
                            "advancedSettings" => Ok(__FieldTag::__advanced_settings),
                            "advanced_settings" => Ok(__FieldTag::__advanced_settings),
                            "knowledgeConnectorSettings" => {
                                Ok(__FieldTag::__knowledge_connector_settings)
                            }
                            "knowledge_connector_settings" => {
                                Ok(__FieldTag::__knowledge_connector_settings)
                            }
                            "multiLanguageSettings" => Ok(__FieldTag::__multi_language_settings),
                            "multi_language_settings" => Ok(__FieldTag::__multi_language_settings),
                            "locked" => Ok(__FieldTag::__locked),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Flow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Flow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transition_routes => {
                            if !fields.insert(__FieldTag::__transition_routes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transition_routes",
                                ));
                            }
                            result.transition_routes =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TransitionRoute>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event_handlers => {
                            if !fields.insert(__FieldTag::__event_handlers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_handlers",
                                ));
                            }
                            result.event_handlers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EventHandler>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__transition_route_groups => {
                            if !fields.insert(__FieldTag::__transition_route_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transition_route_groups",
                                ));
                            }
                            result.transition_route_groups = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__nlu_settings => {
                            if !fields.insert(__FieldTag::__nlu_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nlu_settings",
                                ));
                            }
                            result.nlu_settings =
                                map.next_value::<std::option::Option<crate::model::NluSettings>>()?;
                        }
                        __FieldTag::__advanced_settings => {
                            if !fields.insert(__FieldTag::__advanced_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advanced_settings",
                                ));
                            }
                            result.advanced_settings = map
                                .next_value::<std::option::Option<crate::model::AdvancedSettings>>(
                                )?;
                        }
                        __FieldTag::__knowledge_connector_settings => {
                            if !fields.insert(__FieldTag::__knowledge_connector_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for knowledge_connector_settings",
                                ));
                            }
                            result.knowledge_connector_settings = map.next_value::<std::option::Option<crate::model::KnowledgeConnectorSettings>>()?
                                ;
                        }
                        __FieldTag::__multi_language_settings => {
                            if !fields.insert(__FieldTag::__multi_language_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_language_settings",
                                ));
                            }
                            result.multi_language_settings = map.next_value::<std::option::Option<crate::model::flow::MultiLanguageSettings>>()?
                                ;
                        }
                        __FieldTag::__locked => {
                            if !fields.insert(__FieldTag::__locked) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locked",
                                ));
                            }
                            result.locked = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "flows", feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for Flow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.transition_routes.is_empty() {
            state.serialize_entry("transitionRoutes", &self.transition_routes)?;
        }
        if !self.event_handlers.is_empty() {
            state.serialize_entry("eventHandlers", &self.event_handlers)?;
        }
        if !self.transition_route_groups.is_empty() {
            state.serialize_entry("transitionRouteGroups", &self.transition_route_groups)?;
        }
        if self.nlu_settings.is_some() {
            state.serialize_entry("nluSettings", &self.nlu_settings)?;
        }
        if self.advanced_settings.is_some() {
            state.serialize_entry("advancedSettings", &self.advanced_settings)?;
        }
        if self.knowledge_connector_settings.is_some() {
            state.serialize_entry(
                "knowledgeConnectorSettings",
                &self.knowledge_connector_settings,
            )?;
        }
        if self.multi_language_settings.is_some() {
            state.serialize_entry("multiLanguageSettings", &self.multi_language_settings)?;
        }
        if !wkt::internal::is_default(&self.locked) {
            state.serialize_entry("locked", &self.locked)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Flow].
#[cfg(any(feature = "flows", feature = "sessions", feature = "test-cases",))]
pub mod flow {
    #[allow(unused_imports)]
    use super::*;

    /// Settings for multi-lingual agents.
    #[cfg(any(feature = "flows", feature = "sessions", feature = "test-cases",))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MultiLanguageSettings {
        /// Optional. Enable multi-language detection for this flow. This can be set
        /// only if [agent level multi language
        /// setting][Agent.enable_multi_language_training] is enabled.
        ///
        /// [Agent.enable_multi_language_training]: crate::model::Agent::enable_multi_language_training
        pub enable_multi_language_detection: bool,

        /// Optional. Agent will respond in the detected language if the detected
        /// language code is in the supported resolved languages for this flow. This
        /// will be used only if multi-language training is enabled in the
        /// [agent][google.cloud.dialogflow.cx.v3.Agent.enable_multi_language_training]
        /// and multi-language detection is enabled in the
        /// [flow][google.cloud.dialogflow.cx.v3.Flow.MultiLanguageSettings.enable_multi_language_detection].
        /// The supported languages must be a subset of the languages supported by
        /// the agent.
        ///
        /// [google.cloud.dialogflow.cx.v3.Agent.enable_multi_language_training]: crate::model::Agent::enable_multi_language_training
        /// [google.cloud.dialogflow.cx.v3.Flow.MultiLanguageSettings.enable_multi_language_detection]: crate::model::flow::MultiLanguageSettings::enable_multi_language_detection
        pub supported_response_language_codes: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "flows", feature = "sessions", feature = "test-cases",))]
    impl MultiLanguageSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enable_multi_language_detection][crate::model::flow::MultiLanguageSettings::enable_multi_language_detection].
        pub fn set_enable_multi_language_detection<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.enable_multi_language_detection = v.into();
            self
        }

        /// Sets the value of [supported_response_language_codes][crate::model::flow::MultiLanguageSettings::supported_response_language_codes].
        pub fn set_supported_response_language_codes<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.supported_response_language_codes = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(any(feature = "flows", feature = "sessions", feature = "test-cases",))]
    impl wkt::message::Message for MultiLanguageSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Flow.MultiLanguageSettings"
        }
    }

    #[cfg(any(feature = "flows", feature = "sessions", feature = "test-cases",))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MultiLanguageSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enable_multi_language_detection,
                __supported_response_language_codes,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MultiLanguageSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enableMultiLanguageDetection" => {
                                    Ok(__FieldTag::__enable_multi_language_detection)
                                }
                                "enable_multi_language_detection" => {
                                    Ok(__FieldTag::__enable_multi_language_detection)
                                }
                                "supportedResponseLanguageCodes" => {
                                    Ok(__FieldTag::__supported_response_language_codes)
                                }
                                "supported_response_language_codes" => {
                                    Ok(__FieldTag::__supported_response_language_codes)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MultiLanguageSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MultiLanguageSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enable_multi_language_detection => {
                                if !fields.insert(__FieldTag::__enable_multi_language_detection) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_multi_language_detection",
                                    ));
                                }
                                result.enable_multi_language_detection = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__supported_response_language_codes => {
                                if !fields.insert(__FieldTag::__supported_response_language_codes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for supported_response_language_codes",
                                    ));
                                }
                                result.supported_response_language_codes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(feature = "flows", feature = "sessions", feature = "test-cases",))]
    #[doc(hidden)]
    impl serde::ser::Serialize for MultiLanguageSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.enable_multi_language_detection) {
                state.serialize_entry(
                    "enableMultiLanguageDetection",
                    &self.enable_multi_language_detection,
                )?;
            }
            if !self.supported_response_language_codes.is_empty() {
                state.serialize_entry(
                    "supportedResponseLanguageCodes",
                    &self.supported_response_language_codes,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// The request message for
/// [Flows.CreateFlow][google.cloud.dialogflow.cx.v3.Flows.CreateFlow].
///
/// [google.cloud.dialogflow.cx.v3.Flows.CreateFlow]: crate::client::Flows::create_flow
#[cfg(feature = "flows")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateFlowRequest {
    /// Required. The agent to create a flow for.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// Required. The flow to create.
    pub flow: std::option::Option<crate::model::Flow>,

    /// The language of the following fields in `flow`:
    ///
    /// * `Flow.event_handlers.trigger_fulfillment.messages`
    /// * `Flow.event_handlers.trigger_fulfillment.conditional_cases`
    /// * `Flow.transition_routes.trigger_fulfillment.messages`
    /// * `Flow.transition_routes.trigger_fulfillment.conditional_cases`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "flows")]
impl CreateFlowRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateFlowRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [flow][crate::model::CreateFlowRequest::flow].
    pub fn set_flow<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Flow>,
    {
        self.flow = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [flow][crate::model::CreateFlowRequest::flow].
    pub fn set_or_clear_flow<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Flow>,
    {
        self.flow = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::CreateFlowRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "flows")]
impl wkt::message::Message for CreateFlowRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CreateFlowRequest"
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateFlowRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __flow,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateFlowRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "flow" => Ok(__FieldTag::__flow),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateFlowRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateFlowRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__flow => {
                            if !fields.insert(__FieldTag::__flow) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flow",
                                ));
                            }
                            result.flow =
                                map.next_value::<std::option::Option<crate::model::Flow>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateFlowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.flow.is_some() {
            state.serialize_entry("flow", &self.flow)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Flows.DeleteFlow][google.cloud.dialogflow.cx.v3.Flows.DeleteFlow].
///
/// [google.cloud.dialogflow.cx.v3.Flows.DeleteFlow]: crate::client::Flows::delete_flow
#[cfg(feature = "flows")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteFlowRequest {
    /// Required. The name of the flow to delete.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>`.
    pub name: std::string::String,

    /// This field has no effect for flows with no incoming transitions.
    /// For flows with incoming transitions:
    ///
    /// * If `force` is set to false, an error will be returned with message
    ///   indicating the incoming transitions.
    /// * If `force` is set to true, Dialogflow will remove the flow, as well as
    ///   any transitions to the flow (i.e. [Target
    ///   flow][EventHandler.target_flow] in event handlers or [Target
    ///   flow][TransitionRoute.target_flow] in transition routes that point to
    ///   this flow will be cleared).
    ///
    /// [EventHandler.target_flow]: crate::model::EventHandler::target
    /// [TransitionRoute.target_flow]: crate::model::TransitionRoute::target
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "flows")]
impl DeleteFlowRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteFlowRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteFlowRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

#[cfg(feature = "flows")]
impl wkt::message::Message for DeleteFlowRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DeleteFlowRequest"
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteFlowRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteFlowRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteFlowRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteFlowRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteFlowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Flows.ListFlows][google.cloud.dialogflow.cx.v3.Flows.ListFlows].
///
/// [google.cloud.dialogflow.cx.v3.Flows.ListFlows]: crate::client::Flows::list_flows
#[cfg(feature = "flows")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFlowsRequest {
    /// Required. The agent containing the flows.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// The maximum number of items to return in a single page. By default 100 and
    /// at most 1000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    /// The language to list flows for. The following fields are language
    /// dependent:
    ///
    /// * `Flow.event_handlers.trigger_fulfillment.messages`
    /// * `Flow.event_handlers.trigger_fulfillment.conditional_cases`
    /// * `Flow.transition_routes.trigger_fulfillment.messages`
    /// * `Flow.transition_routes.trigger_fulfillment.conditional_cases`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "flows")]
impl ListFlowsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListFlowsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListFlowsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListFlowsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::ListFlowsRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "flows")]
impl wkt::message::Message for ListFlowsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListFlowsRequest"
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFlowsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFlowsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFlowsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFlowsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for ListFlowsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Flows.ListFlows][google.cloud.dialogflow.cx.v3.Flows.ListFlows].
///
/// [google.cloud.dialogflow.cx.v3.Flows.ListFlows]: crate::client::Flows::list_flows
#[cfg(feature = "flows")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListFlowsResponse {
    /// The list of flows. There will be a maximum number of items returned based
    /// on the page_size field in the request.
    pub flows: std::vec::Vec<crate::model::Flow>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "flows")]
impl ListFlowsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [flows][crate::model::ListFlowsResponse::flows].
    pub fn set_flows<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Flow>,
    {
        use std::iter::Iterator;
        self.flows = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListFlowsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "flows")]
impl wkt::message::Message for ListFlowsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListFlowsResponse"
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListFlowsResponse {
    type PageItem = crate::model::Flow;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.flows
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListFlowsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __flows,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListFlowsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "flows" => Ok(__FieldTag::__flows),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListFlowsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListFlowsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__flows => {
                            if !fields.insert(__FieldTag::__flows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flows",
                                ));
                            }
                            result.flows = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Flow>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for ListFlowsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.flows.is_empty() {
            state.serialize_entry("flows", &self.flows)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Flows.GetFlow][google.cloud.dialogflow.cx.v3.Flows.GetFlow].
///
/// [google.cloud.dialogflow.cx.v3.Flows.GetFlow]: crate::client::Flows::get_flow
#[cfg(feature = "flows")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetFlowRequest {
    /// Required. The name of the flow to get.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>`.
    pub name: std::string::String,

    /// The language to retrieve the flow for. The following fields are language
    /// dependent:
    ///
    /// * `Flow.event_handlers.trigger_fulfillment.messages`
    /// * `Flow.event_handlers.trigger_fulfillment.conditional_cases`
    /// * `Flow.transition_routes.trigger_fulfillment.messages`
    /// * `Flow.transition_routes.trigger_fulfillment.conditional_cases`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "flows")]
impl GetFlowRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFlowRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::GetFlowRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "flows")]
impl wkt::message::Message for GetFlowRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetFlowRequest"
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetFlowRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetFlowRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetFlowRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetFlowRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for GetFlowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Flows.UpdateFlow][google.cloud.dialogflow.cx.v3.Flows.UpdateFlow].
///
/// [google.cloud.dialogflow.cx.v3.Flows.UpdateFlow]: crate::client::Flows::update_flow
#[cfg(feature = "flows")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateFlowRequest {
    /// Required. The flow to update.
    pub flow: std::option::Option<crate::model::Flow>,

    /// The mask to control which fields get updated. If the mask is not present,
    /// all fields will be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// The language of the following fields in `flow`:
    ///
    /// * `Flow.event_handlers.trigger_fulfillment.messages`
    /// * `Flow.event_handlers.trigger_fulfillment.conditional_cases`
    /// * `Flow.transition_routes.trigger_fulfillment.messages`
    /// * `Flow.transition_routes.trigger_fulfillment.conditional_cases`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "flows")]
impl UpdateFlowRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [flow][crate::model::UpdateFlowRequest::flow].
    pub fn set_flow<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Flow>,
    {
        self.flow = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [flow][crate::model::UpdateFlowRequest::flow].
    pub fn set_or_clear_flow<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Flow>,
    {
        self.flow = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFlowRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateFlowRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::UpdateFlowRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "flows")]
impl wkt::message::Message for UpdateFlowRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.UpdateFlowRequest"
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateFlowRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __flow,
            __update_mask,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateFlowRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "flow" => Ok(__FieldTag::__flow),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateFlowRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateFlowRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__flow => {
                            if !fields.insert(__FieldTag::__flow) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flow",
                                ));
                            }
                            result.flow =
                                map.next_value::<std::option::Option<crate::model::Flow>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateFlowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.flow.is_some() {
            state.serialize_entry("flow", &self.flow)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Flows.TrainFlow][google.cloud.dialogflow.cx.v3.Flows.TrainFlow].
///
/// [google.cloud.dialogflow.cx.v3.Flows.TrainFlow]: crate::client::Flows::train_flow
#[cfg(feature = "flows")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TrainFlowRequest {
    /// Required. The flow to train.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "flows")]
impl TrainFlowRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TrainFlowRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "flows")]
impl wkt::message::Message for TrainFlowRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.TrainFlowRequest"
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TrainFlowRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TrainFlowRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TrainFlowRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TrainFlowRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for TrainFlowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Flows.ValidateFlow][google.cloud.dialogflow.cx.v3.Flows.ValidateFlow].
///
/// [google.cloud.dialogflow.cx.v3.Flows.ValidateFlow]: crate::client::Flows::validate_flow
#[cfg(feature = "flows")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidateFlowRequest {
    /// Required. The flow to validate.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>`.
    pub name: std::string::String,

    /// If not specified, the agent's default language is used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "flows")]
impl ValidateFlowRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ValidateFlowRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::ValidateFlowRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "flows")]
impl wkt::message::Message for ValidateFlowRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ValidateFlowRequest"
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValidateFlowRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValidateFlowRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValidateFlowRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValidateFlowRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for ValidateFlowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Flows.GetFlowValidationResult][google.cloud.dialogflow.cx.v3.Flows.GetFlowValidationResult].
///
/// [google.cloud.dialogflow.cx.v3.Flows.GetFlowValidationResult]: crate::client::Flows::get_flow_validation_result
#[cfg(feature = "flows")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetFlowValidationResultRequest {
    /// Required. The flow name.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/validationResult`.
    pub name: std::string::String,

    /// If not specified, the agent's default language is used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "flows")]
impl GetFlowValidationResultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFlowValidationResultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::GetFlowValidationResultRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "flows")]
impl wkt::message::Message for GetFlowValidationResultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetFlowValidationResultRequest"
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetFlowValidationResultRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetFlowValidationResultRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetFlowValidationResultRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetFlowValidationResultRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for GetFlowValidationResultRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Flows.GetFlowValidationResult][google.cloud.dialogflow.cx.v3.Flows.GetFlowValidationResult].
///
/// [google.cloud.dialogflow.cx.v3.Flows.GetFlowValidationResult]: crate::client::Flows::get_flow_validation_result
#[cfg(any(feature = "agents", feature = "flows",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FlowValidationResult {
    /// The unique identifier of the flow validation result.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/validationResult`.
    pub name: std::string::String,

    /// Contains all validation messages.
    pub validation_messages: std::vec::Vec<crate::model::ValidationMessage>,

    /// Last time the flow was validated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "agents", feature = "flows",))]
impl FlowValidationResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FlowValidationResult::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validation_messages][crate::model::FlowValidationResult::validation_messages].
    pub fn set_validation_messages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ValidationMessage>,
    {
        use std::iter::Iterator;
        self.validation_messages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [update_time][crate::model::FlowValidationResult::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::FlowValidationResult::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "agents", feature = "flows",))]
impl wkt::message::Message for FlowValidationResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.FlowValidationResult"
    }
}

#[cfg(any(feature = "agents", feature = "flows",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FlowValidationResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validation_messages,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FlowValidationResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validationMessages" => Ok(__FieldTag::__validation_messages),
                            "validation_messages" => Ok(__FieldTag::__validation_messages),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FlowValidationResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FlowValidationResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validation_messages => {
                            if !fields.insert(__FieldTag::__validation_messages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validation_messages",
                                ));
                            }
                            result.validation_messages =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ValidationMessage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "agents", feature = "flows",))]
#[doc(hidden)]
impl serde::ser::Serialize for FlowValidationResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.validation_messages.is_empty() {
            state.serialize_entry("validationMessages", &self.validation_messages)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Flows.ImportFlow][google.cloud.dialogflow.cx.v3.Flows.ImportFlow].
///
/// [google.cloud.dialogflow.cx.v3.Flows.ImportFlow]: crate::client::Flows::import_flow
#[cfg(feature = "flows")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportFlowRequest {
    /// Required. The agent to import the flow into.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// Flow import mode. If not specified, `KEEP` is assumed.
    pub import_option: crate::model::import_flow_request::ImportOption,

    /// Optional. Specifies the import strategy used when resolving resource
    /// conflicts.
    pub flow_import_strategy: std::option::Option<crate::model::FlowImportStrategy>,

    /// Required. The flow to import.
    pub flow: std::option::Option<crate::model::import_flow_request::Flow>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "flows")]
impl ImportFlowRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportFlowRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [import_option][crate::model::ImportFlowRequest::import_option].
    pub fn set_import_option<
        T: std::convert::Into<crate::model::import_flow_request::ImportOption>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_option = v.into();
        self
    }

    /// Sets the value of [flow_import_strategy][crate::model::ImportFlowRequest::flow_import_strategy].
    pub fn set_flow_import_strategy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FlowImportStrategy>,
    {
        self.flow_import_strategy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [flow_import_strategy][crate::model::ImportFlowRequest::flow_import_strategy].
    pub fn set_or_clear_flow_import_strategy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FlowImportStrategy>,
    {
        self.flow_import_strategy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [flow][crate::model::ImportFlowRequest::flow].
    ///
    /// Note that all the setters affecting `flow` are mutually
    /// exclusive.
    pub fn set_flow<
        T: std::convert::Into<std::option::Option<crate::model::import_flow_request::Flow>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.flow = v.into();
        self
    }

    /// The value of [flow][crate::model::ImportFlowRequest::flow]
    /// if it holds a `FlowUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn flow_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.flow.as_ref().and_then(|v| match v {
            crate::model::import_flow_request::Flow::FlowUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [flow][crate::model::ImportFlowRequest::flow]
    /// to hold a `FlowUri`.
    ///
    /// Note that all the setters affecting `flow` are
    /// mutually exclusive.
    pub fn set_flow_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.flow =
            std::option::Option::Some(crate::model::import_flow_request::Flow::FlowUri(v.into()));
        self
    }

    /// The value of [flow][crate::model::ImportFlowRequest::flow]
    /// if it holds a `FlowContent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn flow_content(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.flow.as_ref().and_then(|v| match v {
            crate::model::import_flow_request::Flow::FlowContent(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [flow][crate::model::ImportFlowRequest::flow]
    /// to hold a `FlowContent`.
    ///
    /// Note that all the setters affecting `flow` are
    /// mutually exclusive.
    pub fn set_flow_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.flow = std::option::Option::Some(
            crate::model::import_flow_request::Flow::FlowContent(v.into()),
        );
        self
    }
}

#[cfg(feature = "flows")]
impl wkt::message::Message for ImportFlowRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ImportFlowRequest"
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportFlowRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __flow_uri,
            __flow_content,
            __import_option,
            __flow_import_strategy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportFlowRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "flowUri" => Ok(__FieldTag::__flow_uri),
                            "flow_uri" => Ok(__FieldTag::__flow_uri),
                            "flowContent" => Ok(__FieldTag::__flow_content),
                            "flow_content" => Ok(__FieldTag::__flow_content),
                            "importOption" => Ok(__FieldTag::__import_option),
                            "import_option" => Ok(__FieldTag::__import_option),
                            "flowImportStrategy" => Ok(__FieldTag::__flow_import_strategy),
                            "flow_import_strategy" => Ok(__FieldTag::__flow_import_strategy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportFlowRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportFlowRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__flow_uri => {
                            if !fields.insert(__FieldTag::__flow_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flow_uri",
                                ));
                            }
                            if result.flow.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `flow`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ImportFlowRequest.flow_uri, latest field was flowUri",
                                ));
                            }
                            result.flow = std::option::Option::Some(
                                crate::model::import_flow_request::Flow::FlowUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__flow_content => {
                            if !fields.insert(__FieldTag::__flow_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flow_content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.flow.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `flow`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ImportFlowRequest.flow_content, latest field was flowContent",
                                ));
                            }
                            result.flow = std::option::Option::Some(
                                crate::model::import_flow_request::Flow::FlowContent(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__import_option => {
                            if !fields.insert(__FieldTag::__import_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_option",
                                ));
                            }
                            result.import_option = map
                                .next_value::<std::option::Option<
                                    crate::model::import_flow_request::ImportOption,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__flow_import_strategy => {
                            if !fields.insert(__FieldTag::__flow_import_strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flow_import_strategy",
                                ));
                            }
                            result.flow_import_strategy = map.next_value::<std::option::Option<crate::model::FlowImportStrategy>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for ImportFlowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.flow_uri() {
            state.serialize_entry("flowUri", value)?;
        }
        if let Some(value) = self.flow_content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("flowContent", &__With(value))?;
        }
        if !wkt::internal::is_default(&self.import_option) {
            state.serialize_entry("importOption", &self.import_option)?;
        }
        if self.flow_import_strategy.is_some() {
            state.serialize_entry("flowImportStrategy", &self.flow_import_strategy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ImportFlowRequest].
#[cfg(feature = "flows")]
pub mod import_flow_request {
    #[allow(unused_imports)]
    use super::*;

    /// Import option.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "flows")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ImportOption {
        /// Unspecified. Treated as `KEEP`.
        Unspecified,
        /// Always respect settings in exported flow content. It may cause a
        /// import failure if some settings (e.g. custom NLU) are not supported in
        /// the agent to import into.
        Keep,
        /// Fallback to default settings if some settings are not supported in the
        /// agent to import into. E.g. Standard NLU will be used if custom NLU is
        /// not available.
        Fallback,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ImportOption::value] or
        /// [ImportOption::name].
        UnknownValue(import_option::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "flows")]
    pub mod import_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "flows")]
    impl ImportOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Keep => std::option::Option::Some(1),
                Self::Fallback => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("IMPORT_OPTION_UNSPECIFIED"),
                Self::Keep => std::option::Option::Some("KEEP"),
                Self::Fallback => std::option::Option::Some("FALLBACK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "flows")]
    impl std::default::Default for ImportOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "flows")]
    impl std::fmt::Display for ImportOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "flows")]
    impl std::convert::From<i32> for ImportOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Keep,
                2 => Self::Fallback,
                _ => Self::UnknownValue(import_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "flows")]
    impl std::convert::From<&str> for ImportOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IMPORT_OPTION_UNSPECIFIED" => Self::Unspecified,
                "KEEP" => Self::Keep,
                "FALLBACK" => Self::Fallback,
                _ => Self::UnknownValue(import_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "flows")]
    impl serde::ser::Serialize for ImportOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Keep => serializer.serialize_i32(1),
                Self::Fallback => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "flows")]
    impl<'de> serde::de::Deserialize<'de> for ImportOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ImportOption>::new(
                ".google.cloud.dialogflow.cx.v3.ImportFlowRequest.ImportOption",
            ))
        }
    }

    /// Required. The flow to import.
    #[cfg(feature = "flows")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Flow {
        /// The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI
        /// to import flow from. The format of this URI must be
        /// `gs://<bucket-name>/<object-name>`.
        ///
        /// Dialogflow performs a read operation for the Cloud Storage object
        /// on the caller's behalf, so your request authentication must
        /// have read permissions for the object. For more information, see
        /// [Dialogflow access
        /// control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
        FlowUri(std::string::String),
        /// Uncompressed raw byte content for flow.
        FlowContent(::bytes::Bytes),
    }
}

/// The flow import strategy used for resource conflict resolution associated
/// with an [ImportFlowRequest][google.cloud.dialogflow.cx.v3.ImportFlowRequest].
///
/// [google.cloud.dialogflow.cx.v3.ImportFlowRequest]: crate::model::ImportFlowRequest
#[cfg(feature = "flows")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FlowImportStrategy {
    /// Optional. Import strategy for resource conflict resolution, applied
    /// globally throughout the flow. It will be applied for all display name
    /// conflicts in the imported content. If not specified, 'CREATE_NEW' is
    /// assumed.
    pub global_import_strategy: crate::model::ImportStrategy,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "flows")]
impl FlowImportStrategy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [global_import_strategy][crate::model::FlowImportStrategy::global_import_strategy].
    pub fn set_global_import_strategy<T: std::convert::Into<crate::model::ImportStrategy>>(
        mut self,
        v: T,
    ) -> Self {
        self.global_import_strategy = v.into();
        self
    }
}

#[cfg(feature = "flows")]
impl wkt::message::Message for FlowImportStrategy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.FlowImportStrategy"
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FlowImportStrategy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __global_import_strategy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FlowImportStrategy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "globalImportStrategy" => Ok(__FieldTag::__global_import_strategy),
                            "global_import_strategy" => Ok(__FieldTag::__global_import_strategy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FlowImportStrategy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FlowImportStrategy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__global_import_strategy => {
                            if !fields.insert(__FieldTag::__global_import_strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for global_import_strategy",
                                ));
                            }
                            result.global_import_strategy = map
                                .next_value::<std::option::Option<crate::model::ImportStrategy>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for FlowImportStrategy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.global_import_strategy) {
            state.serialize_entry("globalImportStrategy", &self.global_import_strategy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Flows.ImportFlow][google.cloud.dialogflow.cx.v3.Flows.ImportFlow].
///
/// [google.cloud.dialogflow.cx.v3.Flows.ImportFlow]: crate::client::Flows::import_flow
#[cfg(feature = "flows")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportFlowResponse {
    /// The unique identifier of the new flow.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>`.
    pub flow: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "flows")]
impl ImportFlowResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [flow][crate::model::ImportFlowResponse::flow].
    pub fn set_flow<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.flow = v.into();
        self
    }
}

#[cfg(feature = "flows")]
impl wkt::message::Message for ImportFlowResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ImportFlowResponse"
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportFlowResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __flow,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportFlowResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "flow" => Ok(__FieldTag::__flow),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportFlowResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportFlowResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__flow => {
                            if !fields.insert(__FieldTag::__flow) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flow",
                                ));
                            }
                            result.flow = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for ImportFlowResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.flow.is_empty() {
            state.serialize_entry("flow", &self.flow)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Flows.ExportFlow][google.cloud.dialogflow.cx.v3.Flows.ExportFlow].
///
/// [google.cloud.dialogflow.cx.v3.Flows.ExportFlow]: crate::client::Flows::export_flow
#[cfg(feature = "flows")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportFlowRequest {
    /// Required. The name of the flow to export.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>`.
    pub name: std::string::String,

    /// Optional. The [Google Cloud
    /// Storage](https://cloud.google.com/storage/docs/) URI to export the flow to.
    /// The format of this URI must be `gs://<bucket-name>/<object-name>`. If left
    /// unspecified, the serialized flow is returned inline.
    ///
    /// Dialogflow performs a write operation for the Cloud Storage object
    /// on the caller's behalf, so your request authentication must
    /// have write permissions for the object. For more information, see
    /// [Dialogflow access
    /// control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
    pub flow_uri: std::string::String,

    /// Optional. Whether to export flows referenced by the specified flow.
    pub include_referenced_flows: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "flows")]
impl ExportFlowRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExportFlowRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [flow_uri][crate::model::ExportFlowRequest::flow_uri].
    pub fn set_flow_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.flow_uri = v.into();
        self
    }

    /// Sets the value of [include_referenced_flows][crate::model::ExportFlowRequest::include_referenced_flows].
    pub fn set_include_referenced_flows<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.include_referenced_flows = v.into();
        self
    }
}

#[cfg(feature = "flows")]
impl wkt::message::Message for ExportFlowRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ExportFlowRequest"
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportFlowRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __flow_uri,
            __include_referenced_flows,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportFlowRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "flowUri" => Ok(__FieldTag::__flow_uri),
                            "flow_uri" => Ok(__FieldTag::__flow_uri),
                            "includeReferencedFlows" => Ok(__FieldTag::__include_referenced_flows),
                            "include_referenced_flows" => {
                                Ok(__FieldTag::__include_referenced_flows)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportFlowRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportFlowRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__flow_uri => {
                            if !fields.insert(__FieldTag::__flow_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flow_uri",
                                ));
                            }
                            result.flow_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__include_referenced_flows => {
                            if !fields.insert(__FieldTag::__include_referenced_flows) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for include_referenced_flows",
                                ));
                            }
                            result.include_referenced_flows = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for ExportFlowRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.flow_uri.is_empty() {
            state.serialize_entry("flowUri", &self.flow_uri)?;
        }
        if !wkt::internal::is_default(&self.include_referenced_flows) {
            state.serialize_entry("includeReferencedFlows", &self.include_referenced_flows)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Flows.ExportFlow][google.cloud.dialogflow.cx.v3.Flows.ExportFlow].
///
/// [google.cloud.dialogflow.cx.v3.Flows.ExportFlow]: crate::client::Flows::export_flow
#[cfg(feature = "flows")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportFlowResponse {
    /// The exported flow.
    pub flow: std::option::Option<crate::model::export_flow_response::Flow>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "flows")]
impl ExportFlowResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [flow][crate::model::ExportFlowResponse::flow].
    ///
    /// Note that all the setters affecting `flow` are mutually
    /// exclusive.
    pub fn set_flow<
        T: std::convert::Into<std::option::Option<crate::model::export_flow_response::Flow>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.flow = v.into();
        self
    }

    /// The value of [flow][crate::model::ExportFlowResponse::flow]
    /// if it holds a `FlowUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn flow_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.flow.as_ref().and_then(|v| match v {
            crate::model::export_flow_response::Flow::FlowUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [flow][crate::model::ExportFlowResponse::flow]
    /// to hold a `FlowUri`.
    ///
    /// Note that all the setters affecting `flow` are
    /// mutually exclusive.
    pub fn set_flow_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.flow =
            std::option::Option::Some(crate::model::export_flow_response::Flow::FlowUri(v.into()));
        self
    }

    /// The value of [flow][crate::model::ExportFlowResponse::flow]
    /// if it holds a `FlowContent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn flow_content(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.flow.as_ref().and_then(|v| match v {
            crate::model::export_flow_response::Flow::FlowContent(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [flow][crate::model::ExportFlowResponse::flow]
    /// to hold a `FlowContent`.
    ///
    /// Note that all the setters affecting `flow` are
    /// mutually exclusive.
    pub fn set_flow_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.flow = std::option::Option::Some(
            crate::model::export_flow_response::Flow::FlowContent(v.into()),
        );
        self
    }
}

#[cfg(feature = "flows")]
impl wkt::message::Message for ExportFlowResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ExportFlowResponse"
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportFlowResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __flow_uri,
            __flow_content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportFlowResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "flowUri" => Ok(__FieldTag::__flow_uri),
                            "flow_uri" => Ok(__FieldTag::__flow_uri),
                            "flowContent" => Ok(__FieldTag::__flow_content),
                            "flow_content" => Ok(__FieldTag::__flow_content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportFlowResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportFlowResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__flow_uri => {
                            if !fields.insert(__FieldTag::__flow_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flow_uri",
                                ));
                            }
                            if result.flow.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `flow`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ExportFlowResponse.flow_uri, latest field was flowUri",
                                ));
                            }
                            result.flow = std::option::Option::Some(
                                crate::model::export_flow_response::Flow::FlowUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__flow_content => {
                            if !fields.insert(__FieldTag::__flow_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flow_content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.flow.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `flow`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ExportFlowResponse.flow_content, latest field was flowContent",
                                ));
                            }
                            result.flow = std::option::Option::Some(
                                crate::model::export_flow_response::Flow::FlowContent(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "flows")]
#[doc(hidden)]
impl serde::ser::Serialize for ExportFlowResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.flow_uri() {
            state.serialize_entry("flowUri", value)?;
        }
        if let Some(value) = self.flow_content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("flowContent", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExportFlowResponse].
#[cfg(feature = "flows")]
pub mod export_flow_response {
    #[allow(unused_imports)]
    use super::*;

    /// The exported flow.
    #[cfg(feature = "flows")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Flow {
        /// The URI to a file containing the exported flow. This field is populated
        /// only if `flow_uri` is specified in
        /// [ExportFlowRequest][google.cloud.dialogflow.cx.v3.ExportFlowRequest].
        ///
        /// [google.cloud.dialogflow.cx.v3.ExportFlowRequest]: crate::model::ExportFlowRequest
        FlowUri(std::string::String),
        /// Uncompressed raw byte content for flow.
        FlowContent(::bytes::Bytes),
    }
}

/// A fulfillment can do one or more of the following actions at the same time:
///
/// * Generate rich message responses.
/// * Set parameter values.
/// * Call the webhook.
///
/// Fulfillments can be called at various stages in the
/// [Page][google.cloud.dialogflow.cx.v3.Page] or
/// [Form][google.cloud.dialogflow.cx.v3.Form] lifecycle. For example, when a
/// [DetectIntentRequest][google.cloud.dialogflow.cx.v3.DetectIntentRequest]
/// drives a session to enter a new page, the page's entry fulfillment can add a
/// static response to the
/// [QueryResult][google.cloud.dialogflow.cx.v3.QueryResult] in the returning
/// [DetectIntentResponse][google.cloud.dialogflow.cx.v3.DetectIntentResponse],
/// call the webhook (for example, to load user data from a database), or both.
///
/// [google.cloud.dialogflow.cx.v3.DetectIntentRequest]: crate::model::DetectIntentRequest
/// [google.cloud.dialogflow.cx.v3.DetectIntentResponse]: crate::model::DetectIntentResponse
/// [google.cloud.dialogflow.cx.v3.Form]: crate::model::Form
/// [google.cloud.dialogflow.cx.v3.Page]: crate::model::Page
/// [google.cloud.dialogflow.cx.v3.QueryResult]: crate::model::QueryResult
#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Fulfillment {
    /// The list of rich message responses to present to the user.
    pub messages: std::vec::Vec<crate::model::ResponseMessage>,

    /// The webhook to call.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/webhooks/<WebhookID>`.
    pub webhook: std::string::String,

    /// Whether Dialogflow should return currently queued fulfillment response
    /// messages in streaming APIs. If a webhook is specified, it happens before
    /// Dialogflow invokes webhook.
    /// Warning:
    ///
    /// ) This flag only affects streaming API. Responses are still queued
    ///   and returned once in non-streaming API.
    /// ) The flag can be enabled in any fulfillment but only the first 3 partial
    ///   responses will be returned. You may only want to apply it to fulfillments
    ///   that have slow webhooks.
    pub return_partial_responses: bool,

    /// The value of this field will be populated in the
    /// [WebhookRequest][google.cloud.dialogflow.cx.v3.WebhookRequest]
    /// `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is
    /// called.
    /// The tag is typically used by the webhook service to identify which
    /// fulfillment is being called, but it could be used for other purposes.
    /// This field is required if `webhook` is specified.
    ///
    /// [google.cloud.dialogflow.cx.v3.WebhookRequest]: crate::model::WebhookRequest
    pub tag: std::string::String,

    /// Set parameter values before executing the webhook.
    pub set_parameter_actions: std::vec::Vec<crate::model::fulfillment::SetParameterAction>,

    /// Conditional cases for this fulfillment.
    pub conditional_cases: std::vec::Vec<crate::model::fulfillment::ConditionalCases>,

    /// Hierarchical advanced settings for this fulfillment. The settings exposed
    /// at the lower level overrides the settings exposed at the higher level.
    pub advanced_settings: std::option::Option<crate::model::AdvancedSettings>,

    /// If the flag is true, the agent will utilize LLM to generate a text
    /// response. If LLM generation fails, the defined
    /// [responses][google.cloud.dialogflow.cx.v3.Fulfillment.messages] in the
    /// fulfillment will be respected. This flag is only useful for fulfillments
    /// associated with no-match event handlers.
    ///
    /// [google.cloud.dialogflow.cx.v3.Fulfillment.messages]: crate::model::Fulfillment::messages
    pub enable_generative_fallback: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl Fulfillment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [messages][crate::model::Fulfillment::messages].
    pub fn set_messages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResponseMessage>,
    {
        use std::iter::Iterator;
        self.messages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [webhook][crate::model::Fulfillment::webhook].
    pub fn set_webhook<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.webhook = v.into();
        self
    }

    /// Sets the value of [return_partial_responses][crate::model::Fulfillment::return_partial_responses].
    pub fn set_return_partial_responses<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.return_partial_responses = v.into();
        self
    }

    /// Sets the value of [tag][crate::model::Fulfillment::tag].
    pub fn set_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag = v.into();
        self
    }

    /// Sets the value of [set_parameter_actions][crate::model::Fulfillment::set_parameter_actions].
    pub fn set_set_parameter_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::fulfillment::SetParameterAction>,
    {
        use std::iter::Iterator;
        self.set_parameter_actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [conditional_cases][crate::model::Fulfillment::conditional_cases].
    pub fn set_conditional_cases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::fulfillment::ConditionalCases>,
    {
        use std::iter::Iterator;
        self.conditional_cases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [advanced_settings][crate::model::Fulfillment::advanced_settings].
    pub fn set_advanced_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedSettings>,
    {
        self.advanced_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [advanced_settings][crate::model::Fulfillment::advanced_settings].
    pub fn set_or_clear_advanced_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedSettings>,
    {
        self.advanced_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_generative_fallback][crate::model::Fulfillment::enable_generative_fallback].
    pub fn set_enable_generative_fallback<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_generative_fallback = v.into();
        self
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl wkt::message::Message for Fulfillment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.Fulfillment"
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Fulfillment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __messages,
            __webhook,
            __return_partial_responses,
            __tag,
            __set_parameter_actions,
            __conditional_cases,
            __advanced_settings,
            __enable_generative_fallback,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Fulfillment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "messages" => Ok(__FieldTag::__messages),
                            "webhook" => Ok(__FieldTag::__webhook),
                            "returnPartialResponses" => Ok(__FieldTag::__return_partial_responses),
                            "return_partial_responses" => {
                                Ok(__FieldTag::__return_partial_responses)
                            }
                            "tag" => Ok(__FieldTag::__tag),
                            "setParameterActions" => Ok(__FieldTag::__set_parameter_actions),
                            "set_parameter_actions" => Ok(__FieldTag::__set_parameter_actions),
                            "conditionalCases" => Ok(__FieldTag::__conditional_cases),
                            "conditional_cases" => Ok(__FieldTag::__conditional_cases),
                            "advancedSettings" => Ok(__FieldTag::__advanced_settings),
                            "advanced_settings" => Ok(__FieldTag::__advanced_settings),
                            "enableGenerativeFallback" => {
                                Ok(__FieldTag::__enable_generative_fallback)
                            }
                            "enable_generative_fallback" => {
                                Ok(__FieldTag::__enable_generative_fallback)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Fulfillment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Fulfillment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__messages => {
                            if !fields.insert(__FieldTag::__messages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for messages",
                                ));
                            }
                            result.messages =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ResponseMessage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__webhook => {
                            if !fields.insert(__FieldTag::__webhook) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook",
                                ));
                            }
                            result.webhook = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__return_partial_responses => {
                            if !fields.insert(__FieldTag::__return_partial_responses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for return_partial_responses",
                                ));
                            }
                            result.return_partial_responses = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tag => {
                            if !fields.insert(__FieldTag::__tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag",
                                ));
                            }
                            result.tag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__set_parameter_actions => {
                            if !fields.insert(__FieldTag::__set_parameter_actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for set_parameter_actions",
                                ));
                            }
                            result.set_parameter_actions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::fulfillment::SetParameterAction>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conditional_cases => {
                            if !fields.insert(__FieldTag::__conditional_cases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditional_cases",
                                ));
                            }
                            result.conditional_cases = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::fulfillment::ConditionalCases>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__advanced_settings => {
                            if !fields.insert(__FieldTag::__advanced_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advanced_settings",
                                ));
                            }
                            result.advanced_settings = map
                                .next_value::<std::option::Option<crate::model::AdvancedSettings>>(
                                )?;
                        }
                        __FieldTag::__enable_generative_fallback => {
                            if !fields.insert(__FieldTag::__enable_generative_fallback) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_generative_fallback",
                                ));
                            }
                            result.enable_generative_fallback = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for Fulfillment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.messages.is_empty() {
            state.serialize_entry("messages", &self.messages)?;
        }
        if !self.webhook.is_empty() {
            state.serialize_entry("webhook", &self.webhook)?;
        }
        if !wkt::internal::is_default(&self.return_partial_responses) {
            state.serialize_entry("returnPartialResponses", &self.return_partial_responses)?;
        }
        if !self.tag.is_empty() {
            state.serialize_entry("tag", &self.tag)?;
        }
        if !self.set_parameter_actions.is_empty() {
            state.serialize_entry("setParameterActions", &self.set_parameter_actions)?;
        }
        if !self.conditional_cases.is_empty() {
            state.serialize_entry("conditionalCases", &self.conditional_cases)?;
        }
        if self.advanced_settings.is_some() {
            state.serialize_entry("advancedSettings", &self.advanced_settings)?;
        }
        if !wkt::internal::is_default(&self.enable_generative_fallback) {
            state.serialize_entry("enableGenerativeFallback", &self.enable_generative_fallback)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Fulfillment].
#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
pub mod fulfillment {
    #[allow(unused_imports)]
    use super::*;

    /// Setting a parameter value.
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetParameterAction {
        /// Display name of the parameter.
        pub parameter: std::string::String,

        /// The new value of the parameter. A null value clears the parameter.
        pub value: std::option::Option<wkt::Value>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl SetParameterAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [parameter][crate::model::fulfillment::SetParameterAction::parameter].
        pub fn set_parameter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.parameter = v.into();
            self
        }

        /// Sets the value of [value][crate::model::fulfillment::SetParameterAction::value].
        pub fn set_value<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Value>,
        {
            self.value = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [value][crate::model::fulfillment::SetParameterAction::value].
        pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Value>,
        {
            self.value = v.map(|x| x.into());
            self
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl wkt::message::Message for SetParameterAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Fulfillment.SetParameterAction"
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SetParameterAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __parameter,
                __value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SetParameterAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "parameter" => Ok(__FieldTag::__parameter),
                                "value" => Ok(__FieldTag::__value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SetParameterAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SetParameterAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__parameter => {
                                if !fields.insert(__FieldTag::__parameter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parameter",
                                    ));
                                }
                                result.parameter = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                result.value = map
                                    .next_value::<std::option::Option<wkt::Value>>()?
                                    .or(Some(wkt::Value::Null));
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for SetParameterAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.parameter.is_empty() {
                state.serialize_entry("parameter", &self.parameter)?;
            }
            if self.value.is_some() {
                state.serialize_entry("value", &self.value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A list of cascading if-else conditions. Cases are mutually exclusive.
    /// The first one with a matching condition is selected, all the rest ignored.
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConditionalCases {
        /// A list of cascading if-else conditions.
        pub cases: std::vec::Vec<crate::model::fulfillment::conditional_cases::Case>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl ConditionalCases {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cases][crate::model::fulfillment::ConditionalCases::cases].
        pub fn set_cases<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::fulfillment::conditional_cases::Case>,
        {
            use std::iter::Iterator;
            self.cases = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl wkt::message::Message for ConditionalCases {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Fulfillment.ConditionalCases"
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConditionalCases {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cases,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConditionalCases")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "cases" => Ok(__FieldTag::__cases),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConditionalCases;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConditionalCases")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cases => {
                                if !fields.insert(__FieldTag::__cases) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cases",
                                    ));
                                }
                                result.cases = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::fulfillment::conditional_cases::Case,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for ConditionalCases {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.cases.is_empty() {
                state.serialize_entry("cases", &self.cases)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ConditionalCases].
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    pub mod conditional_cases {
        #[allow(unused_imports)]
        use super::*;

        /// Each case has a Boolean condition. When it is evaluated to be True, the
        /// corresponding messages will be selected and evaluated recursively.
        #[cfg(any(
            feature = "flows",
            feature = "pages",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Case {
            /// The condition to activate and select this case. Empty means the
            /// condition is always true. The condition is evaluated against [form
            /// parameters][Form.parameters] or [session
            /// parameters][SessionInfo.parameters].
            ///
            /// See the [conditions
            /// reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
            ///
            /// [Form.parameters]: crate::model::Form::parameters
            /// [SessionInfo.parameters]: crate::model::SessionInfo::parameters
            pub condition: std::string::String,

            /// A list of case content.
            pub case_content:
                std::vec::Vec<crate::model::fulfillment::conditional_cases::case::CaseContent>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "flows",
            feature = "pages",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
        ))]
        impl Case {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [condition][crate::model::fulfillment::conditional_cases::Case::condition].
            pub fn set_condition<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.condition = v.into();
                self
            }

            /// Sets the value of [case_content][crate::model::fulfillment::conditional_cases::Case::case_content].
            pub fn set_case_content<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::fulfillment::conditional_cases::case::CaseContent,
                    >,
            {
                use std::iter::Iterator;
                self.case_content = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(any(
            feature = "flows",
            feature = "pages",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
        ))]
        impl wkt::message::Message for Case {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.cx.v3.Fulfillment.ConditionalCases.Case"
            }
        }

        #[cfg(any(
            feature = "flows",
            feature = "pages",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Case {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __condition,
                    __case_content,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Case")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "condition" => Ok(__FieldTag::__condition),
                                    "caseContent" => Ok(__FieldTag::__case_content),
                                    "case_content" => Ok(__FieldTag::__case_content),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Case;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Case")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__condition => {
                                    if !fields.insert(__FieldTag::__condition) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for condition",
                                            ),
                                        );
                                    }
                                    result.condition = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__case_content => {
                                    if !fields.insert(__FieldTag::__case_content) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for case_content",
                                            ),
                                        );
                                    }
                                    result.case_content = map.next_value::<std::option::Option<std::vec::Vec<crate::model::fulfillment::conditional_cases::case::CaseContent>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "flows",
            feature = "pages",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for Case {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.condition.is_empty() {
                    state.serialize_entry("condition", &self.condition)?;
                }
                if !self.case_content.is_empty() {
                    state.serialize_entry("caseContent", &self.case_content)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [Case].
        #[cfg(any(
            feature = "flows",
            feature = "pages",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
        ))]
        pub mod case {
            #[allow(unused_imports)]
            use super::*;

            /// The list of messages or conditional cases to activate for this case.
            #[cfg(any(
                feature = "flows",
                feature = "pages",
                feature = "sessions",
                feature = "test-cases",
                feature = "transition-route-groups",
            ))]
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct CaseContent {

                /// Either a message is returned or additional cases to be evaluated.
                pub cases_or_message: std::option::Option<crate::model::fulfillment::conditional_cases::case::case_content::CasesOrMessage>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(any(
                feature = "flows",
                feature = "pages",
                feature = "sessions",
                feature = "test-cases",
                feature = "transition-route-groups",
            ))]
            impl CaseContent {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [cases_or_message][crate::model::fulfillment::conditional_cases::case::CaseContent::cases_or_message].
                ///
                /// Note that all the setters affecting `cases_or_message` are mutually
                /// exclusive.
                pub fn set_cases_or_message<T: std::convert::Into<std::option::Option<crate::model::fulfillment::conditional_cases::case::case_content::CasesOrMessage>>>(mut self, v: T) -> Self
                {
                    self.cases_or_message = v.into();
                    self
                }

                /// The value of [cases_or_message][crate::model::fulfillment::conditional_cases::case::CaseContent::cases_or_message]
                /// if it holds a `Message`, `None` if the field is not set or
                /// holds a different branch.
                pub fn message(
                    &self,
                ) -> std::option::Option<&std::boxed::Box<crate::model::ResponseMessage>>
                {
                    #[allow(unreachable_patterns)]
                    self.cases_or_message.as_ref().and_then(|v| match v {
                        crate::model::fulfillment::conditional_cases::case::case_content::CasesOrMessage::Message(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [cases_or_message][crate::model::fulfillment::conditional_cases::case::CaseContent::cases_or_message]
                /// to hold a `Message`.
                ///
                /// Note that all the setters affecting `cases_or_message` are
                /// mutually exclusive.
                pub fn set_message<
                    T: std::convert::Into<std::boxed::Box<crate::model::ResponseMessage>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.cases_or_message = std::option::Option::Some(
                        crate::model::fulfillment::conditional_cases::case::case_content::CasesOrMessage::Message(
                            v.into()
                        )
                    );
                    self
                }

                /// The value of [cases_or_message][crate::model::fulfillment::conditional_cases::case::CaseContent::cases_or_message]
                /// if it holds a `AdditionalCases`, `None` if the field is not set or
                /// holds a different branch.
                pub fn additional_cases(
                    &self,
                ) -> std::option::Option<
                    &std::boxed::Box<crate::model::fulfillment::ConditionalCases>,
                > {
                    #[allow(unreachable_patterns)]
                    self.cases_or_message.as_ref().and_then(|v| match v {
                        crate::model::fulfillment::conditional_cases::case::case_content::CasesOrMessage::AdditionalCases(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [cases_or_message][crate::model::fulfillment::conditional_cases::case::CaseContent::cases_or_message]
                /// to hold a `AdditionalCases`.
                ///
                /// Note that all the setters affecting `cases_or_message` are
                /// mutually exclusive.
                pub fn set_additional_cases<
                    T: std::convert::Into<
                            std::boxed::Box<crate::model::fulfillment::ConditionalCases>,
                        >,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.cases_or_message = std::option::Option::Some(
                        crate::model::fulfillment::conditional_cases::case::case_content::CasesOrMessage::AdditionalCases(
                            v.into()
                        )
                    );
                    self
                }
            }

            #[cfg(any(
                feature = "flows",
                feature = "pages",
                feature = "sessions",
                feature = "test-cases",
                feature = "transition-route-groups",
            ))]
            impl wkt::message::Message for CaseContent {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.dialogflow.cx.v3.Fulfillment.ConditionalCases.Case.CaseContent"
                }
            }

            #[cfg(any(
                feature = "flows",
                feature = "pages",
                feature = "sessions",
                feature = "test-cases",
                feature = "transition-route-groups",
            ))]
            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for CaseContent {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __message,
                        __additional_cases,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for CaseContent")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "message" => Ok(__FieldTag::__message),
                                        "additionalCases" => Ok(__FieldTag::__additional_cases),
                                        "additional_cases" => Ok(__FieldTag::__additional_cases),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = CaseContent;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct CaseContent")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__message => {
                                        if !fields.insert(__FieldTag::__message) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for message",
                                                ),
                                            );
                                        }
                                        if result.cases_or_message.is_some() {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for `cases_or_message`, a oneof with full ID .google.cloud.dialogflow.cx.v3.Fulfillment.ConditionalCases.Case.CaseContent.message, latest field was message",
                                                ),
                                            );
                                        }
                                        result.cases_or_message = std::option::Option::Some(
                                            crate::model::fulfillment::conditional_cases::case::case_content::CasesOrMessage::Message(
                                                map.next_value::<std::option::Option<std::boxed::Box<crate::model::ResponseMessage>>>()?.unwrap_or_default()
                                            ),
                                        );
                                    }
                                    __FieldTag::__additional_cases => {
                                        if !fields.insert(__FieldTag::__additional_cases) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for additional_cases",
                                                ),
                                            );
                                        }
                                        if result.cases_or_message.is_some() {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for `cases_or_message`, a oneof with full ID .google.cloud.dialogflow.cx.v3.Fulfillment.ConditionalCases.Case.CaseContent.additional_cases, latest field was additionalCases",
                                                ),
                                            );
                                        }
                                        result.cases_or_message = std::option::Option::Some(
                                            crate::model::fulfillment::conditional_cases::case::case_content::CasesOrMessage::AdditionalCases(
                                                map.next_value::<std::option::Option<std::boxed::Box<crate::model::fulfillment::ConditionalCases>>>()?.unwrap_or_default()
                                            ),
                                        );
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[cfg(any(
                feature = "flows",
                feature = "pages",
                feature = "sessions",
                feature = "test-cases",
                feature = "transition-route-groups",
            ))]
            #[doc(hidden)]
            impl serde::ser::Serialize for CaseContent {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if let Some(value) = self.message() {
                        state.serialize_entry("message", value)?;
                    }
                    if let Some(value) = self.additional_cases() {
                        state.serialize_entry("additionalCases", value)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Defines additional types related to [CaseContent].
            #[cfg(any(
                feature = "flows",
                feature = "pages",
                feature = "sessions",
                feature = "test-cases",
                feature = "transition-route-groups",
            ))]
            pub mod case_content {
                #[allow(unused_imports)]
                use super::*;

                /// Either a message is returned or additional cases to be evaluated.
                #[cfg(any(
                    feature = "flows",
                    feature = "pages",
                    feature = "sessions",
                    feature = "test-cases",
                    feature = "transition-route-groups",
                ))]
                #[derive(Clone, Debug, PartialEq)]
                #[non_exhaustive]
                pub enum CasesOrMessage {
                    /// Returned message.
                    Message(std::boxed::Box<crate::model::ResponseMessage>),
                    /// Additional cases to be evaluated.
                    AdditionalCases(std::boxed::Box<crate::model::fulfillment::ConditionalCases>),
                }
            }
        }
    }
}

/// Google Cloud Storage location for a Dialogflow operation that writes or
/// exports objects (e.g. exported agent or transcripts) outside of Dialogflow.
#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsDestination {
    /// Required. The Google Cloud Storage URI for the exported objects. A URI is
    /// of the form: `gs://bucket/object-name-or-prefix` Whether a full object
    /// name, or just a prefix, its usage depends on the Dialogflow operation.
    pub uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl GcsDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::GcsDestination::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }
}

#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl wkt::message::Message for GcsDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GcsDestination"
    }
}

#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsDestination {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsDestination")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsDestination;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsDestination")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "agents",
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for GcsDestination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Settings for Generative AI.
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerativeSettings {
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/generativeSettings`.
    pub name: std::string::String,

    /// Settings for Generative Fallback.
    pub fallback_settings: std::option::Option<crate::model::generative_settings::FallbackSettings>,

    /// Settings for Generative Safety.
    pub generative_safety_settings: std::option::Option<crate::model::SafetySettings>,

    /// Settings for knowledge connector.
    pub knowledge_connector_settings:
        std::option::Option<crate::model::generative_settings::KnowledgeConnectorSettings>,

    /// Language for this settings.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl GenerativeSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GenerativeSettings::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [fallback_settings][crate::model::GenerativeSettings::fallback_settings].
    pub fn set_fallback_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::generative_settings::FallbackSettings>,
    {
        self.fallback_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fallback_settings][crate::model::GenerativeSettings::fallback_settings].
    pub fn set_or_clear_fallback_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::generative_settings::FallbackSettings>,
    {
        self.fallback_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [generative_safety_settings][crate::model::GenerativeSettings::generative_safety_settings].
    pub fn set_generative_safety_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SafetySettings>,
    {
        self.generative_safety_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [generative_safety_settings][crate::model::GenerativeSettings::generative_safety_settings].
    pub fn set_or_clear_generative_safety_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SafetySettings>,
    {
        self.generative_safety_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [knowledge_connector_settings][crate::model::GenerativeSettings::knowledge_connector_settings].
    pub fn set_knowledge_connector_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::generative_settings::KnowledgeConnectorSettings>,
    {
        self.knowledge_connector_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [knowledge_connector_settings][crate::model::GenerativeSettings::knowledge_connector_settings].
    pub fn set_or_clear_knowledge_connector_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::generative_settings::KnowledgeConnectorSettings>,
    {
        self.knowledge_connector_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::GenerativeSettings::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for GenerativeSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GenerativeSettings"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerativeSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __fallback_settings,
            __generative_safety_settings,
            __knowledge_connector_settings,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerativeSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "fallbackSettings" => Ok(__FieldTag::__fallback_settings),
                            "fallback_settings" => Ok(__FieldTag::__fallback_settings),
                            "generativeSafetySettings" => {
                                Ok(__FieldTag::__generative_safety_settings)
                            }
                            "generative_safety_settings" => {
                                Ok(__FieldTag::__generative_safety_settings)
                            }
                            "knowledgeConnectorSettings" => {
                                Ok(__FieldTag::__knowledge_connector_settings)
                            }
                            "knowledge_connector_settings" => {
                                Ok(__FieldTag::__knowledge_connector_settings)
                            }
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerativeSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerativeSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fallback_settings => {
                            if !fields.insert(__FieldTag::__fallback_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fallback_settings",
                                ));
                            }
                            result.fallback_settings = map.next_value::<std::option::Option<
                                crate::model::generative_settings::FallbackSettings,
                            >>()?;
                        }
                        __FieldTag::__generative_safety_settings => {
                            if !fields.insert(__FieldTag::__generative_safety_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generative_safety_settings",
                                ));
                            }
                            result.generative_safety_settings = map
                                .next_value::<std::option::Option<crate::model::SafetySettings>>(
                                )?;
                        }
                        __FieldTag::__knowledge_connector_settings => {
                            if !fields.insert(__FieldTag::__knowledge_connector_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for knowledge_connector_settings",
                                ));
                            }
                            result.knowledge_connector_settings = map
                                .next_value::<std::option::Option<
                                    crate::model::generative_settings::KnowledgeConnectorSettings,
                                >>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for GenerativeSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.fallback_settings.is_some() {
            state.serialize_entry("fallbackSettings", &self.fallback_settings)?;
        }
        if self.generative_safety_settings.is_some() {
            state.serialize_entry("generativeSafetySettings", &self.generative_safety_settings)?;
        }
        if self.knowledge_connector_settings.is_some() {
            state.serialize_entry(
                "knowledgeConnectorSettings",
                &self.knowledge_connector_settings,
            )?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GenerativeSettings].
#[cfg(feature = "agents")]
pub mod generative_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Settings for Generative Fallback.
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FallbackSettings {
        /// Display name of the selected prompt.
        pub selected_prompt: std::string::String,

        /// Stored prompts that can be selected, for example default templates like
        /// "conservative" or "chatty", or user defined ones.
        pub prompt_templates:
            std::vec::Vec<crate::model::generative_settings::fallback_settings::PromptTemplate>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "agents")]
    impl FallbackSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [selected_prompt][crate::model::generative_settings::FallbackSettings::selected_prompt].
        pub fn set_selected_prompt<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.selected_prompt = v.into();
            self
        }

        /// Sets the value of [prompt_templates][crate::model::generative_settings::FallbackSettings::prompt_templates].
        pub fn set_prompt_templates<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::generative_settings::fallback_settings::PromptTemplate,
                >,
        {
            use std::iter::Iterator;
            self.prompt_templates = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "agents")]
    impl wkt::message::Message for FallbackSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.GenerativeSettings.FallbackSettings"
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FallbackSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __selected_prompt,
                __prompt_templates,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FallbackSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "selectedPrompt" => Ok(__FieldTag::__selected_prompt),
                                "selected_prompt" => Ok(__FieldTag::__selected_prompt),
                                "promptTemplates" => Ok(__FieldTag::__prompt_templates),
                                "prompt_templates" => Ok(__FieldTag::__prompt_templates),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FallbackSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FallbackSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__selected_prompt => {
                                if !fields.insert(__FieldTag::__selected_prompt) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for selected_prompt",
                                    ));
                                }
                                result.selected_prompt = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__prompt_templates => {
                                if !fields.insert(__FieldTag::__prompt_templates) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for prompt_templates",
                                    ));
                                }
                                result.prompt_templates = map.next_value::<std::option::Option<std::vec::Vec<crate::model::generative_settings::fallback_settings::PromptTemplate>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl serde::ser::Serialize for FallbackSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.selected_prompt.is_empty() {
                state.serialize_entry("selectedPrompt", &self.selected_prompt)?;
            }
            if !self.prompt_templates.is_empty() {
                state.serialize_entry("promptTemplates", &self.prompt_templates)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [FallbackSettings].
    #[cfg(feature = "agents")]
    pub mod fallback_settings {
        #[allow(unused_imports)]
        use super::*;

        /// Prompt template.
        #[cfg(feature = "agents")]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct PromptTemplate {
            /// Prompt name.
            pub display_name: std::string::String,

            /// Prompt text that is sent to a LLM on no-match default, placeholders are
            /// filled downstream. For example: "Here is a conversation $conversation,
            /// a response is: "
            pub prompt_text: std::string::String,

            /// If the flag is true, the prompt is frozen and cannot be modified by
            /// users.
            pub frozen: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "agents")]
        impl PromptTemplate {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [display_name][crate::model::generative_settings::fallback_settings::PromptTemplate::display_name].
            pub fn set_display_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.display_name = v.into();
                self
            }

            /// Sets the value of [prompt_text][crate::model::generative_settings::fallback_settings::PromptTemplate::prompt_text].
            pub fn set_prompt_text<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.prompt_text = v.into();
                self
            }

            /// Sets the value of [frozen][crate::model::generative_settings::fallback_settings::PromptTemplate::frozen].
            pub fn set_frozen<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.frozen = v.into();
                self
            }
        }

        #[cfg(feature = "agents")]
        impl wkt::message::Message for PromptTemplate {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.cx.v3.GenerativeSettings.FallbackSettings.PromptTemplate"
            }
        }

        #[cfg(feature = "agents")]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for PromptTemplate {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __display_name,
                    __prompt_text,
                    __frozen,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for PromptTemplate")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "displayName" => Ok(__FieldTag::__display_name),
                                    "display_name" => Ok(__FieldTag::__display_name),
                                    "promptText" => Ok(__FieldTag::__prompt_text),
                                    "prompt_text" => Ok(__FieldTag::__prompt_text),
                                    "frozen" => Ok(__FieldTag::__frozen),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = PromptTemplate;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct PromptTemplate")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__display_name => {
                                    if !fields.insert(__FieldTag::__display_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for display_name",
                                            ),
                                        );
                                    }
                                    result.display_name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__prompt_text => {
                                    if !fields.insert(__FieldTag::__prompt_text) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for prompt_text",
                                            ),
                                        );
                                    }
                                    result.prompt_text = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__frozen => {
                                    if !fields.insert(__FieldTag::__frozen) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for frozen"),
                                        );
                                    }
                                    result.frozen = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(feature = "agents")]
        #[doc(hidden)]
        impl serde::ser::Serialize for PromptTemplate {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.display_name.is_empty() {
                    state.serialize_entry("displayName", &self.display_name)?;
                }
                if !self.prompt_text.is_empty() {
                    state.serialize_entry("promptText", &self.prompt_text)?;
                }
                if !wkt::internal::is_default(&self.frozen) {
                    state.serialize_entry("frozen", &self.frozen)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Settings for knowledge connector. These parameters are used for LLM prompt
    /// like "You are \<agent\>. You are a helpful and verbose <agent_identity> at
    /// \<business\>, <business_description>. Your task is to help humans on
    /// <agent_scope>".
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct KnowledgeConnectorSettings {
        /// Name of the company, organization or other entity that the agent
        /// represents. Used for knowledge connector LLM prompt and for knowledge
        /// search.
        pub business: std::string::String,

        /// Name of the virtual agent. Used for LLM prompt. Can be left empty.
        pub agent: std::string::String,

        /// Identity of the agent, e.g. "virtual agent", "AI assistant".
        pub agent_identity: std::string::String,

        /// Company description, used for LLM prompt, e.g. "a family company selling
        /// freshly roasted coffee beans".
        pub business_description: std::string::String,

        /// Agent scope, e.g. "Example company website", "internal Example
        /// company website for employees", "manual of car owner".
        pub agent_scope: std::string::String,

        /// Whether to disable fallback to Data Store search results (in case the LLM
        /// couldn't pick a proper answer). Per default the feature is enabled.
        pub disable_data_store_fallback: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "agents")]
    impl KnowledgeConnectorSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [business][crate::model::generative_settings::KnowledgeConnectorSettings::business].
        pub fn set_business<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.business = v.into();
            self
        }

        /// Sets the value of [agent][crate::model::generative_settings::KnowledgeConnectorSettings::agent].
        pub fn set_agent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.agent = v.into();
            self
        }

        /// Sets the value of [agent_identity][crate::model::generative_settings::KnowledgeConnectorSettings::agent_identity].
        pub fn set_agent_identity<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.agent_identity = v.into();
            self
        }

        /// Sets the value of [business_description][crate::model::generative_settings::KnowledgeConnectorSettings::business_description].
        pub fn set_business_description<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.business_description = v.into();
            self
        }

        /// Sets the value of [agent_scope][crate::model::generative_settings::KnowledgeConnectorSettings::agent_scope].
        pub fn set_agent_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.agent_scope = v.into();
            self
        }

        /// Sets the value of [disable_data_store_fallback][crate::model::generative_settings::KnowledgeConnectorSettings::disable_data_store_fallback].
        pub fn set_disable_data_store_fallback<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.disable_data_store_fallback = v.into();
            self
        }
    }

    #[cfg(feature = "agents")]
    impl wkt::message::Message for KnowledgeConnectorSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.GenerativeSettings.KnowledgeConnectorSettings"
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for KnowledgeConnectorSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __business,
                __agent,
                __agent_identity,
                __business_description,
                __agent_scope,
                __disable_data_store_fallback,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for KnowledgeConnectorSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "business" => Ok(__FieldTag::__business),
                                "agent" => Ok(__FieldTag::__agent),
                                "agentIdentity" => Ok(__FieldTag::__agent_identity),
                                "agent_identity" => Ok(__FieldTag::__agent_identity),
                                "businessDescription" => Ok(__FieldTag::__business_description),
                                "business_description" => Ok(__FieldTag::__business_description),
                                "agentScope" => Ok(__FieldTag::__agent_scope),
                                "agent_scope" => Ok(__FieldTag::__agent_scope),
                                "disableDataStoreFallback" => {
                                    Ok(__FieldTag::__disable_data_store_fallback)
                                }
                                "disable_data_store_fallback" => {
                                    Ok(__FieldTag::__disable_data_store_fallback)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = KnowledgeConnectorSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct KnowledgeConnectorSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__business => {
                                if !fields.insert(__FieldTag::__business) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for business",
                                    ));
                                }
                                result.business = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__agent => {
                                if !fields.insert(__FieldTag::__agent) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for agent",
                                    ));
                                }
                                result.agent = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__agent_identity => {
                                if !fields.insert(__FieldTag::__agent_identity) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for agent_identity",
                                    ));
                                }
                                result.agent_identity = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__business_description => {
                                if !fields.insert(__FieldTag::__business_description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for business_description",
                                    ));
                                }
                                result.business_description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__agent_scope => {
                                if !fields.insert(__FieldTag::__agent_scope) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for agent_scope",
                                    ));
                                }
                                result.agent_scope = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__disable_data_store_fallback => {
                                if !fields.insert(__FieldTag::__disable_data_store_fallback) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for disable_data_store_fallback",
                                    ));
                                }
                                result.disable_data_store_fallback = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl serde::ser::Serialize for KnowledgeConnectorSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.business.is_empty() {
                state.serialize_entry("business", &self.business)?;
            }
            if !self.agent.is_empty() {
                state.serialize_entry("agent", &self.agent)?;
            }
            if !self.agent_identity.is_empty() {
                state.serialize_entry("agentIdentity", &self.agent_identity)?;
            }
            if !self.business_description.is_empty() {
                state.serialize_entry("businessDescription", &self.business_description)?;
            }
            if !self.agent_scope.is_empty() {
                state.serialize_entry("agentScope", &self.agent_scope)?;
            }
            if !wkt::internal::is_default(&self.disable_data_store_fallback) {
                state.serialize_entry(
                    "disableDataStoreFallback",
                    &self.disable_data_store_fallback,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Generators contain prompt to be sent to the LLM model to generate text. The
/// prompt can contain parameters which will be resolved before calling the
/// model. It can optionally contain banned phrases to ensure the model responses
/// are safe.
#[cfg(feature = "generators")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Generator {
    /// The unique identifier of the generator.
    /// Must be set for the
    /// [Generators.UpdateGenerator][google.cloud.dialogflow.cx.v3.Generators.UpdateGenerator]
    /// method. [Generators.CreateGenerate][] populates the name automatically.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/generators/<GeneratorID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Generators.UpdateGenerator]: crate::client::Generators::update_generator
    pub name: std::string::String,

    /// Required. The human-readable name of the generator, unique within the
    /// agent. The prompt contains pre-defined parameters such as $conversation,
    /// $last-user-utterance, etc. populated by Dialogflow. It can also contain
    /// custom placeholders which will be resolved during fulfillment.
    pub display_name: std::string::String,

    /// Required. Prompt for the LLM model.
    pub prompt_text: std::option::Option<crate::model::Phrase>,

    /// Optional. List of custom placeholders in the prompt text.
    pub placeholders: std::vec::Vec<crate::model::generator::Placeholder>,

    /// Parameters passed to the LLM to configure its behavior.
    pub model_parameter: std::option::Option<crate::model::generator::ModelParameter>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "generators")]
impl Generator {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Generator::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Generator::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [prompt_text][crate::model::Generator::prompt_text].
    pub fn set_prompt_text<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Phrase>,
    {
        self.prompt_text = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [prompt_text][crate::model::Generator::prompt_text].
    pub fn set_or_clear_prompt_text<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Phrase>,
    {
        self.prompt_text = v.map(|x| x.into());
        self
    }

    /// Sets the value of [placeholders][crate::model::Generator::placeholders].
    pub fn set_placeholders<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::generator::Placeholder>,
    {
        use std::iter::Iterator;
        self.placeholders = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [model_parameter][crate::model::Generator::model_parameter].
    pub fn set_model_parameter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::generator::ModelParameter>,
    {
        self.model_parameter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [model_parameter][crate::model::Generator::model_parameter].
    pub fn set_or_clear_model_parameter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::generator::ModelParameter>,
    {
        self.model_parameter = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "generators")]
impl wkt::message::Message for Generator {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.Generator"
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Generator {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __prompt_text,
            __placeholders,
            __model_parameter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Generator")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "promptText" => Ok(__FieldTag::__prompt_text),
                            "prompt_text" => Ok(__FieldTag::__prompt_text),
                            "placeholders" => Ok(__FieldTag::__placeholders),
                            "modelParameter" => Ok(__FieldTag::__model_parameter),
                            "model_parameter" => Ok(__FieldTag::__model_parameter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Generator;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Generator")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__prompt_text => {
                            if !fields.insert(__FieldTag::__prompt_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for prompt_text",
                                ));
                            }
                            result.prompt_text =
                                map.next_value::<std::option::Option<crate::model::Phrase>>()?;
                        }
                        __FieldTag::__placeholders => {
                            if !fields.insert(__FieldTag::__placeholders) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for placeholders",
                                ));
                            }
                            result.placeholders = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::generator::Placeholder>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_parameter => {
                            if !fields.insert(__FieldTag::__model_parameter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_parameter",
                                ));
                            }
                            result.model_parameter = map.next_value::<std::option::Option<crate::model::generator::ModelParameter>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for Generator {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.prompt_text.is_some() {
            state.serialize_entry("promptText", &self.prompt_text)?;
        }
        if !self.placeholders.is_empty() {
            state.serialize_entry("placeholders", &self.placeholders)?;
        }
        if self.model_parameter.is_some() {
            state.serialize_entry("modelParameter", &self.model_parameter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Generator].
#[cfg(feature = "generators")]
pub mod generator {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a custom placeholder in the prompt text.
    #[cfg(feature = "generators")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Placeholder {
        /// Unique ID used to map custom placeholder to parameters in fulfillment.
        pub id: std::string::String,

        /// Custom placeholder value in the prompt text.
        pub name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "generators")]
    impl Placeholder {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::generator::Placeholder::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [name][crate::model::generator::Placeholder::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }
    }

    #[cfg(feature = "generators")]
    impl wkt::message::Message for Placeholder {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Generator.Placeholder"
        }
    }

    #[cfg(feature = "generators")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Placeholder {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Placeholder")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "name" => Ok(__FieldTag::__name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Placeholder;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Placeholder")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "generators")]
    #[doc(hidden)]
    impl serde::ser::Serialize for Placeholder {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Parameters to be passed to the LLM. If not set, default values will be
    /// used.
    #[cfg(feature = "generators")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ModelParameter {
        /// The temperature used for sampling. Temperature sampling occurs after both
        /// topP and topK have been applied.
        /// Valid range: [0.0, 1.0]
        /// Low temperature = less random. High temperature = more random.
        pub temperature: std::option::Option<f32>,

        /// The maximum number of tokens to generate.
        pub max_decode_steps: std::option::Option<i32>,

        /// If set, only the tokens comprising the top top_p probability mass are
        /// considered. If both top_p and top_k are
        /// set, top_p will be used for further refining candidates selected with
        /// top_k.
        /// Valid range: (0.0, 1.0].
        /// Small topP = less random. Large topP = more random.
        pub top_p: std::option::Option<f32>,

        /// If set, the sampling process in each step is limited to the top_k tokens
        /// with highest probabilities.
        /// Valid range: [1, 40] or 1000+.
        /// Small topK = less random. Large topK = more random.
        pub top_k: std::option::Option<i32>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "generators")]
    impl ModelParameter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [temperature][crate::model::generator::ModelParameter::temperature].
        pub fn set_temperature<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<f32>,
        {
            self.temperature = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [temperature][crate::model::generator::ModelParameter::temperature].
        pub fn set_or_clear_temperature<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<f32>,
        {
            self.temperature = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_decode_steps][crate::model::generator::ModelParameter::max_decode_steps].
        pub fn set_max_decode_steps<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.max_decode_steps = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_decode_steps][crate::model::generator::ModelParameter::max_decode_steps].
        pub fn set_or_clear_max_decode_steps<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.max_decode_steps = v.map(|x| x.into());
            self
        }

        /// Sets the value of [top_p][crate::model::generator::ModelParameter::top_p].
        pub fn set_top_p<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<f32>,
        {
            self.top_p = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [top_p][crate::model::generator::ModelParameter::top_p].
        pub fn set_or_clear_top_p<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<f32>,
        {
            self.top_p = v.map(|x| x.into());
            self
        }

        /// Sets the value of [top_k][crate::model::generator::ModelParameter::top_k].
        pub fn set_top_k<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.top_k = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [top_k][crate::model::generator::ModelParameter::top_k].
        pub fn set_or_clear_top_k<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.top_k = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "generators")]
    impl wkt::message::Message for ModelParameter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Generator.ModelParameter"
        }
    }

    #[cfg(feature = "generators")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ModelParameter {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __temperature,
                __max_decode_steps,
                __top_p,
                __top_k,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ModelParameter")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "temperature" => Ok(__FieldTag::__temperature),
                                "maxDecodeSteps" => Ok(__FieldTag::__max_decode_steps),
                                "max_decode_steps" => Ok(__FieldTag::__max_decode_steps),
                                "topP" => Ok(__FieldTag::__top_p),
                                "top_p" => Ok(__FieldTag::__top_p),
                                "topK" => Ok(__FieldTag::__top_k),
                                "top_k" => Ok(__FieldTag::__top_k),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ModelParameter;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ModelParameter")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__temperature => {
                                if !fields.insert(__FieldTag::__temperature) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for temperature",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.temperature = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__max_decode_steps => {
                                if !fields.insert(__FieldTag::__max_decode_steps) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_decode_steps",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_decode_steps = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__top_p => {
                                if !fields.insert(__FieldTag::__top_p) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for top_p",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.top_p = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__top_k => {
                                if !fields.insert(__FieldTag::__top_k) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for top_k",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.top_k = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "generators")]
    #[doc(hidden)]
    impl serde::ser::Serialize for ModelParameter {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.temperature.is_some() {
                struct __With<'a>(&'a std::option::Option<f32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("temperature", &__With(&self.temperature))?;
            }
            if self.max_decode_steps.is_some() {
                struct __With<'a>(&'a std::option::Option<i32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("maxDecodeSteps", &__With(&self.max_decode_steps))?;
            }
            if self.top_p.is_some() {
                struct __With<'a>(&'a std::option::Option<f32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("topP", &__With(&self.top_p))?;
            }
            if self.top_k.is_some() {
                struct __With<'a>(&'a std::option::Option<i32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("topK", &__With(&self.top_k))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Text input which can be used for prompt or banned phrases.
#[cfg(feature = "generators")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Phrase {
    /// Required. Text input which can be used for prompt or banned phrases.
    pub text: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "generators")]
impl Phrase {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [text][crate::model::Phrase::text].
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.text = v.into();
        self
    }
}

#[cfg(feature = "generators")]
impl wkt::message::Message for Phrase {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.Phrase"
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Phrase {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Phrase")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Phrase;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Phrase")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            result.text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for Phrase {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Generators.ListGenerators][google.cloud.dialogflow.cx.v3.Generators.ListGenerators].
///
/// [google.cloud.dialogflow.cx.v3.Generators.ListGenerators]: crate::client::Generators::list_generators
#[cfg(feature = "generators")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGeneratorsRequest {
    /// Required. The agent to list all generators for.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// The language to list generators for.
    pub language_code: std::string::String,

    /// The maximum number of items to return in a single page. By default 100 and
    /// at most 1000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "generators")]
impl ListGeneratorsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGeneratorsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::ListGeneratorsRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGeneratorsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGeneratorsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "generators")]
impl wkt::message::Message for ListGeneratorsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListGeneratorsRequest"
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGeneratorsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __language_code,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGeneratorsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGeneratorsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGeneratorsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for ListGeneratorsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Generators.ListGenerators][google.cloud.dialogflow.cx.v3.Generators.ListGenerators].
///
/// [google.cloud.dialogflow.cx.v3.Generators.ListGenerators]: crate::client::Generators::list_generators
#[cfg(feature = "generators")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGeneratorsResponse {
    /// The list of generators. There will be a maximum number of items returned
    /// based on the page_size field in the request.
    pub generators: std::vec::Vec<crate::model::Generator>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "generators")]
impl ListGeneratorsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generators][crate::model::ListGeneratorsResponse::generators].
    pub fn set_generators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Generator>,
    {
        use std::iter::Iterator;
        self.generators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListGeneratorsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "generators")]
impl wkt::message::Message for ListGeneratorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListGeneratorsResponse"
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListGeneratorsResponse {
    type PageItem = crate::model::Generator;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.generators
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGeneratorsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generators,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGeneratorsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generators" => Ok(__FieldTag::__generators),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGeneratorsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGeneratorsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generators => {
                            if !fields.insert(__FieldTag::__generators) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generators",
                                ));
                            }
                            result.generators = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Generator>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for ListGeneratorsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.generators.is_empty() {
            state.serialize_entry("generators", &self.generators)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Generators.GetGenerator][google.cloud.dialogflow.cx.v3.Generators.GetGenerator].
///
/// [google.cloud.dialogflow.cx.v3.Generators.GetGenerator]: crate::client::Generators::get_generator
#[cfg(feature = "generators")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetGeneratorRequest {
    /// Required. The name of the generator.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/generators/<GeneratorID>`.
    pub name: std::string::String,

    /// The language to list generators for.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "generators")]
impl GetGeneratorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGeneratorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::GetGeneratorRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "generators")]
impl wkt::message::Message for GetGeneratorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetGeneratorRequest"
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetGeneratorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetGeneratorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetGeneratorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetGeneratorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for GetGeneratorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Generators.CreateGenerator][google.cloud.dialogflow.cx.v3.Generators.CreateGenerator].
///
/// [google.cloud.dialogflow.cx.v3.Generators.CreateGenerator]: crate::client::Generators::create_generator
#[cfg(feature = "generators")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateGeneratorRequest {
    /// Required. The agent to create a generator for.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// Required. The generator to create.
    pub generator: std::option::Option<crate::model::Generator>,

    /// The language to create generators for the following fields:
    ///
    /// * `Generator.prompt_text.text`
    ///   If not specified, the agent's default language is used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "generators")]
impl CreateGeneratorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateGeneratorRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [generator][crate::model::CreateGeneratorRequest::generator].
    pub fn set_generator<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Generator>,
    {
        self.generator = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [generator][crate::model::CreateGeneratorRequest::generator].
    pub fn set_or_clear_generator<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Generator>,
    {
        self.generator = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::CreateGeneratorRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "generators")]
impl wkt::message::Message for CreateGeneratorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CreateGeneratorRequest"
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateGeneratorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __generator,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateGeneratorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "generator" => Ok(__FieldTag::__generator),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateGeneratorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateGeneratorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generator => {
                            if !fields.insert(__FieldTag::__generator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generator",
                                ));
                            }
                            result.generator =
                                map.next_value::<std::option::Option<crate::model::Generator>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateGeneratorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.generator.is_some() {
            state.serialize_entry("generator", &self.generator)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Generators.UpdateGenerator][google.cloud.dialogflow.cx.v3.Generators.UpdateGenerator].
///
/// [google.cloud.dialogflow.cx.v3.Generators.UpdateGenerator]: crate::client::Generators::update_generator
#[cfg(feature = "generators")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateGeneratorRequest {
    /// Required. The generator to update.
    pub generator: std::option::Option<crate::model::Generator>,

    /// The language to list generators for.
    pub language_code: std::string::String,

    /// The mask to control which fields get updated. If the mask is not present,
    /// all fields will be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "generators")]
impl UpdateGeneratorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generator][crate::model::UpdateGeneratorRequest::generator].
    pub fn set_generator<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Generator>,
    {
        self.generator = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [generator][crate::model::UpdateGeneratorRequest::generator].
    pub fn set_or_clear_generator<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Generator>,
    {
        self.generator = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::UpdateGeneratorRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateGeneratorRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateGeneratorRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "generators")]
impl wkt::message::Message for UpdateGeneratorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.UpdateGeneratorRequest"
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateGeneratorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generator,
            __language_code,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateGeneratorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generator" => Ok(__FieldTag::__generator),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateGeneratorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateGeneratorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generator => {
                            if !fields.insert(__FieldTag::__generator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generator",
                                ));
                            }
                            result.generator =
                                map.next_value::<std::option::Option<crate::model::Generator>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateGeneratorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.generator.is_some() {
            state.serialize_entry("generator", &self.generator)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Generators.DeleteGenerator][google.cloud.dialogflow.cx.v3.Generators.DeleteGenerator].
///
/// [google.cloud.dialogflow.cx.v3.Generators.DeleteGenerator]: crate::client::Generators::delete_generator
#[cfg(feature = "generators")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteGeneratorRequest {
    /// Required. The name of the generator to delete.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/generators/<GeneratorID>`.
    pub name: std::string::String,

    /// This field has no effect for generators not being used.
    /// For generators that are used by pages/flows/transition route groups:
    ///
    /// * If `force` is set to false, an error will be returned with message
    ///   indicating the referenced resources.
    /// * If `force` is set to true, Dialogflow will remove the generator, as well
    ///   as any references to the generator (i.e.
    ///   [Generator][Fulfillment.generator]) in fulfillments.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "generators")]
impl DeleteGeneratorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGeneratorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteGeneratorRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

#[cfg(feature = "generators")]
impl wkt::message::Message for DeleteGeneratorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DeleteGeneratorRequest"
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteGeneratorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteGeneratorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteGeneratorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteGeneratorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteGeneratorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Inline destination for a Dialogflow operation that writes or exports objects
/// (e.g. [intents][google.cloud.dialogflow.cx.v3.Intent]) outside of Dialogflow.
///
/// [google.cloud.dialogflow.cx.v3.Intent]: crate::model::Intent
#[cfg(any(feature = "entity-types", feature = "intents",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InlineDestination {
    /// Output only. The uncompressed byte content for the objects.
    /// Only populated in responses.
    pub content: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "entity-types", feature = "intents",))]
impl InlineDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::InlineDestination::content].
    pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }
}

#[cfg(any(feature = "entity-types", feature = "intents",))]
impl wkt::message::Message for InlineDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.InlineDestination"
    }
}

#[cfg(any(feature = "entity-types", feature = "intents",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InlineDestination {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InlineDestination")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "content" => Ok(__FieldTag::__content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InlineDestination;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InlineDestination")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.content = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "entity-types", feature = "intents",))]
#[doc(hidden)]
impl serde::ser::Serialize for InlineDestination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("content", &__With(&self.content))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Inline source for a Dialogflow operation that reads or imports objects
/// (e.g. [intents][google.cloud.dialogflow.cx.v3.Intent]) into Dialogflow.
///
/// [google.cloud.dialogflow.cx.v3.Intent]: crate::model::Intent
#[cfg(any(feature = "entity-types", feature = "intents",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InlineSource {
    /// The uncompressed byte content for the objects.
    pub content: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "entity-types", feature = "intents",))]
impl InlineSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::InlineSource::content].
    pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }
}

#[cfg(any(feature = "entity-types", feature = "intents",))]
impl wkt::message::Message for InlineSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.InlineSource"
    }
}

#[cfg(any(feature = "entity-types", feature = "intents",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InlineSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InlineSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "content" => Ok(__FieldTag::__content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InlineSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InlineSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.content = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "entity-types", feature = "intents",))]
#[doc(hidden)]
impl serde::ser::Serialize for InlineSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("content", &__With(&self.content))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An intent represents a user's intent to interact with a conversational agent.
///
/// You can provide information for the Dialogflow API to use to match user input
/// to an intent by adding training phrases (i.e., examples of user input) to
/// your intent.
#[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Intent {
    /// The unique identifier of the intent.
    /// Required for the
    /// [Intents.UpdateIntent][google.cloud.dialogflow.cx.v3.Intents.UpdateIntent]
    /// method.
    /// [Intents.CreateIntent][google.cloud.dialogflow.cx.v3.Intents.CreateIntent]
    /// populates the name automatically.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/intents/<IntentID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Intents.CreateIntent]: crate::client::Intents::create_intent
    /// [google.cloud.dialogflow.cx.v3.Intents.UpdateIntent]: crate::client::Intents::update_intent
    pub name: std::string::String,

    /// Required. The human-readable name of the intent, unique within the agent.
    pub display_name: std::string::String,

    /// The collection of training phrases the agent is trained on to identify the
    /// intent.
    pub training_phrases: std::vec::Vec<crate::model::intent::TrainingPhrase>,

    /// The collection of parameters associated with the intent.
    pub parameters: std::vec::Vec<crate::model::intent::Parameter>,

    /// The priority of this intent. Higher numbers represent higher
    /// priorities.
    ///
    /// - If the supplied value is unspecified or 0, the service
    ///   translates the value to 500,000, which corresponds to the
    ///   `Normal` priority in the console.
    /// - If the supplied value is negative, the intent is ignored
    ///   in runtime detect intent requests.
    pub priority: i32,

    /// Indicates whether this is a fallback intent. Currently only default
    /// fallback intent is allowed in the agent, which is added upon agent
    /// creation.
    /// Adding training phrases to fallback intent is useful in the case of
    /// requests that are mistakenly matched, since training phrases assigned to
    /// fallback intents act as negative examples that triggers no-match event.
    pub is_fallback: bool,

    /// The key/value metadata to label an intent. Labels can contain
    /// lowercase letters, digits and the symbols '-' and '_'. International
    /// characters are allowed, including letters from unicase alphabets. Keys must
    /// start with a letter. Keys and values can be no longer than 63 characters
    /// and no more than 128 bytes.
    ///
    /// Prefix "sys-" is reserved for Dialogflow defined labels. Currently allowed
    /// Dialogflow defined labels include:
    ///
    /// * sys-head
    /// * sys-contextual
    ///   The above labels do not require value. "sys-head" means the intent is a
    ///   head intent. "sys.contextual" means the intent is a contextual intent.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Human readable description for better understanding an intent like its
    /// scope, content, result etc. Maximum character limit: 140 characters.
    pub description: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
impl Intent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Intent::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Intent::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [training_phrases][crate::model::Intent::training_phrases].
    pub fn set_training_phrases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::intent::TrainingPhrase>,
    {
        use std::iter::Iterator;
        self.training_phrases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [parameters][crate::model::Intent::parameters].
    pub fn set_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::intent::Parameter>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [priority][crate::model::Intent::priority].
    pub fn set_priority<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.priority = v.into();
        self
    }

    /// Sets the value of [is_fallback][crate::model::Intent::is_fallback].
    pub fn set_is_fallback<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_fallback = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Intent::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Intent::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

#[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
impl wkt::message::Message for Intent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.Intent"
    }
}

#[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Intent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __training_phrases,
            __parameters,
            __priority,
            __is_fallback,
            __labels,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Intent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "trainingPhrases" => Ok(__FieldTag::__training_phrases),
                            "training_phrases" => Ok(__FieldTag::__training_phrases),
                            "parameters" => Ok(__FieldTag::__parameters),
                            "priority" => Ok(__FieldTag::__priority),
                            "isFallback" => Ok(__FieldTag::__is_fallback),
                            "is_fallback" => Ok(__FieldTag::__is_fallback),
                            "labels" => Ok(__FieldTag::__labels),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Intent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Intent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__training_phrases => {
                            if !fields.insert(__FieldTag::__training_phrases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for training_phrases",
                                ));
                            }
                            result.training_phrases = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::intent::TrainingPhrase>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::intent::Parameter>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__priority => {
                            if !fields.insert(__FieldTag::__priority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for priority",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.priority = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__is_fallback => {
                            if !fields.insert(__FieldTag::__is_fallback) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_fallback",
                                ));
                            }
                            result.is_fallback = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for Intent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.training_phrases.is_empty() {
            state.serialize_entry("trainingPhrases", &self.training_phrases)?;
        }
        if !self.parameters.is_empty() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !wkt::internal::is_default(&self.priority) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if !wkt::internal::is_default(&self.is_fallback) {
            state.serialize_entry("isFallback", &self.is_fallback)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Intent].
#[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
pub mod intent {
    #[allow(unused_imports)]
    use super::*;

    /// Represents an example that the agent is trained on to identify the intent.
    #[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TrainingPhrase {
        /// Output only. The unique identifier of the training phrase.
        pub id: std::string::String,

        /// Required. The ordered list of training phrase parts.
        /// The parts are concatenated in order to form the training phrase.
        ///
        /// Note: The API does not automatically annotate training phrases like the
        /// Dialogflow Console does.
        ///
        /// Note: Do not forget to include whitespace at part boundaries, so the
        /// training phrase is well formatted when the parts are concatenated.
        ///
        /// If the training phrase does not need to be annotated with parameters,
        /// you just need a single part with only the
        /// [Part.text][google.cloud.dialogflow.cx.v3.Intent.TrainingPhrase.Part.text]
        /// field set.
        ///
        /// If you want to annotate the training phrase, you must create multiple
        /// parts, where the fields of each part are populated in one of two ways:
        ///
        /// - `Part.text` is set to a part of the phrase that has no parameters.
        /// - `Part.text` is set to a part of the phrase that you want to annotate,
        ///   and the `parameter_id` field is set.
        ///
        /// [google.cloud.dialogflow.cx.v3.Intent.TrainingPhrase.Part.text]: crate::model::intent::training_phrase::Part::text
        pub parts: std::vec::Vec<crate::model::intent::training_phrase::Part>,

        /// Indicates how many times this example was added to the intent.
        pub repeat_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
    impl TrainingPhrase {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::intent::TrainingPhrase::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [parts][crate::model::intent::TrainingPhrase::parts].
        pub fn set_parts<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::intent::training_phrase::Part>,
        {
            use std::iter::Iterator;
            self.parts = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [repeat_count][crate::model::intent::TrainingPhrase::repeat_count].
        pub fn set_repeat_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.repeat_count = v.into();
            self
        }
    }

    #[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
    impl wkt::message::Message for TrainingPhrase {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Intent.TrainingPhrase"
        }
    }

    #[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TrainingPhrase {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __parts,
                __repeat_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TrainingPhrase")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "parts" => Ok(__FieldTag::__parts),
                                "repeatCount" => Ok(__FieldTag::__repeat_count),
                                "repeat_count" => Ok(__FieldTag::__repeat_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TrainingPhrase;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TrainingPhrase")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__parts => {
                                if !fields.insert(__FieldTag::__parts) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parts",
                                    ));
                                }
                                result.parts = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::intent::training_phrase::Part>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__repeat_count => {
                                if !fields.insert(__FieldTag::__repeat_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for repeat_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.repeat_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
    #[doc(hidden)]
    impl serde::ser::Serialize for TrainingPhrase {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self.parts.is_empty() {
                state.serialize_entry("parts", &self.parts)?;
            }
            if !wkt::internal::is_default(&self.repeat_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("repeatCount", &__With(&self.repeat_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [TrainingPhrase].
    #[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
    pub mod training_phrase {
        #[allow(unused_imports)]
        use super::*;

        /// Represents a part of a training phrase.
        #[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Part {
            /// Required. The text for this part.
            pub text: std::string::String,

            /// The [parameter][google.cloud.dialogflow.cx.v3.Intent.Parameter] used to
            /// annotate this part of the training phrase. This field is required for
            /// annotated parts of the training phrase.
            ///
            /// [google.cloud.dialogflow.cx.v3.Intent.Parameter]: crate::model::intent::Parameter
            pub parameter_id: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
        impl Part {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [text][crate::model::intent::training_phrase::Part::text].
            pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.text = v.into();
                self
            }

            /// Sets the value of [parameter_id][crate::model::intent::training_phrase::Part::parameter_id].
            pub fn set_parameter_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.parameter_id = v.into();
                self
            }
        }

        #[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
        impl wkt::message::Message for Part {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.cx.v3.Intent.TrainingPhrase.Part"
            }
        }

        #[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Part {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __text,
                    __parameter_id,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Part")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "text" => Ok(__FieldTag::__text),
                                    "parameterId" => Ok(__FieldTag::__parameter_id),
                                    "parameter_id" => Ok(__FieldTag::__parameter_id),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Part;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Part")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__text => {
                                    if !fields.insert(__FieldTag::__text) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for text"),
                                        );
                                    }
                                    result.text = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__parameter_id => {
                                    if !fields.insert(__FieldTag::__parameter_id) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for parameter_id",
                                            ),
                                        );
                                    }
                                    result.parameter_id = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
        #[doc(hidden)]
        impl serde::ser::Serialize for Part {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.text.is_empty() {
                    state.serialize_entry("text", &self.text)?;
                }
                if !self.parameter_id.is_empty() {
                    state.serialize_entry("parameterId", &self.parameter_id)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Represents an intent parameter.
    #[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Parameter {
        /// Required. The unique identifier of the parameter. This field
        /// is used by [training
        /// phrases][google.cloud.dialogflow.cx.v3.Intent.TrainingPhrase] to annotate
        /// their [parts][google.cloud.dialogflow.cx.v3.Intent.TrainingPhrase.Part].
        ///
        /// [google.cloud.dialogflow.cx.v3.Intent.TrainingPhrase]: crate::model::intent::TrainingPhrase
        /// [google.cloud.dialogflow.cx.v3.Intent.TrainingPhrase.Part]: crate::model::intent::training_phrase::Part
        pub id: std::string::String,

        /// Required. The entity type of the parameter.
        /// Format:
        /// `projects/-/locations/-/agents/-/entityTypes/<SystemEntityTypeID>` for
        /// system entity types (for example,
        /// `projects/-/locations/-/agents/-/entityTypes/sys.date`), or
        /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/entityTypes/<EntityTypeID>`
        /// for developer entity types.
        pub entity_type: std::string::String,

        /// Indicates whether the parameter represents a list of values.
        pub is_list: bool,

        /// Indicates whether the parameter content should be redacted in log. If
        /// redaction is enabled, the parameter content will be replaced by parameter
        /// name during logging.
        /// Note: the parameter content is subject to redaction if either parameter
        /// level redaction or [entity type level
        /// redaction][google.cloud.dialogflow.cx.v3.EntityType.redact] is enabled.
        ///
        /// [google.cloud.dialogflow.cx.v3.EntityType.redact]: crate::model::EntityType::redact
        pub redact: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
    impl Parameter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::intent::Parameter::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [entity_type][crate::model::intent::Parameter::entity_type].
        pub fn set_entity_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entity_type = v.into();
            self
        }

        /// Sets the value of [is_list][crate::model::intent::Parameter::is_list].
        pub fn set_is_list<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.is_list = v.into();
            self
        }

        /// Sets the value of [redact][crate::model::intent::Parameter::redact].
        pub fn set_redact<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.redact = v.into();
            self
        }
    }

    #[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
    impl wkt::message::Message for Parameter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Intent.Parameter"
        }
    }

    #[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Parameter {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __entity_type,
                __is_list,
                __redact,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Parameter")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "entityType" => Ok(__FieldTag::__entity_type),
                                "entity_type" => Ok(__FieldTag::__entity_type),
                                "isList" => Ok(__FieldTag::__is_list),
                                "is_list" => Ok(__FieldTag::__is_list),
                                "redact" => Ok(__FieldTag::__redact),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Parameter;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Parameter")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__entity_type => {
                                if !fields.insert(__FieldTag::__entity_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for entity_type",
                                    ));
                                }
                                result.entity_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__is_list => {
                                if !fields.insert(__FieldTag::__is_list) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for is_list",
                                    ));
                                }
                                result.is_list = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__redact => {
                                if !fields.insert(__FieldTag::__redact) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for redact",
                                    ));
                                }
                                result.redact = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(feature = "intents", feature = "sessions", feature = "test-cases",))]
    #[doc(hidden)]
    impl serde::ser::Serialize for Parameter {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if !self.entity_type.is_empty() {
                state.serialize_entry("entityType", &self.entity_type)?;
            }
            if !wkt::internal::is_default(&self.is_list) {
                state.serialize_entry("isList", &self.is_list)?;
            }
            if !wkt::internal::is_default(&self.redact) {
                state.serialize_entry("redact", &self.redact)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// The request message for
/// [Intents.ListIntents][google.cloud.dialogflow.cx.v3.Intents.ListIntents].
///
/// [google.cloud.dialogflow.cx.v3.Intents.ListIntents]: crate::client::Intents::list_intents
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIntentsRequest {
    /// Required. The agent to list all intents for.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// The language to list intents for. The following fields are language
    /// dependent:
    ///
    /// * `Intent.training_phrases.parts.text`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    /// The resource view to apply to the returned intent.
    pub intent_view: crate::model::IntentView,

    /// The maximum number of items to return in a single page. By default 100 and
    /// at most 1000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl ListIntentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIntentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::ListIntentsRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [intent_view][crate::model::ListIntentsRequest::intent_view].
    pub fn set_intent_view<T: std::convert::Into<crate::model::IntentView>>(
        mut self,
        v: T,
    ) -> Self {
        self.intent_view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListIntentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListIntentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for ListIntentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListIntentsRequest"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListIntentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __language_code,
            __intent_view,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListIntentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "intentView" => Ok(__FieldTag::__intent_view),
                            "intent_view" => Ok(__FieldTag::__intent_view),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListIntentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIntentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__intent_view => {
                            if !fields.insert(__FieldTag::__intent_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent_view",
                                ));
                            }
                            result.intent_view = map
                                .next_value::<std::option::Option<crate::model::IntentView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for ListIntentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.intent_view) {
            state.serialize_entry("intentView", &self.intent_view)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Intents.ListIntents][google.cloud.dialogflow.cx.v3.Intents.ListIntents].
///
/// [google.cloud.dialogflow.cx.v3.Intents.ListIntents]: crate::client::Intents::list_intents
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIntentsResponse {
    /// The list of intents. There will be a maximum number of items returned based
    /// on the page_size field in the request.
    pub intents: std::vec::Vec<crate::model::Intent>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl ListIntentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [intents][crate::model::ListIntentsResponse::intents].
    pub fn set_intents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Intent>,
    {
        use std::iter::Iterator;
        self.intents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListIntentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for ListIntentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListIntentsResponse"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListIntentsResponse {
    type PageItem = crate::model::Intent;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.intents
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListIntentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __intents,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListIntentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "intents" => Ok(__FieldTag::__intents),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListIntentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIntentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__intents => {
                            if !fields.insert(__FieldTag::__intents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intents",
                                ));
                            }
                            result.intents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Intent>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for ListIntentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.intents.is_empty() {
            state.serialize_entry("intents", &self.intents)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Intents.GetIntent][google.cloud.dialogflow.cx.v3.Intents.GetIntent].
///
/// [google.cloud.dialogflow.cx.v3.Intents.GetIntent]: crate::client::Intents::get_intent
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetIntentRequest {
    /// Required. The name of the intent.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/intents/<IntentID>`.
    pub name: std::string::String,

    /// The language to retrieve the intent for. The following fields are language
    /// dependent:
    ///
    /// * `Intent.training_phrases.parts.text`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl GetIntentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetIntentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::GetIntentRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for GetIntentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetIntentRequest"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for GetIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Intents.CreateIntent][google.cloud.dialogflow.cx.v3.Intents.CreateIntent].
///
/// [google.cloud.dialogflow.cx.v3.Intents.CreateIntent]: crate::client::Intents::create_intent
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateIntentRequest {
    /// Required. The agent to create an intent for.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// Required. The intent to create.
    pub intent: std::option::Option<crate::model::Intent>,

    /// The language of the following fields in `intent`:
    ///
    /// * `Intent.training_phrases.parts.text`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl CreateIntentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateIntentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [intent][crate::model::CreateIntentRequest::intent].
    pub fn set_intent<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Intent>,
    {
        self.intent = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [intent][crate::model::CreateIntentRequest::intent].
    pub fn set_or_clear_intent<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Intent>,
    {
        self.intent = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::CreateIntentRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for CreateIntentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CreateIntentRequest"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __intent,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "intent" => Ok(__FieldTag::__intent),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__intent => {
                            if !fields.insert(__FieldTag::__intent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent",
                                ));
                            }
                            result.intent =
                                map.next_value::<std::option::Option<crate::model::Intent>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.intent.is_some() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Intents.UpdateIntent][google.cloud.dialogflow.cx.v3.Intents.UpdateIntent].
///
/// [google.cloud.dialogflow.cx.v3.Intents.UpdateIntent]: crate::client::Intents::update_intent
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateIntentRequest {
    /// Required. The intent to update.
    pub intent: std::option::Option<crate::model::Intent>,

    /// The language of the following fields in `intent`:
    ///
    /// * `Intent.training_phrases.parts.text`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    /// The mask to control which fields get updated. If the mask is not present,
    /// all fields will be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl UpdateIntentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [intent][crate::model::UpdateIntentRequest::intent].
    pub fn set_intent<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Intent>,
    {
        self.intent = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [intent][crate::model::UpdateIntentRequest::intent].
    pub fn set_or_clear_intent<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Intent>,
    {
        self.intent = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::UpdateIntentRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateIntentRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateIntentRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for UpdateIntentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.UpdateIntentRequest"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __intent,
            __language_code,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "intent" => Ok(__FieldTag::__intent),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__intent => {
                            if !fields.insert(__FieldTag::__intent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent",
                                ));
                            }
                            result.intent =
                                map.next_value::<std::option::Option<crate::model::Intent>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.intent.is_some() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Intents.DeleteIntent][google.cloud.dialogflow.cx.v3.Intents.DeleteIntent].
///
/// [google.cloud.dialogflow.cx.v3.Intents.DeleteIntent]: crate::client::Intents::delete_intent
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteIntentRequest {
    /// Required. The name of the intent to delete.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/intents/<IntentID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl DeleteIntentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteIntentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for DeleteIntentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DeleteIntentRequest"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Intents.ImportIntents][google.cloud.dialogflow.cx.v3.Intents.ImportIntents].
///
/// [google.cloud.dialogflow.cx.v3.Intents.ImportIntents]: crate::client::Intents::import_intents
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportIntentsRequest {
    /// Required. The agent to import the intents into.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// Merge option for importing intents. If not specified, `REJECT` is assumed.
    pub merge_option: crate::model::import_intents_request::MergeOption,

    /// Required. The intents to import.
    pub intents: std::option::Option<crate::model::import_intents_request::Intents>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl ImportIntentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportIntentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [merge_option][crate::model::ImportIntentsRequest::merge_option].
    pub fn set_merge_option<
        T: std::convert::Into<crate::model::import_intents_request::MergeOption>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.merge_option = v.into();
        self
    }

    /// Sets the value of [intents][crate::model::ImportIntentsRequest::intents].
    ///
    /// Note that all the setters affecting `intents` are mutually
    /// exclusive.
    pub fn set_intents<
        T: std::convert::Into<std::option::Option<crate::model::import_intents_request::Intents>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.intents = v.into();
        self
    }

    /// The value of [intents][crate::model::ImportIntentsRequest::intents]
    /// if it holds a `IntentsUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn intents_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.intents.as_ref().and_then(|v| match v {
            crate::model::import_intents_request::Intents::IntentsUri(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [intents][crate::model::ImportIntentsRequest::intents]
    /// to hold a `IntentsUri`.
    ///
    /// Note that all the setters affecting `intents` are
    /// mutually exclusive.
    pub fn set_intents_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.intents = std::option::Option::Some(
            crate::model::import_intents_request::Intents::IntentsUri(v.into()),
        );
        self
    }

    /// The value of [intents][crate::model::ImportIntentsRequest::intents]
    /// if it holds a `IntentsContent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn intents_content(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InlineSource>> {
        #[allow(unreachable_patterns)]
        self.intents.as_ref().and_then(|v| match v {
            crate::model::import_intents_request::Intents::IntentsContent(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [intents][crate::model::ImportIntentsRequest::intents]
    /// to hold a `IntentsContent`.
    ///
    /// Note that all the setters affecting `intents` are
    /// mutually exclusive.
    pub fn set_intents_content<
        T: std::convert::Into<std::boxed::Box<crate::model::InlineSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.intents = std::option::Option::Some(
            crate::model::import_intents_request::Intents::IntentsContent(v.into()),
        );
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for ImportIntentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ImportIntentsRequest"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportIntentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __intents_uri,
            __intents_content,
            __merge_option,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportIntentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "intentsUri" => Ok(__FieldTag::__intents_uri),
                            "intents_uri" => Ok(__FieldTag::__intents_uri),
                            "intentsContent" => Ok(__FieldTag::__intents_content),
                            "intents_content" => Ok(__FieldTag::__intents_content),
                            "mergeOption" => Ok(__FieldTag::__merge_option),
                            "merge_option" => Ok(__FieldTag::__merge_option),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportIntentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportIntentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__intents_uri => {
                            if !fields.insert(__FieldTag::__intents_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intents_uri",
                                ));
                            }
                            if result.intents.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `intents`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ImportIntentsRequest.intents_uri, latest field was intentsUri",
                                ));
                            }
                            result.intents = std::option::Option::Some(
                                crate::model::import_intents_request::Intents::IntentsUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__intents_content => {
                            if !fields.insert(__FieldTag::__intents_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intents_content",
                                ));
                            }
                            if result.intents.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `intents`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ImportIntentsRequest.intents_content, latest field was intentsContent",
                                ));
                            }
                            result.intents = std::option::Option::Some(
                                crate::model::import_intents_request::Intents::IntentsContent(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InlineSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__merge_option => {
                            if !fields.insert(__FieldTag::__merge_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for merge_option",
                                ));
                            }
                            result.merge_option = map
                                .next_value::<std::option::Option<
                                    crate::model::import_intents_request::MergeOption,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for ImportIntentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.intents_uri() {
            state.serialize_entry("intentsUri", value)?;
        }
        if let Some(value) = self.intents_content() {
            state.serialize_entry("intentsContent", value)?;
        }
        if !wkt::internal::is_default(&self.merge_option) {
            state.serialize_entry("mergeOption", &self.merge_option)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ImportIntentsRequest].
#[cfg(feature = "intents")]
pub mod import_intents_request {
    #[allow(unused_imports)]
    use super::*;

    /// Merge option when display name conflicts exist during import.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "intents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MergeOption {
        /// Unspecified. Should not be used.
        Unspecified,
        /// DEPRECATED: Please use
        /// [REPORT_CONFLICT][ImportIntentsRequest.REPORT_CONFLICT] instead.
        /// Fail the request if there are intents whose display names conflict with
        /// the display names of intents in the agent.
        #[deprecated]
        Reject,
        /// Replace the original intent in the agent with the new intent when display
        /// name conflicts exist.
        Replace,
        /// Merge the original intent with the new intent when display name conflicts
        /// exist.
        Merge,
        /// Create new intents with new display names to differentiate them from the
        /// existing intents when display name conflicts exist.
        Rename,
        /// Report conflict information if display names conflict is detected.
        /// Otherwise, import intents.
        ReportConflict,
        /// Keep the original intent and discard the conflicting new intent when
        /// display name conflicts exist.
        Keep,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MergeOption::value] or
        /// [MergeOption::name].
        UnknownValue(merge_option::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "intents")]
    pub mod merge_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "intents")]
    impl MergeOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Reject => std::option::Option::Some(1),
                Self::Replace => std::option::Option::Some(2),
                Self::Merge => std::option::Option::Some(3),
                Self::Rename => std::option::Option::Some(4),
                Self::ReportConflict => std::option::Option::Some(5),
                Self::Keep => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MERGE_OPTION_UNSPECIFIED"),
                Self::Reject => std::option::Option::Some("REJECT"),
                Self::Replace => std::option::Option::Some("REPLACE"),
                Self::Merge => std::option::Option::Some("MERGE"),
                Self::Rename => std::option::Option::Some("RENAME"),
                Self::ReportConflict => std::option::Option::Some("REPORT_CONFLICT"),
                Self::Keep => std::option::Option::Some("KEEP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "intents")]
    impl std::default::Default for MergeOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "intents")]
    impl std::fmt::Display for MergeOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "intents")]
    impl std::convert::From<i32> for MergeOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Reject,
                2 => Self::Replace,
                3 => Self::Merge,
                4 => Self::Rename,
                5 => Self::ReportConflict,
                6 => Self::Keep,
                _ => Self::UnknownValue(merge_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "intents")]
    impl std::convert::From<&str> for MergeOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MERGE_OPTION_UNSPECIFIED" => Self::Unspecified,
                "REJECT" => Self::Reject,
                "REPLACE" => Self::Replace,
                "MERGE" => Self::Merge,
                "RENAME" => Self::Rename,
                "REPORT_CONFLICT" => Self::ReportConflict,
                "KEEP" => Self::Keep,
                _ => Self::UnknownValue(merge_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "intents")]
    impl serde::ser::Serialize for MergeOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Reject => serializer.serialize_i32(1),
                Self::Replace => serializer.serialize_i32(2),
                Self::Merge => serializer.serialize_i32(3),
                Self::Rename => serializer.serialize_i32(4),
                Self::ReportConflict => serializer.serialize_i32(5),
                Self::Keep => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "intents")]
    impl<'de> serde::de::Deserialize<'de> for MergeOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MergeOption>::new(
                ".google.cloud.dialogflow.cx.v3.ImportIntentsRequest.MergeOption",
            ))
        }
    }

    /// Required. The intents to import.
    #[cfg(feature = "intents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Intents {
        /// The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI
        /// to import intents from. The format of this URI must be
        /// `gs://<bucket-name>/<object-name>`.
        ///
        /// Dialogflow performs a read operation for the Cloud Storage object
        /// on the caller's behalf, so your request authentication must
        /// have read permissions for the object. For more information, see
        /// [Dialogflow access
        /// control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
        IntentsUri(std::string::String),
        /// Uncompressed byte content of intents.
        IntentsContent(std::boxed::Box<crate::model::InlineSource>),
    }
}

/// The response message for
/// [Intents.ImportIntents][google.cloud.dialogflow.cx.v3.Intents.ImportIntents].
///
/// [google.cloud.dialogflow.cx.v3.Intents.ImportIntents]: crate::client::Intents::import_intents
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportIntentsResponse {
    /// The unique identifier of the imported intents.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/intents/<IntentID>`.
    pub intents: std::vec::Vec<std::string::String>,

    /// Info which resources have conflicts when
    /// [REPORT_CONFLICT][ImportIntentsResponse.REPORT_CONFLICT] merge_option is
    /// set in ImportIntentsRequest.
    pub conflicting_resources:
        std::option::Option<crate::model::import_intents_response::ConflictingResources>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl ImportIntentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [intents][crate::model::ImportIntentsResponse::intents].
    pub fn set_intents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.intents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [conflicting_resources][crate::model::ImportIntentsResponse::conflicting_resources].
    pub fn set_conflicting_resources<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::import_intents_response::ConflictingResources>,
    {
        self.conflicting_resources = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conflicting_resources][crate::model::ImportIntentsResponse::conflicting_resources].
    pub fn set_or_clear_conflicting_resources<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::import_intents_response::ConflictingResources>,
    {
        self.conflicting_resources = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for ImportIntentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ImportIntentsResponse"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportIntentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __intents,
            __conflicting_resources,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportIntentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "intents" => Ok(__FieldTag::__intents),
                            "conflictingResources" => Ok(__FieldTag::__conflicting_resources),
                            "conflicting_resources" => Ok(__FieldTag::__conflicting_resources),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportIntentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportIntentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__intents => {
                            if !fields.insert(__FieldTag::__intents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intents",
                                ));
                            }
                            result.intents = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__conflicting_resources => {
                            if !fields.insert(__FieldTag::__conflicting_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conflicting_resources",
                                ));
                            }
                            result.conflicting_resources = map.next_value::<std::option::Option<
                                crate::model::import_intents_response::ConflictingResources,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for ImportIntentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.intents.is_empty() {
            state.serialize_entry("intents", &self.intents)?;
        }
        if self.conflicting_resources.is_some() {
            state.serialize_entry("conflictingResources", &self.conflicting_resources)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ImportIntentsResponse].
#[cfg(feature = "intents")]
pub mod import_intents_response {
    #[allow(unused_imports)]
    use super::*;

    /// Conflicting resources detected during the import process. Only filled when
    /// [REPORT_CONFLICT][ImportIntentsResponse.REPORT_CONFLICT] is set in the
    /// request and there are conflicts in the display names.
    #[cfg(feature = "intents")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConflictingResources {
        /// Display names of conflicting intents.
        pub intent_display_names: std::vec::Vec<std::string::String>,

        /// Display names of conflicting entities.
        pub entity_display_names: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "intents")]
    impl ConflictingResources {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [intent_display_names][crate::model::import_intents_response::ConflictingResources::intent_display_names].
        pub fn set_intent_display_names<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.intent_display_names = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [entity_display_names][crate::model::import_intents_response::ConflictingResources::entity_display_names].
        pub fn set_entity_display_names<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.entity_display_names = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "intents")]
    impl wkt::message::Message for ConflictingResources {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.ImportIntentsResponse.ConflictingResources"
        }
    }

    #[cfg(feature = "intents")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConflictingResources {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __intent_display_names,
                __entity_display_names,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConflictingResources")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "intentDisplayNames" => Ok(__FieldTag::__intent_display_names),
                                "intent_display_names" => Ok(__FieldTag::__intent_display_names),
                                "entityDisplayNames" => Ok(__FieldTag::__entity_display_names),
                                "entity_display_names" => Ok(__FieldTag::__entity_display_names),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConflictingResources;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConflictingResources")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__intent_display_names => {
                                if !fields.insert(__FieldTag::__intent_display_names) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for intent_display_names",
                                    ));
                                }
                                result.intent_display_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__entity_display_names => {
                                if !fields.insert(__FieldTag::__entity_display_names) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for entity_display_names",
                                    ));
                                }
                                result.entity_display_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "intents")]
    #[doc(hidden)]
    impl serde::ser::Serialize for ConflictingResources {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.intent_display_names.is_empty() {
                state.serialize_entry("intentDisplayNames", &self.intent_display_names)?;
            }
            if !self.entity_display_names.is_empty() {
                state.serialize_entry("entityDisplayNames", &self.entity_display_names)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Metadata returned for the
/// [Intents.ImportIntents][google.cloud.dialogflow.cx.v3.Intents.ImportIntents]
/// long running operation.
///
/// [google.cloud.dialogflow.cx.v3.Intents.ImportIntents]: crate::client::Intents::import_intents
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportIntentsMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl ImportIntentsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for ImportIntentsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ImportIntentsMetadata"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportIntentsMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportIntentsMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportIntentsMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportIntentsMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for ImportIntentsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Intents.ExportIntents][google.cloud.dialogflow.cx.v3.Intents.ExportIntents].
///
/// [google.cloud.dialogflow.cx.v3.Intents.ExportIntents]: crate::client::Intents::export_intents
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportIntentsRequest {
    /// Required. The name of the parent agent to export intents.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// Required. The name of the intents to export.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/intents/<IntentID>`.
    pub intents: std::vec::Vec<std::string::String>,

    /// Optional. The data format of the exported intents. If not specified, `BLOB`
    /// is assumed.
    pub data_format: crate::model::export_intents_request::DataFormat,

    /// The destination to export.
    pub destination: std::option::Option<crate::model::export_intents_request::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl ExportIntentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ExportIntentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [intents][crate::model::ExportIntentsRequest::intents].
    pub fn set_intents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.intents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_format][crate::model::ExportIntentsRequest::data_format].
    pub fn set_data_format<
        T: std::convert::Into<crate::model::export_intents_request::DataFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_format = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ExportIntentsRequest::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::export_intents_request::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportIntentsRequest::destination]
    /// if it holds a `IntentsUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn intents_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_intents_request::Destination::IntentsUri(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportIntentsRequest::destination]
    /// to hold a `IntentsUri`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_intents_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_intents_request::Destination::IntentsUri(v.into()),
        );
        self
    }

    /// The value of [destination][crate::model::ExportIntentsRequest::destination]
    /// if it holds a `IntentsContentInline`, `None` if the field is not set or
    /// holds a different branch.
    pub fn intents_content_inline(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_intents_request::Destination::IntentsContentInline(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportIntentsRequest::destination]
    /// to hold a `IntentsContentInline`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_intents_content_inline<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_intents_request::Destination::IntentsContentInline(v.into()),
        );
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for ExportIntentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ExportIntentsRequest"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportIntentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __intents,
            __intents_uri,
            __intents_content_inline,
            __data_format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportIntentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "intents" => Ok(__FieldTag::__intents),
                            "intentsUri" => Ok(__FieldTag::__intents_uri),
                            "intents_uri" => Ok(__FieldTag::__intents_uri),
                            "intentsContentInline" => Ok(__FieldTag::__intents_content_inline),
                            "intents_content_inline" => Ok(__FieldTag::__intents_content_inline),
                            "dataFormat" => Ok(__FieldTag::__data_format),
                            "data_format" => Ok(__FieldTag::__data_format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportIntentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportIntentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__intents => {
                            if !fields.insert(__FieldTag::__intents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intents",
                                ));
                            }
                            result.intents = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__intents_uri => {
                            if !fields.insert(__FieldTag::__intents_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intents_uri",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ExportIntentsRequest.intents_uri, latest field was intentsUri",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::export_intents_request::Destination::IntentsUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__intents_content_inline => {
                            if !fields.insert(__FieldTag::__intents_content_inline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intents_content_inline",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ExportIntentsRequest.intents_content_inline, latest field was intentsContentInline",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::export_intents_request::Destination::IntentsContentInline(
                                    map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__data_format => {
                            if !fields.insert(__FieldTag::__data_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_format",
                                ));
                            }
                            result.data_format = map
                                .next_value::<std::option::Option<
                                    crate::model::export_intents_request::DataFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for ExportIntentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.intents.is_empty() {
            state.serialize_entry("intents", &self.intents)?;
        }
        if let Some(value) = self.intents_uri() {
            state.serialize_entry("intentsUri", value)?;
        }
        if let Some(value) = self.intents_content_inline() {
            state.serialize_entry("intentsContentInline", value)?;
        }
        if !wkt::internal::is_default(&self.data_format) {
            state.serialize_entry("dataFormat", &self.data_format)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExportIntentsRequest].
#[cfg(feature = "intents")]
pub mod export_intents_request {
    #[allow(unused_imports)]
    use super::*;

    /// Data format of the exported intents.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "intents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataFormat {
        /// Unspecified format. Treated as `BLOB`.
        Unspecified,
        /// Intents will be exported as raw bytes.
        Blob,
        /// Intents will be exported in JSON format.
        Json,
        /// Intents will be exported in CSV format.
        Csv,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataFormat::value] or
        /// [DataFormat::name].
        UnknownValue(data_format::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "intents")]
    pub mod data_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "intents")]
    impl DataFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Blob => std::option::Option::Some(1),
                Self::Json => std::option::Option::Some(2),
                Self::Csv => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_FORMAT_UNSPECIFIED"),
                Self::Blob => std::option::Option::Some("BLOB"),
                Self::Json => std::option::Option::Some("JSON"),
                Self::Csv => std::option::Option::Some("CSV"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "intents")]
    impl std::default::Default for DataFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "intents")]
    impl std::fmt::Display for DataFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "intents")]
    impl std::convert::From<i32> for DataFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Blob,
                2 => Self::Json,
                3 => Self::Csv,
                _ => Self::UnknownValue(data_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "intents")]
    impl std::convert::From<&str> for DataFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "BLOB" => Self::Blob,
                "JSON" => Self::Json,
                "CSV" => Self::Csv,
                _ => Self::UnknownValue(data_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "intents")]
    impl serde::ser::Serialize for DataFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Blob => serializer.serialize_i32(1),
                Self::Json => serializer.serialize_i32(2),
                Self::Csv => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "intents")]
    impl<'de> serde::de::Deserialize<'de> for DataFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataFormat>::new(
                ".google.cloud.dialogflow.cx.v3.ExportIntentsRequest.DataFormat",
            ))
        }
    }

    /// The destination to export.
    #[cfg(feature = "intents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Optional. The [Google Cloud
        /// Storage](https://cloud.google.com/storage/docs/) URI to export the
        /// intents to. The format of this URI must be
        /// `gs://<bucket-name>/<object-name>`.
        ///
        /// Dialogflow performs a write operation for the Cloud Storage object
        /// on the caller's behalf, so your request authentication must
        /// have write permissions for the object. For more information, see
        /// [Dialogflow access
        /// control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
        IntentsUri(std::string::String),
        /// Optional. The option to return the serialized intents inline.
        IntentsContentInline(bool),
    }
}

/// The response message for
/// [Intents.ExportIntents][google.cloud.dialogflow.cx.v3.Intents.ExportIntents].
///
/// [google.cloud.dialogflow.cx.v3.Intents.ExportIntents]: crate::client::Intents::export_intents
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportIntentsResponse {
    /// The exported intents.
    pub intents: std::option::Option<crate::model::export_intents_response::Intents>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl ExportIntentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [intents][crate::model::ExportIntentsResponse::intents].
    ///
    /// Note that all the setters affecting `intents` are mutually
    /// exclusive.
    pub fn set_intents<
        T: std::convert::Into<std::option::Option<crate::model::export_intents_response::Intents>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.intents = v.into();
        self
    }

    /// The value of [intents][crate::model::ExportIntentsResponse::intents]
    /// if it holds a `IntentsUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn intents_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.intents.as_ref().and_then(|v| match v {
            crate::model::export_intents_response::Intents::IntentsUri(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [intents][crate::model::ExportIntentsResponse::intents]
    /// to hold a `IntentsUri`.
    ///
    /// Note that all the setters affecting `intents` are
    /// mutually exclusive.
    pub fn set_intents_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.intents = std::option::Option::Some(
            crate::model::export_intents_response::Intents::IntentsUri(v.into()),
        );
        self
    }

    /// The value of [intents][crate::model::ExportIntentsResponse::intents]
    /// if it holds a `IntentsContent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn intents_content(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InlineDestination>> {
        #[allow(unreachable_patterns)]
        self.intents.as_ref().and_then(|v| match v {
            crate::model::export_intents_response::Intents::IntentsContent(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [intents][crate::model::ExportIntentsResponse::intents]
    /// to hold a `IntentsContent`.
    ///
    /// Note that all the setters affecting `intents` are
    /// mutually exclusive.
    pub fn set_intents_content<
        T: std::convert::Into<std::boxed::Box<crate::model::InlineDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.intents = std::option::Option::Some(
            crate::model::export_intents_response::Intents::IntentsContent(v.into()),
        );
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for ExportIntentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ExportIntentsResponse"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportIntentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __intents_uri,
            __intents_content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportIntentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "intentsUri" => Ok(__FieldTag::__intents_uri),
                            "intents_uri" => Ok(__FieldTag::__intents_uri),
                            "intentsContent" => Ok(__FieldTag::__intents_content),
                            "intents_content" => Ok(__FieldTag::__intents_content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportIntentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportIntentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__intents_uri => {
                            if !fields.insert(__FieldTag::__intents_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intents_uri",
                                ));
                            }
                            if result.intents.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `intents`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ExportIntentsResponse.intents_uri, latest field was intentsUri",
                                ));
                            }
                            result.intents = std::option::Option::Some(
                                crate::model::export_intents_response::Intents::IntentsUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__intents_content => {
                            if !fields.insert(__FieldTag::__intents_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intents_content",
                                ));
                            }
                            if result.intents.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `intents`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ExportIntentsResponse.intents_content, latest field was intentsContent",
                                ));
                            }
                            result.intents = std::option::Option::Some(
                                crate::model::export_intents_response::Intents::IntentsContent(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InlineDestination>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for ExportIntentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.intents_uri() {
            state.serialize_entry("intentsUri", value)?;
        }
        if let Some(value) = self.intents_content() {
            state.serialize_entry("intentsContent", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExportIntentsResponse].
#[cfg(feature = "intents")]
pub mod export_intents_response {
    #[allow(unused_imports)]
    use super::*;

    /// The exported intents.
    #[cfg(feature = "intents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Intents {
        /// The URI to a file containing the exported intents. This field is
        /// populated only if `intents_uri` is specified in
        /// [ExportIntentsRequest][google.cloud.dialogflow.cx.v3.ExportIntentsRequest].
        ///
        /// [google.cloud.dialogflow.cx.v3.ExportIntentsRequest]: crate::model::ExportIntentsRequest
        IntentsUri(std::string::String),
        /// Uncompressed byte content for intents. This field is populated only if
        /// `intents_content_inline` is set to true in
        /// [ExportIntentsRequest][google.cloud.dialogflow.cx.v3.ExportIntentsRequest].
        ///
        /// [google.cloud.dialogflow.cx.v3.ExportIntentsRequest]: crate::model::ExportIntentsRequest
        IntentsContent(std::boxed::Box<crate::model::InlineDestination>),
    }
}

/// Metadata returned for the
/// [Intents.ExportIntents][google.cloud.dialogflow.cx.v3.Intents.ExportIntents]
/// long running operation.
///
/// [google.cloud.dialogflow.cx.v3.Intents.ExportIntents]: crate::client::Intents::export_intents
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportIntentsMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl ExportIntentsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for ExportIntentsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ExportIntentsMetadata"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportIntentsMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportIntentsMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportIntentsMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportIntentsMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for ExportIntentsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A Dialogflow CX conversation (session) can be described and visualized as a
/// state machine. The states of a CX session are represented by pages.
///
/// For each flow, you define many pages, where your combined pages can handle a
/// complete conversation on the topics the flow is designed for. At any given
/// moment, exactly one page is the current page, the current page is considered
/// active, and the flow associated with that page is considered active. Every
/// flow has a special start page. When a flow initially becomes active, the
/// start page page becomes the current page. For each conversational turn, the
/// current page will either stay the same or transition to another page.
///
/// You configure each page to collect information from the end-user that is
/// relevant for the conversational state represented by the page.
///
/// For more information, see the
/// [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page).
#[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Page {
    /// The unique identifier of the page.
    /// Required for the
    /// [Pages.UpdatePage][google.cloud.dialogflow.cx.v3.Pages.UpdatePage] method.
    /// [Pages.CreatePage][google.cloud.dialogflow.cx.v3.Pages.CreatePage]
    /// populates the name automatically.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/pages/<PageID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Pages.CreatePage]: crate::client::Pages::create_page
    /// [google.cloud.dialogflow.cx.v3.Pages.UpdatePage]: crate::client::Pages::update_page
    pub name: std::string::String,

    /// Required. The human-readable name of the page, unique within the flow.
    pub display_name: std::string::String,

    /// The description of the page. The maximum length is 500 characters.
    pub description: std::string::String,

    /// The fulfillment to call when the session is entering the page.
    pub entry_fulfillment: std::option::Option<crate::model::Fulfillment>,

    /// The form associated with the page, used for collecting parameters
    /// relevant to the page.
    pub form: std::option::Option<crate::model::Form>,

    /// Ordered list of
    /// [`TransitionRouteGroups`][google.cloud.dialogflow.cx.v3.TransitionRouteGroup]
    /// added to the page. Transition route groups must be unique within a page. If
    /// the page links both flow-level transition route groups and agent-level
    /// transition route groups, the flow-level ones will have higher priority and
    /// will be put before the agent-level ones.
    ///
    /// * If multiple transition routes within a page scope refer to the same
    ///   intent, then the precedence order is: page's transition route -> page's
    ///   transition route group -> flow's transition routes.
    ///
    /// * If multiple transition route groups within a page contain the same
    ///   intent, then the first group in the ordered list takes precedence.
    ///
    ///
    /// Format:`projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/transitionRouteGroups/<TransitionRouteGroupID>`
    /// or
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/transitionRouteGroups/<TransitionRouteGroupID>`
    /// for agent-level groups.
    ///
    /// [google.cloud.dialogflow.cx.v3.TransitionRouteGroup]: crate::model::TransitionRouteGroup
    pub transition_route_groups: std::vec::Vec<std::string::String>,

    /// A list of transitions for the transition rules of this page.
    /// They route the conversation to another page in the same flow, or another
    /// flow.
    ///
    /// When we are in a certain page, the TransitionRoutes are evaluated in the
    /// following order:
    ///
    /// * TransitionRoutes defined in the page with intent specified.
    /// * TransitionRoutes defined in the
    ///   [transition route
    ///   groups][google.cloud.dialogflow.cx.v3.Page.transition_route_groups]
    ///   with intent specified.
    /// * TransitionRoutes defined in flow with intent specified.
    /// * TransitionRoutes defined in the
    ///   [transition route
    ///   groups][google.cloud.dialogflow.cx.v3.Flow.transition_route_groups]
    ///   with intent specified.
    /// * TransitionRoutes defined in the page with only condition specified.
    /// * TransitionRoutes defined in the
    ///   [transition route
    ///   groups][google.cloud.dialogflow.cx.v3.Page.transition_route_groups]
    ///   with only condition specified.
    ///
    /// [google.cloud.dialogflow.cx.v3.Flow.transition_route_groups]: crate::model::Flow::transition_route_groups
    /// [google.cloud.dialogflow.cx.v3.Page.transition_route_groups]: crate::model::Page::transition_route_groups
    pub transition_routes: std::vec::Vec<crate::model::TransitionRoute>,

    /// Handlers associated with the page to handle events such as webhook errors,
    /// no match or no input.
    pub event_handlers: std::vec::Vec<crate::model::EventHandler>,

    /// Hierarchical advanced settings for this page. The settings exposed at the
    /// lower level overrides the settings exposed at the higher level.
    pub advanced_settings: std::option::Option<crate::model::AdvancedSettings>,

    /// Optional. Knowledge connector configuration.
    pub knowledge_connector_settings: std::option::Option<crate::model::KnowledgeConnectorSettings>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
impl Page {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Page::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Page::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Page::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [entry_fulfillment][crate::model::Page::entry_fulfillment].
    pub fn set_entry_fulfillment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Fulfillment>,
    {
        self.entry_fulfillment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entry_fulfillment][crate::model::Page::entry_fulfillment].
    pub fn set_or_clear_entry_fulfillment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Fulfillment>,
    {
        self.entry_fulfillment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [form][crate::model::Page::form].
    pub fn set_form<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Form>,
    {
        self.form = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [form][crate::model::Page::form].
    pub fn set_or_clear_form<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Form>,
    {
        self.form = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transition_route_groups][crate::model::Page::transition_route_groups].
    pub fn set_transition_route_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.transition_route_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [transition_routes][crate::model::Page::transition_routes].
    pub fn set_transition_routes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransitionRoute>,
    {
        use std::iter::Iterator;
        self.transition_routes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [event_handlers][crate::model::Page::event_handlers].
    pub fn set_event_handlers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EventHandler>,
    {
        use std::iter::Iterator;
        self.event_handlers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [advanced_settings][crate::model::Page::advanced_settings].
    pub fn set_advanced_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedSettings>,
    {
        self.advanced_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [advanced_settings][crate::model::Page::advanced_settings].
    pub fn set_or_clear_advanced_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedSettings>,
    {
        self.advanced_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [knowledge_connector_settings][crate::model::Page::knowledge_connector_settings].
    pub fn set_knowledge_connector_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KnowledgeConnectorSettings>,
    {
        self.knowledge_connector_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [knowledge_connector_settings][crate::model::Page::knowledge_connector_settings].
    pub fn set_or_clear_knowledge_connector_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KnowledgeConnectorSettings>,
    {
        self.knowledge_connector_settings = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
impl wkt::message::Message for Page {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.Page"
    }
}

#[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Page {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __entry_fulfillment,
            __form,
            __transition_route_groups,
            __transition_routes,
            __event_handlers,
            __advanced_settings,
            __knowledge_connector_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Page")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "entryFulfillment" => Ok(__FieldTag::__entry_fulfillment),
                            "entry_fulfillment" => Ok(__FieldTag::__entry_fulfillment),
                            "form" => Ok(__FieldTag::__form),
                            "transitionRouteGroups" => Ok(__FieldTag::__transition_route_groups),
                            "transition_route_groups" => Ok(__FieldTag::__transition_route_groups),
                            "transitionRoutes" => Ok(__FieldTag::__transition_routes),
                            "transition_routes" => Ok(__FieldTag::__transition_routes),
                            "eventHandlers" => Ok(__FieldTag::__event_handlers),
                            "event_handlers" => Ok(__FieldTag::__event_handlers),
                            "advancedSettings" => Ok(__FieldTag::__advanced_settings),
                            "advanced_settings" => Ok(__FieldTag::__advanced_settings),
                            "knowledgeConnectorSettings" => {
                                Ok(__FieldTag::__knowledge_connector_settings)
                            }
                            "knowledge_connector_settings" => {
                                Ok(__FieldTag::__knowledge_connector_settings)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Page;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Page")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entry_fulfillment => {
                            if !fields.insert(__FieldTag::__entry_fulfillment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entry_fulfillment",
                                ));
                            }
                            result.entry_fulfillment =
                                map.next_value::<std::option::Option<crate::model::Fulfillment>>()?;
                        }
                        __FieldTag::__form => {
                            if !fields.insert(__FieldTag::__form) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for form",
                                ));
                            }
                            result.form =
                                map.next_value::<std::option::Option<crate::model::Form>>()?;
                        }
                        __FieldTag::__transition_route_groups => {
                            if !fields.insert(__FieldTag::__transition_route_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transition_route_groups",
                                ));
                            }
                            result.transition_route_groups = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__transition_routes => {
                            if !fields.insert(__FieldTag::__transition_routes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transition_routes",
                                ));
                            }
                            result.transition_routes =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TransitionRoute>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event_handlers => {
                            if !fields.insert(__FieldTag::__event_handlers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_handlers",
                                ));
                            }
                            result.event_handlers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EventHandler>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__advanced_settings => {
                            if !fields.insert(__FieldTag::__advanced_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advanced_settings",
                                ));
                            }
                            result.advanced_settings = map
                                .next_value::<std::option::Option<crate::model::AdvancedSettings>>(
                                )?;
                        }
                        __FieldTag::__knowledge_connector_settings => {
                            if !fields.insert(__FieldTag::__knowledge_connector_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for knowledge_connector_settings",
                                ));
                            }
                            result.knowledge_connector_settings = map.next_value::<std::option::Option<crate::model::KnowledgeConnectorSettings>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for Page {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.entry_fulfillment.is_some() {
            state.serialize_entry("entryFulfillment", &self.entry_fulfillment)?;
        }
        if self.form.is_some() {
            state.serialize_entry("form", &self.form)?;
        }
        if !self.transition_route_groups.is_empty() {
            state.serialize_entry("transitionRouteGroups", &self.transition_route_groups)?;
        }
        if !self.transition_routes.is_empty() {
            state.serialize_entry("transitionRoutes", &self.transition_routes)?;
        }
        if !self.event_handlers.is_empty() {
            state.serialize_entry("eventHandlers", &self.event_handlers)?;
        }
        if self.advanced_settings.is_some() {
            state.serialize_entry("advancedSettings", &self.advanced_settings)?;
        }
        if self.knowledge_connector_settings.is_some() {
            state.serialize_entry(
                "knowledgeConnectorSettings",
                &self.knowledge_connector_settings,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A form is a data model that groups related parameters that can be collected
/// from the user. The process in which the agent prompts the user and collects
/// parameter values from the user is called form filling. A form can be added to
/// a [page][google.cloud.dialogflow.cx.v3.Page]. When form filling is done, the
/// filled parameters will be written to the
/// [session][google.cloud.dialogflow.cx.v3.SessionInfo.parameters].
///
/// [google.cloud.dialogflow.cx.v3.Page]: crate::model::Page
/// [google.cloud.dialogflow.cx.v3.SessionInfo.parameters]: crate::model::SessionInfo::parameters
#[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Form {
    /// Parameters to collect from the user.
    pub parameters: std::vec::Vec<crate::model::form::Parameter>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
impl Form {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parameters][crate::model::Form::parameters].
    pub fn set_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::form::Parameter>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
impl wkt::message::Message for Form {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.Form"
    }
}

#[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Form {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parameters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Form")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parameters" => Ok(__FieldTag::__parameters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Form;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Form")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::form::Parameter>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for Form {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parameters.is_empty() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Form].
#[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
pub mod form {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a form parameter.
    #[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Parameter {
        /// Required. The human-readable name of the parameter, unique within the
        /// form.
        pub display_name: std::string::String,

        /// Indicates whether the parameter is required. Optional parameters will not
        /// trigger prompts; however, they are filled if the user specifies them.
        /// Required parameters must be filled before form filling concludes.
        pub required: bool,

        /// Required. The entity type of the parameter.
        /// Format:
        /// `projects/-/locations/-/agents/-/entityTypes/<SystemEntityTypeID>` for
        /// system entity types (for example,
        /// `projects/-/locations/-/agents/-/entityTypes/sys.date`), or
        /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/entityTypes/<EntityTypeID>`
        /// for developer entity types.
        pub entity_type: std::string::String,

        /// Indicates whether the parameter represents a list of values.
        pub is_list: bool,

        /// Required. Defines fill behavior for the parameter.
        pub fill_behavior: std::option::Option<crate::model::form::parameter::FillBehavior>,

        /// The default value of an optional parameter. If the parameter is required,
        /// the default value will be ignored.
        pub default_value: std::option::Option<wkt::Value>,

        /// Indicates whether the parameter content should be redacted in log.  If
        /// redaction is enabled, the parameter content will be replaced by parameter
        /// name during logging.
        /// Note: the parameter content is subject to redaction if either parameter
        /// level redaction or [entity type level
        /// redaction][google.cloud.dialogflow.cx.v3.EntityType.redact] is enabled.
        ///
        /// [google.cloud.dialogflow.cx.v3.EntityType.redact]: crate::model::EntityType::redact
        pub redact: bool,

        /// Hierarchical advanced settings for this parameter. The settings exposed
        /// at the lower level overrides the settings exposed at the higher level.
        pub advanced_settings: std::option::Option<crate::model::AdvancedSettings>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
    impl Parameter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::form::Parameter::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [required][crate::model::form::Parameter::required].
        pub fn set_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.required = v.into();
            self
        }

        /// Sets the value of [entity_type][crate::model::form::Parameter::entity_type].
        pub fn set_entity_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.entity_type = v.into();
            self
        }

        /// Sets the value of [is_list][crate::model::form::Parameter::is_list].
        pub fn set_is_list<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.is_list = v.into();
            self
        }

        /// Sets the value of [fill_behavior][crate::model::form::Parameter::fill_behavior].
        pub fn set_fill_behavior<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::form::parameter::FillBehavior>,
        {
            self.fill_behavior = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [fill_behavior][crate::model::form::Parameter::fill_behavior].
        pub fn set_or_clear_fill_behavior<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::form::parameter::FillBehavior>,
        {
            self.fill_behavior = v.map(|x| x.into());
            self
        }

        /// Sets the value of [default_value][crate::model::form::Parameter::default_value].
        pub fn set_default_value<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Value>,
        {
            self.default_value = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [default_value][crate::model::form::Parameter::default_value].
        pub fn set_or_clear_default_value<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Value>,
        {
            self.default_value = v.map(|x| x.into());
            self
        }

        /// Sets the value of [redact][crate::model::form::Parameter::redact].
        pub fn set_redact<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.redact = v.into();
            self
        }

        /// Sets the value of [advanced_settings][crate::model::form::Parameter::advanced_settings].
        pub fn set_advanced_settings<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::AdvancedSettings>,
        {
            self.advanced_settings = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [advanced_settings][crate::model::form::Parameter::advanced_settings].
        pub fn set_or_clear_advanced_settings<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::AdvancedSettings>,
        {
            self.advanced_settings = v.map(|x| x.into());
            self
        }
    }

    #[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
    impl wkt::message::Message for Parameter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Form.Parameter"
        }
    }

    #[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Parameter {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __display_name,
                __required,
                __entity_type,
                __is_list,
                __fill_behavior,
                __default_value,
                __redact,
                __advanced_settings,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Parameter")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                "required" => Ok(__FieldTag::__required),
                                "entityType" => Ok(__FieldTag::__entity_type),
                                "entity_type" => Ok(__FieldTag::__entity_type),
                                "isList" => Ok(__FieldTag::__is_list),
                                "is_list" => Ok(__FieldTag::__is_list),
                                "fillBehavior" => Ok(__FieldTag::__fill_behavior),
                                "fill_behavior" => Ok(__FieldTag::__fill_behavior),
                                "defaultValue" => Ok(__FieldTag::__default_value),
                                "default_value" => Ok(__FieldTag::__default_value),
                                "redact" => Ok(__FieldTag::__redact),
                                "advancedSettings" => Ok(__FieldTag::__advanced_settings),
                                "advanced_settings" => Ok(__FieldTag::__advanced_settings),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Parameter;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Parameter")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__required => {
                                if !fields.insert(__FieldTag::__required) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for required",
                                    ));
                                }
                                result.required = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__entity_type => {
                                if !fields.insert(__FieldTag::__entity_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for entity_type",
                                    ));
                                }
                                result.entity_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__is_list => {
                                if !fields.insert(__FieldTag::__is_list) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for is_list",
                                    ));
                                }
                                result.is_list = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__fill_behavior => {
                                if !fields.insert(__FieldTag::__fill_behavior) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for fill_behavior",
                                    ));
                                }
                                result.fill_behavior = map.next_value::<std::option::Option<
                                    crate::model::form::parameter::FillBehavior,
                                >>()?;
                            }
                            __FieldTag::__default_value => {
                                if !fields.insert(__FieldTag::__default_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for default_value",
                                    ));
                                }
                                result.default_value = map
                                    .next_value::<std::option::Option<wkt::Value>>()?
                                    .or(Some(wkt::Value::Null));
                            }
                            __FieldTag::__redact => {
                                if !fields.insert(__FieldTag::__redact) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for redact",
                                    ));
                                }
                                result.redact = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__advanced_settings => {
                                if !fields.insert(__FieldTag::__advanced_settings) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for advanced_settings",
                                    ));
                                }
                                result.advanced_settings = map.next_value::<std::option::Option<crate::model::AdvancedSettings>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
    #[doc(hidden)]
    impl serde::ser::Serialize for Parameter {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !wkt::internal::is_default(&self.required) {
                state.serialize_entry("required", &self.required)?;
            }
            if !self.entity_type.is_empty() {
                state.serialize_entry("entityType", &self.entity_type)?;
            }
            if !wkt::internal::is_default(&self.is_list) {
                state.serialize_entry("isList", &self.is_list)?;
            }
            if self.fill_behavior.is_some() {
                state.serialize_entry("fillBehavior", &self.fill_behavior)?;
            }
            if self.default_value.is_some() {
                state.serialize_entry("defaultValue", &self.default_value)?;
            }
            if !wkt::internal::is_default(&self.redact) {
                state.serialize_entry("redact", &self.redact)?;
            }
            if self.advanced_settings.is_some() {
                state.serialize_entry("advancedSettings", &self.advanced_settings)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Parameter].
    #[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
    pub mod parameter {
        #[allow(unused_imports)]
        use super::*;

        /// Configuration for how the filling of a parameter should be handled.
        #[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct FillBehavior {
            /// Required. The fulfillment to provide the initial prompt that the agent
            /// can present to the user in order to fill the parameter.
            pub initial_prompt_fulfillment: std::option::Option<crate::model::Fulfillment>,

            /// The handlers for parameter-level events, used to provide reprompt for
            /// the parameter or transition to a different page/flow. The supported
            /// events are:
            ///
            /// * `sys.no-match-<N>`, where N can be from 1 to 6
            /// * `sys.no-match-default`
            /// * `sys.no-input-<N>`, where N can be from 1 to 6
            /// * `sys.no-input-default`
            /// * `sys.invalid-parameter`
            ///
            /// `initial_prompt_fulfillment` provides the first prompt for the
            /// parameter.
            ///
            /// If the user's response does not fill the parameter, a
            /// no-match/no-input event will be triggered, and the fulfillment
            /// associated with the `sys.no-match-1`/`sys.no-input-1` handler (if
            /// defined) will be called to provide a prompt. The
            /// `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to
            /// the next no-match/no-input event, and so on.
            ///
            /// A `sys.no-match-default` or `sys.no-input-default` handler will be used
            /// to handle all following no-match/no-input events after all numbered
            /// no-match/no-input handlers for the parameter are consumed.
            ///
            /// A `sys.invalid-parameter` handler can be defined to handle the case
            /// where the parameter values have been `invalidated` by webhook. For
            /// example, if the user's response fill the parameter, however the
            /// parameter was invalidated by webhook, the fulfillment associated with
            /// the `sys.invalid-parameter` handler (if defined) will be called to
            /// provide a prompt.
            ///
            /// If the event handler for the corresponding event can't be found on the
            /// parameter, `initial_prompt_fulfillment` will be re-prompted.
            pub reprompt_event_handlers: std::vec::Vec<crate::model::EventHandler>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
        impl FillBehavior {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [initial_prompt_fulfillment][crate::model::form::parameter::FillBehavior::initial_prompt_fulfillment].
            pub fn set_initial_prompt_fulfillment<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::Fulfillment>,
            {
                self.initial_prompt_fulfillment = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [initial_prompt_fulfillment][crate::model::form::parameter::FillBehavior::initial_prompt_fulfillment].
            pub fn set_or_clear_initial_prompt_fulfillment<T>(
                mut self,
                v: std::option::Option<T>,
            ) -> Self
            where
                T: std::convert::Into<crate::model::Fulfillment>,
            {
                self.initial_prompt_fulfillment = v.map(|x| x.into());
                self
            }

            /// Sets the value of [reprompt_event_handlers][crate::model::form::parameter::FillBehavior::reprompt_event_handlers].
            pub fn set_reprompt_event_handlers<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::EventHandler>,
            {
                use std::iter::Iterator;
                self.reprompt_event_handlers = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
        impl wkt::message::Message for FillBehavior {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.cx.v3.Form.Parameter.FillBehavior"
            }
        }

        #[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for FillBehavior {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __initial_prompt_fulfillment,
                    __reprompt_event_handlers,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for FillBehavior")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "initialPromptFulfillment" => {
                                        Ok(__FieldTag::__initial_prompt_fulfillment)
                                    }
                                    "initial_prompt_fulfillment" => {
                                        Ok(__FieldTag::__initial_prompt_fulfillment)
                                    }
                                    "repromptEventHandlers" => {
                                        Ok(__FieldTag::__reprompt_event_handlers)
                                    }
                                    "reprompt_event_handlers" => {
                                        Ok(__FieldTag::__reprompt_event_handlers)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = FillBehavior;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct FillBehavior")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__initial_prompt_fulfillment => {
                                    if !fields.insert(__FieldTag::__initial_prompt_fulfillment) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for initial_prompt_fulfillment",
                                            ),
                                        );
                                    }
                                    result.initial_prompt_fulfillment = map.next_value::<std::option::Option<crate::model::Fulfillment>>()?
                                        ;
                                }
                                __FieldTag::__reprompt_event_handlers => {
                                    if !fields.insert(__FieldTag::__reprompt_event_handlers) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for reprompt_event_handlers",
                                            ),
                                        );
                                    }
                                    result.reprompt_event_handlers = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<crate::model::EventHandler>,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(feature = "pages", feature = "sessions", feature = "test-cases",))]
        #[doc(hidden)]
        impl serde::ser::Serialize for FillBehavior {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.initial_prompt_fulfillment.is_some() {
                    state.serialize_entry(
                        "initialPromptFulfillment",
                        &self.initial_prompt_fulfillment,
                    )?;
                }
                if !self.reprompt_event_handlers.is_empty() {
                    state
                        .serialize_entry("repromptEventHandlers", &self.reprompt_event_handlers)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }
}

/// An event handler specifies an
/// [event][google.cloud.dialogflow.cx.v3.EventHandler.event] that can be handled
/// during a session. When the specified event happens, the following actions are
/// taken in order:
///
/// * If there is a
///   [`trigger_fulfillment`][google.cloud.dialogflow.cx.v3.EventHandler.trigger_fulfillment]
///   associated with the event, it will be called.
/// * If there is a
///   [`target_page`][google.cloud.dialogflow.cx.v3.EventHandler.target_page]
///   associated with the event, the session will transition into the specified
///   page.
/// * If there is a
///   [`target_flow`][google.cloud.dialogflow.cx.v3.EventHandler.target_flow]
///   associated with the event, the session will transition into the specified
///   flow.
///
/// [google.cloud.dialogflow.cx.v3.EventHandler.event]: crate::model::EventHandler::event
/// [google.cloud.dialogflow.cx.v3.EventHandler.target_flow]: crate::model::EventHandler::target
/// [google.cloud.dialogflow.cx.v3.EventHandler.target_page]: crate::model::EventHandler::target
/// [google.cloud.dialogflow.cx.v3.EventHandler.trigger_fulfillment]: crate::model::EventHandler::trigger_fulfillment
#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EventHandler {
    /// Output only. The unique identifier of this event handler.
    pub name: std::string::String,

    /// Required. The name of the event to handle.
    pub event: std::string::String,

    /// The fulfillment to call when the event occurs.
    /// Handling webhook errors with a fulfillment enabled with webhook could
    /// cause infinite loop. It is invalid to specify such fulfillment for a
    /// handler handling webhooks.
    pub trigger_fulfillment: std::option::Option<crate::model::Fulfillment>,

    /// The target to transition to, either a page in the same host flow (the flow
    /// that owns this
    /// [TransitionRoute][google.cloud.dialogflow.cx.v3.TransitionRoute]), or
    /// another flow in the same agent.
    ///
    /// [google.cloud.dialogflow.cx.v3.TransitionRoute]: crate::model::TransitionRoute
    pub target: std::option::Option<crate::model::event_handler::Target>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl EventHandler {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EventHandler::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [event][crate::model::EventHandler::event].
    pub fn set_event<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.event = v.into();
        self
    }

    /// Sets the value of [trigger_fulfillment][crate::model::EventHandler::trigger_fulfillment].
    pub fn set_trigger_fulfillment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Fulfillment>,
    {
        self.trigger_fulfillment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [trigger_fulfillment][crate::model::EventHandler::trigger_fulfillment].
    pub fn set_or_clear_trigger_fulfillment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Fulfillment>,
    {
        self.trigger_fulfillment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::EventHandler::target].
    ///
    /// Note that all the setters affecting `target` are mutually
    /// exclusive.
    pub fn set_target<
        T: std::convert::Into<std::option::Option<crate::model::event_handler::Target>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// The value of [target][crate::model::EventHandler::target]
    /// if it holds a `TargetPage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn target_page(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::event_handler::Target::TargetPage(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::EventHandler::target]
    /// to hold a `TargetPage`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_target_page<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target =
            std::option::Option::Some(crate::model::event_handler::Target::TargetPage(v.into()));
        self
    }

    /// The value of [target][crate::model::EventHandler::target]
    /// if it holds a `TargetFlow`, `None` if the field is not set or
    /// holds a different branch.
    pub fn target_flow(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::event_handler::Target::TargetFlow(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::EventHandler::target]
    /// to hold a `TargetFlow`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_target_flow<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target =
            std::option::Option::Some(crate::model::event_handler::Target::TargetFlow(v.into()));
        self
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl wkt::message::Message for EventHandler {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.EventHandler"
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EventHandler {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __event,
            __trigger_fulfillment,
            __target_page,
            __target_flow,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EventHandler")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "event" => Ok(__FieldTag::__event),
                            "triggerFulfillment" => Ok(__FieldTag::__trigger_fulfillment),
                            "trigger_fulfillment" => Ok(__FieldTag::__trigger_fulfillment),
                            "targetPage" => Ok(__FieldTag::__target_page),
                            "target_page" => Ok(__FieldTag::__target_page),
                            "targetFlow" => Ok(__FieldTag::__target_flow),
                            "target_flow" => Ok(__FieldTag::__target_flow),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EventHandler;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EventHandler")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event => {
                            if !fields.insert(__FieldTag::__event) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event",
                                ));
                            }
                            result.event = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger_fulfillment => {
                            if !fields.insert(__FieldTag::__trigger_fulfillment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_fulfillment",
                                ));
                            }
                            result.trigger_fulfillment =
                                map.next_value::<std::option::Option<crate::model::Fulfillment>>()?;
                        }
                        __FieldTag::__target_page => {
                            if !fields.insert(__FieldTag::__target_page) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_page",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.cloud.dialogflow.cx.v3.EventHandler.target_page, latest field was targetPage",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::event_handler::Target::TargetPage(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__target_flow => {
                            if !fields.insert(__FieldTag::__target_flow) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_flow",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.cloud.dialogflow.cx.v3.EventHandler.target_flow, latest field was targetFlow",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::event_handler::Target::TargetFlow(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
#[doc(hidden)]
impl serde::ser::Serialize for EventHandler {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.event.is_empty() {
            state.serialize_entry("event", &self.event)?;
        }
        if self.trigger_fulfillment.is_some() {
            state.serialize_entry("triggerFulfillment", &self.trigger_fulfillment)?;
        }
        if let Some(value) = self.target_page() {
            state.serialize_entry("targetPage", value)?;
        }
        if let Some(value) = self.target_flow() {
            state.serialize_entry("targetFlow", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EventHandler].
#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
pub mod event_handler {
    #[allow(unused_imports)]
    use super::*;

    /// The target to transition to, either a page in the same host flow (the flow
    /// that owns this
    /// [TransitionRoute][google.cloud.dialogflow.cx.v3.TransitionRoute]), or
    /// another flow in the same agent.
    ///
    /// [google.cloud.dialogflow.cx.v3.TransitionRoute]: crate::model::TransitionRoute
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Target {
        /// The target page to transition to.
        /// Format:
        /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/pages/<PageID>`.
        TargetPage(std::string::String),
        /// The target flow to transition to.
        /// Format:
        /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>`.
        TargetFlow(std::string::String),
    }
}

/// A transition route specifies a [intent][google.cloud.dialogflow.cx.v3.Intent]
/// that can be matched and/or a data condition that can be evaluated during a
/// session. When a specified transition is matched, the following actions are
/// taken in order:
///
/// * If there is a
///   [`trigger_fulfillment`][google.cloud.dialogflow.cx.v3.TransitionRoute.trigger_fulfillment]
///   associated with the transition, it will be called.
/// * If there is a
///   [`target_page`][google.cloud.dialogflow.cx.v3.TransitionRoute.target_page]
///   associated with the transition, the session will transition into the
///   specified page.
/// * If there is a
///   [`target_flow`][google.cloud.dialogflow.cx.v3.TransitionRoute.target_flow]
///   associated with the transition, the session will transition into the
///   specified flow.
///
/// [google.cloud.dialogflow.cx.v3.Intent]: crate::model::Intent
/// [google.cloud.dialogflow.cx.v3.TransitionRoute.target_flow]: crate::model::TransitionRoute::target
/// [google.cloud.dialogflow.cx.v3.TransitionRoute.target_page]: crate::model::TransitionRoute::target
/// [google.cloud.dialogflow.cx.v3.TransitionRoute.trigger_fulfillment]: crate::model::TransitionRoute::trigger_fulfillment
#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TransitionRoute {
    /// Output only. The unique identifier of this transition route.
    pub name: std::string::String,

    /// Optional. The description of the transition route. The maximum length is
    /// 500 characters.
    pub description: std::string::String,

    /// The unique identifier of an [Intent][google.cloud.dialogflow.cx.v3.Intent].
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/intents/<IntentID>`.
    /// Indicates that the transition can only happen when the given intent is
    /// matched.
    /// At least one of `intent` or `condition` must be specified. When both
    /// `intent` and `condition` are specified, the transition can only happen
    /// when both are fulfilled.
    ///
    /// [google.cloud.dialogflow.cx.v3.Intent]: crate::model::Intent
    pub intent: std::string::String,

    /// The condition to evaluate against [form
    /// parameters][google.cloud.dialogflow.cx.v3.Form.parameters] or [session
    /// parameters][google.cloud.dialogflow.cx.v3.SessionInfo.parameters].
    ///
    /// See the [conditions
    /// reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
    /// At least one of `intent` or `condition` must be specified. When both
    /// `intent` and `condition` are specified, the transition can only happen
    /// when both are fulfilled.
    ///
    /// [google.cloud.dialogflow.cx.v3.Form.parameters]: crate::model::Form::parameters
    /// [google.cloud.dialogflow.cx.v3.SessionInfo.parameters]: crate::model::SessionInfo::parameters
    pub condition: std::string::String,

    /// The fulfillment to call when the condition is satisfied. At least one of
    /// `trigger_fulfillment` and `target` must be specified. When both are
    /// defined, `trigger_fulfillment` is executed first.
    pub trigger_fulfillment: std::option::Option<crate::model::Fulfillment>,

    /// The target to transition to, either a page in the same host flow (the flow
    /// that owns this
    /// [TransitionRoute][google.cloud.dialogflow.cx.v3.TransitionRoute]), or
    /// another flow in the same agent.
    ///
    /// [google.cloud.dialogflow.cx.v3.TransitionRoute]: crate::model::TransitionRoute
    pub target: std::option::Option<crate::model::transition_route::Target>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl TransitionRoute {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TransitionRoute::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TransitionRoute::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [intent][crate::model::TransitionRoute::intent].
    pub fn set_intent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.intent = v.into();
        self
    }

    /// Sets the value of [condition][crate::model::TransitionRoute::condition].
    pub fn set_condition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.condition = v.into();
        self
    }

    /// Sets the value of [trigger_fulfillment][crate::model::TransitionRoute::trigger_fulfillment].
    pub fn set_trigger_fulfillment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Fulfillment>,
    {
        self.trigger_fulfillment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [trigger_fulfillment][crate::model::TransitionRoute::trigger_fulfillment].
    pub fn set_or_clear_trigger_fulfillment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Fulfillment>,
    {
        self.trigger_fulfillment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::TransitionRoute::target].
    ///
    /// Note that all the setters affecting `target` are mutually
    /// exclusive.
    pub fn set_target<
        T: std::convert::Into<std::option::Option<crate::model::transition_route::Target>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// The value of [target][crate::model::TransitionRoute::target]
    /// if it holds a `TargetPage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn target_page(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::transition_route::Target::TargetPage(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::TransitionRoute::target]
    /// to hold a `TargetPage`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_target_page<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target =
            std::option::Option::Some(crate::model::transition_route::Target::TargetPage(v.into()));
        self
    }

    /// The value of [target][crate::model::TransitionRoute::target]
    /// if it holds a `TargetFlow`, `None` if the field is not set or
    /// holds a different branch.
    pub fn target_flow(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::transition_route::Target::TargetFlow(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::TransitionRoute::target]
    /// to hold a `TargetFlow`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_target_flow<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target =
            std::option::Option::Some(crate::model::transition_route::Target::TargetFlow(v.into()));
        self
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl wkt::message::Message for TransitionRoute {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.TransitionRoute"
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransitionRoute {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __intent,
            __condition,
            __trigger_fulfillment,
            __target_page,
            __target_flow,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransitionRoute")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "intent" => Ok(__FieldTag::__intent),
                            "condition" => Ok(__FieldTag::__condition),
                            "triggerFulfillment" => Ok(__FieldTag::__trigger_fulfillment),
                            "trigger_fulfillment" => Ok(__FieldTag::__trigger_fulfillment),
                            "targetPage" => Ok(__FieldTag::__target_page),
                            "target_page" => Ok(__FieldTag::__target_page),
                            "targetFlow" => Ok(__FieldTag::__target_flow),
                            "target_flow" => Ok(__FieldTag::__target_flow),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransitionRoute;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransitionRoute")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__intent => {
                            if !fields.insert(__FieldTag::__intent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent",
                                ));
                            }
                            result.intent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger_fulfillment => {
                            if !fields.insert(__FieldTag::__trigger_fulfillment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_fulfillment",
                                ));
                            }
                            result.trigger_fulfillment =
                                map.next_value::<std::option::Option<crate::model::Fulfillment>>()?;
                        }
                        __FieldTag::__target_page => {
                            if !fields.insert(__FieldTag::__target_page) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_page",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.cloud.dialogflow.cx.v3.TransitionRoute.target_page, latest field was targetPage",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::transition_route::Target::TargetPage(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__target_flow => {
                            if !fields.insert(__FieldTag::__target_flow) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_flow",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.cloud.dialogflow.cx.v3.TransitionRoute.target_flow, latest field was targetFlow",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::transition_route::Target::TargetFlow(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for TransitionRoute {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.intent.is_empty() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !self.condition.is_empty() {
            state.serialize_entry("condition", &self.condition)?;
        }
        if self.trigger_fulfillment.is_some() {
            state.serialize_entry("triggerFulfillment", &self.trigger_fulfillment)?;
        }
        if let Some(value) = self.target_page() {
            state.serialize_entry("targetPage", value)?;
        }
        if let Some(value) = self.target_flow() {
            state.serialize_entry("targetFlow", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TransitionRoute].
#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
pub mod transition_route {
    #[allow(unused_imports)]
    use super::*;

    /// The target to transition to, either a page in the same host flow (the flow
    /// that owns this
    /// [TransitionRoute][google.cloud.dialogflow.cx.v3.TransitionRoute]), or
    /// another flow in the same agent.
    ///
    /// [google.cloud.dialogflow.cx.v3.TransitionRoute]: crate::model::TransitionRoute
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Target {
        /// The target page to transition to.
        /// Format:
        /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/pages/<PageID>`.
        TargetPage(std::string::String),
        /// The target flow to transition to.
        /// Format:
        /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>`.
        TargetFlow(std::string::String),
    }
}

/// The request message for
/// [Pages.ListPages][google.cloud.dialogflow.cx.v3.Pages.ListPages].
///
/// [google.cloud.dialogflow.cx.v3.Pages.ListPages]: crate::client::Pages::list_pages
#[cfg(feature = "pages")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPagesRequest {
    /// Required. The flow to list all pages for.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>`.
    pub parent: std::string::String,

    /// The language to list pages for. The following fields are language
    /// dependent:
    ///
    /// * `Page.entry_fulfillment.messages`
    /// * `Page.entry_fulfillment.conditional_cases`
    /// * `Page.event_handlers.trigger_fulfillment.messages`
    /// * `Page.event_handlers.trigger_fulfillment.conditional_cases`
    /// * `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.messages`
    ///
    /// `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.conditional_cases`
    ///
    /// * `Page.form.parameters.fill_behavior.reprompt_event_handlers.messages`
    ///
    /// `Page.form.parameters.fill_behavior.reprompt_event_handlers.conditional_cases`
    ///
    /// * `Page.transition_routes.trigger_fulfillment.messages`
    /// * `Page.transition_routes.trigger_fulfillment.conditional_cases`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    /// The maximum number of items to return in a single page. By default 100 and
    /// at most 1000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pages")]
impl ListPagesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPagesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::ListPagesRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPagesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPagesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "pages")]
impl wkt::message::Message for ListPagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListPagesRequest"
    }
}

#[cfg(feature = "pages")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPagesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __language_code,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPagesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPagesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPagesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "pages")]
#[doc(hidden)]
impl serde::ser::Serialize for ListPagesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Pages.ListPages][google.cloud.dialogflow.cx.v3.Pages.ListPages].
///
/// [google.cloud.dialogflow.cx.v3.Pages.ListPages]: crate::client::Pages::list_pages
#[cfg(feature = "pages")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListPagesResponse {
    /// The list of pages. There will be a maximum number of items returned based
    /// on the page_size field in the request.
    pub pages: std::vec::Vec<crate::model::Page>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pages")]
impl ListPagesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pages][crate::model::ListPagesResponse::pages].
    pub fn set_pages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Page>,
    {
        use std::iter::Iterator;
        self.pages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListPagesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "pages")]
impl wkt::message::Message for ListPagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListPagesResponse"
    }
}

#[cfg(feature = "pages")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListPagesResponse {
    type PageItem = crate::model::Page;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.pages
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "pages")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListPagesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pages,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListPagesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pages" => Ok(__FieldTag::__pages),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListPagesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListPagesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pages => {
                            if !fields.insert(__FieldTag::__pages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pages",
                                ));
                            }
                            result.pages = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Page>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "pages")]
#[doc(hidden)]
impl serde::ser::Serialize for ListPagesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.pages.is_empty() {
            state.serialize_entry("pages", &self.pages)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Pages.GetPage][google.cloud.dialogflow.cx.v3.Pages.GetPage].
///
/// [google.cloud.dialogflow.cx.v3.Pages.GetPage]: crate::client::Pages::get_page
#[cfg(feature = "pages")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetPageRequest {
    /// Required. The name of the page.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/pages/<PageID>`.
    pub name: std::string::String,

    /// The language to retrieve the page for. The following fields are language
    /// dependent:
    ///
    /// * `Page.entry_fulfillment.messages`
    /// * `Page.entry_fulfillment.conditional_cases`
    /// * `Page.event_handlers.trigger_fulfillment.messages`
    /// * `Page.event_handlers.trigger_fulfillment.conditional_cases`
    /// * `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.messages`
    ///
    /// `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.conditional_cases`
    ///
    /// * `Page.form.parameters.fill_behavior.reprompt_event_handlers.messages`
    ///
    /// `Page.form.parameters.fill_behavior.reprompt_event_handlers.conditional_cases`
    ///
    /// * `Page.transition_routes.trigger_fulfillment.messages`
    /// * `Page.transition_routes.trigger_fulfillment.conditional_cases`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pages")]
impl GetPageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPageRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::GetPageRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "pages")]
impl wkt::message::Message for GetPageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetPageRequest"
    }
}

#[cfg(feature = "pages")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetPageRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPageRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetPageRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPageRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "pages")]
#[doc(hidden)]
impl serde::ser::Serialize for GetPageRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Pages.CreatePage][google.cloud.dialogflow.cx.v3.Pages.CreatePage].
///
/// [google.cloud.dialogflow.cx.v3.Pages.CreatePage]: crate::client::Pages::create_page
#[cfg(feature = "pages")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreatePageRequest {
    /// Required. The flow to create a page for.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>`.
    pub parent: std::string::String,

    /// Required. The page to create.
    pub page: std::option::Option<crate::model::Page>,

    /// The language of the following fields in `page`:
    ///
    /// * `Page.entry_fulfillment.messages`
    /// * `Page.entry_fulfillment.conditional_cases`
    /// * `Page.event_handlers.trigger_fulfillment.messages`
    /// * `Page.event_handlers.trigger_fulfillment.conditional_cases`
    /// * `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.messages`
    ///
    /// `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.conditional_cases`
    ///
    /// * `Page.form.parameters.fill_behavior.reprompt_event_handlers.messages`
    ///
    /// `Page.form.parameters.fill_behavior.reprompt_event_handlers.conditional_cases`
    ///
    /// * `Page.transition_routes.trigger_fulfillment.messages`
    /// * `Page.transition_routes.trigger_fulfillment.conditional_cases`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pages")]
impl CreatePageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePageRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page][crate::model::CreatePageRequest::page].
    pub fn set_page<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Page>,
    {
        self.page = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [page][crate::model::CreatePageRequest::page].
    pub fn set_or_clear_page<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Page>,
    {
        self.page = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::CreatePageRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "pages")]
impl wkt::message::Message for CreatePageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CreatePageRequest"
    }
}

#[cfg(feature = "pages")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreatePageRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreatePageRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "page" => Ok(__FieldTag::__page),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreatePageRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreatePageRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page => {
                            if !fields.insert(__FieldTag::__page) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page",
                                ));
                            }
                            result.page =
                                map.next_value::<std::option::Option<crate::model::Page>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "pages")]
#[doc(hidden)]
impl serde::ser::Serialize for CreatePageRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.page.is_some() {
            state.serialize_entry("page", &self.page)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Pages.UpdatePage][google.cloud.dialogflow.cx.v3.Pages.UpdatePage].
///
/// [google.cloud.dialogflow.cx.v3.Pages.UpdatePage]: crate::client::Pages::update_page
#[cfg(feature = "pages")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdatePageRequest {
    /// Required. The page to update.
    pub page: std::option::Option<crate::model::Page>,

    /// The language of the following fields in `page`:
    ///
    /// * `Page.entry_fulfillment.messages`
    /// * `Page.entry_fulfillment.conditional_cases`
    /// * `Page.event_handlers.trigger_fulfillment.messages`
    /// * `Page.event_handlers.trigger_fulfillment.conditional_cases`
    /// * `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.messages`
    ///
    /// `Page.form.parameters.fill_behavior.initial_prompt_fulfillment.conditional_cases`
    ///
    /// * `Page.form.parameters.fill_behavior.reprompt_event_handlers.messages`
    ///
    /// `Page.form.parameters.fill_behavior.reprompt_event_handlers.conditional_cases`
    ///
    /// * `Page.transition_routes.trigger_fulfillment.messages`
    /// * `Page.transition_routes.trigger_fulfillment.conditional_cases`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    /// The mask to control which fields get updated. If the mask is not present,
    /// all fields will be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pages")]
impl UpdatePageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [page][crate::model::UpdatePageRequest::page].
    pub fn set_page<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Page>,
    {
        self.page = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [page][crate::model::UpdatePageRequest::page].
    pub fn set_or_clear_page<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Page>,
    {
        self.page = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::UpdatePageRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdatePageRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdatePageRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "pages")]
impl wkt::message::Message for UpdatePageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.UpdatePageRequest"
    }
}

#[cfg(feature = "pages")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdatePageRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __page,
            __language_code,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdatePageRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "page" => Ok(__FieldTag::__page),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdatePageRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdatePageRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__page => {
                            if !fields.insert(__FieldTag::__page) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page",
                                ));
                            }
                            result.page =
                                map.next_value::<std::option::Option<crate::model::Page>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "pages")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdatePageRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.page.is_some() {
            state.serialize_entry("page", &self.page)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Pages.DeletePage][google.cloud.dialogflow.cx.v3.Pages.DeletePage].
///
/// [google.cloud.dialogflow.cx.v3.Pages.DeletePage]: crate::client::Pages::delete_page
#[cfg(feature = "pages")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeletePageRequest {
    /// Required. The name of the page to delete.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/Flows/<flowID>/pages/<PageID>`.
    pub name: std::string::String,

    /// This field has no effect for pages with no incoming transitions.
    /// For pages with incoming transitions:
    ///
    /// * If `force` is set to false, an error will be returned with message
    ///   indicating the incoming transitions.
    /// * If `force` is set to true, Dialogflow will remove the page, as well as
    ///   any transitions to the page (i.e. [Target
    ///   page][EventHandler.target_page] in event handlers or [Target
    ///   page][TransitionRoute.target_page] in transition routes that point to
    ///   this page will be cleared).
    ///
    /// [EventHandler.target_page]: crate::model::EventHandler::target
    /// [TransitionRoute.target_page]: crate::model::TransitionRoute::target
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "pages")]
impl DeletePageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePageRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeletePageRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

#[cfg(feature = "pages")]
impl wkt::message::Message for DeletePageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DeletePageRequest"
    }
}

#[cfg(feature = "pages")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeletePageRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeletePageRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeletePageRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeletePageRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "pages")]
#[doc(hidden)]
impl serde::ser::Serialize for DeletePageRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The Knowledge Connector settings for this page or flow.
/// This includes information such as the attached Knowledge Bases, and the way
/// to execute fulfillment.
#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct KnowledgeConnectorSettings {
    /// Whether Knowledge Connector is enabled or not.
    pub enabled: bool,

    /// The fulfillment to be triggered.
    ///
    /// When the answers from the Knowledge Connector are selected by Dialogflow,
    /// you can utitlize the request scoped parameter `$request.knowledge.answers`
    /// (contains up to the 5 highest confidence answers) and
    /// `$request.knowledge.questions` (contains the corresponding questions) to
    /// construct the fulfillment.
    pub trigger_fulfillment: std::option::Option<crate::model::Fulfillment>,

    /// Optional. List of related data store connections.
    pub data_store_connections: std::vec::Vec<crate::model::DataStoreConnection>,

    /// The target to transition to, either a page in the same host flow (the flow
    /// that owns this
    /// [KnowledgeConnectorSettings][google.cloud.dialogflow.cx.v3.KnowledgeConnectorSettings]),
    /// or another flow in the same agent.
    ///
    /// [google.cloud.dialogflow.cx.v3.KnowledgeConnectorSettings]: crate::model::KnowledgeConnectorSettings
    pub target: std::option::Option<crate::model::knowledge_connector_settings::Target>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl KnowledgeConnectorSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::KnowledgeConnectorSettings::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [trigger_fulfillment][crate::model::KnowledgeConnectorSettings::trigger_fulfillment].
    pub fn set_trigger_fulfillment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Fulfillment>,
    {
        self.trigger_fulfillment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [trigger_fulfillment][crate::model::KnowledgeConnectorSettings::trigger_fulfillment].
    pub fn set_or_clear_trigger_fulfillment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Fulfillment>,
    {
        self.trigger_fulfillment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_store_connections][crate::model::KnowledgeConnectorSettings::data_store_connections].
    pub fn set_data_store_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataStoreConnection>,
    {
        use std::iter::Iterator;
        self.data_store_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target][crate::model::KnowledgeConnectorSettings::target].
    ///
    /// Note that all the setters affecting `target` are mutually
    /// exclusive.
    pub fn set_target<
        T: std::convert::Into<std::option::Option<crate::model::knowledge_connector_settings::Target>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// The value of [target][crate::model::KnowledgeConnectorSettings::target]
    /// if it holds a `TargetPage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn target_page(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::knowledge_connector_settings::Target::TargetPage(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::KnowledgeConnectorSettings::target]
    /// to hold a `TargetPage`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_target_page<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = std::option::Option::Some(
            crate::model::knowledge_connector_settings::Target::TargetPage(v.into()),
        );
        self
    }

    /// The value of [target][crate::model::KnowledgeConnectorSettings::target]
    /// if it holds a `TargetFlow`, `None` if the field is not set or
    /// holds a different branch.
    pub fn target_flow(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::knowledge_connector_settings::Target::TargetFlow(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::KnowledgeConnectorSettings::target]
    /// to hold a `TargetFlow`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_target_flow<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = std::option::Option::Some(
            crate::model::knowledge_connector_settings::Target::TargetFlow(v.into()),
        );
        self
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl wkt::message::Message for KnowledgeConnectorSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.KnowledgeConnectorSettings"
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KnowledgeConnectorSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __trigger_fulfillment,
            __target_page,
            __target_flow,
            __data_store_connections,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KnowledgeConnectorSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "triggerFulfillment" => Ok(__FieldTag::__trigger_fulfillment),
                            "trigger_fulfillment" => Ok(__FieldTag::__trigger_fulfillment),
                            "targetPage" => Ok(__FieldTag::__target_page),
                            "target_page" => Ok(__FieldTag::__target_page),
                            "targetFlow" => Ok(__FieldTag::__target_flow),
                            "target_flow" => Ok(__FieldTag::__target_flow),
                            "dataStoreConnections" => Ok(__FieldTag::__data_store_connections),
                            "data_store_connections" => Ok(__FieldTag::__data_store_connections),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KnowledgeConnectorSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KnowledgeConnectorSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger_fulfillment => {
                            if !fields.insert(__FieldTag::__trigger_fulfillment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_fulfillment",
                                ));
                            }
                            result.trigger_fulfillment =
                                map.next_value::<std::option::Option<crate::model::Fulfillment>>()?;
                        }
                        __FieldTag::__target_page => {
                            if !fields.insert(__FieldTag::__target_page) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_page",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.cloud.dialogflow.cx.v3.KnowledgeConnectorSettings.target_page, latest field was targetPage",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::knowledge_connector_settings::Target::TargetPage(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__target_flow => {
                            if !fields.insert(__FieldTag::__target_flow) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_flow",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.cloud.dialogflow.cx.v3.KnowledgeConnectorSettings.target_flow, latest field was targetFlow",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::knowledge_connector_settings::Target::TargetFlow(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_store_connections => {
                            if !fields.insert(__FieldTag::__data_store_connections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_store_connections",
                                ));
                            }
                            result.data_store_connections = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DataStoreConnection>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
#[doc(hidden)]
impl serde::ser::Serialize for KnowledgeConnectorSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if self.trigger_fulfillment.is_some() {
            state.serialize_entry("triggerFulfillment", &self.trigger_fulfillment)?;
        }
        if let Some(value) = self.target_page() {
            state.serialize_entry("targetPage", value)?;
        }
        if let Some(value) = self.target_flow() {
            state.serialize_entry("targetFlow", value)?;
        }
        if !self.data_store_connections.is_empty() {
            state.serialize_entry("dataStoreConnections", &self.data_store_connections)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [KnowledgeConnectorSettings].
#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
pub mod knowledge_connector_settings {
    #[allow(unused_imports)]
    use super::*;

    /// The target to transition to, either a page in the same host flow (the flow
    /// that owns this
    /// [KnowledgeConnectorSettings][google.cloud.dialogflow.cx.v3.KnowledgeConnectorSettings]),
    /// or another flow in the same agent.
    ///
    /// [google.cloud.dialogflow.cx.v3.KnowledgeConnectorSettings]: crate::model::KnowledgeConnectorSettings
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Target {
        /// The target page to transition to.
        /// Format:
        /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/pages/<PageID>`.
        TargetPage(std::string::String),
        /// The target flow to transition to.
        /// Format:
        /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>`.
        TargetFlow(std::string::String),
    }
}

/// Represents a response message that can be returned by a conversational agent.
///
/// Response messages are also used for output audio synthesis. The approach is
/// as follows:
///
/// * If at least one OutputAudioText response is present, then all
///   OutputAudioText responses are linearly concatenated, and the result is used
///   for output audio synthesis.
/// * If the OutputAudioText responses are a mixture of text and SSML, then the
///   concatenated result is treated as SSML; otherwise, the result is treated as
///   either text or SSML as appropriate. The agent designer should ideally use
///   either text or SSML consistently throughout the bot design.
/// * Otherwise, all Text responses are linearly concatenated, and the result is
///   used for output audio synthesis.
///
/// This approach allows for more sophisticated user experience scenarios, where
/// the text displayed to the user may differ from what is heard.
#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResponseMessage {
    /// Response type.
    pub response_type: crate::model::response_message::ResponseType,

    /// The channel which the response is associated with. Clients can specify the
    /// channel via
    /// [QueryParameters.channel][google.cloud.dialogflow.cx.v3.QueryParameters.channel],
    /// and only associated channel response will be returned.
    ///
    /// [google.cloud.dialogflow.cx.v3.QueryParameters.channel]: crate::model::QueryParameters::channel
    pub channel: std::string::String,

    /// Required. The rich response message.
    pub message: std::option::Option<crate::model::response_message::Message>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl ResponseMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [response_type][crate::model::ResponseMessage::response_type].
    pub fn set_response_type<
        T: std::convert::Into<crate::model::response_message::ResponseType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response_type = v.into();
        self
    }

    /// Sets the value of [channel][crate::model::ResponseMessage::channel].
    pub fn set_channel<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.channel = v.into();
        self
    }

    /// Sets the value of [message][crate::model::ResponseMessage::message].
    ///
    /// Note that all the setters affecting `message` are mutually
    /// exclusive.
    pub fn set_message<
        T: std::convert::Into<std::option::Option<crate::model::response_message::Message>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.message = v.into();
        self
    }

    /// The value of [message][crate::model::ResponseMessage::message]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::response_message::Text>> {
        #[allow(unreachable_patterns)]
        self.message.as_ref().and_then(|v| match v {
            crate::model::response_message::Message::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [message][crate::model::ResponseMessage::message]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `message` are
    /// mutually exclusive.
    pub fn set_text<
        T: std::convert::Into<std::boxed::Box<crate::model::response_message::Text>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.message =
            std::option::Option::Some(crate::model::response_message::Message::Text(v.into()));
        self
    }

    /// The value of [message][crate::model::ResponseMessage::message]
    /// if it holds a `Payload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn payload(&self) -> std::option::Option<&std::boxed::Box<wkt::Struct>> {
        #[allow(unreachable_patterns)]
        self.message.as_ref().and_then(|v| match v {
            crate::model::response_message::Message::Payload(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [message][crate::model::ResponseMessage::message]
    /// to hold a `Payload`.
    ///
    /// Note that all the setters affecting `message` are
    /// mutually exclusive.
    pub fn set_payload<T: std::convert::Into<std::boxed::Box<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.message =
            std::option::Option::Some(crate::model::response_message::Message::Payload(v.into()));
        self
    }

    /// The value of [message][crate::model::ResponseMessage::message]
    /// if it holds a `ConversationSuccess`, `None` if the field is not set or
    /// holds a different branch.
    pub fn conversation_success(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::response_message::ConversationSuccess>>
    {
        #[allow(unreachable_patterns)]
        self.message.as_ref().and_then(|v| match v {
            crate::model::response_message::Message::ConversationSuccess(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [message][crate::model::ResponseMessage::message]
    /// to hold a `ConversationSuccess`.
    ///
    /// Note that all the setters affecting `message` are
    /// mutually exclusive.
    pub fn set_conversation_success<
        T: std::convert::Into<std::boxed::Box<crate::model::response_message::ConversationSuccess>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.message = std::option::Option::Some(
            crate::model::response_message::Message::ConversationSuccess(v.into()),
        );
        self
    }

    /// The value of [message][crate::model::ResponseMessage::message]
    /// if it holds a `OutputAudioText`, `None` if the field is not set or
    /// holds a different branch.
    pub fn output_audio_text(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::response_message::OutputAudioText>>
    {
        #[allow(unreachable_patterns)]
        self.message.as_ref().and_then(|v| match v {
            crate::model::response_message::Message::OutputAudioText(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [message][crate::model::ResponseMessage::message]
    /// to hold a `OutputAudioText`.
    ///
    /// Note that all the setters affecting `message` are
    /// mutually exclusive.
    pub fn set_output_audio_text<
        T: std::convert::Into<std::boxed::Box<crate::model::response_message::OutputAudioText>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.message = std::option::Option::Some(
            crate::model::response_message::Message::OutputAudioText(v.into()),
        );
        self
    }

    /// The value of [message][crate::model::ResponseMessage::message]
    /// if it holds a `LiveAgentHandoff`, `None` if the field is not set or
    /// holds a different branch.
    pub fn live_agent_handoff(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::response_message::LiveAgentHandoff>>
    {
        #[allow(unreachable_patterns)]
        self.message.as_ref().and_then(|v| match v {
            crate::model::response_message::Message::LiveAgentHandoff(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [message][crate::model::ResponseMessage::message]
    /// to hold a `LiveAgentHandoff`.
    ///
    /// Note that all the setters affecting `message` are
    /// mutually exclusive.
    pub fn set_live_agent_handoff<
        T: std::convert::Into<std::boxed::Box<crate::model::response_message::LiveAgentHandoff>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.message = std::option::Option::Some(
            crate::model::response_message::Message::LiveAgentHandoff(v.into()),
        );
        self
    }

    /// The value of [message][crate::model::ResponseMessage::message]
    /// if it holds a `EndInteraction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn end_interaction(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::response_message::EndInteraction>> {
        #[allow(unreachable_patterns)]
        self.message.as_ref().and_then(|v| match v {
            crate::model::response_message::Message::EndInteraction(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [message][crate::model::ResponseMessage::message]
    /// to hold a `EndInteraction`.
    ///
    /// Note that all the setters affecting `message` are
    /// mutually exclusive.
    pub fn set_end_interaction<
        T: std::convert::Into<std::boxed::Box<crate::model::response_message::EndInteraction>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.message = std::option::Option::Some(
            crate::model::response_message::Message::EndInteraction(v.into()),
        );
        self
    }

    /// The value of [message][crate::model::ResponseMessage::message]
    /// if it holds a `PlayAudio`, `None` if the field is not set or
    /// holds a different branch.
    pub fn play_audio(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::response_message::PlayAudio>> {
        #[allow(unreachable_patterns)]
        self.message.as_ref().and_then(|v| match v {
            crate::model::response_message::Message::PlayAudio(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [message][crate::model::ResponseMessage::message]
    /// to hold a `PlayAudio`.
    ///
    /// Note that all the setters affecting `message` are
    /// mutually exclusive.
    pub fn set_play_audio<
        T: std::convert::Into<std::boxed::Box<crate::model::response_message::PlayAudio>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.message =
            std::option::Option::Some(crate::model::response_message::Message::PlayAudio(v.into()));
        self
    }

    /// The value of [message][crate::model::ResponseMessage::message]
    /// if it holds a `MixedAudio`, `None` if the field is not set or
    /// holds a different branch.
    pub fn mixed_audio(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::response_message::MixedAudio>> {
        #[allow(unreachable_patterns)]
        self.message.as_ref().and_then(|v| match v {
            crate::model::response_message::Message::MixedAudio(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [message][crate::model::ResponseMessage::message]
    /// to hold a `MixedAudio`.
    ///
    /// Note that all the setters affecting `message` are
    /// mutually exclusive.
    pub fn set_mixed_audio<
        T: std::convert::Into<std::boxed::Box<crate::model::response_message::MixedAudio>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.message = std::option::Option::Some(
            crate::model::response_message::Message::MixedAudio(v.into()),
        );
        self
    }

    /// The value of [message][crate::model::ResponseMessage::message]
    /// if it holds a `TelephonyTransferCall`, `None` if the field is not set or
    /// holds a different branch.
    pub fn telephony_transfer_call(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::response_message::TelephonyTransferCall>>
    {
        #[allow(unreachable_patterns)]
        self.message.as_ref().and_then(|v| match v {
            crate::model::response_message::Message::TelephonyTransferCall(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [message][crate::model::ResponseMessage::message]
    /// to hold a `TelephonyTransferCall`.
    ///
    /// Note that all the setters affecting `message` are
    /// mutually exclusive.
    pub fn set_telephony_transfer_call<
        T: std::convert::Into<std::boxed::Box<crate::model::response_message::TelephonyTransferCall>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.message = std::option::Option::Some(
            crate::model::response_message::Message::TelephonyTransferCall(v.into()),
        );
        self
    }

    /// The value of [message][crate::model::ResponseMessage::message]
    /// if it holds a `KnowledgeInfoCard`, `None` if the field is not set or
    /// holds a different branch.
    pub fn knowledge_info_card(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::response_message::KnowledgeInfoCard>>
    {
        #[allow(unreachable_patterns)]
        self.message.as_ref().and_then(|v| match v {
            crate::model::response_message::Message::KnowledgeInfoCard(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [message][crate::model::ResponseMessage::message]
    /// to hold a `KnowledgeInfoCard`.
    ///
    /// Note that all the setters affecting `message` are
    /// mutually exclusive.
    pub fn set_knowledge_info_card<
        T: std::convert::Into<std::boxed::Box<crate::model::response_message::KnowledgeInfoCard>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.message = std::option::Option::Some(
            crate::model::response_message::Message::KnowledgeInfoCard(v.into()),
        );
        self
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
impl wkt::message::Message for ResponseMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ResponseMessage"
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResponseMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __payload,
            __conversation_success,
            __output_audio_text,
            __live_agent_handoff,
            __end_interaction,
            __play_audio,
            __mixed_audio,
            __telephony_transfer_call,
            __knowledge_info_card,
            __response_type,
            __channel,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResponseMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "payload" => Ok(__FieldTag::__payload),
                            "conversationSuccess" => Ok(__FieldTag::__conversation_success),
                            "conversation_success" => Ok(__FieldTag::__conversation_success),
                            "outputAudioText" => Ok(__FieldTag::__output_audio_text),
                            "output_audio_text" => Ok(__FieldTag::__output_audio_text),
                            "liveAgentHandoff" => Ok(__FieldTag::__live_agent_handoff),
                            "live_agent_handoff" => Ok(__FieldTag::__live_agent_handoff),
                            "endInteraction" => Ok(__FieldTag::__end_interaction),
                            "end_interaction" => Ok(__FieldTag::__end_interaction),
                            "playAudio" => Ok(__FieldTag::__play_audio),
                            "play_audio" => Ok(__FieldTag::__play_audio),
                            "mixedAudio" => Ok(__FieldTag::__mixed_audio),
                            "mixed_audio" => Ok(__FieldTag::__mixed_audio),
                            "telephonyTransferCall" => Ok(__FieldTag::__telephony_transfer_call),
                            "telephony_transfer_call" => Ok(__FieldTag::__telephony_transfer_call),
                            "knowledgeInfoCard" => Ok(__FieldTag::__knowledge_info_card),
                            "knowledge_info_card" => Ok(__FieldTag::__knowledge_info_card),
                            "responseType" => Ok(__FieldTag::__response_type),
                            "response_type" => Ok(__FieldTag::__response_type),
                            "channel" => Ok(__FieldTag::__channel),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResponseMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResponseMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ResponseMessage.text, latest field was text",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::response_message::Message::Text(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::response_message::Text>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__payload => {
                            if !fields.insert(__FieldTag::__payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload",
                                ));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ResponseMessage.payload, latest field was payload",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::response_message::Message::Payload(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Struct>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__conversation_success => {
                            if !fields.insert(__FieldTag::__conversation_success) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_success",
                                ));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ResponseMessage.conversation_success, latest field was conversationSuccess",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::response_message::Message::ConversationSuccess(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::response_message::ConversationSuccess,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__output_audio_text => {
                            if !fields.insert(__FieldTag::__output_audio_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_audio_text",
                                ));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ResponseMessage.output_audio_text, latest field was outputAudioText",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::response_message::Message::OutputAudioText(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::response_message::OutputAudioText,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__live_agent_handoff => {
                            if !fields.insert(__FieldTag::__live_agent_handoff) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for live_agent_handoff",
                                ));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ResponseMessage.live_agent_handoff, latest field was liveAgentHandoff",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::response_message::Message::LiveAgentHandoff(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::response_message::LiveAgentHandoff,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__end_interaction => {
                            if !fields.insert(__FieldTag::__end_interaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_interaction",
                                ));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ResponseMessage.end_interaction, latest field was endInteraction",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::response_message::Message::EndInteraction(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::response_message::EndInteraction,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__play_audio => {
                            if !fields.insert(__FieldTag::__play_audio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for play_audio",
                                ));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ResponseMessage.play_audio, latest field was playAudio",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::response_message::Message::PlayAudio(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::response_message::PlayAudio>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__mixed_audio => {
                            if !fields.insert(__FieldTag::__mixed_audio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mixed_audio",
                                ));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ResponseMessage.mixed_audio, latest field was mixedAudio",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::response_message::Message::MixedAudio(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::response_message::MixedAudio>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__telephony_transfer_call => {
                            if !fields.insert(__FieldTag::__telephony_transfer_call) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for telephony_transfer_call",
                                ));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ResponseMessage.telephony_transfer_call, latest field was telephonyTransferCall",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::response_message::Message::TelephonyTransferCall(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::response_message::TelephonyTransferCall,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__knowledge_info_card => {
                            if !fields.insert(__FieldTag::__knowledge_info_card) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for knowledge_info_card",
                                ));
                            }
                            if result.message.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ResponseMessage.knowledge_info_card, latest field was knowledgeInfoCard",
                                ));
                            }
                            result.message = std::option::Option::Some(
                                crate::model::response_message::Message::KnowledgeInfoCard(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::response_message::KnowledgeInfoCard,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__response_type => {
                            if !fields.insert(__FieldTag::__response_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_type",
                                ));
                            }
                            result.response_type =
                                map.next_value::<std::option::Option<
                                    crate::model::response_message::ResponseType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__channel => {
                            if !fields.insert(__FieldTag::__channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel",
                                ));
                            }
                            result.channel = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
#[doc(hidden)]
impl serde::ser::Serialize for ResponseMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.payload() {
            state.serialize_entry("payload", value)?;
        }
        if let Some(value) = self.conversation_success() {
            state.serialize_entry("conversationSuccess", value)?;
        }
        if let Some(value) = self.output_audio_text() {
            state.serialize_entry("outputAudioText", value)?;
        }
        if let Some(value) = self.live_agent_handoff() {
            state.serialize_entry("liveAgentHandoff", value)?;
        }
        if let Some(value) = self.end_interaction() {
            state.serialize_entry("endInteraction", value)?;
        }
        if let Some(value) = self.play_audio() {
            state.serialize_entry("playAudio", value)?;
        }
        if let Some(value) = self.mixed_audio() {
            state.serialize_entry("mixedAudio", value)?;
        }
        if let Some(value) = self.telephony_transfer_call() {
            state.serialize_entry("telephonyTransferCall", value)?;
        }
        if let Some(value) = self.knowledge_info_card() {
            state.serialize_entry("knowledgeInfoCard", value)?;
        }
        if !wkt::internal::is_default(&self.response_type) {
            state.serialize_entry("responseType", &self.response_type)?;
        }
        if !self.channel.is_empty() {
            state.serialize_entry("channel", &self.channel)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ResponseMessage].
#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
))]
pub mod response_message {
    #[allow(unused_imports)]
    use super::*;

    /// The text response message.
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Text {
        /// Required. A collection of text response variants. If multiple variants
        /// are defined, only one text response variant is returned at runtime.
        pub text: std::vec::Vec<std::string::String>,

        /// Output only. Whether the playback of this message can be interrupted by
        /// the end user's speech and the client can then starts the next Dialogflow
        /// request.
        pub allow_playback_interruption: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl Text {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text][crate::model::response_message::Text::text].
        pub fn set_text<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.text = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [allow_playback_interruption][crate::model::response_message::Text::allow_playback_interruption].
        pub fn set_allow_playback_interruption<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.allow_playback_interruption = v.into();
            self
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl wkt::message::Message for Text {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.ResponseMessage.Text"
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Text {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __text,
                __allow_playback_interruption,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Text")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "text" => Ok(__FieldTag::__text),
                                "allowPlaybackInterruption" => {
                                    Ok(__FieldTag::__allow_playback_interruption)
                                }
                                "allow_playback_interruption" => {
                                    Ok(__FieldTag::__allow_playback_interruption)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Text;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Text")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__text => {
                                if !fields.insert(__FieldTag::__text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text",
                                    ));
                                }
                                result.text = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__allow_playback_interruption => {
                                if !fields.insert(__FieldTag::__allow_playback_interruption) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allow_playback_interruption",
                                    ));
                                }
                                result.allow_playback_interruption = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for Text {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.text.is_empty() {
                state.serialize_entry("text", &self.text)?;
            }
            if !wkt::internal::is_default(&self.allow_playback_interruption) {
                state.serialize_entry(
                    "allowPlaybackInterruption",
                    &self.allow_playback_interruption,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Indicates that the conversation should be handed off to a live agent.
    ///
    /// Dialogflow only uses this to determine which conversations were handed off
    /// to a human agent for measurement purposes. What else to do with this signal
    /// is up to you and your handoff procedures.
    ///
    /// You may set this, for example:
    ///
    /// * In the
    ///   [entry_fulfillment][google.cloud.dialogflow.cx.v3.Page.entry_fulfillment]
    ///   of a [Page][google.cloud.dialogflow.cx.v3.Page] if
    ///   entering the page indicates something went extremely wrong in the
    ///   conversation.
    /// * In a webhook response when you determine that the customer issue can only
    ///   be handled by a human.
    ///
    /// [google.cloud.dialogflow.cx.v3.Page]: crate::model::Page
    /// [google.cloud.dialogflow.cx.v3.Page.entry_fulfillment]: crate::model::Page::entry_fulfillment
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LiveAgentHandoff {
        /// Custom metadata for your handoff procedure. Dialogflow doesn't impose
        /// any structure on this.
        pub metadata: std::option::Option<wkt::Struct>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl LiveAgentHandoff {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [metadata][crate::model::response_message::LiveAgentHandoff::metadata].
        pub fn set_metadata<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.metadata = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [metadata][crate::model::response_message::LiveAgentHandoff::metadata].
        pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.metadata = v.map(|x| x.into());
            self
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl wkt::message::Message for LiveAgentHandoff {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.ResponseMessage.LiveAgentHandoff"
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LiveAgentHandoff {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __metadata,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LiveAgentHandoff")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "metadata" => Ok(__FieldTag::__metadata),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LiveAgentHandoff;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LiveAgentHandoff")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__metadata => {
                                if !fields.insert(__FieldTag::__metadata) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for metadata",
                                    ));
                                }
                                result.metadata =
                                    map.next_value::<std::option::Option<wkt::Struct>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for LiveAgentHandoff {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.metadata.is_some() {
                state.serialize_entry("metadata", &self.metadata)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Indicates that the conversation succeeded, i.e., the bot handled the issue
    /// that the customer talked to it about.
    ///
    /// Dialogflow only uses this to determine which conversations should be
    /// counted as successful and doesn't process the metadata in this message in
    /// any way. Note that Dialogflow also considers conversations that get to the
    /// conversation end page as successful even if they don't return
    /// [ConversationSuccess][google.cloud.dialogflow.cx.v3.ResponseMessage.ConversationSuccess].
    ///
    /// You may set this, for example:
    ///
    /// * In the
    ///   [entry_fulfillment][google.cloud.dialogflow.cx.v3.Page.entry_fulfillment]
    ///   of a [Page][google.cloud.dialogflow.cx.v3.Page] if
    ///   entering the page indicates that the conversation succeeded.
    /// * In a webhook response when you determine that you handled the customer
    ///   issue.
    ///
    /// [google.cloud.dialogflow.cx.v3.Page]: crate::model::Page
    /// [google.cloud.dialogflow.cx.v3.Page.entry_fulfillment]: crate::model::Page::entry_fulfillment
    /// [google.cloud.dialogflow.cx.v3.ResponseMessage.ConversationSuccess]: crate::model::response_message::ConversationSuccess
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConversationSuccess {
        /// Custom metadata. Dialogflow doesn't impose any structure on this.
        pub metadata: std::option::Option<wkt::Struct>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl ConversationSuccess {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [metadata][crate::model::response_message::ConversationSuccess::metadata].
        pub fn set_metadata<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.metadata = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [metadata][crate::model::response_message::ConversationSuccess::metadata].
        pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.metadata = v.map(|x| x.into());
            self
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl wkt::message::Message for ConversationSuccess {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.ResponseMessage.ConversationSuccess"
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConversationSuccess {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __metadata,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConversationSuccess")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "metadata" => Ok(__FieldTag::__metadata),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConversationSuccess;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConversationSuccess")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__metadata => {
                                if !fields.insert(__FieldTag::__metadata) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for metadata",
                                    ));
                                }
                                result.metadata =
                                    map.next_value::<std::option::Option<wkt::Struct>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for ConversationSuccess {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.metadata.is_some() {
                state.serialize_entry("metadata", &self.metadata)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A text or ssml response that is preferentially used for TTS output audio
    /// synthesis, as described in the comment on the ResponseMessage message.
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct OutputAudioText {
        /// Output only. Whether the playback of this message can be interrupted by
        /// the end user's speech and the client can then starts the next Dialogflow
        /// request.
        pub allow_playback_interruption: bool,

        /// The source, which is either plain text or SSML.
        pub source: std::option::Option<crate::model::response_message::output_audio_text::Source>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl OutputAudioText {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [allow_playback_interruption][crate::model::response_message::OutputAudioText::allow_playback_interruption].
        pub fn set_allow_playback_interruption<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.allow_playback_interruption = v.into();
            self
        }

        /// Sets the value of [source][crate::model::response_message::OutputAudioText::source].
        ///
        /// Note that all the setters affecting `source` are mutually
        /// exclusive.
        pub fn set_source<
            T: std::convert::Into<
                    std::option::Option<crate::model::response_message::output_audio_text::Source>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = v.into();
            self
        }

        /// The value of [source][crate::model::response_message::OutputAudioText::source]
        /// if it holds a `Text`, `None` if the field is not set or
        /// holds a different branch.
        pub fn text(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::response_message::output_audio_text::Source::Text(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::response_message::OutputAudioText::source]
        /// to hold a `Text`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source = std::option::Option::Some(
                crate::model::response_message::output_audio_text::Source::Text(v.into()),
            );
            self
        }

        /// The value of [source][crate::model::response_message::OutputAudioText::source]
        /// if it holds a `Ssml`, `None` if the field is not set or
        /// holds a different branch.
        pub fn ssml(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::response_message::output_audio_text::Source::Ssml(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::response_message::OutputAudioText::source]
        /// to hold a `Ssml`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_ssml<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.source = std::option::Option::Some(
                crate::model::response_message::output_audio_text::Source::Ssml(v.into()),
            );
            self
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl wkt::message::Message for OutputAudioText {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.ResponseMessage.OutputAudioText"
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for OutputAudioText {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __text,
                __ssml,
                __allow_playback_interruption,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for OutputAudioText")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "text" => Ok(__FieldTag::__text),
                                "ssml" => Ok(__FieldTag::__ssml),
                                "allowPlaybackInterruption" => {
                                    Ok(__FieldTag::__allow_playback_interruption)
                                }
                                "allow_playback_interruption" => {
                                    Ok(__FieldTag::__allow_playback_interruption)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = OutputAudioText;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct OutputAudioText")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__text => {
                                if !fields.insert(__FieldTag::__text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text",
                                    ));
                                }
                                if result.source.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ResponseMessage.OutputAudioText.text, latest field was text",
                                    ));
                                }
                                result.source = std::option::Option::Some(
                                    crate::model::response_message::output_audio_text::Source::Text(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__ssml => {
                                if !fields.insert(__FieldTag::__ssml) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ssml",
                                    ));
                                }
                                if result.source.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ResponseMessage.OutputAudioText.ssml, latest field was ssml",
                                    ));
                                }
                                result.source = std::option::Option::Some(
                                    crate::model::response_message::output_audio_text::Source::Ssml(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__allow_playback_interruption => {
                                if !fields.insert(__FieldTag::__allow_playback_interruption) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allow_playback_interruption",
                                    ));
                                }
                                result.allow_playback_interruption = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for OutputAudioText {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.text() {
                state.serialize_entry("text", value)?;
            }
            if let Some(value) = self.ssml() {
                state.serialize_entry("ssml", value)?;
            }
            if !wkt::internal::is_default(&self.allow_playback_interruption) {
                state.serialize_entry(
                    "allowPlaybackInterruption",
                    &self.allow_playback_interruption,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [OutputAudioText].
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    pub mod output_audio_text {
        #[allow(unused_imports)]
        use super::*;

        /// The source, which is either plain text or SSML.
        #[cfg(any(
            feature = "flows",
            feature = "pages",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
        ))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Source {
            /// The raw text to be synthesized.
            Text(std::string::String),
            /// The SSML text to be synthesized. For more information, see
            /// [SSML](/speech/text-to-speech/docs/ssml).
            Ssml(std::string::String),
        }
    }

    /// Indicates that interaction with the Dialogflow agent has ended.
    /// This message is generated by Dialogflow only and not supposed to be
    /// defined by the user.
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct EndInteraction {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl EndInteraction {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl wkt::message::Message for EndInteraction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.ResponseMessage.EndInteraction"
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for EndInteraction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for EndInteraction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = EndInteraction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct EndInteraction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for EndInteraction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Specifies an audio clip to be played by the client as part of the response.
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PlayAudio {
        /// Required. URI of the audio clip. Dialogflow does not impose any
        /// validation on this value. It is specific to the client that reads it.
        pub audio_uri: std::string::String,

        /// Output only. Whether the playback of this message can be interrupted by
        /// the end user's speech and the client can then starts the next Dialogflow
        /// request.
        pub allow_playback_interruption: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl PlayAudio {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [audio_uri][crate::model::response_message::PlayAudio::audio_uri].
        pub fn set_audio_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.audio_uri = v.into();
            self
        }

        /// Sets the value of [allow_playback_interruption][crate::model::response_message::PlayAudio::allow_playback_interruption].
        pub fn set_allow_playback_interruption<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.allow_playback_interruption = v.into();
            self
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl wkt::message::Message for PlayAudio {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.ResponseMessage.PlayAudio"
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PlayAudio {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __audio_uri,
                __allow_playback_interruption,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PlayAudio")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "audioUri" => Ok(__FieldTag::__audio_uri),
                                "audio_uri" => Ok(__FieldTag::__audio_uri),
                                "allowPlaybackInterruption" => {
                                    Ok(__FieldTag::__allow_playback_interruption)
                                }
                                "allow_playback_interruption" => {
                                    Ok(__FieldTag::__allow_playback_interruption)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PlayAudio;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PlayAudio")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__audio_uri => {
                                if !fields.insert(__FieldTag::__audio_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for audio_uri",
                                    ));
                                }
                                result.audio_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__allow_playback_interruption => {
                                if !fields.insert(__FieldTag::__allow_playback_interruption) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allow_playback_interruption",
                                    ));
                                }
                                result.allow_playback_interruption = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for PlayAudio {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.audio_uri.is_empty() {
                state.serialize_entry("audioUri", &self.audio_uri)?;
            }
            if !wkt::internal::is_default(&self.allow_playback_interruption) {
                state.serialize_entry(
                    "allowPlaybackInterruption",
                    &self.allow_playback_interruption,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Represents an audio message that is composed of both segments
    /// synthesized from the Dialogflow agent prompts and ones hosted externally
    /// at the specified URIs.
    /// The external URIs are specified via
    /// [play_audio][google.cloud.dialogflow.cx.v3.ResponseMessage.play_audio].
    /// This message is generated by Dialogflow only and not supposed to be
    /// defined by the user.
    ///
    /// [google.cloud.dialogflow.cx.v3.ResponseMessage.play_audio]: crate::model::ResponseMessage::message
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MixedAudio {
        /// Segments this audio response is composed of.
        pub segments: std::vec::Vec<crate::model::response_message::mixed_audio::Segment>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl MixedAudio {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [segments][crate::model::response_message::MixedAudio::segments].
        pub fn set_segments<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::response_message::mixed_audio::Segment>,
        {
            use std::iter::Iterator;
            self.segments = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl wkt::message::Message for MixedAudio {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.ResponseMessage.MixedAudio"
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MixedAudio {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __segments,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MixedAudio")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "segments" => Ok(__FieldTag::__segments),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MixedAudio;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MixedAudio")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__segments => {
                                if !fields.insert(__FieldTag::__segments) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for segments",
                                    ));
                                }
                                result.segments = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::response_message::mixed_audio::Segment,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for MixedAudio {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.segments.is_empty() {
                state.serialize_entry("segments", &self.segments)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [MixedAudio].
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    pub mod mixed_audio {
        #[allow(unused_imports)]
        use super::*;

        /// Represents one segment of audio.
        #[cfg(any(
            feature = "flows",
            feature = "pages",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Segment {
            /// Output only. Whether the playback of this segment can be interrupted by
            /// the end user's speech and the client should then start the next
            /// Dialogflow request.
            pub allow_playback_interruption: bool,

            /// Content of the segment.
            pub content:
                std::option::Option<crate::model::response_message::mixed_audio::segment::Content>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "flows",
            feature = "pages",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
        ))]
        impl Segment {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [allow_playback_interruption][crate::model::response_message::mixed_audio::Segment::allow_playback_interruption].
            pub fn set_allow_playback_interruption<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.allow_playback_interruption = v.into();
                self
            }

            /// Sets the value of [content][crate::model::response_message::mixed_audio::Segment::content].
            ///
            /// Note that all the setters affecting `content` are mutually
            /// exclusive.
            pub fn set_content<
                T: std::convert::Into<
                        std::option::Option<
                            crate::model::response_message::mixed_audio::segment::Content,
                        >,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.content = v.into();
                self
            }

            /// The value of [content][crate::model::response_message::mixed_audio::Segment::content]
            /// if it holds a `Audio`, `None` if the field is not set or
            /// holds a different branch.
            pub fn audio(&self) -> std::option::Option<&::bytes::Bytes> {
                #[allow(unreachable_patterns)]
                self.content.as_ref().and_then(|v| match v {
                    crate::model::response_message::mixed_audio::segment::Content::Audio(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [content][crate::model::response_message::mixed_audio::Segment::content]
            /// to hold a `Audio`.
            ///
            /// Note that all the setters affecting `content` are
            /// mutually exclusive.
            pub fn set_audio<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
                self.content = std::option::Option::Some(
                    crate::model::response_message::mixed_audio::segment::Content::Audio(v.into()),
                );
                self
            }

            /// The value of [content][crate::model::response_message::mixed_audio::Segment::content]
            /// if it holds a `Uri`, `None` if the field is not set or
            /// holds a different branch.
            pub fn uri(&self) -> std::option::Option<&std::string::String> {
                #[allow(unreachable_patterns)]
                self.content.as_ref().and_then(|v| match v {
                    crate::model::response_message::mixed_audio::segment::Content::Uri(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [content][crate::model::response_message::mixed_audio::Segment::content]
            /// to hold a `Uri`.
            ///
            /// Note that all the setters affecting `content` are
            /// mutually exclusive.
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.content = std::option::Option::Some(
                    crate::model::response_message::mixed_audio::segment::Content::Uri(v.into()),
                );
                self
            }
        }

        #[cfg(any(
            feature = "flows",
            feature = "pages",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
        ))]
        impl wkt::message::Message for Segment {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.cx.v3.ResponseMessage.MixedAudio.Segment"
            }
        }

        #[cfg(any(
            feature = "flows",
            feature = "pages",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Segment {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __audio,
                    __uri,
                    __allow_playback_interruption,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Segment")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "audio" => Ok(__FieldTag::__audio),
                                    "uri" => Ok(__FieldTag::__uri),
                                    "allowPlaybackInterruption" => {
                                        Ok(__FieldTag::__allow_playback_interruption)
                                    }
                                    "allow_playback_interruption" => {
                                        Ok(__FieldTag::__allow_playback_interruption)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Segment;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Segment")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__audio => {
                                    if !fields.insert(__FieldTag::__audio) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for audio"),
                                        );
                                    }
                                    struct __With(std::option::Option<::bytes::Bytes>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::<
                                                std::option::Option<serde_with::base64::Base64>,
                                            >::deserialize(
                                                deserializer
                                            )
                                            .map(__With)
                                        }
                                    }
                                    if result.content.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `content`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ResponseMessage.MixedAudio.Segment.audio, latest field was audio",
                                            ),
                                        );
                                    }
                                    result.content = std::option::Option::Some(
                                        crate::model::response_message::mixed_audio::segment::Content::Audio(
                                            map.next_value::<__With>()?.0.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__uri => {
                                    if !fields.insert(__FieldTag::__uri) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for uri"),
                                        );
                                    }
                                    if result.content.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `content`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ResponseMessage.MixedAudio.Segment.uri, latest field was uri",
                                            ),
                                        );
                                    }
                                    result.content = std::option::Option::Some(
                                        crate::model::response_message::mixed_audio::segment::Content::Uri(
                                            map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__allow_playback_interruption => {
                                    if !fields.insert(__FieldTag::__allow_playback_interruption) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for allow_playback_interruption",
                                            ),
                                        );
                                    }
                                    result.allow_playback_interruption = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "flows",
            feature = "pages",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for Segment {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.audio() {
                    struct __With<'a>(&'a ::bytes::Bytes);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<serde_with::base64::Base64>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("audio", &__With(value))?;
                }
                if let Some(value) = self.uri() {
                    state.serialize_entry("uri", value)?;
                }
                if !wkt::internal::is_default(&self.allow_playback_interruption) {
                    state.serialize_entry(
                        "allowPlaybackInterruption",
                        &self.allow_playback_interruption,
                    )?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [Segment].
        #[cfg(any(
            feature = "flows",
            feature = "pages",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
        ))]
        pub mod segment {
            #[allow(unused_imports)]
            use super::*;

            /// Content of the segment.
            #[cfg(any(
                feature = "flows",
                feature = "pages",
                feature = "sessions",
                feature = "test-cases",
                feature = "transition-route-groups",
            ))]
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Content {
                /// Raw audio synthesized from the Dialogflow agent's response using
                /// the output config specified in the request.
                Audio(::bytes::Bytes),
                /// Client-specific URI that points to an audio clip accessible to the
                /// client. Dialogflow does not impose any validation on it.
                Uri(std::string::String),
            }
        }
    }

    /// Represents the signal that telles the client to transfer the phone call
    /// connected to the agent to a third-party endpoint.
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TelephonyTransferCall {
        /// Endpoint to transfer the call to.
        pub endpoint:
            std::option::Option<crate::model::response_message::telephony_transfer_call::Endpoint>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl TelephonyTransferCall {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [endpoint][crate::model::response_message::TelephonyTransferCall::endpoint].
        ///
        /// Note that all the setters affecting `endpoint` are mutually
        /// exclusive.
        pub fn set_endpoint<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::response_message::telephony_transfer_call::Endpoint,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.endpoint = v.into();
            self
        }

        /// The value of [endpoint][crate::model::response_message::TelephonyTransferCall::endpoint]
        /// if it holds a `PhoneNumber`, `None` if the field is not set or
        /// holds a different branch.
        pub fn phone_number(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.endpoint.as_ref().and_then(|v| match v {
                crate::model::response_message::telephony_transfer_call::Endpoint::PhoneNumber(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [endpoint][crate::model::response_message::TelephonyTransferCall::endpoint]
        /// to hold a `PhoneNumber`.
        ///
        /// Note that all the setters affecting `endpoint` are
        /// mutually exclusive.
        pub fn set_phone_number<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.endpoint = std::option::Option::Some(
                crate::model::response_message::telephony_transfer_call::Endpoint::PhoneNumber(
                    v.into(),
                ),
            );
            self
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl wkt::message::Message for TelephonyTransferCall {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.ResponseMessage.TelephonyTransferCall"
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TelephonyTransferCall {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __phone_number,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TelephonyTransferCall")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "phoneNumber" => Ok(__FieldTag::__phone_number),
                                "phone_number" => Ok(__FieldTag::__phone_number),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TelephonyTransferCall;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TelephonyTransferCall")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__phone_number => {
                                if !fields.insert(__FieldTag::__phone_number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for phone_number",
                                    ));
                                }
                                if result.endpoint.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `endpoint`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ResponseMessage.TelephonyTransferCall.phone_number, latest field was phoneNumber",
                                    ));
                                }
                                result.endpoint = std::option::Option::Some(
                                    crate::model::response_message::telephony_transfer_call::Endpoint::PhoneNumber(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for TelephonyTransferCall {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.phone_number() {
                state.serialize_entry("phoneNumber", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [TelephonyTransferCall].
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    pub mod telephony_transfer_call {
        #[allow(unused_imports)]
        use super::*;

        /// Endpoint to transfer the call to.
        #[cfg(any(
            feature = "flows",
            feature = "pages",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
        ))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Endpoint {
            /// Transfer the call to a phone number
            /// in [E.164 format](https://en.wikipedia.org/wiki/E.164).
            PhoneNumber(std::string::String),
        }
    }

    /// Represents info card response. If the response contains generative
    /// knowledge prediction, Dialogflow will return a payload with Infobot
    /// Messenger compatible info card.
    ///
    /// Otherwise, the info card response is skipped.
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct KnowledgeInfoCard {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl KnowledgeInfoCard {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl wkt::message::Message for KnowledgeInfoCard {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.ResponseMessage.KnowledgeInfoCard"
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for KnowledgeInfoCard {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for KnowledgeInfoCard")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = KnowledgeInfoCard;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct KnowledgeInfoCard")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for KnowledgeInfoCard {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Represents different response types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ResponseType {
        /// Not specified.
        Unspecified,
        /// The response is from an [entry
        /// prompt][google.cloud.dialogflow.cx.v3.Page.entry_fulfillment] in the
        /// page.
        ///
        /// [google.cloud.dialogflow.cx.v3.Page.entry_fulfillment]: crate::model::Page::entry_fulfillment
        EntryPrompt,
        /// The response is from [form-filling
        /// prompt][google.cloud.dialogflow.cx.v3.Form.Parameter.fill_behavior] in
        /// the page.
        ///
        /// [google.cloud.dialogflow.cx.v3.Form.Parameter.fill_behavior]: crate::model::form::Parameter::fill_behavior
        ParameterPrompt,
        /// The response is from a [transition
        /// route][google.cloud.dialogflow.cx.v3.TransitionRoute] or an [event
        /// handler][EventHandler] in the page or flow or transition route group.
        ///
        /// [EventHandler]: crate::model::EventHandler
        /// [google.cloud.dialogflow.cx.v3.TransitionRoute]: crate::model::TransitionRoute
        HandlerPrompt,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ResponseType::value] or
        /// [ResponseType::name].
        UnknownValue(response_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    pub mod response_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl ResponseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::EntryPrompt => std::option::Option::Some(1),
                Self::ParameterPrompt => std::option::Option::Some(2),
                Self::HandlerPrompt => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESPONSE_TYPE_UNSPECIFIED"),
                Self::EntryPrompt => std::option::Option::Some("ENTRY_PROMPT"),
                Self::ParameterPrompt => std::option::Option::Some("PARAMETER_PROMPT"),
                Self::HandlerPrompt => std::option::Option::Some("HANDLER_PROMPT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl std::default::Default for ResponseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl std::fmt::Display for ResponseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl std::convert::From<i32> for ResponseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::EntryPrompt,
                2 => Self::ParameterPrompt,
                3 => Self::HandlerPrompt,
                _ => Self::UnknownValue(response_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl std::convert::From<&str> for ResponseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESPONSE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ENTRY_PROMPT" => Self::EntryPrompt,
                "PARAMETER_PROMPT" => Self::ParameterPrompt,
                "HANDLER_PROMPT" => Self::HandlerPrompt,
                _ => Self::UnknownValue(response_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl serde::ser::Serialize for ResponseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::EntryPrompt => serializer.serialize_i32(1),
                Self::ParameterPrompt => serializer.serialize_i32(2),
                Self::HandlerPrompt => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    impl<'de> serde::de::Deserialize<'de> for ResponseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResponseType>::new(
                ".google.cloud.dialogflow.cx.v3.ResponseMessage.ResponseType",
            ))
        }
    }

    /// Required. The rich response message.
    #[cfg(any(
        feature = "flows",
        feature = "pages",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Message {
        /// Returns a text response.
        Text(std::boxed::Box<crate::model::response_message::Text>),
        /// Returns a response containing a custom, platform-specific payload.
        Payload(std::boxed::Box<wkt::Struct>),
        /// Indicates that the conversation succeeded.
        ConversationSuccess(std::boxed::Box<crate::model::response_message::ConversationSuccess>),
        /// A text or ssml response that is preferentially used for TTS output audio
        /// synthesis, as described in the comment on the ResponseMessage message.
        OutputAudioText(std::boxed::Box<crate::model::response_message::OutputAudioText>),
        /// Hands off conversation to a human agent.
        LiveAgentHandoff(std::boxed::Box<crate::model::response_message::LiveAgentHandoff>),
        /// Output only. A signal that indicates the interaction with the Dialogflow
        /// agent has ended. This message is generated by Dialogflow only when the
        /// conversation reaches `END_SESSION` page. It is not supposed to be defined
        /// by the user.
        ///
        /// It's guaranteed that there is at most one such message in each response.
        EndInteraction(std::boxed::Box<crate::model::response_message::EndInteraction>),
        /// Signal that the client should play an audio clip hosted at a
        /// client-specific URI. Dialogflow uses this to construct
        /// [mixed_audio][google.cloud.dialogflow.cx.v3.ResponseMessage.mixed_audio].
        /// However, Dialogflow itself does not try to read or process the URI in any
        /// way.
        ///
        /// [google.cloud.dialogflow.cx.v3.ResponseMessage.mixed_audio]: crate::model::ResponseMessage::message
        PlayAudio(std::boxed::Box<crate::model::response_message::PlayAudio>),
        /// Output only. An audio response message composed of both the synthesized
        /// Dialogflow agent responses and responses defined via
        /// [play_audio][google.cloud.dialogflow.cx.v3.ResponseMessage.play_audio].
        /// This message is generated by Dialogflow only and not supposed to be
        /// defined by the user.
        ///
        /// [google.cloud.dialogflow.cx.v3.ResponseMessage.play_audio]: crate::model::ResponseMessage::message
        MixedAudio(std::boxed::Box<crate::model::response_message::MixedAudio>),
        /// A signal that the client should transfer the phone call connected to
        /// this agent to a third-party endpoint.
        TelephonyTransferCall(
            std::boxed::Box<crate::model::response_message::TelephonyTransferCall>,
        ),
        /// Represents info card for knowledge answers, to be better rendered in
        /// Dialogflow Messenger.
        KnowledgeInfoCard(std::boxed::Box<crate::model::response_message::KnowledgeInfoCard>),
    }
}

/// Settings for Generative Safety.
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SafetySettings {
    /// Banned phrases for generated text.
    pub banned_phrases: std::vec::Vec<crate::model::safety_settings::Phrase>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl SafetySettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [banned_phrases][crate::model::SafetySettings::banned_phrases].
    pub fn set_banned_phrases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::safety_settings::Phrase>,
    {
        use std::iter::Iterator;
        self.banned_phrases = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for SafetySettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.SafetySettings"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SafetySettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __banned_phrases,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SafetySettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bannedPhrases" => Ok(__FieldTag::__banned_phrases),
                            "banned_phrases" => Ok(__FieldTag::__banned_phrases),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SafetySettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SafetySettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__banned_phrases => {
                            if !fields.insert(__FieldTag::__banned_phrases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for banned_phrases",
                                ));
                            }
                            result.banned_phrases = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::safety_settings::Phrase>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for SafetySettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.banned_phrases.is_empty() {
            state.serialize_entry("bannedPhrases", &self.banned_phrases)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SafetySettings].
#[cfg(feature = "agents")]
pub mod safety_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Text input which can be used for prompt or banned phrases.
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Phrase {
        /// Required. Text input which can be used for prompt or banned phrases.
        pub text: std::string::String,

        /// Required. Language code of the phrase.
        pub language_code: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "agents")]
    impl Phrase {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text][crate::model::safety_settings::Phrase::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }

        /// Sets the value of [language_code][crate::model::safety_settings::Phrase::language_code].
        pub fn set_language_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.language_code = v.into();
            self
        }
    }

    #[cfg(feature = "agents")]
    impl wkt::message::Message for Phrase {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.SafetySettings.Phrase"
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Phrase {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __text,
                __language_code,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Phrase")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "text" => Ok(__FieldTag::__text),
                                "languageCode" => Ok(__FieldTag::__language_code),
                                "language_code" => Ok(__FieldTag::__language_code),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Phrase;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Phrase")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__text => {
                                if !fields.insert(__FieldTag::__text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text",
                                    ));
                                }
                                result.text = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__language_code => {
                                if !fields.insert(__FieldTag::__language_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for language_code",
                                    ));
                                }
                                result.language_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "agents")]
    #[doc(hidden)]
    impl serde::ser::Serialize for Phrase {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.text.is_empty() {
                state.serialize_entry("text", &self.text)?;
            }
            if !self.language_code.is_empty() {
                state.serialize_entry("languageCode", &self.language_code)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// The request message for
/// [SecuritySettingsService.GetSecuritySettings][google.cloud.dialogflow.cx.v3.SecuritySettingsService.GetSecuritySettings].
///
/// [google.cloud.dialogflow.cx.v3.SecuritySettingsService.GetSecuritySettings]: crate::client::SecuritySettingsService::get_security_settings
#[cfg(feature = "security-settings-service")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSecuritySettingsRequest {
    /// Required. Resource name of the settings.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/securitySettings/<securitysettingsID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "security-settings-service")]
impl GetSecuritySettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSecuritySettingsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "security-settings-service")]
impl wkt::message::Message for GetSecuritySettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetSecuritySettingsRequest"
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSecuritySettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSecuritySettingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSecuritySettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSecuritySettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl serde::ser::Serialize for GetSecuritySettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [SecuritySettingsService.UpdateSecuritySettings][google.cloud.dialogflow.cx.v3.SecuritySettingsService.UpdateSecuritySettings].
///
/// [google.cloud.dialogflow.cx.v3.SecuritySettingsService.UpdateSecuritySettings]: crate::client::SecuritySettingsService::update_security_settings
#[cfg(feature = "security-settings-service")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSecuritySettingsRequest {
    /// Required. [SecuritySettings] object that contains values for each of the
    /// fields to update.
    pub security_settings: std::option::Option<crate::model::SecuritySettings>,

    /// Required. The mask to control which fields get updated. If the mask is not
    /// present, all fields will be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "security-settings-service")]
impl UpdateSecuritySettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [security_settings][crate::model::UpdateSecuritySettingsRequest::security_settings].
    pub fn set_security_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SecuritySettings>,
    {
        self.security_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [security_settings][crate::model::UpdateSecuritySettingsRequest::security_settings].
    pub fn set_or_clear_security_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SecuritySettings>,
    {
        self.security_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSecuritySettingsRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSecuritySettingsRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "security-settings-service")]
impl wkt::message::Message for UpdateSecuritySettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.UpdateSecuritySettingsRequest"
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSecuritySettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __security_settings,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSecuritySettingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "securitySettings" => Ok(__FieldTag::__security_settings),
                            "security_settings" => Ok(__FieldTag::__security_settings),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSecuritySettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSecuritySettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__security_settings => {
                            if !fields.insert(__FieldTag::__security_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_settings",
                                ));
                            }
                            result.security_settings = map
                                .next_value::<std::option::Option<crate::model::SecuritySettings>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateSecuritySettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.security_settings.is_some() {
            state.serialize_entry("securitySettings", &self.security_settings)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for [SecuritySettings.ListSecuritySettings][].
#[cfg(feature = "security-settings-service")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSecuritySettingsRequest {
    /// Required. The location to list all security settings for.
    /// Format: `projects/<ProjectID>/locations/<LocationID>`.
    pub parent: std::string::String,

    /// The maximum number of items to return in a single page. By default 20 and
    /// at most 100.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "security-settings-service")]
impl ListSecuritySettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSecuritySettingsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSecuritySettingsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSecuritySettingsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "security-settings-service")]
impl wkt::message::Message for ListSecuritySettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListSecuritySettingsRequest"
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSecuritySettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSecuritySettingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSecuritySettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSecuritySettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl serde::ser::Serialize for ListSecuritySettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for [SecuritySettings.ListSecuritySettings][].
#[cfg(feature = "security-settings-service")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSecuritySettingsResponse {
    /// The list of security settings.
    pub security_settings: std::vec::Vec<crate::model::SecuritySettings>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "security-settings-service")]
impl ListSecuritySettingsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [security_settings][crate::model::ListSecuritySettingsResponse::security_settings].
    pub fn set_security_settings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SecuritySettings>,
    {
        use std::iter::Iterator;
        self.security_settings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSecuritySettingsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "security-settings-service")]
impl wkt::message::Message for ListSecuritySettingsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListSecuritySettingsResponse"
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSecuritySettingsResponse {
    type PageItem = crate::model::SecuritySettings;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.security_settings
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSecuritySettingsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __security_settings,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSecuritySettingsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "securitySettings" => Ok(__FieldTag::__security_settings),
                            "security_settings" => Ok(__FieldTag::__security_settings),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSecuritySettingsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSecuritySettingsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__security_settings => {
                            if !fields.insert(__FieldTag::__security_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_settings",
                                ));
                            }
                            result.security_settings =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SecuritySettings>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl serde::ser::Serialize for ListSecuritySettingsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.security_settings.is_empty() {
            state.serialize_entry("securitySettings", &self.security_settings)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for [SecuritySettings.CreateSecuritySettings][].
#[cfg(feature = "security-settings-service")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSecuritySettingsRequest {
    /// Required. The location to create an
    /// [SecuritySettings][google.cloud.dialogflow.cx.v3.SecuritySettings] for.
    /// Format: `projects/<ProjectID>/locations/<LocationID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.SecuritySettings]: crate::model::SecuritySettings
    pub parent: std::string::String,

    /// Required. The security settings to create.
    pub security_settings: std::option::Option<crate::model::SecuritySettings>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "security-settings-service")]
impl CreateSecuritySettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSecuritySettingsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [security_settings][crate::model::CreateSecuritySettingsRequest::security_settings].
    pub fn set_security_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SecuritySettings>,
    {
        self.security_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [security_settings][crate::model::CreateSecuritySettingsRequest::security_settings].
    pub fn set_or_clear_security_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SecuritySettings>,
    {
        self.security_settings = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "security-settings-service")]
impl wkt::message::Message for CreateSecuritySettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CreateSecuritySettingsRequest"
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSecuritySettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __security_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSecuritySettingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "securitySettings" => Ok(__FieldTag::__security_settings),
                            "security_settings" => Ok(__FieldTag::__security_settings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSecuritySettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSecuritySettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__security_settings => {
                            if !fields.insert(__FieldTag::__security_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_settings",
                                ));
                            }
                            result.security_settings = map
                                .next_value::<std::option::Option<crate::model::SecuritySettings>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateSecuritySettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.security_settings.is_some() {
            state.serialize_entry("securitySettings", &self.security_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for [SecuritySettings.DeleteSecuritySettings][].
#[cfg(feature = "security-settings-service")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSecuritySettingsRequest {
    /// Required. The name of the
    /// [SecuritySettings][google.cloud.dialogflow.cx.v3.SecuritySettings] to
    /// delete. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/securitySettings/<SecuritySettingsID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.SecuritySettings]: crate::model::SecuritySettings
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "security-settings-service")]
impl DeleteSecuritySettingsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSecuritySettingsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "security-settings-service")]
impl wkt::message::Message for DeleteSecuritySettingsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DeleteSecuritySettingsRequest"
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSecuritySettingsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSecuritySettingsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSecuritySettingsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSecuritySettingsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteSecuritySettingsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the settings related to security issues, such as data redaction
/// and data retention. It may take hours for updates on the settings to
/// propagate to all the related components and take effect.
#[cfg(feature = "security-settings-service")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SecuritySettings {
    /// Resource name of the settings.
    /// Required for the
    /// [SecuritySettingsService.UpdateSecuritySettings][google.cloud.dialogflow.cx.v3.SecuritySettingsService.UpdateSecuritySettings]
    /// method.
    /// [SecuritySettingsService.CreateSecuritySettings][google.cloud.dialogflow.cx.v3.SecuritySettingsService.CreateSecuritySettings]
    /// populates the name automatically. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/securitySettings/<SecuritySettingsID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.SecuritySettingsService.CreateSecuritySettings]: crate::client::SecuritySettingsService::create_security_settings
    /// [google.cloud.dialogflow.cx.v3.SecuritySettingsService.UpdateSecuritySettings]: crate::client::SecuritySettingsService::update_security_settings
    pub name: std::string::String,

    /// Required. The human-readable name of the security settings, unique within
    /// the location.
    pub display_name: std::string::String,

    /// Strategy that defines how we do redaction.
    pub redaction_strategy: crate::model::security_settings::RedactionStrategy,

    /// Defines the data for which Dialogflow applies redaction. Dialogflow does
    /// not redact data that it does not have access to  for example, Cloud
    /// logging.
    pub redaction_scope: crate::model::security_settings::RedactionScope,

    /// [DLP](https://cloud.google.com/dlp/docs) inspect template name. Use this
    /// template to define inspect base settings.
    ///
    /// The `DLP Inspect Templates Reader` role is needed on the Dialogflow
    /// service identity service account (has the form
    /// `service-PROJECT_NUMBER@gcp-sa-dialogflow.iam.gserviceaccount.com`)
    /// for your agent's project.
    ///
    /// If empty, we use the default DLP inspect config.
    ///
    /// The template name will have one of the following formats:
    /// `projects/<ProjectID>/locations/<LocationID>/inspectTemplates/<TemplateID>`
    /// OR
    /// `organizations/<OrganizationID>/locations/<LocationID>/inspectTemplates/<TemplateID>`
    ///
    /// Note: `inspect_template` must be located in the same region as the
    /// `SecuritySettings`.
    pub inspect_template: std::string::String,

    /// [DLP](https://cloud.google.com/dlp/docs) deidentify template name. Use this
    /// template to define de-identification configuration for the content.
    ///
    /// The `DLP De-identify Templates Reader` role is needed on the Dialogflow
    /// service identity service account (has the form
    /// `service-PROJECT_NUMBER@gcp-sa-dialogflow.iam.gserviceaccount.com`)
    /// for your agent's project.
    ///
    /// If empty, Dialogflow replaces sensitive info with `[redacted]` text.
    ///
    /// The template name will have one of the following formats:
    /// `projects/<ProjectID>/locations/<LocationID>/deidentifyTemplates/<TemplateID>`
    /// OR
    /// `organizations/<OrganizationID>/locations/<LocationID>/deidentifyTemplates/<TemplateID>`
    ///
    /// Note: `deidentify_template` must be located in the same region as the
    /// `SecuritySettings`.
    pub deidentify_template: std::string::String,

    /// List of types of data to remove when retention settings triggers purge.
    pub purge_data_types: std::vec::Vec<crate::model::security_settings::PurgeDataType>,

    /// Controls audio export settings for post-conversation analytics when
    /// ingesting audio to conversations via [Participants.AnalyzeContent][] or
    /// [Participants.StreamingAnalyzeContent][].
    ///
    /// If
    /// [retention_strategy][google.cloud.dialogflow.cx.v3.SecuritySettings.retention_strategy]
    /// is set to REMOVE_AFTER_CONVERSATION or [audio_export_settings.gcs_bucket][]
    /// is empty, audio export is disabled.
    ///
    /// If audio export is enabled, audio is recorded and saved to
    /// [audio_export_settings.gcs_bucket][], subject to retention policy of
    /// [audio_export_settings.gcs_bucket][].
    ///
    /// This setting won't effect audio input for implicit sessions via
    /// [Sessions.DetectIntent][google.cloud.dialogflow.cx.v3.Sessions.DetectIntent]
    /// or
    /// [Sessions.StreamingDetectIntent][google.cloud.dialogflow.cx.v3.Sessions.StreamingDetectIntent].
    ///
    /// [google.cloud.dialogflow.cx.v3.SecuritySettings.retention_strategy]: crate::model::SecuritySettings::data_retention
    /// [google.cloud.dialogflow.cx.v3.Sessions.DetectIntent]: crate::client::Sessions::detect_intent
    pub audio_export_settings:
        std::option::Option<crate::model::security_settings::AudioExportSettings>,

    /// Controls conversation exporting settings to Insights after conversation is
    /// completed.
    ///
    /// If
    /// [retention_strategy][google.cloud.dialogflow.cx.v3.SecuritySettings.retention_strategy]
    /// is set to REMOVE_AFTER_CONVERSATION, Insights export is disabled no matter
    /// what you configure here.
    ///
    /// [google.cloud.dialogflow.cx.v3.SecuritySettings.retention_strategy]: crate::model::SecuritySettings::data_retention
    pub insights_export_settings:
        std::option::Option<crate::model::security_settings::InsightsExportSettings>,

    /// Specifies how data is retained. Note that even if the data is
    /// purged due to retention policy, we may still hold it in backup storage for
    /// a few days without allowing direct readings.
    pub data_retention: std::option::Option<crate::model::security_settings::DataRetention>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "security-settings-service")]
impl SecuritySettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SecuritySettings::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::SecuritySettings::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [redaction_strategy][crate::model::SecuritySettings::redaction_strategy].
    pub fn set_redaction_strategy<
        T: std::convert::Into<crate::model::security_settings::RedactionStrategy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.redaction_strategy = v.into();
        self
    }

    /// Sets the value of [redaction_scope][crate::model::SecuritySettings::redaction_scope].
    pub fn set_redaction_scope<
        T: std::convert::Into<crate::model::security_settings::RedactionScope>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.redaction_scope = v.into();
        self
    }

    /// Sets the value of [inspect_template][crate::model::SecuritySettings::inspect_template].
    pub fn set_inspect_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.inspect_template = v.into();
        self
    }

    /// Sets the value of [deidentify_template][crate::model::SecuritySettings::deidentify_template].
    pub fn set_deidentify_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.deidentify_template = v.into();
        self
    }

    /// Sets the value of [purge_data_types][crate::model::SecuritySettings::purge_data_types].
    pub fn set_purge_data_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::security_settings::PurgeDataType>,
    {
        use std::iter::Iterator;
        self.purge_data_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [audio_export_settings][crate::model::SecuritySettings::audio_export_settings].
    pub fn set_audio_export_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::security_settings::AudioExportSettings>,
    {
        self.audio_export_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [audio_export_settings][crate::model::SecuritySettings::audio_export_settings].
    pub fn set_or_clear_audio_export_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::security_settings::AudioExportSettings>,
    {
        self.audio_export_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [insights_export_settings][crate::model::SecuritySettings::insights_export_settings].
    pub fn set_insights_export_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::security_settings::InsightsExportSettings>,
    {
        self.insights_export_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [insights_export_settings][crate::model::SecuritySettings::insights_export_settings].
    pub fn set_or_clear_insights_export_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::security_settings::InsightsExportSettings>,
    {
        self.insights_export_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_retention][crate::model::SecuritySettings::data_retention].
    ///
    /// Note that all the setters affecting `data_retention` are mutually
    /// exclusive.
    pub fn set_data_retention<
        T: std::convert::Into<std::option::Option<crate::model::security_settings::DataRetention>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_retention = v.into();
        self
    }

    /// The value of [data_retention][crate::model::SecuritySettings::data_retention]
    /// if it holds a `RetentionWindowDays`, `None` if the field is not set or
    /// holds a different branch.
    pub fn retention_window_days(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.data_retention.as_ref().and_then(|v| match v {
            crate::model::security_settings::DataRetention::RetentionWindowDays(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_retention][crate::model::SecuritySettings::data_retention]
    /// to hold a `RetentionWindowDays`.
    ///
    /// Note that all the setters affecting `data_retention` are
    /// mutually exclusive.
    pub fn set_retention_window_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.data_retention = std::option::Option::Some(
            crate::model::security_settings::DataRetention::RetentionWindowDays(v.into()),
        );
        self
    }

    /// The value of [data_retention][crate::model::SecuritySettings::data_retention]
    /// if it holds a `RetentionStrategy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn retention_strategy(
        &self,
    ) -> std::option::Option<&crate::model::security_settings::RetentionStrategy> {
        #[allow(unreachable_patterns)]
        self.data_retention.as_ref().and_then(|v| match v {
            crate::model::security_settings::DataRetention::RetentionStrategy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [data_retention][crate::model::SecuritySettings::data_retention]
    /// to hold a `RetentionStrategy`.
    ///
    /// Note that all the setters affecting `data_retention` are
    /// mutually exclusive.
    pub fn set_retention_strategy<
        T: std::convert::Into<crate::model::security_settings::RetentionStrategy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_retention = std::option::Option::Some(
            crate::model::security_settings::DataRetention::RetentionStrategy(v.into()),
        );
        self
    }
}

#[cfg(feature = "security-settings-service")]
impl wkt::message::Message for SecuritySettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.SecuritySettings"
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecuritySettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __redaction_strategy,
            __redaction_scope,
            __inspect_template,
            __deidentify_template,
            __retention_window_days,
            __retention_strategy,
            __purge_data_types,
            __audio_export_settings,
            __insights_export_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecuritySettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "redactionStrategy" => Ok(__FieldTag::__redaction_strategy),
                            "redaction_strategy" => Ok(__FieldTag::__redaction_strategy),
                            "redactionScope" => Ok(__FieldTag::__redaction_scope),
                            "redaction_scope" => Ok(__FieldTag::__redaction_scope),
                            "inspectTemplate" => Ok(__FieldTag::__inspect_template),
                            "inspect_template" => Ok(__FieldTag::__inspect_template),
                            "deidentifyTemplate" => Ok(__FieldTag::__deidentify_template),
                            "deidentify_template" => Ok(__FieldTag::__deidentify_template),
                            "retentionWindowDays" => Ok(__FieldTag::__retention_window_days),
                            "retention_window_days" => Ok(__FieldTag::__retention_window_days),
                            "retentionStrategy" => Ok(__FieldTag::__retention_strategy),
                            "retention_strategy" => Ok(__FieldTag::__retention_strategy),
                            "purgeDataTypes" => Ok(__FieldTag::__purge_data_types),
                            "purge_data_types" => Ok(__FieldTag::__purge_data_types),
                            "audioExportSettings" => Ok(__FieldTag::__audio_export_settings),
                            "audio_export_settings" => Ok(__FieldTag::__audio_export_settings),
                            "insightsExportSettings" => Ok(__FieldTag::__insights_export_settings),
                            "insights_export_settings" => {
                                Ok(__FieldTag::__insights_export_settings)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecuritySettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecuritySettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__redaction_strategy => {
                            if !fields.insert(__FieldTag::__redaction_strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redaction_strategy",
                                ));
                            }
                            result.redaction_strategy = map
                                .next_value::<std::option::Option<
                                    crate::model::security_settings::RedactionStrategy,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__redaction_scope => {
                            if !fields.insert(__FieldTag::__redaction_scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redaction_scope",
                                ));
                            }
                            result.redaction_scope = map
                                .next_value::<std::option::Option<
                                    crate::model::security_settings::RedactionScope,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inspect_template => {
                            if !fields.insert(__FieldTag::__inspect_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inspect_template",
                                ));
                            }
                            result.inspect_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deidentify_template => {
                            if !fields.insert(__FieldTag::__deidentify_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deidentify_template",
                                ));
                            }
                            result.deidentify_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__retention_window_days => {
                            if !fields.insert(__FieldTag::__retention_window_days) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retention_window_days",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.data_retention.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_retention`, a oneof with full ID .google.cloud.dialogflow.cx.v3.SecuritySettings.retention_window_days, latest field was retentionWindowDays",
                                ));
                            }
                            result.data_retention = std::option::Option::Some(
                                crate::model::security_settings::DataRetention::RetentionWindowDays(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__retention_strategy => {
                            if !fields.insert(__FieldTag::__retention_strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retention_strategy",
                                ));
                            }
                            if result.data_retention.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `data_retention`, a oneof with full ID .google.cloud.dialogflow.cx.v3.SecuritySettings.retention_strategy, latest field was retentionStrategy",
                                ));
                            }
                            result.data_retention = std::option::Option::Some(
                                crate::model::security_settings::DataRetention::RetentionStrategy(
                                    map.next_value::<std::option::Option<
                                        crate::model::security_settings::RetentionStrategy,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__purge_data_types => {
                            if !fields.insert(__FieldTag::__purge_data_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for purge_data_types",
                                ));
                            }
                            result.purge_data_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::security_settings::PurgeDataType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__audio_export_settings => {
                            if !fields.insert(__FieldTag::__audio_export_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_export_settings",
                                ));
                            }
                            result.audio_export_settings = map.next_value::<std::option::Option<
                                crate::model::security_settings::AudioExportSettings,
                            >>()?;
                        }
                        __FieldTag::__insights_export_settings => {
                            if !fields.insert(__FieldTag::__insights_export_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insights_export_settings",
                                ));
                            }
                            result.insights_export_settings = map
                                .next_value::<std::option::Option<
                                    crate::model::security_settings::InsightsExportSettings,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "security-settings-service")]
#[doc(hidden)]
impl serde::ser::Serialize for SecuritySettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.redaction_strategy) {
            state.serialize_entry("redactionStrategy", &self.redaction_strategy)?;
        }
        if !wkt::internal::is_default(&self.redaction_scope) {
            state.serialize_entry("redactionScope", &self.redaction_scope)?;
        }
        if !self.inspect_template.is_empty() {
            state.serialize_entry("inspectTemplate", &self.inspect_template)?;
        }
        if !self.deidentify_template.is_empty() {
            state.serialize_entry("deidentifyTemplate", &self.deidentify_template)?;
        }
        if let Some(value) = self.retention_window_days() {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("retentionWindowDays", &__With(value))?;
        }
        if let Some(value) = self.retention_strategy() {
            state.serialize_entry("retentionStrategy", value)?;
        }
        if !self.purge_data_types.is_empty() {
            state.serialize_entry("purgeDataTypes", &self.purge_data_types)?;
        }
        if self.audio_export_settings.is_some() {
            state.serialize_entry("audioExportSettings", &self.audio_export_settings)?;
        }
        if self.insights_export_settings.is_some() {
            state.serialize_entry("insightsExportSettings", &self.insights_export_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SecuritySettings].
#[cfg(feature = "security-settings-service")]
pub mod security_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Settings for exporting audio.
    #[cfg(feature = "security-settings-service")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AudioExportSettings {
        /// Cloud Storage bucket to export audio record to.
        /// Setting this field would grant the Storage Object Creator role to
        /// the Dialogflow Service Agent.
        /// API caller that tries to modify this field should have the permission of
        /// storage.buckets.setIamPolicy.
        pub gcs_bucket: std::string::String,

        /// Filename pattern for exported audio.
        pub audio_export_pattern: std::string::String,

        /// Enable audio redaction if it is true.
        /// Note that this only redacts end-user audio data;
        /// Synthesised audio from the virtual agent is not redacted.
        pub enable_audio_redaction: bool,

        /// File format for exported audio file. Currently only in telephony
        /// recordings.
        pub audio_format: crate::model::security_settings::audio_export_settings::AudioFormat,

        /// Whether to store TTS audio. By default, TTS audio from the virtual agent
        /// is not exported.
        pub store_tts_audio: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "security-settings-service")]
    impl AudioExportSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [gcs_bucket][crate::model::security_settings::AudioExportSettings::gcs_bucket].
        pub fn set_gcs_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.gcs_bucket = v.into();
            self
        }

        /// Sets the value of [audio_export_pattern][crate::model::security_settings::AudioExportSettings::audio_export_pattern].
        pub fn set_audio_export_pattern<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.audio_export_pattern = v.into();
            self
        }

        /// Sets the value of [enable_audio_redaction][crate::model::security_settings::AudioExportSettings::enable_audio_redaction].
        pub fn set_enable_audio_redaction<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_audio_redaction = v.into();
            self
        }

        /// Sets the value of [audio_format][crate::model::security_settings::AudioExportSettings::audio_format].
        pub fn set_audio_format<
            T: std::convert::Into<crate::model::security_settings::audio_export_settings::AudioFormat>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.audio_format = v.into();
            self
        }

        /// Sets the value of [store_tts_audio][crate::model::security_settings::AudioExportSettings::store_tts_audio].
        pub fn set_store_tts_audio<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.store_tts_audio = v.into();
            self
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl wkt::message::Message for AudioExportSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.SecuritySettings.AudioExportSettings"
        }
    }

    #[cfg(feature = "security-settings-service")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AudioExportSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __gcs_bucket,
                __audio_export_pattern,
                __enable_audio_redaction,
                __audio_format,
                __store_tts_audio,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AudioExportSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "gcsBucket" => Ok(__FieldTag::__gcs_bucket),
                                "gcs_bucket" => Ok(__FieldTag::__gcs_bucket),
                                "audioExportPattern" => Ok(__FieldTag::__audio_export_pattern),
                                "audio_export_pattern" => Ok(__FieldTag::__audio_export_pattern),
                                "enableAudioRedaction" => Ok(__FieldTag::__enable_audio_redaction),
                                "enable_audio_redaction" => {
                                    Ok(__FieldTag::__enable_audio_redaction)
                                }
                                "audioFormat" => Ok(__FieldTag::__audio_format),
                                "audio_format" => Ok(__FieldTag::__audio_format),
                                "storeTtsAudio" => Ok(__FieldTag::__store_tts_audio),
                                "store_tts_audio" => Ok(__FieldTag::__store_tts_audio),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AudioExportSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AudioExportSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__gcs_bucket => {
                                if !fields.insert(__FieldTag::__gcs_bucket) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for gcs_bucket",
                                    ));
                                }
                                result.gcs_bucket = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__audio_export_pattern => {
                                if !fields.insert(__FieldTag::__audio_export_pattern) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for audio_export_pattern",
                                    ));
                                }
                                result.audio_export_pattern = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__enable_audio_redaction => {
                                if !fields.insert(__FieldTag::__enable_audio_redaction) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_audio_redaction",
                                    ));
                                }
                                result.enable_audio_redaction = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__audio_format => {
                                if !fields.insert(__FieldTag::__audio_format) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for audio_format",
                                    ));
                                }
                                result.audio_format = map.next_value::<std::option::Option<crate::model::security_settings::audio_export_settings::AudioFormat>>()?.unwrap_or_default();
                            }
                            __FieldTag::__store_tts_audio => {
                                if !fields.insert(__FieldTag::__store_tts_audio) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for store_tts_audio",
                                    ));
                                }
                                result.store_tts_audio = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "security-settings-service")]
    #[doc(hidden)]
    impl serde::ser::Serialize for AudioExportSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.gcs_bucket.is_empty() {
                state.serialize_entry("gcsBucket", &self.gcs_bucket)?;
            }
            if !self.audio_export_pattern.is_empty() {
                state.serialize_entry("audioExportPattern", &self.audio_export_pattern)?;
            }
            if !wkt::internal::is_default(&self.enable_audio_redaction) {
                state.serialize_entry("enableAudioRedaction", &self.enable_audio_redaction)?;
            }
            if !wkt::internal::is_default(&self.audio_format) {
                state.serialize_entry("audioFormat", &self.audio_format)?;
            }
            if !wkt::internal::is_default(&self.store_tts_audio) {
                state.serialize_entry("storeTtsAudio", &self.store_tts_audio)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [AudioExportSettings].
    #[cfg(feature = "security-settings-service")]
    pub mod audio_export_settings {
        #[allow(unused_imports)]
        use super::*;

        /// File format for exported audio file. Currently only in telephony
        /// recordings.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "security-settings-service")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum AudioFormat {
            /// Unspecified. Do not use.
            Unspecified,
            /// G.711 mu-law PCM with 8kHz sample rate.
            Mulaw,
            /// MP3 file format.
            Mp3,
            /// OGG Vorbis.
            Ogg,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [AudioFormat::value] or
            /// [AudioFormat::name].
            UnknownValue(audio_format::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "security-settings-service")]
        pub mod audio_format {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "security-settings-service")]
        impl AudioFormat {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Mulaw => std::option::Option::Some(1),
                    Self::Mp3 => std::option::Option::Some(2),
                    Self::Ogg => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("AUDIO_FORMAT_UNSPECIFIED"),
                    Self::Mulaw => std::option::Option::Some("MULAW"),
                    Self::Mp3 => std::option::Option::Some("MP3"),
                    Self::Ogg => std::option::Option::Some("OGG"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "security-settings-service")]
        impl std::default::Default for AudioFormat {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "security-settings-service")]
        impl std::fmt::Display for AudioFormat {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "security-settings-service")]
        impl std::convert::From<i32> for AudioFormat {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Mulaw,
                    2 => Self::Mp3,
                    3 => Self::Ogg,
                    _ => Self::UnknownValue(audio_format::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "security-settings-service")]
        impl std::convert::From<&str> for AudioFormat {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "AUDIO_FORMAT_UNSPECIFIED" => Self::Unspecified,
                    "MULAW" => Self::Mulaw,
                    "MP3" => Self::Mp3,
                    "OGG" => Self::Ogg,
                    _ => Self::UnknownValue(audio_format::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "security-settings-service")]
        impl serde::ser::Serialize for AudioFormat {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Mulaw => serializer.serialize_i32(1),
                    Self::Mp3 => serializer.serialize_i32(2),
                    Self::Ogg => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "security-settings-service")]
        impl<'de> serde::de::Deserialize<'de> for AudioFormat {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<AudioFormat>::new(
                    ".google.cloud.dialogflow.cx.v3.SecuritySettings.AudioExportSettings.AudioFormat"))
            }
        }
    }

    /// Settings for exporting conversations to
    /// [Insights](https://cloud.google.com/contact-center/insights/docs).
    #[cfg(feature = "security-settings-service")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InsightsExportSettings {
        /// If enabled, we will automatically exports
        /// conversations to Insights and Insights runs its analyzers.
        pub enable_insights_export: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "security-settings-service")]
    impl InsightsExportSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enable_insights_export][crate::model::security_settings::InsightsExportSettings::enable_insights_export].
        pub fn set_enable_insights_export<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_insights_export = v.into();
            self
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl wkt::message::Message for InsightsExportSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.SecuritySettings.InsightsExportSettings"
        }
    }

    #[cfg(feature = "security-settings-service")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for InsightsExportSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enable_insights_export,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for InsightsExportSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enableInsightsExport" => Ok(__FieldTag::__enable_insights_export),
                                "enable_insights_export" => {
                                    Ok(__FieldTag::__enable_insights_export)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = InsightsExportSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct InsightsExportSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enable_insights_export => {
                                if !fields.insert(__FieldTag::__enable_insights_export) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_insights_export",
                                    ));
                                }
                                result.enable_insights_export = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "security-settings-service")]
    #[doc(hidden)]
    impl serde::ser::Serialize for InsightsExportSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.enable_insights_export) {
                state.serialize_entry("enableInsightsExport", &self.enable_insights_export)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines how we redact data.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "security-settings-service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RedactionStrategy {
        /// Do not redact.
        Unspecified,
        /// Call redaction service to clean up the data to be persisted.
        RedactWithService,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RedactionStrategy::value] or
        /// [RedactionStrategy::name].
        UnknownValue(redaction_strategy::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "security-settings-service")]
    pub mod redaction_strategy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "security-settings-service")]
    impl RedactionStrategy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RedactWithService => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REDACTION_STRATEGY_UNSPECIFIED"),
                Self::RedactWithService => std::option::Option::Some("REDACT_WITH_SERVICE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl std::default::Default for RedactionStrategy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl std::fmt::Display for RedactionStrategy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl std::convert::From<i32> for RedactionStrategy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::RedactWithService,
                _ => Self::UnknownValue(redaction_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl std::convert::From<&str> for RedactionStrategy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REDACTION_STRATEGY_UNSPECIFIED" => Self::Unspecified,
                "REDACT_WITH_SERVICE" => Self::RedactWithService,
                _ => Self::UnknownValue(redaction_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl serde::ser::Serialize for RedactionStrategy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RedactWithService => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl<'de> serde::de::Deserialize<'de> for RedactionStrategy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RedactionStrategy>::new(
                ".google.cloud.dialogflow.cx.v3.SecuritySettings.RedactionStrategy",
            ))
        }
    }

    /// Defines what types of data to redact.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "security-settings-service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RedactionScope {
        /// Don't redact any kind of data.
        Unspecified,
        /// On data to be written to disk or similar devices that are capable of
        /// holding data even if power is disconnected. This includes data that are
        /// temporarily saved on disk.
        RedactDiskStorage,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RedactionScope::value] or
        /// [RedactionScope::name].
        UnknownValue(redaction_scope::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "security-settings-service")]
    pub mod redaction_scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "security-settings-service")]
    impl RedactionScope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RedactDiskStorage => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REDACTION_SCOPE_UNSPECIFIED"),
                Self::RedactDiskStorage => std::option::Option::Some("REDACT_DISK_STORAGE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl std::default::Default for RedactionScope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl std::fmt::Display for RedactionScope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl std::convert::From<i32> for RedactionScope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::RedactDiskStorage,
                _ => Self::UnknownValue(redaction_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl std::convert::From<&str> for RedactionScope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REDACTION_SCOPE_UNSPECIFIED" => Self::Unspecified,
                "REDACT_DISK_STORAGE" => Self::RedactDiskStorage,
                _ => Self::UnknownValue(redaction_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl serde::ser::Serialize for RedactionScope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RedactDiskStorage => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl<'de> serde::de::Deserialize<'de> for RedactionScope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RedactionScope>::new(
                ".google.cloud.dialogflow.cx.v3.SecuritySettings.RedactionScope",
            ))
        }
    }

    /// Defines how long we retain persisted data that contains sensitive info.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "security-settings-service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RetentionStrategy {
        /// Retains the persisted data with Dialogflow's internal default 365d TTLs.
        Unspecified,
        /// Removes data when the conversation ends. If there is no [Conversation][]
        /// explicitly established, a default conversation ends when the
        /// corresponding Dialogflow session ends.
        RemoveAfterConversation,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RetentionStrategy::value] or
        /// [RetentionStrategy::name].
        UnknownValue(retention_strategy::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "security-settings-service")]
    pub mod retention_strategy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "security-settings-service")]
    impl RetentionStrategy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::RemoveAfterConversation => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RETENTION_STRATEGY_UNSPECIFIED"),
                Self::RemoveAfterConversation => {
                    std::option::Option::Some("REMOVE_AFTER_CONVERSATION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl std::default::Default for RetentionStrategy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl std::fmt::Display for RetentionStrategy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl std::convert::From<i32> for RetentionStrategy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::RemoveAfterConversation,
                _ => Self::UnknownValue(retention_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl std::convert::From<&str> for RetentionStrategy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RETENTION_STRATEGY_UNSPECIFIED" => Self::Unspecified,
                "REMOVE_AFTER_CONVERSATION" => Self::RemoveAfterConversation,
                _ => Self::UnknownValue(retention_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl serde::ser::Serialize for RetentionStrategy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::RemoveAfterConversation => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl<'de> serde::de::Deserialize<'de> for RetentionStrategy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RetentionStrategy>::new(
                ".google.cloud.dialogflow.cx.v3.SecuritySettings.RetentionStrategy",
            ))
        }
    }

    /// Type of data we purge after retention settings triggers purge.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "security-settings-service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PurgeDataType {
        /// Unspecified. Do not use.
        Unspecified,
        /// Dialogflow history. This does not include Cloud logging, which is
        /// owned by the user - not Dialogflow.
        DialogflowHistory,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PurgeDataType::value] or
        /// [PurgeDataType::name].
        UnknownValue(purge_data_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "security-settings-service")]
    pub mod purge_data_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "security-settings-service")]
    impl PurgeDataType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DialogflowHistory => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PURGE_DATA_TYPE_UNSPECIFIED"),
                Self::DialogflowHistory => std::option::Option::Some("DIALOGFLOW_HISTORY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl std::default::Default for PurgeDataType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl std::fmt::Display for PurgeDataType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl std::convert::From<i32> for PurgeDataType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DialogflowHistory,
                _ => Self::UnknownValue(purge_data_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl std::convert::From<&str> for PurgeDataType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PURGE_DATA_TYPE_UNSPECIFIED" => Self::Unspecified,
                "DIALOGFLOW_HISTORY" => Self::DialogflowHistory,
                _ => Self::UnknownValue(purge_data_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl serde::ser::Serialize for PurgeDataType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DialogflowHistory => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "security-settings-service")]
    impl<'de> serde::de::Deserialize<'de> for PurgeDataType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PurgeDataType>::new(
                ".google.cloud.dialogflow.cx.v3.SecuritySettings.PurgeDataType",
            ))
        }
    }

    /// Specifies how data is retained. Note that even if the data is
    /// purged due to retention policy, we may still hold it in backup storage for
    /// a few days without allowing direct readings.
    #[cfg(feature = "security-settings-service")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataRetention {
        /// Retains the data for the specified number of days.
        /// User must set a value lower than Dialogflow's default 365d TTL (30 days
        /// for Agent Assist traffic), higher value will be ignored and use default.
        /// Setting a value higher than that has no effect. A missing value or
        /// setting to 0 also means we use default TTL.
        /// When data retention configuration is changed, it only applies to the data
        /// created after the change; the TTL of existing data created before the
        /// change stays intact.
        RetentionWindowDays(i32),
        /// Specifies the retention behavior defined by
        /// [SecuritySettings.RetentionStrategy][google.cloud.dialogflow.cx.v3.SecuritySettings.RetentionStrategy].
        ///
        /// [google.cloud.dialogflow.cx.v3.SecuritySettings.RetentionStrategy]: crate::model::security_settings::RetentionStrategy
        RetentionStrategy(crate::model::security_settings::RetentionStrategy),
    }
}

/// Stores information about feedback provided by users about a response.
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AnswerFeedback {
    /// Optional. Rating from user for the specific Dialogflow response.
    pub rating: crate::model::answer_feedback::Rating,

    /// Optional. In case of thumbs down rating provided, users can optionally
    /// provide context about the rating.
    pub rating_reason: std::option::Option<crate::model::answer_feedback::RatingReason>,

    /// Optional. Custom rating from the user about the provided answer, with
    /// maximum length of 1024 characters. For example, client could use a
    /// customized JSON object to indicate the rating.
    pub custom_rating: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl AnswerFeedback {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rating][crate::model::AnswerFeedback::rating].
    pub fn set_rating<T: std::convert::Into<crate::model::answer_feedback::Rating>>(
        mut self,
        v: T,
    ) -> Self {
        self.rating = v.into();
        self
    }

    /// Sets the value of [rating_reason][crate::model::AnswerFeedback::rating_reason].
    pub fn set_rating_reason<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::answer_feedback::RatingReason>,
    {
        self.rating_reason = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rating_reason][crate::model::AnswerFeedback::rating_reason].
    pub fn set_or_clear_rating_reason<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::answer_feedback::RatingReason>,
    {
        self.rating_reason = v.map(|x| x.into());
        self
    }

    /// Sets the value of [custom_rating][crate::model::AnswerFeedback::custom_rating].
    pub fn set_custom_rating<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.custom_rating = v.into();
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for AnswerFeedback {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.AnswerFeedback"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnswerFeedback {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rating,
            __rating_reason,
            __custom_rating,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnswerFeedback")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rating" => Ok(__FieldTag::__rating),
                            "ratingReason" => Ok(__FieldTag::__rating_reason),
                            "rating_reason" => Ok(__FieldTag::__rating_reason),
                            "customRating" => Ok(__FieldTag::__custom_rating),
                            "custom_rating" => Ok(__FieldTag::__custom_rating),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnswerFeedback;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnswerFeedback")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rating => {
                            if !fields.insert(__FieldTag::__rating) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rating",
                                ));
                            }
                            result.rating = map.next_value::<std::option::Option<crate::model::answer_feedback::Rating>>()?.unwrap_or_default();
                        }
                        __FieldTag::__rating_reason => {
                            if !fields.insert(__FieldTag::__rating_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rating_reason",
                                ));
                            }
                            result.rating_reason =
                                map.next_value::<std::option::Option<
                                    crate::model::answer_feedback::RatingReason,
                                >>()?;
                        }
                        __FieldTag::__custom_rating => {
                            if !fields.insert(__FieldTag::__custom_rating) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_rating",
                                ));
                            }
                            result.custom_rating = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for AnswerFeedback {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.rating) {
            state.serialize_entry("rating", &self.rating)?;
        }
        if self.rating_reason.is_some() {
            state.serialize_entry("ratingReason", &self.rating_reason)?;
        }
        if !self.custom_rating.is_empty() {
            state.serialize_entry("customRating", &self.custom_rating)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AnswerFeedback].
#[cfg(feature = "sessions")]
pub mod answer_feedback {
    #[allow(unused_imports)]
    use super::*;

    /// Stores extra information about why users provided thumbs down rating.
    #[cfg(feature = "sessions")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RatingReason {
        /// Optional. Custom reason labels for thumbs down rating provided by the
        /// user. The maximum number of labels allowed is 10 and the maximum length
        /// of a single label is 128 characters.
        pub reason_labels: std::vec::Vec<std::string::String>,

        /// Optional. Additional feedback about the rating.
        /// This field can be populated without choosing a predefined `reason`.
        pub feedback: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "sessions")]
    impl RatingReason {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [reason_labels][crate::model::answer_feedback::RatingReason::reason_labels].
        pub fn set_reason_labels<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.reason_labels = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [feedback][crate::model::answer_feedback::RatingReason::feedback].
        pub fn set_feedback<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.feedback = v.into();
            self
        }
    }

    #[cfg(feature = "sessions")]
    impl wkt::message::Message for RatingReason {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.AnswerFeedback.RatingReason"
        }
    }

    #[cfg(feature = "sessions")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RatingReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __reason_labels,
                __feedback,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RatingReason")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "reasonLabels" => Ok(__FieldTag::__reason_labels),
                                "reason_labels" => Ok(__FieldTag::__reason_labels),
                                "feedback" => Ok(__FieldTag::__feedback),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RatingReason;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RatingReason")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__reason_labels => {
                                if !fields.insert(__FieldTag::__reason_labels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for reason_labels",
                                    ));
                                }
                                result.reason_labels = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__feedback => {
                                if !fields.insert(__FieldTag::__feedback) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for feedback",
                                    ));
                                }
                                result.feedback = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "sessions")]
    #[doc(hidden)]
    impl serde::ser::Serialize for RatingReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.reason_labels.is_empty() {
                state.serialize_entry("reasonLabels", &self.reason_labels)?;
            }
            if !self.feedback.is_empty() {
                state.serialize_entry("feedback", &self.feedback)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Represents thumbs up/down rating provided by user about a response.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "sessions")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Rating {
        /// Rating not specified.
        Unspecified,
        /// Thumbs up feedback from user.
        ThumbsUp,
        /// Thumbs down feedback from user.
        ThumbsDown,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Rating::value] or
        /// [Rating::name].
        UnknownValue(rating::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "sessions")]
    pub mod rating {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "sessions")]
    impl Rating {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ThumbsUp => std::option::Option::Some(1),
                Self::ThumbsDown => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RATING_UNSPECIFIED"),
                Self::ThumbsUp => std::option::Option::Some("THUMBS_UP"),
                Self::ThumbsDown => std::option::Option::Some("THUMBS_DOWN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "sessions")]
    impl std::default::Default for Rating {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "sessions")]
    impl std::fmt::Display for Rating {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "sessions")]
    impl std::convert::From<i32> for Rating {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ThumbsUp,
                2 => Self::ThumbsDown,
                _ => Self::UnknownValue(rating::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "sessions")]
    impl std::convert::From<&str> for Rating {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RATING_UNSPECIFIED" => Self::Unspecified,
                "THUMBS_UP" => Self::ThumbsUp,
                "THUMBS_DOWN" => Self::ThumbsDown,
                _ => Self::UnknownValue(rating::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "sessions")]
    impl serde::ser::Serialize for Rating {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ThumbsUp => serializer.serialize_i32(1),
                Self::ThumbsDown => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "sessions")]
    impl<'de> serde::de::Deserialize<'de> for Rating {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Rating>::new(
                ".google.cloud.dialogflow.cx.v3.AnswerFeedback.Rating",
            ))
        }
    }
}

/// The request to set the feedback for a bot answer.
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SubmitAnswerFeedbackRequest {
    /// Required. The name of the session the feedback was sent to.
    pub session: std::string::String,

    /// Required. ID of the response to update its feedback. This is the same as
    /// DetectIntentResponse.response_id.
    pub response_id: std::string::String,

    /// Required. Feedback provided for a bot answer.
    pub answer_feedback: std::option::Option<crate::model::AnswerFeedback>,

    /// Optional. The mask to control which fields to update. If the mask is not
    /// present, all fields will be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl SubmitAnswerFeedbackRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session][crate::model::SubmitAnswerFeedbackRequest::session].
    pub fn set_session<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session = v.into();
        self
    }

    /// Sets the value of [response_id][crate::model::SubmitAnswerFeedbackRequest::response_id].
    pub fn set_response_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.response_id = v.into();
        self
    }

    /// Sets the value of [answer_feedback][crate::model::SubmitAnswerFeedbackRequest::answer_feedback].
    pub fn set_answer_feedback<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnswerFeedback>,
    {
        self.answer_feedback = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [answer_feedback][crate::model::SubmitAnswerFeedbackRequest::answer_feedback].
    pub fn set_or_clear_answer_feedback<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AnswerFeedback>,
    {
        self.answer_feedback = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::SubmitAnswerFeedbackRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::SubmitAnswerFeedbackRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for SubmitAnswerFeedbackRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.SubmitAnswerFeedbackRequest"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SubmitAnswerFeedbackRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session,
            __response_id,
            __answer_feedback,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SubmitAnswerFeedbackRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "session" => Ok(__FieldTag::__session),
                            "responseId" => Ok(__FieldTag::__response_id),
                            "response_id" => Ok(__FieldTag::__response_id),
                            "answerFeedback" => Ok(__FieldTag::__answer_feedback),
                            "answer_feedback" => Ok(__FieldTag::__answer_feedback),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SubmitAnswerFeedbackRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SubmitAnswerFeedbackRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session => {
                            if !fields.insert(__FieldTag::__session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session",
                                ));
                            }
                            result.session = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__response_id => {
                            if !fields.insert(__FieldTag::__response_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_id",
                                ));
                            }
                            result.response_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__answer_feedback => {
                            if !fields.insert(__FieldTag::__answer_feedback) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_feedback",
                                ));
                            }
                            result.answer_feedback = map
                                .next_value::<std::option::Option<crate::model::AnswerFeedback>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for SubmitAnswerFeedbackRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if !self.response_id.is_empty() {
            state.serialize_entry("responseId", &self.response_id)?;
        }
        if self.answer_feedback.is_some() {
            state.serialize_entry("answerFeedback", &self.answer_feedback)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request to detect user's intent.
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DetectIntentRequest {
    /// Required. The name of the session this query is sent to.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/sessions/<Session
    /// ID>` or
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>/sessions/<SessionID>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment.
    /// It's up to the API caller to choose an appropriate `Session ID`. It can be
    /// a random number or some type of session identifiers (preferably hashed).
    /// The length of the `Session ID` must not exceed 36 characters.
    ///
    /// For more information, see the [sessions
    /// guide](https://cloud.google.com/dialogflow/cx/docs/concept/session).
    ///
    /// Note: Always use agent versions for production traffic.
    /// See [Versions and
    /// environments](https://cloud.google.com/dialogflow/cx/docs/concept/version).
    pub session: std::string::String,

    /// The parameters of this query.
    pub query_params: std::option::Option<crate::model::QueryParameters>,

    /// Required. The input specification.
    pub query_input: std::option::Option<crate::model::QueryInput>,

    /// Instructs the speech synthesizer how to generate the output audio.
    pub output_audio_config: std::option::Option<crate::model::OutputAudioConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl DetectIntentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session][crate::model::DetectIntentRequest::session].
    pub fn set_session<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session = v.into();
        self
    }

    /// Sets the value of [query_params][crate::model::DetectIntentRequest::query_params].
    pub fn set_query_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameters>,
    {
        self.query_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_params][crate::model::DetectIntentRequest::query_params].
    pub fn set_or_clear_query_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameters>,
    {
        self.query_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query_input][crate::model::DetectIntentRequest::query_input].
    pub fn set_query_input<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryInput>,
    {
        self.query_input = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_input][crate::model::DetectIntentRequest::query_input].
    pub fn set_or_clear_query_input<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryInput>,
    {
        self.query_input = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_audio_config][crate::model::DetectIntentRequest::output_audio_config].
    pub fn set_output_audio_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.output_audio_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_audio_config][crate::model::DetectIntentRequest::output_audio_config].
    pub fn set_or_clear_output_audio_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.output_audio_config = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for DetectIntentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DetectIntentRequest"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DetectIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session,
            __query_params,
            __query_input,
            __output_audio_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DetectIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "session" => Ok(__FieldTag::__session),
                            "queryParams" => Ok(__FieldTag::__query_params),
                            "query_params" => Ok(__FieldTag::__query_params),
                            "queryInput" => Ok(__FieldTag::__query_input),
                            "query_input" => Ok(__FieldTag::__query_input),
                            "outputAudioConfig" => Ok(__FieldTag::__output_audio_config),
                            "output_audio_config" => Ok(__FieldTag::__output_audio_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DetectIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DetectIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session => {
                            if !fields.insert(__FieldTag::__session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session",
                                ));
                            }
                            result.session = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_params => {
                            if !fields.insert(__FieldTag::__query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_params",
                                ));
                            }
                            result.query_params = map
                                .next_value::<std::option::Option<crate::model::QueryParameters>>(
                                )?;
                        }
                        __FieldTag::__query_input => {
                            if !fields.insert(__FieldTag::__query_input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_input",
                                ));
                            }
                            result.query_input =
                                map.next_value::<std::option::Option<crate::model::QueryInput>>()?;
                        }
                        __FieldTag::__output_audio_config => {
                            if !fields.insert(__FieldTag::__output_audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_audio_config",
                                ));
                            }
                            result.output_audio_config = map
                                .next_value::<std::option::Option<crate::model::OutputAudioConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for DetectIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if self.query_params.is_some() {
            state.serialize_entry("queryParams", &self.query_params)?;
        }
        if self.query_input.is_some() {
            state.serialize_entry("queryInput", &self.query_input)?;
        }
        if self.output_audio_config.is_some() {
            state.serialize_entry("outputAudioConfig", &self.output_audio_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The message returned from the DetectIntent method.
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DetectIntentResponse {
    /// Output only. The unique identifier of the response. It can be used to
    /// locate a response in the training example set or for reporting issues.
    pub response_id: std::string::String,

    /// The result of the conversational query.
    pub query_result: std::option::Option<crate::model::QueryResult>,

    /// The audio data bytes encoded as specified in the request.
    /// Note: The output audio is generated based on the values of default platform
    /// text responses found in the
    /// [`query_result.response_messages`][google.cloud.dialogflow.cx.v3.QueryResult.response_messages]
    /// field. If multiple default text responses exist, they will be concatenated
    /// when generating audio. If no default platform text responses exist, the
    /// generated audio content will be empty.
    ///
    /// In some scenarios, multiple output audio fields may be present in the
    /// response structure. In these cases, only the top-most-level audio output
    /// has content.
    ///
    /// [google.cloud.dialogflow.cx.v3.QueryResult.response_messages]: crate::model::QueryResult::response_messages
    pub output_audio: ::bytes::Bytes,

    /// The config used by the speech synthesizer to generate the output audio.
    pub output_audio_config: std::option::Option<crate::model::OutputAudioConfig>,

    /// Response type.
    pub response_type: crate::model::detect_intent_response::ResponseType,

    /// Indicates whether the partial response can be cancelled when a later
    /// response arrives. e.g. if the agent specified some music as partial
    /// response, it can be cancelled.
    pub allow_cancellation: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl DetectIntentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [response_id][crate::model::DetectIntentResponse::response_id].
    pub fn set_response_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.response_id = v.into();
        self
    }

    /// Sets the value of [query_result][crate::model::DetectIntentResponse::query_result].
    pub fn set_query_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryResult>,
    {
        self.query_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_result][crate::model::DetectIntentResponse::query_result].
    pub fn set_or_clear_query_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryResult>,
    {
        self.query_result = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_audio][crate::model::DetectIntentResponse::output_audio].
    pub fn set_output_audio<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.output_audio = v.into();
        self
    }

    /// Sets the value of [output_audio_config][crate::model::DetectIntentResponse::output_audio_config].
    pub fn set_output_audio_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.output_audio_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_audio_config][crate::model::DetectIntentResponse::output_audio_config].
    pub fn set_or_clear_output_audio_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.output_audio_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [response_type][crate::model::DetectIntentResponse::response_type].
    pub fn set_response_type<
        T: std::convert::Into<crate::model::detect_intent_response::ResponseType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response_type = v.into();
        self
    }

    /// Sets the value of [allow_cancellation][crate::model::DetectIntentResponse::allow_cancellation].
    pub fn set_allow_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_cancellation = v.into();
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for DetectIntentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DetectIntentResponse"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DetectIntentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __response_id,
            __query_result,
            __output_audio,
            __output_audio_config,
            __response_type,
            __allow_cancellation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DetectIntentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "responseId" => Ok(__FieldTag::__response_id),
                            "response_id" => Ok(__FieldTag::__response_id),
                            "queryResult" => Ok(__FieldTag::__query_result),
                            "query_result" => Ok(__FieldTag::__query_result),
                            "outputAudio" => Ok(__FieldTag::__output_audio),
                            "output_audio" => Ok(__FieldTag::__output_audio),
                            "outputAudioConfig" => Ok(__FieldTag::__output_audio_config),
                            "output_audio_config" => Ok(__FieldTag::__output_audio_config),
                            "responseType" => Ok(__FieldTag::__response_type),
                            "response_type" => Ok(__FieldTag::__response_type),
                            "allowCancellation" => Ok(__FieldTag::__allow_cancellation),
                            "allow_cancellation" => Ok(__FieldTag::__allow_cancellation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DetectIntentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DetectIntentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__response_id => {
                            if !fields.insert(__FieldTag::__response_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_id",
                                ));
                            }
                            result.response_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_result => {
                            if !fields.insert(__FieldTag::__query_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_result",
                                ));
                            }
                            result.query_result =
                                map.next_value::<std::option::Option<crate::model::QueryResult>>()?;
                        }
                        __FieldTag::__output_audio => {
                            if !fields.insert(__FieldTag::__output_audio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_audio",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.output_audio = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__output_audio_config => {
                            if !fields.insert(__FieldTag::__output_audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_audio_config",
                                ));
                            }
                            result.output_audio_config = map
                                .next_value::<std::option::Option<crate::model::OutputAudioConfig>>(
                                )?;
                        }
                        __FieldTag::__response_type => {
                            if !fields.insert(__FieldTag::__response_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_type",
                                ));
                            }
                            result.response_type = map
                                .next_value::<std::option::Option<
                                    crate::model::detect_intent_response::ResponseType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_cancellation => {
                            if !fields.insert(__FieldTag::__allow_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_cancellation",
                                ));
                            }
                            result.allow_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for DetectIntentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.response_id.is_empty() {
            state.serialize_entry("responseId", &self.response_id)?;
        }
        if self.query_result.is_some() {
            state.serialize_entry("queryResult", &self.query_result)?;
        }
        if !self.output_audio.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("outputAudio", &__With(&self.output_audio))?;
        }
        if self.output_audio_config.is_some() {
            state.serialize_entry("outputAudioConfig", &self.output_audio_config)?;
        }
        if !wkt::internal::is_default(&self.response_type) {
            state.serialize_entry("responseType", &self.response_type)?;
        }
        if !wkt::internal::is_default(&self.allow_cancellation) {
            state.serialize_entry("allowCancellation", &self.allow_cancellation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DetectIntentResponse].
#[cfg(feature = "sessions")]
pub mod detect_intent_response {
    #[allow(unused_imports)]
    use super::*;

    /// Represents different DetectIntentResponse types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "sessions")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ResponseType {
        /// Not specified. This should never happen.
        Unspecified,
        /// Partial response. e.g. Aggregated responses in a Fulfillment that enables
        /// `return_partial_response` can be returned as partial response.
        /// WARNING: partial response is not eligible for barge-in.
        Partial,
        /// Final response.
        Final,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ResponseType::value] or
        /// [ResponseType::name].
        UnknownValue(response_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "sessions")]
    pub mod response_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "sessions")]
    impl ResponseType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Partial => std::option::Option::Some(1),
                Self::Final => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESPONSE_TYPE_UNSPECIFIED"),
                Self::Partial => std::option::Option::Some("PARTIAL"),
                Self::Final => std::option::Option::Some("FINAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "sessions")]
    impl std::default::Default for ResponseType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "sessions")]
    impl std::fmt::Display for ResponseType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "sessions")]
    impl std::convert::From<i32> for ResponseType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Partial,
                2 => Self::Final,
                _ => Self::UnknownValue(response_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "sessions")]
    impl std::convert::From<&str> for ResponseType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESPONSE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PARTIAL" => Self::Partial,
                "FINAL" => Self::Final,
                _ => Self::UnknownValue(response_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "sessions")]
    impl serde::ser::Serialize for ResponseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Partial => serializer.serialize_i32(1),
                Self::Final => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "sessions")]
    impl<'de> serde::de::Deserialize<'de> for ResponseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResponseType>::new(
                ".google.cloud.dialogflow.cx.v3.DetectIntentResponse.ResponseType",
            ))
        }
    }
}

/// The top-level message sent by the client to the
/// [Sessions.StreamingDetectIntent][google.cloud.dialogflow.cx.v3.Sessions.StreamingDetectIntent]
/// method.
///
/// Multiple request messages should be sent in order:
///
/// . The first message must contain
///   [session][google.cloud.dialogflow.cx.v3.StreamingDetectIntentRequest.session],
///   [query_input][google.cloud.dialogflow.cx.v3.StreamingDetectIntentRequest.query_input]
///   plus optionally
///   [query_params][google.cloud.dialogflow.cx.v3.StreamingDetectIntentRequest.query_params].
///   If the client wants to receive an audio response, it should also contain
///   [output_audio_config][google.cloud.dialogflow.cx.v3.StreamingDetectIntentRequest.output_audio_config].
///
/// . If
///   [query_input][google.cloud.dialogflow.cx.v3.StreamingDetectIntentRequest.query_input]
///   was set to
///   [query_input.audio.config][google.cloud.dialogflow.cx.v3.AudioInput.config],
///   all subsequent messages must contain
///   [query_input.audio.audio][google.cloud.dialogflow.cx.v3.AudioInput.audio]
///   to continue with Speech recognition. If you decide to rather detect an
///   intent from text input after you already started Speech recognition,
///   please send a message with
///   [query_input.text][google.cloud.dialogflow.cx.v3.QueryInput.text].
///
/// . However, note that:
///
///   * Dialogflow will bill you for the audio duration so far.
///   * Dialogflow discards all Speech recognition results in favor of the
///     input text.
///   * Dialogflow will use the language code from the first message.
///
/// After you sent all input, you must half-close or abort the request stream.
///
/// [google.cloud.dialogflow.cx.v3.AudioInput.audio]: crate::model::AudioInput::audio
/// [google.cloud.dialogflow.cx.v3.AudioInput.config]: crate::model::AudioInput::config
/// [google.cloud.dialogflow.cx.v3.QueryInput.text]: crate::model::QueryInput::input
/// [google.cloud.dialogflow.cx.v3.StreamingDetectIntentRequest.output_audio_config]: crate::model::StreamingDetectIntentRequest::output_audio_config
/// [google.cloud.dialogflow.cx.v3.StreamingDetectIntentRequest.query_input]: crate::model::StreamingDetectIntentRequest::query_input
/// [google.cloud.dialogflow.cx.v3.StreamingDetectIntentRequest.query_params]: crate::model::StreamingDetectIntentRequest::query_params
/// [google.cloud.dialogflow.cx.v3.StreamingDetectIntentRequest.session]: crate::model::StreamingDetectIntentRequest::session
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingDetectIntentRequest {
    /// The name of the session this query is sent to.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/sessions/<SessionID>`
    /// or
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>/sessions/<SessionID>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment.
    /// It's up to the API caller to choose an appropriate `Session ID`. It can be
    /// a random number or some type of session identifiers (preferably hashed).
    /// The length of the `Session ID` must not exceed 36 characters.
    /// Note: session must be set in the first request.
    ///
    /// For more information, see the [sessions
    /// guide](https://cloud.google.com/dialogflow/cx/docs/concept/session).
    ///
    /// Note: Always use agent versions for production traffic.
    /// See [Versions and
    /// environments](https://cloud.google.com/dialogflow/cx/docs/concept/version).
    pub session: std::string::String,

    /// The parameters of this query.
    pub query_params: std::option::Option<crate::model::QueryParameters>,

    /// Required. The input specification.
    pub query_input: std::option::Option<crate::model::QueryInput>,

    /// Instructs the speech synthesizer how to generate the output audio.
    pub output_audio_config: std::option::Option<crate::model::OutputAudioConfig>,

    /// Enable partial detect intent response. If this flag is not enabled,
    /// response stream still contains only one final `DetectIntentResponse` even
    /// if some `Fulfillment`s in the agent have been configured to return partial
    /// responses.
    pub enable_partial_response: bool,

    /// If true, `StreamingDetectIntentResponse.debugging_info` will get populated.
    pub enable_debugging_info: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl StreamingDetectIntentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session][crate::model::StreamingDetectIntentRequest::session].
    pub fn set_session<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session = v.into();
        self
    }

    /// Sets the value of [query_params][crate::model::StreamingDetectIntentRequest::query_params].
    pub fn set_query_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameters>,
    {
        self.query_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_params][crate::model::StreamingDetectIntentRequest::query_params].
    pub fn set_or_clear_query_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameters>,
    {
        self.query_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query_input][crate::model::StreamingDetectIntentRequest::query_input].
    pub fn set_query_input<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryInput>,
    {
        self.query_input = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_input][crate::model::StreamingDetectIntentRequest::query_input].
    pub fn set_or_clear_query_input<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryInput>,
    {
        self.query_input = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_audio_config][crate::model::StreamingDetectIntentRequest::output_audio_config].
    pub fn set_output_audio_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.output_audio_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_audio_config][crate::model::StreamingDetectIntentRequest::output_audio_config].
    pub fn set_or_clear_output_audio_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.output_audio_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_partial_response][crate::model::StreamingDetectIntentRequest::enable_partial_response].
    pub fn set_enable_partial_response<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_partial_response = v.into();
        self
    }

    /// Sets the value of [enable_debugging_info][crate::model::StreamingDetectIntentRequest::enable_debugging_info].
    pub fn set_enable_debugging_info<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_debugging_info = v.into();
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for StreamingDetectIntentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.StreamingDetectIntentRequest"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingDetectIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session,
            __query_params,
            __query_input,
            __output_audio_config,
            __enable_partial_response,
            __enable_debugging_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingDetectIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "session" => Ok(__FieldTag::__session),
                            "queryParams" => Ok(__FieldTag::__query_params),
                            "query_params" => Ok(__FieldTag::__query_params),
                            "queryInput" => Ok(__FieldTag::__query_input),
                            "query_input" => Ok(__FieldTag::__query_input),
                            "outputAudioConfig" => Ok(__FieldTag::__output_audio_config),
                            "output_audio_config" => Ok(__FieldTag::__output_audio_config),
                            "enablePartialResponse" => Ok(__FieldTag::__enable_partial_response),
                            "enable_partial_response" => Ok(__FieldTag::__enable_partial_response),
                            "enableDebuggingInfo" => Ok(__FieldTag::__enable_debugging_info),
                            "enable_debugging_info" => Ok(__FieldTag::__enable_debugging_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingDetectIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingDetectIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session => {
                            if !fields.insert(__FieldTag::__session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session",
                                ));
                            }
                            result.session = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_params => {
                            if !fields.insert(__FieldTag::__query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_params",
                                ));
                            }
                            result.query_params = map
                                .next_value::<std::option::Option<crate::model::QueryParameters>>(
                                )?;
                        }
                        __FieldTag::__query_input => {
                            if !fields.insert(__FieldTag::__query_input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_input",
                                ));
                            }
                            result.query_input =
                                map.next_value::<std::option::Option<crate::model::QueryInput>>()?;
                        }
                        __FieldTag::__output_audio_config => {
                            if !fields.insert(__FieldTag::__output_audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_audio_config",
                                ));
                            }
                            result.output_audio_config = map
                                .next_value::<std::option::Option<crate::model::OutputAudioConfig>>(
                                )?;
                        }
                        __FieldTag::__enable_partial_response => {
                            if !fields.insert(__FieldTag::__enable_partial_response) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_partial_response",
                                ));
                            }
                            result.enable_partial_response = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_debugging_info => {
                            if !fields.insert(__FieldTag::__enable_debugging_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_debugging_info",
                                ));
                            }
                            result.enable_debugging_info = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for StreamingDetectIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if self.query_params.is_some() {
            state.serialize_entry("queryParams", &self.query_params)?;
        }
        if self.query_input.is_some() {
            state.serialize_entry("queryInput", &self.query_input)?;
        }
        if self.output_audio_config.is_some() {
            state.serialize_entry("outputAudioConfig", &self.output_audio_config)?;
        }
        if !wkt::internal::is_default(&self.enable_partial_response) {
            state.serialize_entry("enablePartialResponse", &self.enable_partial_response)?;
        }
        if !wkt::internal::is_default(&self.enable_debugging_info) {
            state.serialize_entry("enableDebuggingInfo", &self.enable_debugging_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Cloud conversation info for easier debugging.
/// It will get populated in `StreamingDetectIntentResponse` or
/// `StreamingAnalyzeContentResponse` when the flag `enable_debugging_info` is
/// set to true in corresponding requests.
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudConversationDebuggingInfo {
    /// Number of input audio data chunks in streaming requests.
    pub audio_data_chunks: i32,

    /// Time offset of the end of speech utterance relative to the
    /// beginning of the first audio chunk.
    pub result_end_time_offset: std::option::Option<wkt::Duration>,

    /// Duration of first audio chunk.
    pub first_audio_duration: std::option::Option<wkt::Duration>,

    /// Whether client used single utterance mode.
    pub single_utterance: bool,

    /// Time offsets of the speech partial results relative to the beginning of
    /// the stream.
    pub speech_partial_results_end_times: std::vec::Vec<wkt::Duration>,

    /// Time offsets of the speech final results (is_final=true) relative to the
    /// beginning of the stream.
    pub speech_final_results_end_times: std::vec::Vec<wkt::Duration>,

    /// Total number of partial responses.
    pub partial_responses: i32,

    /// Time offset of Speaker ID stream close time relative to the Speech stream
    /// close time in milliseconds. Only meaningful for conversations involving
    /// passive verification.
    pub speaker_id_passive_latency_ms_offset: i32,

    /// Whether a barge-in event is triggered in this request.
    pub bargein_event_triggered: bool,

    /// Whether speech uses single utterance mode.
    pub speech_single_utterance: bool,

    /// Time offsets of the DTMF partial results relative to the beginning of
    /// the stream.
    pub dtmf_partial_results_times: std::vec::Vec<wkt::Duration>,

    /// Time offsets of the DTMF final results relative to the beginning of
    /// the stream.
    pub dtmf_final_results_times: std::vec::Vec<wkt::Duration>,

    /// Time offset of the end-of-single-utterance signal relative to the
    /// beginning of the stream.
    pub single_utterance_end_time_offset: std::option::Option<wkt::Duration>,

    /// No speech timeout settings for the stream.
    pub no_speech_timeout: std::option::Option<wkt::Duration>,

    /// Speech endpointing timeout settings for the stream.
    pub endpointing_timeout: std::option::Option<wkt::Duration>,

    /// Whether the streaming terminates with an injected text query.
    pub is_input_text: bool,

    /// Client half close time in terms of input audio duration.
    pub client_half_close_time_offset: std::option::Option<wkt::Duration>,

    /// Client half close time in terms of API streaming duration.
    pub client_half_close_streaming_time_offset: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl CloudConversationDebuggingInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audio_data_chunks][crate::model::CloudConversationDebuggingInfo::audio_data_chunks].
    pub fn set_audio_data_chunks<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.audio_data_chunks = v.into();
        self
    }

    /// Sets the value of [result_end_time_offset][crate::model::CloudConversationDebuggingInfo::result_end_time_offset].
    pub fn set_result_end_time_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.result_end_time_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [result_end_time_offset][crate::model::CloudConversationDebuggingInfo::result_end_time_offset].
    pub fn set_or_clear_result_end_time_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.result_end_time_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [first_audio_duration][crate::model::CloudConversationDebuggingInfo::first_audio_duration].
    pub fn set_first_audio_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.first_audio_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [first_audio_duration][crate::model::CloudConversationDebuggingInfo::first_audio_duration].
    pub fn set_or_clear_first_audio_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.first_audio_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [single_utterance][crate::model::CloudConversationDebuggingInfo::single_utterance].
    pub fn set_single_utterance<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.single_utterance = v.into();
        self
    }

    /// Sets the value of [speech_partial_results_end_times][crate::model::CloudConversationDebuggingInfo::speech_partial_results_end_times].
    pub fn set_speech_partial_results_end_times<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Duration>,
    {
        use std::iter::Iterator;
        self.speech_partial_results_end_times = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [speech_final_results_end_times][crate::model::CloudConversationDebuggingInfo::speech_final_results_end_times].
    pub fn set_speech_final_results_end_times<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Duration>,
    {
        use std::iter::Iterator;
        self.speech_final_results_end_times = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [partial_responses][crate::model::CloudConversationDebuggingInfo::partial_responses].
    pub fn set_partial_responses<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.partial_responses = v.into();
        self
    }

    /// Sets the value of [speaker_id_passive_latency_ms_offset][crate::model::CloudConversationDebuggingInfo::speaker_id_passive_latency_ms_offset].
    pub fn set_speaker_id_passive_latency_ms_offset<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.speaker_id_passive_latency_ms_offset = v.into();
        self
    }

    /// Sets the value of [bargein_event_triggered][crate::model::CloudConversationDebuggingInfo::bargein_event_triggered].
    pub fn set_bargein_event_triggered<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.bargein_event_triggered = v.into();
        self
    }

    /// Sets the value of [speech_single_utterance][crate::model::CloudConversationDebuggingInfo::speech_single_utterance].
    pub fn set_speech_single_utterance<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.speech_single_utterance = v.into();
        self
    }

    /// Sets the value of [dtmf_partial_results_times][crate::model::CloudConversationDebuggingInfo::dtmf_partial_results_times].
    pub fn set_dtmf_partial_results_times<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Duration>,
    {
        use std::iter::Iterator;
        self.dtmf_partial_results_times = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dtmf_final_results_times][crate::model::CloudConversationDebuggingInfo::dtmf_final_results_times].
    pub fn set_dtmf_final_results_times<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Duration>,
    {
        use std::iter::Iterator;
        self.dtmf_final_results_times = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [single_utterance_end_time_offset][crate::model::CloudConversationDebuggingInfo::single_utterance_end_time_offset].
    pub fn set_single_utterance_end_time_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.single_utterance_end_time_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [single_utterance_end_time_offset][crate::model::CloudConversationDebuggingInfo::single_utterance_end_time_offset].
    pub fn set_or_clear_single_utterance_end_time_offset<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.single_utterance_end_time_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [no_speech_timeout][crate::model::CloudConversationDebuggingInfo::no_speech_timeout].
    pub fn set_no_speech_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.no_speech_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [no_speech_timeout][crate::model::CloudConversationDebuggingInfo::no_speech_timeout].
    pub fn set_or_clear_no_speech_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.no_speech_timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [endpointing_timeout][crate::model::CloudConversationDebuggingInfo::endpointing_timeout].
    pub fn set_endpointing_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.endpointing_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [endpointing_timeout][crate::model::CloudConversationDebuggingInfo::endpointing_timeout].
    pub fn set_or_clear_endpointing_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.endpointing_timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [is_input_text][crate::model::CloudConversationDebuggingInfo::is_input_text].
    pub fn set_is_input_text<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_input_text = v.into();
        self
    }

    /// Sets the value of [client_half_close_time_offset][crate::model::CloudConversationDebuggingInfo::client_half_close_time_offset].
    pub fn set_client_half_close_time_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.client_half_close_time_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_half_close_time_offset][crate::model::CloudConversationDebuggingInfo::client_half_close_time_offset].
    pub fn set_or_clear_client_half_close_time_offset<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.client_half_close_time_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [client_half_close_streaming_time_offset][crate::model::CloudConversationDebuggingInfo::client_half_close_streaming_time_offset].
    pub fn set_client_half_close_streaming_time_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.client_half_close_streaming_time_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_half_close_streaming_time_offset][crate::model::CloudConversationDebuggingInfo::client_half_close_streaming_time_offset].
    pub fn set_or_clear_client_half_close_streaming_time_offset<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.client_half_close_streaming_time_offset = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for CloudConversationDebuggingInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CloudConversationDebuggingInfo"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudConversationDebuggingInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_data_chunks,
            __result_end_time_offset,
            __first_audio_duration,
            __single_utterance,
            __speech_partial_results_end_times,
            __speech_final_results_end_times,
            __partial_responses,
            __speaker_id_passive_latency_ms_offset,
            __bargein_event_triggered,
            __speech_single_utterance,
            __dtmf_partial_results_times,
            __dtmf_final_results_times,
            __single_utterance_end_time_offset,
            __no_speech_timeout,
            __endpointing_timeout,
            __is_input_text,
            __client_half_close_time_offset,
            __client_half_close_streaming_time_offset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudConversationDebuggingInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioDataChunks" => Ok(__FieldTag::__audio_data_chunks),
                            "audio_data_chunks" => Ok(__FieldTag::__audio_data_chunks),
                            "resultEndTimeOffset" => Ok(__FieldTag::__result_end_time_offset),
                            "result_end_time_offset" => Ok(__FieldTag::__result_end_time_offset),
                            "firstAudioDuration" => Ok(__FieldTag::__first_audio_duration),
                            "first_audio_duration" => Ok(__FieldTag::__first_audio_duration),
                            "singleUtterance" => Ok(__FieldTag::__single_utterance),
                            "single_utterance" => Ok(__FieldTag::__single_utterance),
                            "speechPartialResultsEndTimes" => {
                                Ok(__FieldTag::__speech_partial_results_end_times)
                            }
                            "speech_partial_results_end_times" => {
                                Ok(__FieldTag::__speech_partial_results_end_times)
                            }
                            "speechFinalResultsEndTimes" => {
                                Ok(__FieldTag::__speech_final_results_end_times)
                            }
                            "speech_final_results_end_times" => {
                                Ok(__FieldTag::__speech_final_results_end_times)
                            }
                            "partialResponses" => Ok(__FieldTag::__partial_responses),
                            "partial_responses" => Ok(__FieldTag::__partial_responses),
                            "speakerIdPassiveLatencyMsOffset" => {
                                Ok(__FieldTag::__speaker_id_passive_latency_ms_offset)
                            }
                            "speaker_id_passive_latency_ms_offset" => {
                                Ok(__FieldTag::__speaker_id_passive_latency_ms_offset)
                            }
                            "bargeinEventTriggered" => Ok(__FieldTag::__bargein_event_triggered),
                            "bargein_event_triggered" => Ok(__FieldTag::__bargein_event_triggered),
                            "speechSingleUtterance" => Ok(__FieldTag::__speech_single_utterance),
                            "speech_single_utterance" => Ok(__FieldTag::__speech_single_utterance),
                            "dtmfPartialResultsTimes" => {
                                Ok(__FieldTag::__dtmf_partial_results_times)
                            }
                            "dtmf_partial_results_times" => {
                                Ok(__FieldTag::__dtmf_partial_results_times)
                            }
                            "dtmfFinalResultsTimes" => Ok(__FieldTag::__dtmf_final_results_times),
                            "dtmf_final_results_times" => {
                                Ok(__FieldTag::__dtmf_final_results_times)
                            }
                            "singleUtteranceEndTimeOffset" => {
                                Ok(__FieldTag::__single_utterance_end_time_offset)
                            }
                            "single_utterance_end_time_offset" => {
                                Ok(__FieldTag::__single_utterance_end_time_offset)
                            }
                            "noSpeechTimeout" => Ok(__FieldTag::__no_speech_timeout),
                            "no_speech_timeout" => Ok(__FieldTag::__no_speech_timeout),
                            "endpointingTimeout" => Ok(__FieldTag::__endpointing_timeout),
                            "endpointing_timeout" => Ok(__FieldTag::__endpointing_timeout),
                            "isInputText" => Ok(__FieldTag::__is_input_text),
                            "is_input_text" => Ok(__FieldTag::__is_input_text),
                            "clientHalfCloseTimeOffset" => {
                                Ok(__FieldTag::__client_half_close_time_offset)
                            }
                            "client_half_close_time_offset" => {
                                Ok(__FieldTag::__client_half_close_time_offset)
                            }
                            "clientHalfCloseStreamingTimeOffset" => {
                                Ok(__FieldTag::__client_half_close_streaming_time_offset)
                            }
                            "client_half_close_streaming_time_offset" => {
                                Ok(__FieldTag::__client_half_close_streaming_time_offset)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudConversationDebuggingInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudConversationDebuggingInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_data_chunks => {
                            if !fields.insert(__FieldTag::__audio_data_chunks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_data_chunks",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.audio_data_chunks =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__result_end_time_offset => {
                            if !fields.insert(__FieldTag::__result_end_time_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result_end_time_offset",
                                ));
                            }
                            result.result_end_time_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__first_audio_duration => {
                            if !fields.insert(__FieldTag::__first_audio_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for first_audio_duration",
                                ));
                            }
                            result.first_audio_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__single_utterance => {
                            if !fields.insert(__FieldTag::__single_utterance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_utterance",
                                ));
                            }
                            result.single_utterance = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__speech_partial_results_end_times => {
                            if !fields.insert(__FieldTag::__speech_partial_results_end_times) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_partial_results_end_times",
                                ));
                            }
                            result.speech_partial_results_end_times = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Duration>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__speech_final_results_end_times => {
                            if !fields.insert(__FieldTag::__speech_final_results_end_times) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_final_results_end_times",
                                ));
                            }
                            result.speech_final_results_end_times = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Duration>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__partial_responses => {
                            if !fields.insert(__FieldTag::__partial_responses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partial_responses",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.partial_responses =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__speaker_id_passive_latency_ms_offset => {
                            if !fields.insert(__FieldTag::__speaker_id_passive_latency_ms_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speaker_id_passive_latency_ms_offset",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.speaker_id_passive_latency_ms_offset =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bargein_event_triggered => {
                            if !fields.insert(__FieldTag::__bargein_event_triggered) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bargein_event_triggered",
                                ));
                            }
                            result.bargein_event_triggered = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__speech_single_utterance => {
                            if !fields.insert(__FieldTag::__speech_single_utterance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_single_utterance",
                                ));
                            }
                            result.speech_single_utterance = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dtmf_partial_results_times => {
                            if !fields.insert(__FieldTag::__dtmf_partial_results_times) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dtmf_partial_results_times",
                                ));
                            }
                            result.dtmf_partial_results_times = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Duration>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dtmf_final_results_times => {
                            if !fields.insert(__FieldTag::__dtmf_final_results_times) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dtmf_final_results_times",
                                ));
                            }
                            result.dtmf_final_results_times = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Duration>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__single_utterance_end_time_offset => {
                            if !fields.insert(__FieldTag::__single_utterance_end_time_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_utterance_end_time_offset",
                                ));
                            }
                            result.single_utterance_end_time_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__no_speech_timeout => {
                            if !fields.insert(__FieldTag::__no_speech_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for no_speech_timeout",
                                ));
                            }
                            result.no_speech_timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__endpointing_timeout => {
                            if !fields.insert(__FieldTag::__endpointing_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpointing_timeout",
                                ));
                            }
                            result.endpointing_timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__is_input_text => {
                            if !fields.insert(__FieldTag::__is_input_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_input_text",
                                ));
                            }
                            result.is_input_text = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_half_close_time_offset => {
                            if !fields.insert(__FieldTag::__client_half_close_time_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_half_close_time_offset",
                                ));
                            }
                            result.client_half_close_time_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__client_half_close_streaming_time_offset => {
                            if !fields.insert(__FieldTag::__client_half_close_streaming_time_offset)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_half_close_streaming_time_offset",
                                ));
                            }
                            result.client_half_close_streaming_time_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for CloudConversationDebuggingInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.audio_data_chunks) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("audioDataChunks", &__With(&self.audio_data_chunks))?;
        }
        if self.result_end_time_offset.is_some() {
            state.serialize_entry("resultEndTimeOffset", &self.result_end_time_offset)?;
        }
        if self.first_audio_duration.is_some() {
            state.serialize_entry("firstAudioDuration", &self.first_audio_duration)?;
        }
        if !wkt::internal::is_default(&self.single_utterance) {
            state.serialize_entry("singleUtterance", &self.single_utterance)?;
        }
        if !self.speech_partial_results_end_times.is_empty() {
            state.serialize_entry(
                "speechPartialResultsEndTimes",
                &self.speech_partial_results_end_times,
            )?;
        }
        if !self.speech_final_results_end_times.is_empty() {
            state.serialize_entry(
                "speechFinalResultsEndTimes",
                &self.speech_final_results_end_times,
            )?;
        }
        if !wkt::internal::is_default(&self.partial_responses) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("partialResponses", &__With(&self.partial_responses))?;
        }
        if !wkt::internal::is_default(&self.speaker_id_passive_latency_ms_offset) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "speakerIdPassiveLatencyMsOffset",
                &__With(&self.speaker_id_passive_latency_ms_offset),
            )?;
        }
        if !wkt::internal::is_default(&self.bargein_event_triggered) {
            state.serialize_entry("bargeinEventTriggered", &self.bargein_event_triggered)?;
        }
        if !wkt::internal::is_default(&self.speech_single_utterance) {
            state.serialize_entry("speechSingleUtterance", &self.speech_single_utterance)?;
        }
        if !self.dtmf_partial_results_times.is_empty() {
            state.serialize_entry("dtmfPartialResultsTimes", &self.dtmf_partial_results_times)?;
        }
        if !self.dtmf_final_results_times.is_empty() {
            state.serialize_entry("dtmfFinalResultsTimes", &self.dtmf_final_results_times)?;
        }
        if self.single_utterance_end_time_offset.is_some() {
            state.serialize_entry(
                "singleUtteranceEndTimeOffset",
                &self.single_utterance_end_time_offset,
            )?;
        }
        if self.no_speech_timeout.is_some() {
            state.serialize_entry("noSpeechTimeout", &self.no_speech_timeout)?;
        }
        if self.endpointing_timeout.is_some() {
            state.serialize_entry("endpointingTimeout", &self.endpointing_timeout)?;
        }
        if !wkt::internal::is_default(&self.is_input_text) {
            state.serialize_entry("isInputText", &self.is_input_text)?;
        }
        if self.client_half_close_time_offset.is_some() {
            state.serialize_entry(
                "clientHalfCloseTimeOffset",
                &self.client_half_close_time_offset,
            )?;
        }
        if self.client_half_close_streaming_time_offset.is_some() {
            state.serialize_entry(
                "clientHalfCloseStreamingTimeOffset",
                &self.client_half_close_streaming_time_offset,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The top-level message returned from the
/// [StreamingDetectIntent][google.cloud.dialogflow.cx.v3.Sessions.StreamingDetectIntent]
/// method.
///
/// Multiple response messages can be returned in order:
///
/// * If the `StreamingDetectIntentRequest.query_input.audio` field was
///   set, the first M messages contain `recognition_result`.
///   Each `recognition_result` represents a more complete transcript of what
///   the user said. The last `recognition_result` has `is_final` set to
///   `true`.
///
/// * If the `StreamingDetectIntentRequest.enable_partial_response` field was
///   true, the `detect_intent_response` field is populated for each
///   of the following N responses, where 0 <= N <= 5.
///   These responses set the
///   [DetectIntentResponse.response_type][google.cloud.dialogflow.cx.v3.DetectIntentResponse.response_type]
///   field to `PARTIAL`.
///
///
/// For the last response message, the `detect_intent_response` is fully
/// populated, and
/// [DetectIntentResponse.response_type][google.cloud.dialogflow.cx.v3.DetectIntentResponse.response_type]
/// is set to `FINAL`.
///
/// [google.cloud.dialogflow.cx.v3.DetectIntentResponse.response_type]: crate::model::DetectIntentResponse::response_type
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingDetectIntentResponse {
    /// Debugging info that would get populated when
    /// `StreamingDetectIntentRequest.enable_debugging_info` is set to true.
    pub debugging_info: std::option::Option<crate::model::CloudConversationDebuggingInfo>,

    /// The output response.
    pub response: std::option::Option<crate::model::streaming_detect_intent_response::Response>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl StreamingDetectIntentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [debugging_info][crate::model::StreamingDetectIntentResponse::debugging_info].
    pub fn set_debugging_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudConversationDebuggingInfo>,
    {
        self.debugging_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [debugging_info][crate::model::StreamingDetectIntentResponse::debugging_info].
    pub fn set_or_clear_debugging_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudConversationDebuggingInfo>,
    {
        self.debugging_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [response][crate::model::StreamingDetectIntentResponse::response].
    ///
    /// Note that all the setters affecting `response` are mutually
    /// exclusive.
    pub fn set_response<
        T: std::convert::Into<
                std::option::Option<crate::model::streaming_detect_intent_response::Response>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response = v.into();
        self
    }

    /// The value of [response][crate::model::StreamingDetectIntentResponse::response]
    /// if it holds a `RecognitionResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn recognition_result(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StreamingRecognitionResult>> {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::streaming_detect_intent_response::Response::RecognitionResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [response][crate::model::StreamingDetectIntentResponse::response]
    /// to hold a `RecognitionResult`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_recognition_result<
        T: std::convert::Into<std::boxed::Box<crate::model::StreamingRecognitionResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response = std::option::Option::Some(
            crate::model::streaming_detect_intent_response::Response::RecognitionResult(v.into()),
        );
        self
    }

    /// The value of [response][crate::model::StreamingDetectIntentResponse::response]
    /// if it holds a `DetectIntentResponse`, `None` if the field is not set or
    /// holds a different branch.
    pub fn detect_intent_response(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DetectIntentResponse>> {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::streaming_detect_intent_response::Response::DetectIntentResponse(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [response][crate::model::StreamingDetectIntentResponse::response]
    /// to hold a `DetectIntentResponse`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_detect_intent_response<
        T: std::convert::Into<std::boxed::Box<crate::model::DetectIntentResponse>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response = std::option::Option::Some(
            crate::model::streaming_detect_intent_response::Response::DetectIntentResponse(
                v.into(),
            ),
        );
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for StreamingDetectIntentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.StreamingDetectIntentResponse"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingDetectIntentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __recognition_result,
            __detect_intent_response,
            __debugging_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingDetectIntentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "recognitionResult" => Ok(__FieldTag::__recognition_result),
                            "recognition_result" => Ok(__FieldTag::__recognition_result),
                            "detectIntentResponse" => Ok(__FieldTag::__detect_intent_response),
                            "detect_intent_response" => Ok(__FieldTag::__detect_intent_response),
                            "debuggingInfo" => Ok(__FieldTag::__debugging_info),
                            "debugging_info" => Ok(__FieldTag::__debugging_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingDetectIntentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingDetectIntentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__recognition_result => {
                            if !fields.insert(__FieldTag::__recognition_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recognition_result",
                                ));
                            }
                            if result.response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `response`, a oneof with full ID .google.cloud.dialogflow.cx.v3.StreamingDetectIntentResponse.recognition_result, latest field was recognitionResult",
                                ));
                            }
                            result.response = std::option::Option::Some(
                                crate::model::streaming_detect_intent_response::Response::RecognitionResult(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StreamingRecognitionResult>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__detect_intent_response => {
                            if !fields.insert(__FieldTag::__detect_intent_response) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detect_intent_response",
                                ));
                            }
                            if result.response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `response`, a oneof with full ID .google.cloud.dialogflow.cx.v3.StreamingDetectIntentResponse.detect_intent_response, latest field was detectIntentResponse",
                                ));
                            }
                            result.response = std::option::Option::Some(
                                crate::model::streaming_detect_intent_response::Response::DetectIntentResponse(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DetectIntentResponse>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__debugging_info => {
                            if !fields.insert(__FieldTag::__debugging_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for debugging_info",
                                ));
                            }
                            result.debugging_info =
                                map.next_value::<std::option::Option<
                                    crate::model::CloudConversationDebuggingInfo,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for StreamingDetectIntentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.recognition_result() {
            state.serialize_entry("recognitionResult", value)?;
        }
        if let Some(value) = self.detect_intent_response() {
            state.serialize_entry("detectIntentResponse", value)?;
        }
        if self.debugging_info.is_some() {
            state.serialize_entry("debuggingInfo", &self.debugging_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StreamingDetectIntentResponse].
#[cfg(feature = "sessions")]
pub mod streaming_detect_intent_response {
    #[allow(unused_imports)]
    use super::*;

    /// The output response.
    #[cfg(feature = "sessions")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Response {
        /// The result of speech recognition.
        RecognitionResult(std::boxed::Box<crate::model::StreamingRecognitionResult>),
        /// The response from detect intent.
        DetectIntentResponse(std::boxed::Box<crate::model::DetectIntentResponse>),
    }
}

/// Contains a speech recognition result corresponding to a portion of the audio
/// that is currently being processed or an indication that this is the end
/// of the single requested utterance.
///
/// While end-user audio is being processed, Dialogflow sends a series of
/// results. Each result may contain a `transcript` value. A transcript
/// represents a portion of the utterance. While the recognizer is processing
/// audio, transcript values may be interim values or finalized values.
/// Once a transcript is finalized, the `is_final` value is set to true and
/// processing continues for the next transcript.
///
/// If `StreamingDetectIntentRequest.query_input.audio.config.single_utterance`
/// was true, and the recognizer has completed processing audio,
/// the `message_type` value is set to `END_OF_SINGLE_UTTERANCE and the
/// following (last) result contains the last finalized transcript.
///
/// The complete end-user utterance is determined by concatenating the
/// finalized transcript values received for the series of results.
///
/// In the following example, single utterance is enabled. In the case where
/// single utterance is not enabled, result 7 would not occur.
///
/// ```norust
/// Num | transcript              | message_type            | is_final
/// --- | ----------------------- | ----------------------- | --------
/// 1   | "tube"                  | TRANSCRIPT              | false
/// 2   | "to be a"               | TRANSCRIPT              | false
/// 3   | "to be"                 | TRANSCRIPT              | false
/// 4   | "to be or not to be"    | TRANSCRIPT              | true
/// 5   | "that's"                | TRANSCRIPT              | false
/// 6   | "that is                | TRANSCRIPT              | false
/// 7   | unset                   | END_OF_SINGLE_UTTERANCE | unset
/// 8   | " that is the question" | TRANSCRIPT              | true
/// ```
///
/// Concatenating the finalized transcripts with `is_final` set to true,
/// the complete utterance becomes "to be or not to be that is the question".
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingRecognitionResult {
    /// Type of the result message.
    pub message_type: crate::model::streaming_recognition_result::MessageType,

    /// Transcript text representing the words that the user spoke.
    /// Populated if and only if `message_type` = `TRANSCRIPT`.
    pub transcript: std::string::String,

    /// If `false`, the `StreamingRecognitionResult` represents an
    /// interim result that may change. If `true`, the recognizer will not return
    /// any further hypotheses about this piece of the audio. May only be populated
    /// for `message_type` = `TRANSCRIPT`.
    pub is_final: bool,

    /// The Speech confidence between 0.0 and 1.0 for the current portion of audio.
    /// A higher number indicates an estimated greater likelihood that the
    /// recognized words are correct. The default of 0.0 is a sentinel value
    /// indicating that confidence was not set.
    ///
    /// This field is typically only provided if `is_final` is true and you should
    /// not rely on it being accurate or even set.
    pub confidence: f32,

    /// An estimate of the likelihood that the speech recognizer will
    /// not change its guess about this interim recognition result:
    ///
    /// * If the value is unspecified or 0.0, Dialogflow didn't compute the
    ///   stability. In particular, Dialogflow will only provide stability for
    ///   `TRANSCRIPT` results with `is_final = false`.
    /// * Otherwise, the value is in (0.0, 1.0] where 0.0 means completely
    ///   unstable and 1.0 means completely stable.
    pub stability: f32,

    /// Word-specific information for the words recognized by Speech in
    /// [transcript][google.cloud.dialogflow.cx.v3.StreamingRecognitionResult.transcript].
    /// Populated if and only if `message_type` = `TRANSCRIPT` and
    /// [InputAudioConfig.enable_word_info] is set.
    ///
    /// [google.cloud.dialogflow.cx.v3.StreamingRecognitionResult.transcript]: crate::model::StreamingRecognitionResult::transcript
    pub speech_word_info: std::vec::Vec<crate::model::SpeechWordInfo>,

    /// Time offset of the end of this Speech recognition result relative to the
    /// beginning of the audio. Only populated for `message_type` =
    /// `TRANSCRIPT`.
    pub speech_end_offset: std::option::Option<wkt::Duration>,

    /// Detected language code for the transcript.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl StreamingRecognitionResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message_type][crate::model::StreamingRecognitionResult::message_type].
    pub fn set_message_type<
        T: std::convert::Into<crate::model::streaming_recognition_result::MessageType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.message_type = v.into();
        self
    }

    /// Sets the value of [transcript][crate::model::StreamingRecognitionResult::transcript].
    pub fn set_transcript<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.transcript = v.into();
        self
    }

    /// Sets the value of [is_final][crate::model::StreamingRecognitionResult::is_final].
    pub fn set_is_final<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_final = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::StreamingRecognitionResult::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [stability][crate::model::StreamingRecognitionResult::stability].
    pub fn set_stability<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.stability = v.into();
        self
    }

    /// Sets the value of [speech_word_info][crate::model::StreamingRecognitionResult::speech_word_info].
    pub fn set_speech_word_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SpeechWordInfo>,
    {
        use std::iter::Iterator;
        self.speech_word_info = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [speech_end_offset][crate::model::StreamingRecognitionResult::speech_end_offset].
    pub fn set_speech_end_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.speech_end_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [speech_end_offset][crate::model::StreamingRecognitionResult::speech_end_offset].
    pub fn set_or_clear_speech_end_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.speech_end_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::StreamingRecognitionResult::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for StreamingRecognitionResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.StreamingRecognitionResult"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingRecognitionResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message_type,
            __transcript,
            __is_final,
            __confidence,
            __stability,
            __speech_word_info,
            __speech_end_offset,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingRecognitionResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "messageType" => Ok(__FieldTag::__message_type),
                            "message_type" => Ok(__FieldTag::__message_type),
                            "transcript" => Ok(__FieldTag::__transcript),
                            "isFinal" => Ok(__FieldTag::__is_final),
                            "is_final" => Ok(__FieldTag::__is_final),
                            "confidence" => Ok(__FieldTag::__confidence),
                            "stability" => Ok(__FieldTag::__stability),
                            "speechWordInfo" => Ok(__FieldTag::__speech_word_info),
                            "speech_word_info" => Ok(__FieldTag::__speech_word_info),
                            "speechEndOffset" => Ok(__FieldTag::__speech_end_offset),
                            "speech_end_offset" => Ok(__FieldTag::__speech_end_offset),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingRecognitionResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingRecognitionResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message_type => {
                            if !fields.insert(__FieldTag::__message_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_type",
                                ));
                            }
                            result.message_type = map
                                .next_value::<std::option::Option<
                                    crate::model::streaming_recognition_result::MessageType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transcript => {
                            if !fields.insert(__FieldTag::__transcript) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transcript",
                                ));
                            }
                            result.transcript = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_final => {
                            if !fields.insert(__FieldTag::__is_final) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_final",
                                ));
                            }
                            result.is_final = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__stability => {
                            if !fields.insert(__FieldTag::__stability) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stability",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.stability = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__speech_word_info => {
                            if !fields.insert(__FieldTag::__speech_word_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_word_info",
                                ));
                            }
                            result.speech_word_info =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SpeechWordInfo>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__speech_end_offset => {
                            if !fields.insert(__FieldTag::__speech_end_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_end_offset",
                                ));
                            }
                            result.speech_end_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for StreamingRecognitionResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.message_type) {
            state.serialize_entry("messageType", &self.message_type)?;
        }
        if !self.transcript.is_empty() {
            state.serialize_entry("transcript", &self.transcript)?;
        }
        if !wkt::internal::is_default(&self.is_final) {
            state.serialize_entry("isFinal", &self.is_final)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !wkt::internal::is_default(&self.stability) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("stability", &__With(&self.stability))?;
        }
        if !self.speech_word_info.is_empty() {
            state.serialize_entry("speechWordInfo", &self.speech_word_info)?;
        }
        if self.speech_end_offset.is_some() {
            state.serialize_entry("speechEndOffset", &self.speech_end_offset)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StreamingRecognitionResult].
#[cfg(feature = "sessions")]
pub mod streaming_recognition_result {
    #[allow(unused_imports)]
    use super::*;

    /// Type of the response message.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "sessions")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MessageType {
        /// Not specified. Should never be used.
        Unspecified,
        /// Message contains a (possibly partial) transcript.
        Transcript,
        /// This event indicates that the server has detected the end of the user's
        /// speech utterance and expects no additional speech. Therefore, the server
        /// will not process additional audio (although it may subsequently return
        /// additional results). The client should stop sending additional audio
        /// data, half-close the gRPC connection, and wait for any additional results
        /// until the server closes the gRPC connection. This message is only sent if
        /// [`single_utterance`][google.cloud.dialogflow.cx.v3.InputAudioConfig.single_utterance]
        /// was set to `true`, and is not used otherwise.
        ///
        /// [google.cloud.dialogflow.cx.v3.InputAudioConfig.single_utterance]: crate::model::InputAudioConfig::single_utterance
        EndOfSingleUtterance,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MessageType::value] or
        /// [MessageType::name].
        UnknownValue(message_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "sessions")]
    pub mod message_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "sessions")]
    impl MessageType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Transcript => std::option::Option::Some(1),
                Self::EndOfSingleUtterance => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MESSAGE_TYPE_UNSPECIFIED"),
                Self::Transcript => std::option::Option::Some("TRANSCRIPT"),
                Self::EndOfSingleUtterance => std::option::Option::Some("END_OF_SINGLE_UTTERANCE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "sessions")]
    impl std::default::Default for MessageType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "sessions")]
    impl std::fmt::Display for MessageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "sessions")]
    impl std::convert::From<i32> for MessageType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Transcript,
                2 => Self::EndOfSingleUtterance,
                _ => Self::UnknownValue(message_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "sessions")]
    impl std::convert::From<&str> for MessageType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MESSAGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "TRANSCRIPT" => Self::Transcript,
                "END_OF_SINGLE_UTTERANCE" => Self::EndOfSingleUtterance,
                _ => Self::UnknownValue(message_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "sessions")]
    impl serde::ser::Serialize for MessageType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Transcript => serializer.serialize_i32(1),
                Self::EndOfSingleUtterance => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "sessions")]
    impl<'de> serde::de::Deserialize<'de> for MessageType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MessageType>::new(
                ".google.cloud.dialogflow.cx.v3.StreamingRecognitionResult.MessageType",
            ))
        }
    }
}

/// Represents the parameters of a conversational query.
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryParameters {
    /// The time zone of this conversational query from the [time zone
    /// database](https://www.iana.org/time-zones), e.g., America/New_York,
    /// Europe/Paris. If not provided, the time zone specified in the agent is
    /// used.
    pub time_zone: std::string::String,

    /// The geo location of this conversational query.
    pub geo_location: std::option::Option<gtype::model::LatLng>,

    /// Additional session entity types to replace or extend developer entity types
    /// with. The entity synonyms apply to all languages and persist for the
    /// session of this query.
    pub session_entity_types: std::vec::Vec<crate::model::SessionEntityType>,

    /// This field can be used to pass custom data into the webhook associated with
    /// the agent. Arbitrary JSON objects are supported.
    /// Some integrations that query a Dialogflow agent may provide additional
    /// information in the payload.
    /// In particular, for the Dialogflow Phone Gateway integration, this field has
    /// the form:
    ///
    /// ```norust
    /// {
    ///  "telephony": {
    ///    "caller_id": "+18558363987"
    ///  }
    /// }
    /// ```
    pub payload: std::option::Option<wkt::Struct>,

    /// Additional parameters to be put into [session
    /// parameters][SessionInfo.parameters]. To remove a
    /// parameter from the session, clients should explicitly set the parameter
    /// value to null.
    ///
    /// You can reference the session parameters in the agent with the following
    /// format: $session.params.parameter-id.
    ///
    /// Depending on your protocol or client library language, this is a
    /// map, associative array, symbol table, dictionary, or JSON object
    /// composed of a collection of (MapKey, MapValue) pairs:
    ///
    /// * MapKey type: string
    /// * MapKey value: parameter name
    /// * MapValue type: If parameter's entity type is a composite entity then use
    ///   map, otherwise, depending on the parameter value type, it could be one of
    ///   string, number, boolean, null, list or map.
    /// * MapValue value: If parameter's entity type is a composite entity then use
    ///   map from composite entity property names to property values, otherwise,
    ///   use parameter value.
    ///
    /// [SessionInfo.parameters]: crate::model::SessionInfo::parameters
    pub parameters: std::option::Option<wkt::Struct>,

    /// The unique identifier of the [page][google.cloud.dialogflow.cx.v3.Page] to
    /// override the [current page][QueryResult.current_page] in the session.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/pages/<PageID>`.
    ///
    /// If `current_page` is specified, the previous state of the session will be
    /// ignored by Dialogflow, including the [previous
    /// page][QueryResult.current_page] and the [previous session
    /// parameters][QueryResult.parameters].
    /// In most cases,
    /// [current_page][google.cloud.dialogflow.cx.v3.QueryParameters.current_page]
    /// and [parameters][google.cloud.dialogflow.cx.v3.QueryParameters.parameters]
    /// should be configured together to direct a session to a specific state.
    ///
    /// [QueryResult.current_page]: crate::model::QueryResult::current_page
    /// [QueryResult.parameters]: crate::model::QueryResult::parameters
    /// [google.cloud.dialogflow.cx.v3.Page]: crate::model::Page
    /// [google.cloud.dialogflow.cx.v3.QueryParameters.current_page]: crate::model::QueryParameters::current_page
    /// [google.cloud.dialogflow.cx.v3.QueryParameters.parameters]: crate::model::QueryParameters::parameters
    pub current_page: std::string::String,

    /// Whether to disable webhook calls for this request.
    pub disable_webhook: bool,

    /// Configures whether sentiment analysis should be performed. If not
    /// provided, sentiment analysis is not performed.
    pub analyze_query_text_sentiment: bool,

    /// This field can be used to pass HTTP headers for a webhook
    /// call. These headers will be sent to webhook along with the headers that
    /// have been configured through Dialogflow web console. The headers defined
    /// within this field will overwrite the headers configured through Dialogflow
    /// console if there is a conflict. Header names are case-insensitive.
    /// Google's specified headers are not allowed. Including: "Host",
    /// "Content-Length", "Connection", "From", "User-Agent", "Accept-Encoding",
    /// "If-Modified-Since", "If-None-Match", "X-Forwarded-For", etc.
    pub webhook_headers: std::collections::HashMap<std::string::String, std::string::String>,

    /// A list of flow versions to override for the request.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/versions/<VersionID>`.
    ///
    /// If version 1 of flow X is included in this list, the traffic of
    /// flow X will go through version 1 regardless of the version configuration in
    /// the environment. Each flow can have at most one version specified in this
    /// list.
    pub flow_versions: std::vec::Vec<std::string::String>,

    /// The channel which this query is for.
    ///
    /// If specified, only the
    /// [ResponseMessage][google.cloud.dialogflow.cx.v3.ResponseMessage] associated
    /// with the channel will be returned. If no
    /// [ResponseMessage][google.cloud.dialogflow.cx.v3.ResponseMessage] is
    /// associated with the channel, it falls back to the
    /// [ResponseMessage][google.cloud.dialogflow.cx.v3.ResponseMessage] with
    /// unspecified channel.
    ///
    /// If unspecified, the
    /// [ResponseMessage][google.cloud.dialogflow.cx.v3.ResponseMessage] with
    /// unspecified channel will be returned.
    ///
    /// [google.cloud.dialogflow.cx.v3.ResponseMessage]: crate::model::ResponseMessage
    pub channel: std::string::String,

    /// Optional. Configure lifetime of the Dialogflow session.
    /// By default, a Dialogflow session remains active and its data is stored for
    /// 30 minutes after the last request is sent for the session.
    /// This value should be no longer than 1 day.
    pub session_ttl: std::option::Option<wkt::Duration>,

    /// Optional. Information about the end-user to improve the relevance and
    /// accuracy of generative answers.
    ///
    /// This will be interpreted and used by a language model, so, for good
    /// results, the data should be self-descriptive, and in a simple structure.
    ///
    /// Example:
    ///
    /// ```norust
    /// {
    ///   "subscription plan": "Business Premium Plus",
    ///   "devices owned": [
    ///     {"model": "Google Pixel 7"},
    ///     {"model": "Google Pixel Tablet"}
    ///   ]
    /// }
    /// ```
    pub end_user_metadata: std::option::Option<wkt::Struct>,

    /// Optional. Search configuration for UCS search queries.
    pub search_config: std::option::Option<crate::model::SearchConfig>,

    /// Optional. If set to true and data stores are involved in serving the
    /// request then
    /// DetectIntentResponse.query_result.data_store_connection_signals
    /// will be filled with data that can help evaluations.
    #[deprecated]
    pub populate_data_store_connection_signals: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl QueryParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_zone][crate::model::QueryParameters::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [geo_location][crate::model::QueryParameters::geo_location].
    pub fn set_geo_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::LatLng>,
    {
        self.geo_location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [geo_location][crate::model::QueryParameters::geo_location].
    pub fn set_or_clear_geo_location<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::LatLng>,
    {
        self.geo_location = v.map(|x| x.into());
        self
    }

    /// Sets the value of [session_entity_types][crate::model::QueryParameters::session_entity_types].
    pub fn set_session_entity_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SessionEntityType>,
    {
        use std::iter::Iterator;
        self.session_entity_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [payload][crate::model::QueryParameters::payload].
    pub fn set_payload<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.payload = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [payload][crate::model::QueryParameters::payload].
    pub fn set_or_clear_payload<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.payload = v.map(|x| x.into());
        self
    }

    /// Sets the value of [parameters][crate::model::QueryParameters::parameters].
    pub fn set_parameters<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.parameters = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [parameters][crate::model::QueryParameters::parameters].
    pub fn set_or_clear_parameters<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.parameters = v.map(|x| x.into());
        self
    }

    /// Sets the value of [current_page][crate::model::QueryParameters::current_page].
    pub fn set_current_page<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.current_page = v.into();
        self
    }

    /// Sets the value of [disable_webhook][crate::model::QueryParameters::disable_webhook].
    pub fn set_disable_webhook<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_webhook = v.into();
        self
    }

    /// Sets the value of [analyze_query_text_sentiment][crate::model::QueryParameters::analyze_query_text_sentiment].
    pub fn set_analyze_query_text_sentiment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.analyze_query_text_sentiment = v.into();
        self
    }

    /// Sets the value of [webhook_headers][crate::model::QueryParameters::webhook_headers].
    pub fn set_webhook_headers<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.webhook_headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [flow_versions][crate::model::QueryParameters::flow_versions].
    pub fn set_flow_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.flow_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [channel][crate::model::QueryParameters::channel].
    pub fn set_channel<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.channel = v.into();
        self
    }

    /// Sets the value of [session_ttl][crate::model::QueryParameters::session_ttl].
    pub fn set_session_ttl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.session_ttl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session_ttl][crate::model::QueryParameters::session_ttl].
    pub fn set_or_clear_session_ttl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.session_ttl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_user_metadata][crate::model::QueryParameters::end_user_metadata].
    pub fn set_end_user_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.end_user_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_user_metadata][crate::model::QueryParameters::end_user_metadata].
    pub fn set_or_clear_end_user_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.end_user_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [search_config][crate::model::QueryParameters::search_config].
    pub fn set_search_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SearchConfig>,
    {
        self.search_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [search_config][crate::model::QueryParameters::search_config].
    pub fn set_or_clear_search_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SearchConfig>,
    {
        self.search_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [populate_data_store_connection_signals][crate::model::QueryParameters::populate_data_store_connection_signals].
    #[deprecated]
    pub fn set_populate_data_store_connection_signals<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.populate_data_store_connection_signals = v.into();
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for QueryParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.QueryParameters"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryParameters {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time_zone,
            __geo_location,
            __session_entity_types,
            __payload,
            __parameters,
            __current_page,
            __disable_webhook,
            __analyze_query_text_sentiment,
            __webhook_headers,
            __flow_versions,
            __channel,
            __session_ttl,
            __end_user_metadata,
            __search_config,
            __populate_data_store_connection_signals,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryParameters")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "geoLocation" => Ok(__FieldTag::__geo_location),
                            "geo_location" => Ok(__FieldTag::__geo_location),
                            "sessionEntityTypes" => Ok(__FieldTag::__session_entity_types),
                            "session_entity_types" => Ok(__FieldTag::__session_entity_types),
                            "payload" => Ok(__FieldTag::__payload),
                            "parameters" => Ok(__FieldTag::__parameters),
                            "currentPage" => Ok(__FieldTag::__current_page),
                            "current_page" => Ok(__FieldTag::__current_page),
                            "disableWebhook" => Ok(__FieldTag::__disable_webhook),
                            "disable_webhook" => Ok(__FieldTag::__disable_webhook),
                            "analyzeQueryTextSentiment" => {
                                Ok(__FieldTag::__analyze_query_text_sentiment)
                            }
                            "analyze_query_text_sentiment" => {
                                Ok(__FieldTag::__analyze_query_text_sentiment)
                            }
                            "webhookHeaders" => Ok(__FieldTag::__webhook_headers),
                            "webhook_headers" => Ok(__FieldTag::__webhook_headers),
                            "flowVersions" => Ok(__FieldTag::__flow_versions),
                            "flow_versions" => Ok(__FieldTag::__flow_versions),
                            "channel" => Ok(__FieldTag::__channel),
                            "sessionTtl" => Ok(__FieldTag::__session_ttl),
                            "session_ttl" => Ok(__FieldTag::__session_ttl),
                            "endUserMetadata" => Ok(__FieldTag::__end_user_metadata),
                            "end_user_metadata" => Ok(__FieldTag::__end_user_metadata),
                            "searchConfig" => Ok(__FieldTag::__search_config),
                            "search_config" => Ok(__FieldTag::__search_config),
                            "populateDataStoreConnectionSignals" => {
                                Ok(__FieldTag::__populate_data_store_connection_signals)
                            }
                            "populate_data_store_connection_signals" => {
                                Ok(__FieldTag::__populate_data_store_connection_signals)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryParameters;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryParameters")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__geo_location => {
                            if !fields.insert(__FieldTag::__geo_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for geo_location",
                                ));
                            }
                            result.geo_location =
                                map.next_value::<std::option::Option<gtype::model::LatLng>>()?;
                        }
                        __FieldTag::__session_entity_types => {
                            if !fields.insert(__FieldTag::__session_entity_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_entity_types",
                                ));
                            }
                            result.session_entity_types =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SessionEntityType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__payload => {
                            if !fields.insert(__FieldTag::__payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload",
                                ));
                            }
                            result.payload =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__current_page => {
                            if !fields.insert(__FieldTag::__current_page) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_page",
                                ));
                            }
                            result.current_page = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disable_webhook => {
                            if !fields.insert(__FieldTag::__disable_webhook) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disable_webhook",
                                ));
                            }
                            result.disable_webhook = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__analyze_query_text_sentiment => {
                            if !fields.insert(__FieldTag::__analyze_query_text_sentiment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analyze_query_text_sentiment",
                                ));
                            }
                            result.analyze_query_text_sentiment = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__webhook_headers => {
                            if !fields.insert(__FieldTag::__webhook_headers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_headers",
                                ));
                            }
                            result.webhook_headers = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__flow_versions => {
                            if !fields.insert(__FieldTag::__flow_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flow_versions",
                                ));
                            }
                            result.flow_versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__channel => {
                            if !fields.insert(__FieldTag::__channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel",
                                ));
                            }
                            result.channel = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__session_ttl => {
                            if !fields.insert(__FieldTag::__session_ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_ttl",
                                ));
                            }
                            result.session_ttl =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__end_user_metadata => {
                            if !fields.insert(__FieldTag::__end_user_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_user_metadata",
                                ));
                            }
                            result.end_user_metadata =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__search_config => {
                            if !fields.insert(__FieldTag::__search_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for search_config",
                                ));
                            }
                            result.search_config = map
                                .next_value::<std::option::Option<crate::model::SearchConfig>>()?;
                        }
                        __FieldTag::__populate_data_store_connection_signals => {
                            if !fields.insert(__FieldTag::__populate_data_store_connection_signals)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for populate_data_store_connection_signals",
                                ));
                            }
                            result.populate_data_store_connection_signals = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for QueryParameters {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if self.geo_location.is_some() {
            state.serialize_entry("geoLocation", &self.geo_location)?;
        }
        if !self.session_entity_types.is_empty() {
            state.serialize_entry("sessionEntityTypes", &self.session_entity_types)?;
        }
        if self.payload.is_some() {
            state.serialize_entry("payload", &self.payload)?;
        }
        if self.parameters.is_some() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self.current_page.is_empty() {
            state.serialize_entry("currentPage", &self.current_page)?;
        }
        if !wkt::internal::is_default(&self.disable_webhook) {
            state.serialize_entry("disableWebhook", &self.disable_webhook)?;
        }
        if !wkt::internal::is_default(&self.analyze_query_text_sentiment) {
            state.serialize_entry(
                "analyzeQueryTextSentiment",
                &self.analyze_query_text_sentiment,
            )?;
        }
        if !self.webhook_headers.is_empty() {
            state.serialize_entry("webhookHeaders", &self.webhook_headers)?;
        }
        if !self.flow_versions.is_empty() {
            state.serialize_entry("flowVersions", &self.flow_versions)?;
        }
        if !self.channel.is_empty() {
            state.serialize_entry("channel", &self.channel)?;
        }
        if self.session_ttl.is_some() {
            state.serialize_entry("sessionTtl", &self.session_ttl)?;
        }
        if self.end_user_metadata.is_some() {
            state.serialize_entry("endUserMetadata", &self.end_user_metadata)?;
        }
        if self.search_config.is_some() {
            state.serialize_entry("searchConfig", &self.search_config)?;
        }
        if !wkt::internal::is_default(&self.populate_data_store_connection_signals) {
            state.serialize_entry(
                "populateDataStoreConnectionSignals",
                &self.populate_data_store_connection_signals,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Search configuration for UCS search queries.
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchConfig {
    /// Optional. Boosting configuration for the datastores.
    ///
    /// Maps from datastore name to their boost configuration. Do not specify more
    /// than one BoostSpecs for each datastore name. If multiple BoostSpecs are
    /// provided for the same datastore name, the behavior is undefined.
    pub boost_specs: std::vec::Vec<crate::model::BoostSpecs>,

    /// Optional. Filter configuration for the datastores.
    ///
    /// Maps from datastore name to the filter expression for that datastore. Do
    /// not specify more than one FilterSpecs for each datastore name. If multiple
    /// FilterSpecs are provided for the same datastore name, the behavior is
    /// undefined.
    pub filter_specs: std::vec::Vec<crate::model::FilterSpecs>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl SearchConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [boost_specs][crate::model::SearchConfig::boost_specs].
    pub fn set_boost_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BoostSpecs>,
    {
        use std::iter::Iterator;
        self.boost_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [filter_specs][crate::model::SearchConfig::filter_specs].
    pub fn set_filter_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FilterSpecs>,
    {
        use std::iter::Iterator;
        self.filter_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for SearchConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.SearchConfig"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __boost_specs,
            __filter_specs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "boostSpecs" => Ok(__FieldTag::__boost_specs),
                            "boost_specs" => Ok(__FieldTag::__boost_specs),
                            "filterSpecs" => Ok(__FieldTag::__filter_specs),
                            "filter_specs" => Ok(__FieldTag::__filter_specs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__boost_specs => {
                            if !fields.insert(__FieldTag::__boost_specs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boost_specs",
                                ));
                            }
                            result.boost_specs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BoostSpecs>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__filter_specs => {
                            if !fields.insert(__FieldTag::__filter_specs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter_specs",
                                ));
                            }
                            result.filter_specs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FilterSpecs>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for SearchConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.boost_specs.is_empty() {
            state.serialize_entry("boostSpecs", &self.boost_specs)?;
        }
        if !self.filter_specs.is_empty() {
            state.serialize_entry("filterSpecs", &self.filter_specs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Boost specification to boost certain documents.
/// A copy of google.cloud.discoveryengine.v1main.BoostSpec, field documentation
/// is available at
/// <https://cloud.google.com/generative-ai-app-builder/docs/reference/rest/v1alpha/BoostSpec>
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BoostSpec {
    /// Optional. Condition boost specifications. If a document matches multiple
    /// conditions in the specifications, boost scores from these specifications
    /// are all applied and combined in a non-linear way. Maximum number of
    /// specifications is 20.
    pub condition_boost_specs: std::vec::Vec<crate::model::boost_spec::ConditionBoostSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl BoostSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [condition_boost_specs][crate::model::BoostSpec::condition_boost_specs].
    pub fn set_condition_boost_specs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::boost_spec::ConditionBoostSpec>,
    {
        use std::iter::Iterator;
        self.condition_boost_specs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for BoostSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.BoostSpec"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BoostSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __condition_boost_specs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BoostSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conditionBoostSpecs" => Ok(__FieldTag::__condition_boost_specs),
                            "condition_boost_specs" => Ok(__FieldTag::__condition_boost_specs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BoostSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BoostSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__condition_boost_specs => {
                            if !fields.insert(__FieldTag::__condition_boost_specs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition_boost_specs",
                                ));
                            }
                            result.condition_boost_specs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::boost_spec::ConditionBoostSpec>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for BoostSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.condition_boost_specs.is_empty() {
            state.serialize_entry("conditionBoostSpecs", &self.condition_boost_specs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BoostSpec].
#[cfg(feature = "sessions")]
pub mod boost_spec {
    #[allow(unused_imports)]
    use super::*;

    /// Boost applies to documents which match a condition.
    #[cfg(feature = "sessions")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConditionBoostSpec {
        /// Optional. An expression which specifies a boost condition. The syntax and
        /// supported fields are the same as a filter expression.
        /// Examples:
        ///
        /// * To boost documents with document ID "doc_1" or "doc_2", and
        ///   color
        ///   "Red" or "Blue":
        ///   * (id: ANY("doc_1", "doc_2")) AND (color: ANY("Red","Blue"))
        pub condition: std::string::String,

        /// Optional. Strength of the condition boost, which should be in [-1, 1].
        /// Negative boost means demotion. Default is 0.0.
        ///
        /// Setting to 1.0 gives the document a big promotion. However, it does not
        /// necessarily mean that the boosted document will be the top result at
        /// all times, nor that other documents will be excluded. Results could
        /// still be shown even when none of them matches the condition. And
        /// results that are significantly more relevant to the search query can
        /// still trump your heavily favored but irrelevant documents.
        ///
        /// Setting to -1.0 gives the document a big demotion. However, results
        /// that are deeply relevant might still be shown. The document will have
        /// an upstream battle to get a fairly high ranking, but it is not blocked
        /// out completely.
        ///
        /// Setting to 0.0 means no boost applied. The boosting condition is
        /// ignored.
        pub boost: f32,

        /// Optional. Complex specification for custom ranking based on customer
        /// defined attribute value.
        pub boost_control_spec:
            std::option::Option<crate::model::boost_spec::condition_boost_spec::BoostControlSpec>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "sessions")]
    impl ConditionBoostSpec {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [condition][crate::model::boost_spec::ConditionBoostSpec::condition].
        pub fn set_condition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.condition = v.into();
            self
        }

        /// Sets the value of [boost][crate::model::boost_spec::ConditionBoostSpec::boost].
        pub fn set_boost<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.boost = v.into();
            self
        }

        /// Sets the value of [boost_control_spec][crate::model::boost_spec::ConditionBoostSpec::boost_control_spec].
        pub fn set_boost_control_spec<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::boost_spec::condition_boost_spec::BoostControlSpec>,
        {
            self.boost_control_spec = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [boost_control_spec][crate::model::boost_spec::ConditionBoostSpec::boost_control_spec].
        pub fn set_or_clear_boost_control_spec<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::boost_spec::condition_boost_spec::BoostControlSpec>,
        {
            self.boost_control_spec = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "sessions")]
    impl wkt::message::Message for ConditionBoostSpec {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.BoostSpec.ConditionBoostSpec"
        }
    }

    #[cfg(feature = "sessions")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConditionBoostSpec {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __condition,
                __boost,
                __boost_control_spec,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConditionBoostSpec")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "condition" => Ok(__FieldTag::__condition),
                                "boost" => Ok(__FieldTag::__boost),
                                "boostControlSpec" => Ok(__FieldTag::__boost_control_spec),
                                "boost_control_spec" => Ok(__FieldTag::__boost_control_spec),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConditionBoostSpec;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConditionBoostSpec")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__condition => {
                                if !fields.insert(__FieldTag::__condition) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for condition",
                                    ));
                                }
                                result.condition = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__boost => {
                                if !fields.insert(__FieldTag::__boost) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for boost",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.boost = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__boost_control_spec => {
                                if !fields.insert(__FieldTag::__boost_control_spec) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for boost_control_spec",
                                    ));
                                }
                                result.boost_control_spec = map.next_value::<std::option::Option<crate::model::boost_spec::condition_boost_spec::BoostControlSpec>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "sessions")]
    #[doc(hidden)]
    impl serde::ser::Serialize for ConditionBoostSpec {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.condition.is_empty() {
                state.serialize_entry("condition", &self.condition)?;
            }
            if !wkt::internal::is_default(&self.boost) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("boost", &__With(&self.boost))?;
            }
            if self.boost_control_spec.is_some() {
                state.serialize_entry("boostControlSpec", &self.boost_control_spec)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ConditionBoostSpec].
    #[cfg(feature = "sessions")]
    pub mod condition_boost_spec {
        #[allow(unused_imports)]
        use super::*;

        /// Specification for custom ranking based on customer specified attribute
        /// value. It provides more controls for customized ranking than the simple
        /// (condition, boost) combination above.
        #[cfg(feature = "sessions")]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct BoostControlSpec {

            /// Optional. The name of the field whose value will be used to determine
            /// the boost amount.
            pub field_name: std::string::String,

            /// Optional. The attribute type to be used to determine the boost amount.
            /// The attribute value can be derived from the field value of the
            /// specified field_name. In the case of numerical it is straightforward
            /// i.e. attribute_value = numerical_field_value. In the case of freshness
            /// however, attribute_value = (time.now() - datetime_field_value).
            pub attribute_type: crate::model::boost_spec::condition_boost_spec::boost_control_spec::AttributeType,

            /// Optional. The interpolation type to be applied to connect the control
            /// points listed below.
            pub interpolation_type: crate::model::boost_spec::condition_boost_spec::boost_control_spec::InterpolationType,

            /// Optional. The control points used to define the curve. The monotonic
            /// function (defined through the interpolation_type above) passes through
            /// the control points listed here.
            pub control_points: std::vec::Vec<crate::model::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "sessions")]
        impl BoostControlSpec {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [field_name][crate::model::boost_spec::condition_boost_spec::BoostControlSpec::field_name].
            pub fn set_field_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.field_name = v.into();
                self
            }

            /// Sets the value of [attribute_type][crate::model::boost_spec::condition_boost_spec::BoostControlSpec::attribute_type].
            pub fn set_attribute_type<T: std::convert::Into<crate::model::boost_spec::condition_boost_spec::boost_control_spec::AttributeType>>(mut self, v: T) -> Self{
                self.attribute_type = v.into();
                self
            }

            /// Sets the value of [interpolation_type][crate::model::boost_spec::condition_boost_spec::BoostControlSpec::interpolation_type].
            pub fn set_interpolation_type<T: std::convert::Into<crate::model::boost_spec::condition_boost_spec::boost_control_spec::InterpolationType>>(mut self, v: T) -> Self{
                self.interpolation_type = v.into();
                self
            }

            /// Sets the value of [control_points][crate::model::boost_spec::condition_boost_spec::BoostControlSpec::control_points].
            pub fn set_control_points<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint>
            {
                use std::iter::Iterator;
                self.control_points = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(feature = "sessions")]
        impl wkt::message::Message for BoostControlSpec {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.cx.v3.BoostSpec.ConditionBoostSpec.BoostControlSpec"
            }
        }

        #[cfg(feature = "sessions")]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for BoostControlSpec {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __field_name,
                    __attribute_type,
                    __interpolation_type,
                    __control_points,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for BoostControlSpec")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "fieldName" => Ok(__FieldTag::__field_name),
                                    "field_name" => Ok(__FieldTag::__field_name),
                                    "attributeType" => Ok(__FieldTag::__attribute_type),
                                    "attribute_type" => Ok(__FieldTag::__attribute_type),
                                    "interpolationType" => Ok(__FieldTag::__interpolation_type),
                                    "interpolation_type" => Ok(__FieldTag::__interpolation_type),
                                    "controlPoints" => Ok(__FieldTag::__control_points),
                                    "control_points" => Ok(__FieldTag::__control_points),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = BoostControlSpec;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct BoostControlSpec")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__field_name => {
                                    if !fields.insert(__FieldTag::__field_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for field_name",
                                            ),
                                        );
                                    }
                                    result.field_name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__attribute_type => {
                                    if !fields.insert(__FieldTag::__attribute_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for attribute_type",
                                            ),
                                        );
                                    }
                                    result.attribute_type = map.next_value::<std::option::Option<crate::model::boost_spec::condition_boost_spec::boost_control_spec::AttributeType>>()?.unwrap_or_default();
                                }
                                __FieldTag::__interpolation_type => {
                                    if !fields.insert(__FieldTag::__interpolation_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for interpolation_type",
                                            ),
                                        );
                                    }
                                    result.interpolation_type = map.next_value::<std::option::Option<crate::model::boost_spec::condition_boost_spec::boost_control_spec::InterpolationType>>()?.unwrap_or_default();
                                }
                                __FieldTag::__control_points => {
                                    if !fields.insert(__FieldTag::__control_points) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for control_points",
                                            ),
                                        );
                                    }
                                    result.control_points = map.next_value::<std::option::Option<std::vec::Vec<crate::model::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(feature = "sessions")]
        #[doc(hidden)]
        impl serde::ser::Serialize for BoostControlSpec {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.field_name.is_empty() {
                    state.serialize_entry("fieldName", &self.field_name)?;
                }
                if !wkt::internal::is_default(&self.attribute_type) {
                    state.serialize_entry("attributeType", &self.attribute_type)?;
                }
                if !wkt::internal::is_default(&self.interpolation_type) {
                    state.serialize_entry("interpolationType", &self.interpolation_type)?;
                }
                if !self.control_points.is_empty() {
                    state.serialize_entry("controlPoints", &self.control_points)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [BoostControlSpec].
        #[cfg(feature = "sessions")]
        pub mod boost_control_spec {
            #[allow(unused_imports)]
            use super::*;

            /// The control points used to define the curve. The curve defined
            /// through these control points can only be monotonically increasing
            /// or decreasing(constant values are acceptable).
            #[cfg(feature = "sessions")]
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct ControlPoint {
                /// Optional. Can be one of:
                ///
                /// . The numerical field value.
                /// . The duration spec for freshness:
                ///   The value must be formatted as an XSD `dayTimeDuration` value (a
                ///   restricted subset of an ISO 8601 duration value). The pattern for
                ///   this is: `[nD][T[nH][nM][nS]]`.
                pub attribute_value: std::string::String,

                /// Optional. The value between -1 to 1 by which to boost the score if
                /// the attribute_value evaluates to the value specified above.
                pub boost_amount: f32,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(feature = "sessions")]
            impl ControlPoint {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [attribute_value][crate::model::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint::attribute_value].
                pub fn set_attribute_value<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.attribute_value = v.into();
                    self
                }

                /// Sets the value of [boost_amount][crate::model::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint::boost_amount].
                pub fn set_boost_amount<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                    self.boost_amount = v.into();
                    self
                }
            }

            #[cfg(feature = "sessions")]
            impl wkt::message::Message for ControlPoint {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.dialogflow.cx.v3.BoostSpec.ConditionBoostSpec.BoostControlSpec.ControlPoint"
                }
            }

            #[cfg(feature = "sessions")]
            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for ControlPoint {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __attribute_value,
                        __boost_amount,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for ControlPoint")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "attributeValue" => Ok(__FieldTag::__attribute_value),
                                        "attribute_value" => Ok(__FieldTag::__attribute_value),
                                        "boostAmount" => Ok(__FieldTag::__boost_amount),
                                        "boost_amount" => Ok(__FieldTag::__boost_amount),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = ControlPoint;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct ControlPoint")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__attribute_value => {
                                        if !fields.insert(__FieldTag::__attribute_value) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for attribute_value",
                                                ),
                                            );
                                        }
                                        result.attribute_value = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__boost_amount => {
                                        if !fields.insert(__FieldTag::__boost_amount) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for boost_amount",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<f32>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<wkt::internal::F32>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.boost_amount =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[cfg(feature = "sessions")]
            #[doc(hidden)]
            impl serde::ser::Serialize for ControlPoint {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.attribute_value.is_empty() {
                        state.serialize_entry("attributeValue", &self.attribute_value)?;
                    }
                    if !wkt::internal::is_default(&self.boost_amount) {
                        struct __With<'a>(&'a f32);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                            }
                        }
                        state.serialize_entry("boostAmount", &__With(&self.boost_amount))?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// The attribute(or function) for which the custom ranking is to be
            /// applied.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[cfg(feature = "sessions")]
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum AttributeType {
                /// Unspecified AttributeType.
                Unspecified,
                /// The value of the numerical field will be used to dynamically update
                /// the boost amount. In this case, the attribute_value (the x value)
                /// of the control point will be the actual value of the numerical
                /// field for which the boost_amount is specified.
                Numerical,
                /// For the freshness use case the attribute value will be the duration
                /// between the current time and the date in the datetime field
                /// specified. The value must be formatted as an XSD `dayTimeDuration`
                /// value (a restricted subset of an ISO 8601 duration value). The
                /// pattern for this is: `[nD][T[nH][nM][nS]]`.
                /// E.g. `5D`, `3DT12H30M`, `T24H`.
                Freshness,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [AttributeType::value] or
                /// [AttributeType::name].
                UnknownValue(attribute_type::UnknownValue),
            }

            #[doc(hidden)]
            #[cfg(feature = "sessions")]
            pub mod attribute_type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            #[cfg(feature = "sessions")]
            impl AttributeType {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Numerical => std::option::Option::Some(1),
                        Self::Freshness => std::option::Option::Some(2),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("ATTRIBUTE_TYPE_UNSPECIFIED")
                        }
                        Self::Numerical => std::option::Option::Some("NUMERICAL"),
                        Self::Freshness => std::option::Option::Some("FRESHNESS"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            #[cfg(feature = "sessions")]
            impl std::default::Default for AttributeType {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            #[cfg(feature = "sessions")]
            impl std::fmt::Display for AttributeType {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            #[cfg(feature = "sessions")]
            impl std::convert::From<i32> for AttributeType {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Numerical,
                        2 => Self::Freshness,
                        _ => Self::UnknownValue(attribute_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            #[cfg(feature = "sessions")]
            impl std::convert::From<&str> for AttributeType {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "ATTRIBUTE_TYPE_UNSPECIFIED" => Self::Unspecified,
                        "NUMERICAL" => Self::Numerical,
                        "FRESHNESS" => Self::Freshness,
                        _ => Self::UnknownValue(attribute_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            #[cfg(feature = "sessions")]
            impl serde::ser::Serialize for AttributeType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Numerical => serializer.serialize_i32(1),
                        Self::Freshness => serializer.serialize_i32(2),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            #[cfg(feature = "sessions")]
            impl<'de> serde::de::Deserialize<'de> for AttributeType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttributeType>::new(
                        ".google.cloud.dialogflow.cx.v3.BoostSpec.ConditionBoostSpec.BoostControlSpec.AttributeType"))
                }
            }

            /// The interpolation type to be applied. Default will be linear
            /// (Piecewise Linear).
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[cfg(feature = "sessions")]
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum InterpolationType {
                /// Interpolation type is unspecified. In this case, it defaults to
                /// Linear.
                Unspecified,
                /// Piecewise linear interpolation will be applied.
                Linear,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [InterpolationType::value] or
                /// [InterpolationType::name].
                UnknownValue(interpolation_type::UnknownValue),
            }

            #[doc(hidden)]
            #[cfg(feature = "sessions")]
            pub mod interpolation_type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            #[cfg(feature = "sessions")]
            impl InterpolationType {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Linear => std::option::Option::Some(1),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("INTERPOLATION_TYPE_UNSPECIFIED")
                        }
                        Self::Linear => std::option::Option::Some("LINEAR"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            #[cfg(feature = "sessions")]
            impl std::default::Default for InterpolationType {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            #[cfg(feature = "sessions")]
            impl std::fmt::Display for InterpolationType {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            #[cfg(feature = "sessions")]
            impl std::convert::From<i32> for InterpolationType {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Linear,
                        _ => Self::UnknownValue(interpolation_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            #[cfg(feature = "sessions")]
            impl std::convert::From<&str> for InterpolationType {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "INTERPOLATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                        "LINEAR" => Self::Linear,
                        _ => Self::UnknownValue(interpolation_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            #[cfg(feature = "sessions")]
            impl serde::ser::Serialize for InterpolationType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Linear => serializer.serialize_i32(1),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            #[cfg(feature = "sessions")]
            impl<'de> serde::de::Deserialize<'de> for InterpolationType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<InterpolationType>::new(
                        ".google.cloud.dialogflow.cx.v3.BoostSpec.ConditionBoostSpec.BoostControlSpec.InterpolationType"))
                }
            }
        }
    }
}

/// Boost specifications for data stores.
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BoostSpecs {
    /// Optional. Data Stores where the boosting configuration is applied. The full
    /// names of the referenced data stores. Formats:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`
    /// `projects/{project}/locations/{location}/dataStores/{data_store}`
    pub data_stores: std::vec::Vec<std::string::String>,

    /// Optional. A list of boosting specifications.
    pub spec: std::vec::Vec<crate::model::BoostSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl BoostSpecs {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_stores][crate::model::BoostSpecs::data_stores].
    pub fn set_data_stores<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data_stores = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [spec][crate::model::BoostSpecs::spec].
    pub fn set_spec<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BoostSpec>,
    {
        use std::iter::Iterator;
        self.spec = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for BoostSpecs {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.BoostSpecs"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BoostSpecs {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_stores,
            __spec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BoostSpecs")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataStores" => Ok(__FieldTag::__data_stores),
                            "data_stores" => Ok(__FieldTag::__data_stores),
                            "spec" => Ok(__FieldTag::__spec),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BoostSpecs;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BoostSpecs")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_stores => {
                            if !fields.insert(__FieldTag::__data_stores) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_stores",
                                ));
                            }
                            result.data_stores = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__spec => {
                            if !fields.insert(__FieldTag::__spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spec",
                                ));
                            }
                            result.spec = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BoostSpec>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for BoostSpecs {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_stores.is_empty() {
            state.serialize_entry("dataStores", &self.data_stores)?;
        }
        if !self.spec.is_empty() {
            state.serialize_entry("spec", &self.spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Filter specifications for data stores.
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FilterSpecs {
    /// Optional. Data Stores where the boosting configuration is applied. The full
    /// names of the referenced data stores. Formats:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`
    /// `projects/{project}/locations/{location}/dataStores/{data_store}`
    pub data_stores: std::vec::Vec<std::string::String>,

    /// Optional. The filter expression to be applied.
    /// Expression syntax is documented at
    /// <https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata#filter-expression-syntax>
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl FilterSpecs {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data_stores][crate::model::FilterSpecs::data_stores].
    pub fn set_data_stores<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.data_stores = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [filter][crate::model::FilterSpecs::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for FilterSpecs {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.FilterSpecs"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FilterSpecs {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __data_stores,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FilterSpecs")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataStores" => Ok(__FieldTag::__data_stores),
                            "data_stores" => Ok(__FieldTag::__data_stores),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FilterSpecs;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FilterSpecs")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__data_stores => {
                            if !fields.insert(__FieldTag::__data_stores) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_stores",
                                ));
                            }
                            result.data_stores = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for FilterSpecs {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.data_stores.is_empty() {
            state.serialize_entry("dataStores", &self.data_stores)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the query input. It can contain one of:
///
/// . A conversational query in the form of text.
///
/// . An intent query that specifies which intent to trigger.
///
/// . Natural language speech audio to be processed.
///
/// . An event to be triggered.
///
/// . DTMF digits to invoke an intent and fill in parameter value.
///
/// . The results of a tool executed by the client.
///
#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryInput {
    /// Required. The language of the input. See [Language
    /// Support](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// for a list of the currently supported language codes. Note that queries in
    /// the same session do not necessarily need to specify the same language.
    pub language_code: std::string::String,

    /// Required. The input specification.
    pub input: std::option::Option<crate::model::query_input::Input>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl QueryInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language_code][crate::model::QueryInput::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [input][crate::model::QueryInput::input].
    ///
    /// Note that all the setters affecting `input` are mutually
    /// exclusive.
    pub fn set_input<
        T: std::convert::Into<std::option::Option<crate::model::query_input::Input>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input = v.into();
        self
    }

    /// The value of [input][crate::model::QueryInput::input]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text(&self) -> std::option::Option<&std::boxed::Box<crate::model::TextInput>> {
        #[allow(unreachable_patterns)]
        self.input.as_ref().and_then(|v| match v {
            crate::model::query_input::Input::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input][crate::model::QueryInput::input]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `input` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::boxed::Box<crate::model::TextInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.input = std::option::Option::Some(crate::model::query_input::Input::Text(v.into()));
        self
    }

    /// The value of [input][crate::model::QueryInput::input]
    /// if it holds a `Intent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn intent(&self) -> std::option::Option<&std::boxed::Box<crate::model::IntentInput>> {
        #[allow(unreachable_patterns)]
        self.input.as_ref().and_then(|v| match v {
            crate::model::query_input::Input::Intent(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input][crate::model::QueryInput::input]
    /// to hold a `Intent`.
    ///
    /// Note that all the setters affecting `input` are
    /// mutually exclusive.
    pub fn set_intent<T: std::convert::Into<std::boxed::Box<crate::model::IntentInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.input = std::option::Option::Some(crate::model::query_input::Input::Intent(v.into()));
        self
    }

    /// The value of [input][crate::model::QueryInput::input]
    /// if it holds a `Audio`, `None` if the field is not set or
    /// holds a different branch.
    pub fn audio(&self) -> std::option::Option<&std::boxed::Box<crate::model::AudioInput>> {
        #[allow(unreachable_patterns)]
        self.input.as_ref().and_then(|v| match v {
            crate::model::query_input::Input::Audio(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input][crate::model::QueryInput::input]
    /// to hold a `Audio`.
    ///
    /// Note that all the setters affecting `input` are
    /// mutually exclusive.
    pub fn set_audio<T: std::convert::Into<std::boxed::Box<crate::model::AudioInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.input = std::option::Option::Some(crate::model::query_input::Input::Audio(v.into()));
        self
    }

    /// The value of [input][crate::model::QueryInput::input]
    /// if it holds a `Event`, `None` if the field is not set or
    /// holds a different branch.
    pub fn event(&self) -> std::option::Option<&std::boxed::Box<crate::model::EventInput>> {
        #[allow(unreachable_patterns)]
        self.input.as_ref().and_then(|v| match v {
            crate::model::query_input::Input::Event(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input][crate::model::QueryInput::input]
    /// to hold a `Event`.
    ///
    /// Note that all the setters affecting `input` are
    /// mutually exclusive.
    pub fn set_event<T: std::convert::Into<std::boxed::Box<crate::model::EventInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.input = std::option::Option::Some(crate::model::query_input::Input::Event(v.into()));
        self
    }

    /// The value of [input][crate::model::QueryInput::input]
    /// if it holds a `Dtmf`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dtmf(&self) -> std::option::Option<&std::boxed::Box<crate::model::DtmfInput>> {
        #[allow(unreachable_patterns)]
        self.input.as_ref().and_then(|v| match v {
            crate::model::query_input::Input::Dtmf(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input][crate::model::QueryInput::input]
    /// to hold a `Dtmf`.
    ///
    /// Note that all the setters affecting `input` are
    /// mutually exclusive.
    pub fn set_dtmf<T: std::convert::Into<std::boxed::Box<crate::model::DtmfInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.input = std::option::Option::Some(crate::model::query_input::Input::Dtmf(v.into()));
        self
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl wkt::message::Message for QueryInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.QueryInput"
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __intent,
            __audio,
            __event,
            __dtmf,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "intent" => Ok(__FieldTag::__intent),
                            "audio" => Ok(__FieldTag::__audio),
                            "event" => Ok(__FieldTag::__event),
                            "dtmf" => Ok(__FieldTag::__dtmf),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.cx.v3.QueryInput.text, latest field was text",
                                ));
                            }
                            result.input =
                                std::option::Option::Some(crate::model::query_input::Input::Text(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TextInput>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__intent => {
                            if !fields.insert(__FieldTag::__intent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent",
                                ));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.cx.v3.QueryInput.intent, latest field was intent",
                                ));
                            }
                            result.input = std::option::Option::Some(
                                crate::model::query_input::Input::Intent(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::IntentInput>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__audio => {
                            if !fields.insert(__FieldTag::__audio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio",
                                ));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.cx.v3.QueryInput.audio, latest field was audio",
                                ));
                            }
                            result.input =
                                std::option::Option::Some(crate::model::query_input::Input::Audio(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AudioInput>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__event => {
                            if !fields.insert(__FieldTag::__event) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event",
                                ));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.cx.v3.QueryInput.event, latest field was event",
                                ));
                            }
                            result.input =
                                std::option::Option::Some(crate::model::query_input::Input::Event(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::EventInput>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__dtmf => {
                            if !fields.insert(__FieldTag::__dtmf) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dtmf",
                                ));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.cx.v3.QueryInput.dtmf, latest field was dtmf",
                                ));
                            }
                            result.input =
                                std::option::Option::Some(crate::model::query_input::Input::Dtmf(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DtmfInput>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for QueryInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.intent() {
            state.serialize_entry("intent", value)?;
        }
        if let Some(value) = self.audio() {
            state.serialize_entry("audio", value)?;
        }
        if let Some(value) = self.event() {
            state.serialize_entry("event", value)?;
        }
        if let Some(value) = self.dtmf() {
            state.serialize_entry("dtmf", value)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [QueryInput].
#[cfg(any(feature = "sessions", feature = "test-cases",))]
pub mod query_input {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The input specification.
    #[cfg(any(feature = "sessions", feature = "test-cases",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Input {
        /// The natural language text to be processed.
        Text(std::boxed::Box<crate::model::TextInput>),
        /// The intent to be triggered.
        Intent(std::boxed::Box<crate::model::IntentInput>),
        /// The natural language speech audio to be processed.
        Audio(std::boxed::Box<crate::model::AudioInput>),
        /// The event to be triggered.
        Event(std::boxed::Box<crate::model::EventInput>),
        /// The DTMF event to be handled.
        Dtmf(std::boxed::Box<crate::model::DtmfInput>),
    }
}

/// Represents the result of a conversational query.
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryResult {
    /// The language that was triggered during intent detection.
    /// See [Language
    /// Support](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// for a list of the currently supported language codes.
    pub language_code: std::string::String,

    /// The collected [session
    /// parameters][google.cloud.dialogflow.cx.v3.SessionInfo.parameters].
    ///
    /// Depending on your protocol or client library language, this is a
    /// map, associative array, symbol table, dictionary, or JSON object
    /// composed of a collection of (MapKey, MapValue) pairs:
    ///
    /// * MapKey type: string
    /// * MapKey value: parameter name
    /// * MapValue type: If parameter's entity type is a composite entity then use
    ///   map, otherwise, depending on the parameter value type, it could be one of
    ///   string, number, boolean, null, list or map.
    /// * MapValue value: If parameter's entity type is a composite entity then use
    ///   map from composite entity property names to property values, otherwise,
    ///   use parameter value.
    ///
    /// [google.cloud.dialogflow.cx.v3.SessionInfo.parameters]: crate::model::SessionInfo::parameters
    pub parameters: std::option::Option<wkt::Struct>,

    /// The list of rich messages returned to the client. Responses vary from
    /// simple text messages to more sophisticated, structured payloads used
    /// to drive complex logic.
    pub response_messages: std::vec::Vec<crate::model::ResponseMessage>,

    /// The list of webhook ids in the order of call sequence.
    pub webhook_ids: std::vec::Vec<std::string::String>,

    /// The list of webhook display names in the order of call sequence.
    pub webhook_display_names: std::vec::Vec<std::string::String>,

    /// The list of webhook latencies in the order of call sequence.
    pub webhook_latencies: std::vec::Vec<wkt::Duration>,

    /// The list of webhook tags in the order of call sequence.
    pub webhook_tags: std::vec::Vec<std::string::String>,

    /// The list of webhook call status in the order of call sequence.
    pub webhook_statuses: std::vec::Vec<rpc::model::Status>,

    /// The list of webhook payload in
    /// [WebhookResponse.payload][google.cloud.dialogflow.cx.v3.WebhookResponse.payload],
    /// in the order of call sequence. If some webhook call fails or doesn't return
    /// any payload, an empty `Struct` would be used instead.
    ///
    /// [google.cloud.dialogflow.cx.v3.WebhookResponse.payload]: crate::model::WebhookResponse::payload
    pub webhook_payloads: std::vec::Vec<wkt::Struct>,

    /// The current [Page][google.cloud.dialogflow.cx.v3.Page]. Some, not all
    /// fields are filled in this message, including but not limited to `name` and
    /// `display_name`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Page]: crate::model::Page
    pub current_page: std::option::Option<crate::model::Page>,

    /// The current [Flow][google.cloud.dialogflow.cx.v3.Flow]. Some, not all
    /// fields are filled in this message, including but not limited to `name` and
    /// `display_name`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Flow]: crate::model::Flow
    pub current_flow: std::option::Option<crate::model::Flow>,

    /// The [Intent][google.cloud.dialogflow.cx.v3.Intent] that matched the
    /// conversational query. Some, not all fields are filled in this message,
    /// including but not limited to: `name` and `display_name`. This field is
    /// deprecated, please use
    /// [QueryResult.match][google.cloud.dialogflow.cx.v3.QueryResult.match]
    /// instead.
    ///
    /// [google.cloud.dialogflow.cx.v3.Intent]: crate::model::Intent
    /// [google.cloud.dialogflow.cx.v3.QueryResult.match]: crate::model::QueryResult::match
    #[deprecated]
    pub intent: std::option::Option<crate::model::Intent>,

    /// The intent detection confidence. Values range from 0.0 (completely
    /// uncertain) to 1.0 (completely certain).
    /// This value is for informational purpose only and is only used to
    /// help match the best intent within the classification threshold.
    /// This value may change for the same end-user expression at any time due to a
    /// model retraining or change in implementation.
    /// This field is deprecated, please use
    /// [QueryResult.match][google.cloud.dialogflow.cx.v3.QueryResult.match]
    /// instead.
    ///
    /// [google.cloud.dialogflow.cx.v3.QueryResult.match]: crate::model::QueryResult::match
    #[deprecated]
    pub intent_detection_confidence: f32,

    /// Intent match result, could be an intent or an event.
    pub r#match: std::option::Option<crate::model::Match>,

    /// The free-form diagnostic info. For example, this field could contain
    /// webhook call latency. The fields of this data can change without notice,
    /// so you should not write code that depends on its structure.
    ///
    /// One of the fields is called "Alternative Matched Intents", which may
    /// aid with debugging. The following describes these intent results:
    ///
    /// - The list is empty if no intent was matched to end-user input.
    /// - Only intents that are referenced in the currently active flow are
    ///   included.
    /// - The matched intent is included.
    /// - Other intents that could have matched end-user input, but did not match
    ///   because they are referenced by intent routes that are out of
    ///   [scope](https://cloud.google.com/dialogflow/cx/docs/concept/handler#scope),
    ///   are included.
    /// - Other intents referenced by intent routes in scope that matched end-user
    ///   input, but had a lower confidence score.
    pub diagnostic_info: std::option::Option<wkt::Struct>,

    /// The sentiment analyss result, which depends on
    /// [`analyze_query_text_sentiment`]
    /// [google.cloud.dialogflow.cx.v3.QueryParameters.analyze_query_text_sentiment],
    /// specified in the request.
    pub sentiment_analysis_result: std::option::Option<crate::model::SentimentAnalysisResult>,

    /// Returns the current advanced settings including IVR settings. Even though
    /// the operations configured by these settings are performed by Dialogflow,
    /// the client may need to perform special logic at the moment. For example, if
    /// Dialogflow exports audio to Google Cloud Storage, then the client may need
    /// to wait for the resulting object to appear in the bucket before proceeding.
    pub advanced_settings: std::option::Option<crate::model::AdvancedSettings>,

    /// Indicates whether the Thumbs up/Thumbs down rating controls are need to be
    /// shown for the response in the Dialogflow Messenger widget.
    pub allow_answer_feedback: bool,

    /// Optional. Data store connection feature output signals.
    /// Filled only when data stores are involved in serving the query.
    pub data_store_connection_signals:
        std::option::Option<crate::model::DataStoreConnectionSignals>,

    /// The original conversational query.
    pub query: std::option::Option<crate::model::query_result::Query>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl QueryResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language_code][crate::model::QueryResult::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::QueryResult::parameters].
    pub fn set_parameters<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.parameters = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [parameters][crate::model::QueryResult::parameters].
    pub fn set_or_clear_parameters<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.parameters = v.map(|x| x.into());
        self
    }

    /// Sets the value of [response_messages][crate::model::QueryResult::response_messages].
    pub fn set_response_messages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResponseMessage>,
    {
        use std::iter::Iterator;
        self.response_messages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [webhook_ids][crate::model::QueryResult::webhook_ids].
    pub fn set_webhook_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.webhook_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [webhook_display_names][crate::model::QueryResult::webhook_display_names].
    pub fn set_webhook_display_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.webhook_display_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [webhook_latencies][crate::model::QueryResult::webhook_latencies].
    pub fn set_webhook_latencies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Duration>,
    {
        use std::iter::Iterator;
        self.webhook_latencies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [webhook_tags][crate::model::QueryResult::webhook_tags].
    pub fn set_webhook_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.webhook_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [webhook_statuses][crate::model::QueryResult::webhook_statuses].
    pub fn set_webhook_statuses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.webhook_statuses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [webhook_payloads][crate::model::QueryResult::webhook_payloads].
    pub fn set_webhook_payloads<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Struct>,
    {
        use std::iter::Iterator;
        self.webhook_payloads = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [current_page][crate::model::QueryResult::current_page].
    pub fn set_current_page<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Page>,
    {
        self.current_page = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [current_page][crate::model::QueryResult::current_page].
    pub fn set_or_clear_current_page<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Page>,
    {
        self.current_page = v.map(|x| x.into());
        self
    }

    /// Sets the value of [current_flow][crate::model::QueryResult::current_flow].
    pub fn set_current_flow<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Flow>,
    {
        self.current_flow = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [current_flow][crate::model::QueryResult::current_flow].
    pub fn set_or_clear_current_flow<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Flow>,
    {
        self.current_flow = v.map(|x| x.into());
        self
    }

    /// Sets the value of [intent][crate::model::QueryResult::intent].
    #[deprecated]
    pub fn set_intent<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Intent>,
    {
        self.intent = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [intent][crate::model::QueryResult::intent].
    #[deprecated]
    pub fn set_or_clear_intent<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Intent>,
    {
        self.intent = v.map(|x| x.into());
        self
    }

    /// Sets the value of [intent_detection_confidence][crate::model::QueryResult::intent_detection_confidence].
    #[deprecated]
    pub fn set_intent_detection_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.intent_detection_confidence = v.into();
        self
    }

    /// Sets the value of [r#match][crate::model::QueryResult::match].
    pub fn set_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Match>,
    {
        self.r#match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#match][crate::model::QueryResult::match].
    pub fn set_or_clear_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Match>,
    {
        self.r#match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [diagnostic_info][crate::model::QueryResult::diagnostic_info].
    pub fn set_diagnostic_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.diagnostic_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [diagnostic_info][crate::model::QueryResult::diagnostic_info].
    pub fn set_or_clear_diagnostic_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.diagnostic_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sentiment_analysis_result][crate::model::QueryResult::sentiment_analysis_result].
    pub fn set_sentiment_analysis_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SentimentAnalysisResult>,
    {
        self.sentiment_analysis_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sentiment_analysis_result][crate::model::QueryResult::sentiment_analysis_result].
    pub fn set_or_clear_sentiment_analysis_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SentimentAnalysisResult>,
    {
        self.sentiment_analysis_result = v.map(|x| x.into());
        self
    }

    /// Sets the value of [advanced_settings][crate::model::QueryResult::advanced_settings].
    pub fn set_advanced_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedSettings>,
    {
        self.advanced_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [advanced_settings][crate::model::QueryResult::advanced_settings].
    pub fn set_or_clear_advanced_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedSettings>,
    {
        self.advanced_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_answer_feedback][crate::model::QueryResult::allow_answer_feedback].
    pub fn set_allow_answer_feedback<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_answer_feedback = v.into();
        self
    }

    /// Sets the value of [data_store_connection_signals][crate::model::QueryResult::data_store_connection_signals].
    pub fn set_data_store_connection_signals<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataStoreConnectionSignals>,
    {
        self.data_store_connection_signals = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_store_connection_signals][crate::model::QueryResult::data_store_connection_signals].
    pub fn set_or_clear_data_store_connection_signals<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::DataStoreConnectionSignals>,
    {
        self.data_store_connection_signals = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query][crate::model::QueryResult::query].
    ///
    /// Note that all the setters affecting `query` are mutually
    /// exclusive.
    pub fn set_query<
        T: std::convert::Into<std::option::Option<crate::model::query_result::Query>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.query = v.into();
        self
    }

    /// The value of [query][crate::model::QueryResult::query]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.query.as_ref().and_then(|v| match v {
            crate::model::query_result::Query::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [query][crate::model::QueryResult::query]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `query` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = std::option::Option::Some(crate::model::query_result::Query::Text(v.into()));
        self
    }

    /// The value of [query][crate::model::QueryResult::query]
    /// if it holds a `TriggerIntent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn trigger_intent(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.query.as_ref().and_then(|v| match v {
            crate::model::query_result::Query::TriggerIntent(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [query][crate::model::QueryResult::query]
    /// to hold a `TriggerIntent`.
    ///
    /// Note that all the setters affecting `query` are
    /// mutually exclusive.
    pub fn set_trigger_intent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query =
            std::option::Option::Some(crate::model::query_result::Query::TriggerIntent(v.into()));
        self
    }

    /// The value of [query][crate::model::QueryResult::query]
    /// if it holds a `Transcript`, `None` if the field is not set or
    /// holds a different branch.
    pub fn transcript(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.query.as_ref().and_then(|v| match v {
            crate::model::query_result::Query::Transcript(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [query][crate::model::QueryResult::query]
    /// to hold a `Transcript`.
    ///
    /// Note that all the setters affecting `query` are
    /// mutually exclusive.
    pub fn set_transcript<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query =
            std::option::Option::Some(crate::model::query_result::Query::Transcript(v.into()));
        self
    }

    /// The value of [query][crate::model::QueryResult::query]
    /// if it holds a `TriggerEvent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn trigger_event(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.query.as_ref().and_then(|v| match v {
            crate::model::query_result::Query::TriggerEvent(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [query][crate::model::QueryResult::query]
    /// to hold a `TriggerEvent`.
    ///
    /// Note that all the setters affecting `query` are
    /// mutually exclusive.
    pub fn set_trigger_event<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query =
            std::option::Option::Some(crate::model::query_result::Query::TriggerEvent(v.into()));
        self
    }

    /// The value of [query][crate::model::QueryResult::query]
    /// if it holds a `Dtmf`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dtmf(&self) -> std::option::Option<&std::boxed::Box<crate::model::DtmfInput>> {
        #[allow(unreachable_patterns)]
        self.query.as_ref().and_then(|v| match v {
            crate::model::query_result::Query::Dtmf(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [query][crate::model::QueryResult::query]
    /// to hold a `Dtmf`.
    ///
    /// Note that all the setters affecting `query` are
    /// mutually exclusive.
    pub fn set_dtmf<T: std::convert::Into<std::boxed::Box<crate::model::DtmfInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.query = std::option::Option::Some(crate::model::query_result::Query::Dtmf(v.into()));
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for QueryResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.QueryResult"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __trigger_intent,
            __transcript,
            __trigger_event,
            __dtmf,
            __language_code,
            __parameters,
            __response_messages,
            __webhook_ids,
            __webhook_display_names,
            __webhook_latencies,
            __webhook_tags,
            __webhook_statuses,
            __webhook_payloads,
            __current_page,
            __current_flow,
            __intent,
            __intent_detection_confidence,
            __match,
            __diagnostic_info,
            __sentiment_analysis_result,
            __advanced_settings,
            __allow_answer_feedback,
            __data_store_connection_signals,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "triggerIntent" => Ok(__FieldTag::__trigger_intent),
                            "trigger_intent" => Ok(__FieldTag::__trigger_intent),
                            "transcript" => Ok(__FieldTag::__transcript),
                            "triggerEvent" => Ok(__FieldTag::__trigger_event),
                            "trigger_event" => Ok(__FieldTag::__trigger_event),
                            "dtmf" => Ok(__FieldTag::__dtmf),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "parameters" => Ok(__FieldTag::__parameters),
                            "responseMessages" => Ok(__FieldTag::__response_messages),
                            "response_messages" => Ok(__FieldTag::__response_messages),
                            "webhookIds" => Ok(__FieldTag::__webhook_ids),
                            "webhook_ids" => Ok(__FieldTag::__webhook_ids),
                            "webhookDisplayNames" => Ok(__FieldTag::__webhook_display_names),
                            "webhook_display_names" => Ok(__FieldTag::__webhook_display_names),
                            "webhookLatencies" => Ok(__FieldTag::__webhook_latencies),
                            "webhook_latencies" => Ok(__FieldTag::__webhook_latencies),
                            "webhookTags" => Ok(__FieldTag::__webhook_tags),
                            "webhook_tags" => Ok(__FieldTag::__webhook_tags),
                            "webhookStatuses" => Ok(__FieldTag::__webhook_statuses),
                            "webhook_statuses" => Ok(__FieldTag::__webhook_statuses),
                            "webhookPayloads" => Ok(__FieldTag::__webhook_payloads),
                            "webhook_payloads" => Ok(__FieldTag::__webhook_payloads),
                            "currentPage" => Ok(__FieldTag::__current_page),
                            "current_page" => Ok(__FieldTag::__current_page),
                            "currentFlow" => Ok(__FieldTag::__current_flow),
                            "current_flow" => Ok(__FieldTag::__current_flow),
                            "intent" => Ok(__FieldTag::__intent),
                            "intentDetectionConfidence" => {
                                Ok(__FieldTag::__intent_detection_confidence)
                            }
                            "intent_detection_confidence" => {
                                Ok(__FieldTag::__intent_detection_confidence)
                            }
                            "match" => Ok(__FieldTag::__match),
                            "diagnosticInfo" => Ok(__FieldTag::__diagnostic_info),
                            "diagnostic_info" => Ok(__FieldTag::__diagnostic_info),
                            "sentimentAnalysisResult" => {
                                Ok(__FieldTag::__sentiment_analysis_result)
                            }
                            "sentiment_analysis_result" => {
                                Ok(__FieldTag::__sentiment_analysis_result)
                            }
                            "advancedSettings" => Ok(__FieldTag::__advanced_settings),
                            "advanced_settings" => Ok(__FieldTag::__advanced_settings),
                            "allowAnswerFeedback" => Ok(__FieldTag::__allow_answer_feedback),
                            "allow_answer_feedback" => Ok(__FieldTag::__allow_answer_feedback),
                            "dataStoreConnectionSignals" => {
                                Ok(__FieldTag::__data_store_connection_signals)
                            }
                            "data_store_connection_signals" => {
                                Ok(__FieldTag::__data_store_connection_signals)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            if result.query.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query`, a oneof with full ID .google.cloud.dialogflow.cx.v3.QueryResult.text, latest field was text",
                                ));
                            }
                            result.query =
                                std::option::Option::Some(crate::model::query_result::Query::Text(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__trigger_intent => {
                            if !fields.insert(__FieldTag::__trigger_intent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_intent",
                                ));
                            }
                            if result.query.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query`, a oneof with full ID .google.cloud.dialogflow.cx.v3.QueryResult.trigger_intent, latest field was triggerIntent",
                                ));
                            }
                            result.query = std::option::Option::Some(
                                crate::model::query_result::Query::TriggerIntent(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__transcript => {
                            if !fields.insert(__FieldTag::__transcript) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transcript",
                                ));
                            }
                            if result.query.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query`, a oneof with full ID .google.cloud.dialogflow.cx.v3.QueryResult.transcript, latest field was transcript",
                                ));
                            }
                            result.query = std::option::Option::Some(
                                crate::model::query_result::Query::Transcript(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__trigger_event => {
                            if !fields.insert(__FieldTag::__trigger_event) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_event",
                                ));
                            }
                            if result.query.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query`, a oneof with full ID .google.cloud.dialogflow.cx.v3.QueryResult.trigger_event, latest field was triggerEvent",
                                ));
                            }
                            result.query = std::option::Option::Some(
                                crate::model::query_result::Query::TriggerEvent(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__dtmf => {
                            if !fields.insert(__FieldTag::__dtmf) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dtmf",
                                ));
                            }
                            if result.query.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query`, a oneof with full ID .google.cloud.dialogflow.cx.v3.QueryResult.dtmf, latest field was dtmf",
                                ));
                            }
                            result.query =
                                std::option::Option::Some(crate::model::query_result::Query::Dtmf(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DtmfInput>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__response_messages => {
                            if !fields.insert(__FieldTag::__response_messages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_messages",
                                ));
                            }
                            result.response_messages =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ResponseMessage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__webhook_ids => {
                            if !fields.insert(__FieldTag::__webhook_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_ids",
                                ));
                            }
                            result.webhook_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__webhook_display_names => {
                            if !fields.insert(__FieldTag::__webhook_display_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_display_names",
                                ));
                            }
                            result.webhook_display_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__webhook_latencies => {
                            if !fields.insert(__FieldTag::__webhook_latencies) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_latencies",
                                ));
                            }
                            result.webhook_latencies = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Duration>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__webhook_tags => {
                            if !fields.insert(__FieldTag::__webhook_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_tags",
                                ));
                            }
                            result.webhook_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__webhook_statuses => {
                            if !fields.insert(__FieldTag::__webhook_statuses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_statuses",
                                ));
                            }
                            result.webhook_statuses = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__webhook_payloads => {
                            if !fields.insert(__FieldTag::__webhook_payloads) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_payloads",
                                ));
                            }
                            result.webhook_payloads = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Struct>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__current_page => {
                            if !fields.insert(__FieldTag::__current_page) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_page",
                                ));
                            }
                            result.current_page =
                                map.next_value::<std::option::Option<crate::model::Page>>()?;
                        }
                        __FieldTag::__current_flow => {
                            if !fields.insert(__FieldTag::__current_flow) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_flow",
                                ));
                            }
                            result.current_flow =
                                map.next_value::<std::option::Option<crate::model::Flow>>()?;
                        }
                        __FieldTag::__intent => {
                            if !fields.insert(__FieldTag::__intent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent",
                                ));
                            }
                            result.intent =
                                map.next_value::<std::option::Option<crate::model::Intent>>()?;
                        }
                        __FieldTag::__intent_detection_confidence => {
                            if !fields.insert(__FieldTag::__intent_detection_confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent_detection_confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.intent_detection_confidence =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__match => {
                            if !fields.insert(__FieldTag::__match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for match",
                                ));
                            }
                            result.r#match =
                                map.next_value::<std::option::Option<crate::model::Match>>()?;
                        }
                        __FieldTag::__diagnostic_info => {
                            if !fields.insert(__FieldTag::__diagnostic_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for diagnostic_info",
                                ));
                            }
                            result.diagnostic_info =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__sentiment_analysis_result => {
                            if !fields.insert(__FieldTag::__sentiment_analysis_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sentiment_analysis_result",
                                ));
                            }
                            result.sentiment_analysis_result = map.next_value::<std::option::Option<crate::model::SentimentAnalysisResult>>()?
                                ;
                        }
                        __FieldTag::__advanced_settings => {
                            if !fields.insert(__FieldTag::__advanced_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advanced_settings",
                                ));
                            }
                            result.advanced_settings = map
                                .next_value::<std::option::Option<crate::model::AdvancedSettings>>(
                                )?;
                        }
                        __FieldTag::__allow_answer_feedback => {
                            if !fields.insert(__FieldTag::__allow_answer_feedback) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_answer_feedback",
                                ));
                            }
                            result.allow_answer_feedback = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_store_connection_signals => {
                            if !fields.insert(__FieldTag::__data_store_connection_signals) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_store_connection_signals",
                                ));
                            }
                            result.data_store_connection_signals = map.next_value::<std::option::Option<crate::model::DataStoreConnectionSignals>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for QueryResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.trigger_intent() {
            state.serialize_entry("triggerIntent", value)?;
        }
        if let Some(value) = self.transcript() {
            state.serialize_entry("transcript", value)?;
        }
        if let Some(value) = self.trigger_event() {
            state.serialize_entry("triggerEvent", value)?;
        }
        if let Some(value) = self.dtmf() {
            state.serialize_entry("dtmf", value)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.parameters.is_some() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self.response_messages.is_empty() {
            state.serialize_entry("responseMessages", &self.response_messages)?;
        }
        if !self.webhook_ids.is_empty() {
            state.serialize_entry("webhookIds", &self.webhook_ids)?;
        }
        if !self.webhook_display_names.is_empty() {
            state.serialize_entry("webhookDisplayNames", &self.webhook_display_names)?;
        }
        if !self.webhook_latencies.is_empty() {
            state.serialize_entry("webhookLatencies", &self.webhook_latencies)?;
        }
        if !self.webhook_tags.is_empty() {
            state.serialize_entry("webhookTags", &self.webhook_tags)?;
        }
        if !self.webhook_statuses.is_empty() {
            state.serialize_entry("webhookStatuses", &self.webhook_statuses)?;
        }
        if !self.webhook_payloads.is_empty() {
            state.serialize_entry("webhookPayloads", &self.webhook_payloads)?;
        }
        if self.current_page.is_some() {
            state.serialize_entry("currentPage", &self.current_page)?;
        }
        if self.current_flow.is_some() {
            state.serialize_entry("currentFlow", &self.current_flow)?;
        }
        if self.intent.is_some() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !wkt::internal::is_default(&self.intent_detection_confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "intentDetectionConfidence",
                &__With(&self.intent_detection_confidence),
            )?;
        }
        if self.r#match.is_some() {
            state.serialize_entry("match", &self.r#match)?;
        }
        if self.diagnostic_info.is_some() {
            state.serialize_entry("diagnosticInfo", &self.diagnostic_info)?;
        }
        if self.sentiment_analysis_result.is_some() {
            state.serialize_entry("sentimentAnalysisResult", &self.sentiment_analysis_result)?;
        }
        if self.advanced_settings.is_some() {
            state.serialize_entry("advancedSettings", &self.advanced_settings)?;
        }
        if !wkt::internal::is_default(&self.allow_answer_feedback) {
            state.serialize_entry("allowAnswerFeedback", &self.allow_answer_feedback)?;
        }
        if self.data_store_connection_signals.is_some() {
            state.serialize_entry(
                "dataStoreConnectionSignals",
                &self.data_store_connection_signals,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [QueryResult].
#[cfg(feature = "sessions")]
pub mod query_result {
    #[allow(unused_imports)]
    use super::*;

    /// The original conversational query.
    #[cfg(feature = "sessions")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Query {
        /// If [natural language text][google.cloud.dialogflow.cx.v3.TextInput] was
        /// provided as input, this field will contain a copy of the text.
        ///
        /// [google.cloud.dialogflow.cx.v3.TextInput]: crate::model::TextInput
        Text(std::string::String),
        /// If an [intent][google.cloud.dialogflow.cx.v3.IntentInput] was provided as
        /// input, this field will contain a copy of the intent identifier. Format:
        /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/intents/<IntentID>`.
        ///
        /// [google.cloud.dialogflow.cx.v3.IntentInput]: crate::model::IntentInput
        TriggerIntent(std::string::String),
        /// If [natural language speech
        /// audio][google.cloud.dialogflow.cx.v3.AudioInput] was provided as input,
        /// this field will contain the transcript for the audio.
        ///
        /// [google.cloud.dialogflow.cx.v3.AudioInput]: crate::model::AudioInput
        Transcript(std::string::String),
        /// If an [event][google.cloud.dialogflow.cx.v3.EventInput] was provided as
        /// input, this field will contain the name of the event.
        ///
        /// [google.cloud.dialogflow.cx.v3.EventInput]: crate::model::EventInput
        TriggerEvent(std::string::String),
        /// If a [DTMF][google.cloud.dialogflow.cx.v3.DtmfInput] was provided as
        /// input, this field will contain a copy of the
        /// [DtmfInput][google.cloud.dialogflow.cx.v3.DtmfInput].
        ///
        /// [google.cloud.dialogflow.cx.v3.DtmfInput]: crate::model::DtmfInput
        Dtmf(std::boxed::Box<crate::model::DtmfInput>),
    }
}

/// Represents the natural language text to be processed.
#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TextInput {
    /// Required. The UTF-8 encoded natural language text to be processed.
    pub text: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl TextInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [text][crate::model::TextInput::text].
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.text = v.into();
        self
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl wkt::message::Message for TextInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.TextInput"
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TextInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TextInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TextInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TextInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            result.text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for TextInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the intent to trigger programmatically rather than as a result of
/// natural language processing.
#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct IntentInput {
    /// Required. The unique identifier of the intent.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/intents/<IntentID>`.
    pub intent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl IntentInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [intent][crate::model::IntentInput::intent].
    pub fn set_intent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.intent = v.into();
        self
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl wkt::message::Message for IntentInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.IntentInput"
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IntentInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __intent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IntentInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "intent" => Ok(__FieldTag::__intent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IntentInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IntentInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__intent => {
                            if !fields.insert(__FieldTag::__intent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent",
                                ));
                            }
                            result.intent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for IntentInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.intent.is_empty() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the natural speech audio to be processed.
#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AudioInput {
    /// Required. Instructs the speech recognizer how to process the speech audio.
    pub config: std::option::Option<crate::model::InputAudioConfig>,

    /// The natural language speech audio to be processed.
    /// A single request can contain up to 2 minutes of speech audio data.
    /// The [transcribed
    /// text][google.cloud.dialogflow.cx.v3.QueryResult.transcript] cannot contain
    /// more than 256 bytes.
    ///
    /// For non-streaming audio detect intent, both `config` and `audio` must be
    /// provided.
    /// For streaming audio detect intent, `config` must be provided in
    /// the first request and `audio` must be provided in all following requests.
    ///
    /// [google.cloud.dialogflow.cx.v3.QueryResult.transcript]: crate::model::QueryResult::query
    pub audio: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl AudioInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::AudioInput::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InputAudioConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::AudioInput::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InputAudioConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [audio][crate::model::AudioInput::audio].
    pub fn set_audio<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.audio = v.into();
        self
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl wkt::message::Message for AudioInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.AudioInput"
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AudioInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __config,
            __audio,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AudioInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "config" => Ok(__FieldTag::__config),
                            "audio" => Ok(__FieldTag::__audio),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AudioInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AudioInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<crate::model::InputAudioConfig>>(
                                )?;
                        }
                        __FieldTag::__audio => {
                            if !fields.insert(__FieldTag::__audio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.audio = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for AudioInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if !self.audio.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("audio", &__With(&self.audio))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the event to trigger.
#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EventInput {
    /// Name of the event.
    pub event: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl EventInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [event][crate::model::EventInput::event].
    pub fn set_event<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.event = v.into();
        self
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl wkt::message::Message for EventInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.EventInput"
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EventInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __event,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EventInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "event" => Ok(__FieldTag::__event),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EventInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EventInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__event => {
                            if !fields.insert(__FieldTag::__event) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event",
                                ));
                            }
                            result.event = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for EventInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.event.is_empty() {
            state.serialize_entry("event", &self.event)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the input for dtmf event.
#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DtmfInput {
    /// The dtmf digits.
    pub digits: std::string::String,

    /// The finish digit (if any).
    pub finish_digit: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl DtmfInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [digits][crate::model::DtmfInput::digits].
    pub fn set_digits<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.digits = v.into();
        self
    }

    /// Sets the value of [finish_digit][crate::model::DtmfInput::finish_digit].
    pub fn set_finish_digit<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.finish_digit = v.into();
        self
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl wkt::message::Message for DtmfInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DtmfInput"
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DtmfInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __digits,
            __finish_digit,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DtmfInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "digits" => Ok(__FieldTag::__digits),
                            "finishDigit" => Ok(__FieldTag::__finish_digit),
                            "finish_digit" => Ok(__FieldTag::__finish_digit),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DtmfInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DtmfInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__digits => {
                            if !fields.insert(__FieldTag::__digits) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for digits",
                                ));
                            }
                            result.digits = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__finish_digit => {
                            if !fields.insert(__FieldTag::__finish_digit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finish_digit",
                                ));
                            }
                            result.finish_digit = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for DtmfInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.digits.is_empty() {
            state.serialize_entry("digits", &self.digits)?;
        }
        if !self.finish_digit.is_empty() {
            state.serialize_entry("finishDigit", &self.finish_digit)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents one match result of [MatchIntent][].
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Match {
    /// The [Intent][google.cloud.dialogflow.cx.v3.Intent] that matched the query.
    /// Some, not all fields are filled in this message, including but not limited
    /// to: `name` and `display_name`. Only filled for
    /// [`INTENT`][google.cloud.dialogflow.cx.v3.Match.MatchType] match type.
    ///
    /// [google.cloud.dialogflow.cx.v3.Intent]: crate::model::Intent
    /// [google.cloud.dialogflow.cx.v3.Match.MatchType]: crate::model::r#match::MatchType
    pub intent: std::option::Option<crate::model::Intent>,

    /// The event that matched the query. Filled for
    /// [`EVENT`][google.cloud.dialogflow.cx.v3.Match.MatchType],
    /// [`NO_MATCH`][google.cloud.dialogflow.cx.v3.Match.MatchType] and
    /// [`NO_INPUT`][google.cloud.dialogflow.cx.v3.Match.MatchType] match types.
    ///
    /// [google.cloud.dialogflow.cx.v3.Match.MatchType]: crate::model::r#match::MatchType
    pub event: std::string::String,

    /// The collection of parameters extracted from the query.
    ///
    /// Depending on your protocol or client library language, this is a
    /// map, associative array, symbol table, dictionary, or JSON object
    /// composed of a collection of (MapKey, MapValue) pairs:
    ///
    /// * MapKey type: string
    /// * MapKey value: parameter name
    /// * MapValue type: If parameter's entity type is a composite entity then use
    ///   map, otherwise, depending on the parameter value type, it could be one of
    ///   string, number, boolean, null, list or map.
    /// * MapValue value: If parameter's entity type is a composite entity then use
    ///   map from composite entity property names to property values, otherwise,
    ///   use parameter value.
    pub parameters: std::option::Option<wkt::Struct>,

    /// Final text input which was matched during MatchIntent. This value can be
    /// different from original input sent in request because of spelling
    /// correction or other processing.
    pub resolved_input: std::string::String,

    /// Type of this [Match][google.cloud.dialogflow.cx.v3.Match].
    ///
    /// [google.cloud.dialogflow.cx.v3.Match]: crate::model::Match
    pub match_type: crate::model::r#match::MatchType,

    /// The confidence of this match. Values range from 0.0 (completely uncertain)
    /// to 1.0 (completely certain).
    /// This value is for informational purpose only and is only used to help match
    /// the best intent within the classification threshold. This value may change
    /// for the same end-user expression at any time due to a model retraining or
    /// change in implementation.
    pub confidence: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl Match {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [intent][crate::model::Match::intent].
    pub fn set_intent<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Intent>,
    {
        self.intent = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [intent][crate::model::Match::intent].
    pub fn set_or_clear_intent<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Intent>,
    {
        self.intent = v.map(|x| x.into());
        self
    }

    /// Sets the value of [event][crate::model::Match::event].
    pub fn set_event<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.event = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::Match::parameters].
    pub fn set_parameters<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.parameters = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [parameters][crate::model::Match::parameters].
    pub fn set_or_clear_parameters<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.parameters = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resolved_input][crate::model::Match::resolved_input].
    pub fn set_resolved_input<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resolved_input = v.into();
        self
    }

    /// Sets the value of [match_type][crate::model::Match::match_type].
    pub fn set_match_type<T: std::convert::Into<crate::model::r#match::MatchType>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_type = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::Match::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for Match {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.Match"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Match {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __intent,
            __event,
            __parameters,
            __resolved_input,
            __match_type,
            __confidence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Match")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "intent" => Ok(__FieldTag::__intent),
                            "event" => Ok(__FieldTag::__event),
                            "parameters" => Ok(__FieldTag::__parameters),
                            "resolvedInput" => Ok(__FieldTag::__resolved_input),
                            "resolved_input" => Ok(__FieldTag::__resolved_input),
                            "matchType" => Ok(__FieldTag::__match_type),
                            "match_type" => Ok(__FieldTag::__match_type),
                            "confidence" => Ok(__FieldTag::__confidence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Match;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Match")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__intent => {
                            if !fields.insert(__FieldTag::__intent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent",
                                ));
                            }
                            result.intent =
                                map.next_value::<std::option::Option<crate::model::Intent>>()?;
                        }
                        __FieldTag::__event => {
                            if !fields.insert(__FieldTag::__event) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event",
                                ));
                            }
                            result.event = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__resolved_input => {
                            if !fields.insert(__FieldTag::__resolved_input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resolved_input",
                                ));
                            }
                            result.resolved_input = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__match_type => {
                            if !fields.insert(__FieldTag::__match_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for match_type",
                                ));
                            }
                            result.match_type = map.next_value::<std::option::Option<crate::model::r#match::MatchType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for Match {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.intent.is_some() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !self.event.is_empty() {
            state.serialize_entry("event", &self.event)?;
        }
        if self.parameters.is_some() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self.resolved_input.is_empty() {
            state.serialize_entry("resolvedInput", &self.resolved_input)?;
        }
        if !wkt::internal::is_default(&self.match_type) {
            state.serialize_entry("matchType", &self.match_type)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Match].
#[cfg(feature = "sessions")]
pub mod r#match {
    #[allow(unused_imports)]
    use super::*;

    /// Type of a Match.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "sessions")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MatchType {
        /// Not specified. Should never be used.
        Unspecified,
        /// The query was matched to an intent.
        Intent,
        /// The query directly triggered an intent.
        DirectIntent,
        /// The query was used for parameter filling.
        ParameterFilling,
        /// No match was found for the query.
        NoMatch,
        /// Indicates an empty query.
        NoInput,
        /// The query directly triggered an event.
        Event,
        /// The query was matched to a Knowledge Connector answer.
        KnowledgeConnector,
        /// The query was handled by a [`Playbook`][Playbook].
        Playbook,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MatchType::value] or
        /// [MatchType::name].
        UnknownValue(match_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "sessions")]
    pub mod match_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "sessions")]
    impl MatchType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Intent => std::option::Option::Some(1),
                Self::DirectIntent => std::option::Option::Some(2),
                Self::ParameterFilling => std::option::Option::Some(3),
                Self::NoMatch => std::option::Option::Some(4),
                Self::NoInput => std::option::Option::Some(5),
                Self::Event => std::option::Option::Some(6),
                Self::KnowledgeConnector => std::option::Option::Some(8),
                Self::Playbook => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MATCH_TYPE_UNSPECIFIED"),
                Self::Intent => std::option::Option::Some("INTENT"),
                Self::DirectIntent => std::option::Option::Some("DIRECT_INTENT"),
                Self::ParameterFilling => std::option::Option::Some("PARAMETER_FILLING"),
                Self::NoMatch => std::option::Option::Some("NO_MATCH"),
                Self::NoInput => std::option::Option::Some("NO_INPUT"),
                Self::Event => std::option::Option::Some("EVENT"),
                Self::KnowledgeConnector => std::option::Option::Some("KNOWLEDGE_CONNECTOR"),
                Self::Playbook => std::option::Option::Some("PLAYBOOK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "sessions")]
    impl std::default::Default for MatchType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "sessions")]
    impl std::fmt::Display for MatchType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "sessions")]
    impl std::convert::From<i32> for MatchType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Intent,
                2 => Self::DirectIntent,
                3 => Self::ParameterFilling,
                4 => Self::NoMatch,
                5 => Self::NoInput,
                6 => Self::Event,
                8 => Self::KnowledgeConnector,
                9 => Self::Playbook,
                _ => Self::UnknownValue(match_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "sessions")]
    impl std::convert::From<&str> for MatchType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MATCH_TYPE_UNSPECIFIED" => Self::Unspecified,
                "INTENT" => Self::Intent,
                "DIRECT_INTENT" => Self::DirectIntent,
                "PARAMETER_FILLING" => Self::ParameterFilling,
                "NO_MATCH" => Self::NoMatch,
                "NO_INPUT" => Self::NoInput,
                "EVENT" => Self::Event,
                "KNOWLEDGE_CONNECTOR" => Self::KnowledgeConnector,
                "PLAYBOOK" => Self::Playbook,
                _ => Self::UnknownValue(match_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "sessions")]
    impl serde::ser::Serialize for MatchType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Intent => serializer.serialize_i32(1),
                Self::DirectIntent => serializer.serialize_i32(2),
                Self::ParameterFilling => serializer.serialize_i32(3),
                Self::NoMatch => serializer.serialize_i32(4),
                Self::NoInput => serializer.serialize_i32(5),
                Self::Event => serializer.serialize_i32(6),
                Self::KnowledgeConnector => serializer.serialize_i32(8),
                Self::Playbook => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "sessions")]
    impl<'de> serde::de::Deserialize<'de> for MatchType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MatchType>::new(
                ".google.cloud.dialogflow.cx.v3.Match.MatchType",
            ))
        }
    }
}

/// Request of [MatchIntent][].
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MatchIntentRequest {
    /// Required. The name of the session this query is sent to.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/sessions/<SessionID>`
    /// or
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>/sessions/<SessionID>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment.
    /// It's up to the API caller to choose an appropriate `Session ID`. It can be
    /// a random number or some type of session identifiers (preferably hashed).
    /// The length of the `Session ID` must not exceed 36 characters.
    ///
    /// For more information, see the [sessions
    /// guide](https://cloud.google.com/dialogflow/cx/docs/concept/session).
    pub session: std::string::String,

    /// The parameters of this query.
    pub query_params: std::option::Option<crate::model::QueryParameters>,

    /// Required. The input specification.
    pub query_input: std::option::Option<crate::model::QueryInput>,

    /// Persist session parameter changes from `query_params`.
    pub persist_parameter_changes: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl MatchIntentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session][crate::model::MatchIntentRequest::session].
    pub fn set_session<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session = v.into();
        self
    }

    /// Sets the value of [query_params][crate::model::MatchIntentRequest::query_params].
    pub fn set_query_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameters>,
    {
        self.query_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_params][crate::model::MatchIntentRequest::query_params].
    pub fn set_or_clear_query_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameters>,
    {
        self.query_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query_input][crate::model::MatchIntentRequest::query_input].
    pub fn set_query_input<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryInput>,
    {
        self.query_input = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_input][crate::model::MatchIntentRequest::query_input].
    pub fn set_or_clear_query_input<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryInput>,
    {
        self.query_input = v.map(|x| x.into());
        self
    }

    /// Sets the value of [persist_parameter_changes][crate::model::MatchIntentRequest::persist_parameter_changes].
    pub fn set_persist_parameter_changes<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.persist_parameter_changes = v.into();
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for MatchIntentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.MatchIntentRequest"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MatchIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session,
            __query_params,
            __query_input,
            __persist_parameter_changes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MatchIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "session" => Ok(__FieldTag::__session),
                            "queryParams" => Ok(__FieldTag::__query_params),
                            "query_params" => Ok(__FieldTag::__query_params),
                            "queryInput" => Ok(__FieldTag::__query_input),
                            "query_input" => Ok(__FieldTag::__query_input),
                            "persistParameterChanges" => {
                                Ok(__FieldTag::__persist_parameter_changes)
                            }
                            "persist_parameter_changes" => {
                                Ok(__FieldTag::__persist_parameter_changes)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MatchIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MatchIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session => {
                            if !fields.insert(__FieldTag::__session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session",
                                ));
                            }
                            result.session = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_params => {
                            if !fields.insert(__FieldTag::__query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_params",
                                ));
                            }
                            result.query_params = map
                                .next_value::<std::option::Option<crate::model::QueryParameters>>(
                                )?;
                        }
                        __FieldTag::__query_input => {
                            if !fields.insert(__FieldTag::__query_input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_input",
                                ));
                            }
                            result.query_input =
                                map.next_value::<std::option::Option<crate::model::QueryInput>>()?;
                        }
                        __FieldTag::__persist_parameter_changes => {
                            if !fields.insert(__FieldTag::__persist_parameter_changes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for persist_parameter_changes",
                                ));
                            }
                            result.persist_parameter_changes = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for MatchIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if self.query_params.is_some() {
            state.serialize_entry("queryParams", &self.query_params)?;
        }
        if self.query_input.is_some() {
            state.serialize_entry("queryInput", &self.query_input)?;
        }
        if !wkt::internal::is_default(&self.persist_parameter_changes) {
            state.serialize_entry("persistParameterChanges", &self.persist_parameter_changes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response of [MatchIntent][].
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MatchIntentResponse {
    /// Match results, if more than one, ordered descendingly by the confidence
    /// we have that the particular intent matches the query.
    pub matches: std::vec::Vec<crate::model::Match>,

    /// The current [Page][google.cloud.dialogflow.cx.v3.Page]. Some, not all
    /// fields are filled in this message, including but not limited to `name` and
    /// `display_name`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Page]: crate::model::Page
    pub current_page: std::option::Option<crate::model::Page>,

    /// The original conversational query.
    pub query: std::option::Option<crate::model::match_intent_response::Query>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl MatchIntentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [matches][crate::model::MatchIntentResponse::matches].
    pub fn set_matches<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Match>,
    {
        use std::iter::Iterator;
        self.matches = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [current_page][crate::model::MatchIntentResponse::current_page].
    pub fn set_current_page<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Page>,
    {
        self.current_page = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [current_page][crate::model::MatchIntentResponse::current_page].
    pub fn set_or_clear_current_page<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Page>,
    {
        self.current_page = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query][crate::model::MatchIntentResponse::query].
    ///
    /// Note that all the setters affecting `query` are mutually
    /// exclusive.
    pub fn set_query<
        T: std::convert::Into<std::option::Option<crate::model::match_intent_response::Query>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.query = v.into();
        self
    }

    /// The value of [query][crate::model::MatchIntentResponse::query]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.query.as_ref().and_then(|v| match v {
            crate::model::match_intent_response::Query::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [query][crate::model::MatchIntentResponse::query]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `query` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query =
            std::option::Option::Some(crate::model::match_intent_response::Query::Text(v.into()));
        self
    }

    /// The value of [query][crate::model::MatchIntentResponse::query]
    /// if it holds a `TriggerIntent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn trigger_intent(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.query.as_ref().and_then(|v| match v {
            crate::model::match_intent_response::Query::TriggerIntent(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [query][crate::model::MatchIntentResponse::query]
    /// to hold a `TriggerIntent`.
    ///
    /// Note that all the setters affecting `query` are
    /// mutually exclusive.
    pub fn set_trigger_intent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = std::option::Option::Some(
            crate::model::match_intent_response::Query::TriggerIntent(v.into()),
        );
        self
    }

    /// The value of [query][crate::model::MatchIntentResponse::query]
    /// if it holds a `Transcript`, `None` if the field is not set or
    /// holds a different branch.
    pub fn transcript(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.query.as_ref().and_then(|v| match v {
            crate::model::match_intent_response::Query::Transcript(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [query][crate::model::MatchIntentResponse::query]
    /// to hold a `Transcript`.
    ///
    /// Note that all the setters affecting `query` are
    /// mutually exclusive.
    pub fn set_transcript<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = std::option::Option::Some(
            crate::model::match_intent_response::Query::Transcript(v.into()),
        );
        self
    }

    /// The value of [query][crate::model::MatchIntentResponse::query]
    /// if it holds a `TriggerEvent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn trigger_event(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.query.as_ref().and_then(|v| match v {
            crate::model::match_intent_response::Query::TriggerEvent(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [query][crate::model::MatchIntentResponse::query]
    /// to hold a `TriggerEvent`.
    ///
    /// Note that all the setters affecting `query` are
    /// mutually exclusive.
    pub fn set_trigger_event<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = std::option::Option::Some(
            crate::model::match_intent_response::Query::TriggerEvent(v.into()),
        );
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for MatchIntentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.MatchIntentResponse"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MatchIntentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __trigger_intent,
            __transcript,
            __trigger_event,
            __matches,
            __current_page,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MatchIntentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "triggerIntent" => Ok(__FieldTag::__trigger_intent),
                            "trigger_intent" => Ok(__FieldTag::__trigger_intent),
                            "transcript" => Ok(__FieldTag::__transcript),
                            "triggerEvent" => Ok(__FieldTag::__trigger_event),
                            "trigger_event" => Ok(__FieldTag::__trigger_event),
                            "matches" => Ok(__FieldTag::__matches),
                            "currentPage" => Ok(__FieldTag::__current_page),
                            "current_page" => Ok(__FieldTag::__current_page),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MatchIntentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MatchIntentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            if result.query.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query`, a oneof with full ID .google.cloud.dialogflow.cx.v3.MatchIntentResponse.text, latest field was text",
                                ));
                            }
                            result.query = std::option::Option::Some(
                                crate::model::match_intent_response::Query::Text(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__trigger_intent => {
                            if !fields.insert(__FieldTag::__trigger_intent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_intent",
                                ));
                            }
                            if result.query.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query`, a oneof with full ID .google.cloud.dialogflow.cx.v3.MatchIntentResponse.trigger_intent, latest field was triggerIntent",
                                ));
                            }
                            result.query = std::option::Option::Some(
                                crate::model::match_intent_response::Query::TriggerIntent(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__transcript => {
                            if !fields.insert(__FieldTag::__transcript) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transcript",
                                ));
                            }
                            if result.query.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query`, a oneof with full ID .google.cloud.dialogflow.cx.v3.MatchIntentResponse.transcript, latest field was transcript",
                                ));
                            }
                            result.query = std::option::Option::Some(
                                crate::model::match_intent_response::Query::Transcript(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__trigger_event => {
                            if !fields.insert(__FieldTag::__trigger_event) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_event",
                                ));
                            }
                            if result.query.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query`, a oneof with full ID .google.cloud.dialogflow.cx.v3.MatchIntentResponse.trigger_event, latest field was triggerEvent",
                                ));
                            }
                            result.query = std::option::Option::Some(
                                crate::model::match_intent_response::Query::TriggerEvent(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__matches => {
                            if !fields.insert(__FieldTag::__matches) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for matches",
                                ));
                            }
                            result.matches = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Match>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__current_page => {
                            if !fields.insert(__FieldTag::__current_page) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_page",
                                ));
                            }
                            result.current_page =
                                map.next_value::<std::option::Option<crate::model::Page>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for MatchIntentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.trigger_intent() {
            state.serialize_entry("triggerIntent", value)?;
        }
        if let Some(value) = self.transcript() {
            state.serialize_entry("transcript", value)?;
        }
        if let Some(value) = self.trigger_event() {
            state.serialize_entry("triggerEvent", value)?;
        }
        if !self.matches.is_empty() {
            state.serialize_entry("matches", &self.matches)?;
        }
        if self.current_page.is_some() {
            state.serialize_entry("currentPage", &self.current_page)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [MatchIntentResponse].
#[cfg(feature = "sessions")]
pub mod match_intent_response {
    #[allow(unused_imports)]
    use super::*;

    /// The original conversational query.
    #[cfg(feature = "sessions")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Query {
        /// If [natural language text][google.cloud.dialogflow.cx.v3.TextInput] was
        /// provided as input, this field will contain a copy of the text.
        ///
        /// [google.cloud.dialogflow.cx.v3.TextInput]: crate::model::TextInput
        Text(std::string::String),
        /// If an [intent][google.cloud.dialogflow.cx.v3.IntentInput] was provided as
        /// input, this field will contain a copy of the intent identifier. Format:
        /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/intents/<IntentID>`.
        ///
        /// [google.cloud.dialogflow.cx.v3.IntentInput]: crate::model::IntentInput
        TriggerIntent(std::string::String),
        /// If [natural language speech
        /// audio][google.cloud.dialogflow.cx.v3.AudioInput] was provided as input,
        /// this field will contain the transcript for the audio.
        ///
        /// [google.cloud.dialogflow.cx.v3.AudioInput]: crate::model::AudioInput
        Transcript(std::string::String),
        /// If an [event][google.cloud.dialogflow.cx.v3.EventInput] was provided as
        /// input, this field will contain a copy of the event name.
        ///
        /// [google.cloud.dialogflow.cx.v3.EventInput]: crate::model::EventInput
        TriggerEvent(std::string::String),
    }
}

/// Request of [FulfillIntent][]
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FulfillIntentRequest {
    /// Must be same as the corresponding MatchIntent request, otherwise the
    /// behavior is undefined.
    pub match_intent_request: std::option::Option<crate::model::MatchIntentRequest>,

    /// The matched intent/event to fulfill.
    pub r#match: std::option::Option<crate::model::Match>,

    /// Instructs the speech synthesizer how to generate output audio.
    pub output_audio_config: std::option::Option<crate::model::OutputAudioConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl FulfillIntentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [match_intent_request][crate::model::FulfillIntentRequest::match_intent_request].
    pub fn set_match_intent_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MatchIntentRequest>,
    {
        self.match_intent_request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [match_intent_request][crate::model::FulfillIntentRequest::match_intent_request].
    pub fn set_or_clear_match_intent_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MatchIntentRequest>,
    {
        self.match_intent_request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#match][crate::model::FulfillIntentRequest::match].
    pub fn set_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Match>,
    {
        self.r#match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#match][crate::model::FulfillIntentRequest::match].
    pub fn set_or_clear_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Match>,
    {
        self.r#match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_audio_config][crate::model::FulfillIntentRequest::output_audio_config].
    pub fn set_output_audio_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.output_audio_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_audio_config][crate::model::FulfillIntentRequest::output_audio_config].
    pub fn set_or_clear_output_audio_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.output_audio_config = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for FulfillIntentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.FulfillIntentRequest"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FulfillIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __match_intent_request,
            __match,
            __output_audio_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FulfillIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "matchIntentRequest" => Ok(__FieldTag::__match_intent_request),
                            "match_intent_request" => Ok(__FieldTag::__match_intent_request),
                            "match" => Ok(__FieldTag::__match),
                            "outputAudioConfig" => Ok(__FieldTag::__output_audio_config),
                            "output_audio_config" => Ok(__FieldTag::__output_audio_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FulfillIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FulfillIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__match_intent_request => {
                            if !fields.insert(__FieldTag::__match_intent_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for match_intent_request",
                                ));
                            }
                            result.match_intent_request = map.next_value::<std::option::Option<crate::model::MatchIntentRequest>>()?
                                ;
                        }
                        __FieldTag::__match => {
                            if !fields.insert(__FieldTag::__match) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for match",
                                ));
                            }
                            result.r#match =
                                map.next_value::<std::option::Option<crate::model::Match>>()?;
                        }
                        __FieldTag::__output_audio_config => {
                            if !fields.insert(__FieldTag::__output_audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_audio_config",
                                ));
                            }
                            result.output_audio_config = map
                                .next_value::<std::option::Option<crate::model::OutputAudioConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for FulfillIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.match_intent_request.is_some() {
            state.serialize_entry("matchIntentRequest", &self.match_intent_request)?;
        }
        if self.r#match.is_some() {
            state.serialize_entry("match", &self.r#match)?;
        }
        if self.output_audio_config.is_some() {
            state.serialize_entry("outputAudioConfig", &self.output_audio_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response of [FulfillIntent][]
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FulfillIntentResponse {
    /// Output only. The unique identifier of the response. It can be used to
    /// locate a response in the training example set or for reporting issues.
    pub response_id: std::string::String,

    /// The result of the conversational query.
    pub query_result: std::option::Option<crate::model::QueryResult>,

    /// The audio data bytes encoded as specified in the request.
    /// Note: The output audio is generated based on the values of default platform
    /// text responses found in the
    /// [`query_result.response_messages`][google.cloud.dialogflow.cx.v3.QueryResult.response_messages]
    /// field. If multiple default text responses exist, they will be concatenated
    /// when generating audio. If no default platform text responses exist, the
    /// generated audio content will be empty.
    ///
    /// In some scenarios, multiple output audio fields may be present in the
    /// response structure. In these cases, only the top-most-level audio output
    /// has content.
    ///
    /// [google.cloud.dialogflow.cx.v3.QueryResult.response_messages]: crate::model::QueryResult::response_messages
    pub output_audio: ::bytes::Bytes,

    /// The config used by the speech synthesizer to generate the output audio.
    pub output_audio_config: std::option::Option<crate::model::OutputAudioConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl FulfillIntentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [response_id][crate::model::FulfillIntentResponse::response_id].
    pub fn set_response_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.response_id = v.into();
        self
    }

    /// Sets the value of [query_result][crate::model::FulfillIntentResponse::query_result].
    pub fn set_query_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryResult>,
    {
        self.query_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_result][crate::model::FulfillIntentResponse::query_result].
    pub fn set_or_clear_query_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryResult>,
    {
        self.query_result = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_audio][crate::model::FulfillIntentResponse::output_audio].
    pub fn set_output_audio<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.output_audio = v.into();
        self
    }

    /// Sets the value of [output_audio_config][crate::model::FulfillIntentResponse::output_audio_config].
    pub fn set_output_audio_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.output_audio_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_audio_config][crate::model::FulfillIntentResponse::output_audio_config].
    pub fn set_or_clear_output_audio_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.output_audio_config = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for FulfillIntentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.FulfillIntentResponse"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FulfillIntentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __response_id,
            __query_result,
            __output_audio,
            __output_audio_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FulfillIntentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "responseId" => Ok(__FieldTag::__response_id),
                            "response_id" => Ok(__FieldTag::__response_id),
                            "queryResult" => Ok(__FieldTag::__query_result),
                            "query_result" => Ok(__FieldTag::__query_result),
                            "outputAudio" => Ok(__FieldTag::__output_audio),
                            "output_audio" => Ok(__FieldTag::__output_audio),
                            "outputAudioConfig" => Ok(__FieldTag::__output_audio_config),
                            "output_audio_config" => Ok(__FieldTag::__output_audio_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FulfillIntentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FulfillIntentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__response_id => {
                            if !fields.insert(__FieldTag::__response_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_id",
                                ));
                            }
                            result.response_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_result => {
                            if !fields.insert(__FieldTag::__query_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_result",
                                ));
                            }
                            result.query_result =
                                map.next_value::<std::option::Option<crate::model::QueryResult>>()?;
                        }
                        __FieldTag::__output_audio => {
                            if !fields.insert(__FieldTag::__output_audio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_audio",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.output_audio = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__output_audio_config => {
                            if !fields.insert(__FieldTag::__output_audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_audio_config",
                                ));
                            }
                            result.output_audio_config = map
                                .next_value::<std::option::Option<crate::model::OutputAudioConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for FulfillIntentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.response_id.is_empty() {
            state.serialize_entry("responseId", &self.response_id)?;
        }
        if self.query_result.is_some() {
            state.serialize_entry("queryResult", &self.query_result)?;
        }
        if !self.output_audio.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("outputAudio", &__With(&self.output_audio))?;
        }
        if self.output_audio_config.is_some() {
            state.serialize_entry("outputAudioConfig", &self.output_audio_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The result of sentiment analysis. Sentiment analysis inspects user input
/// and identifies the prevailing subjective opinion, especially to determine a
/// user's attitude as positive, negative, or neutral.
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SentimentAnalysisResult {
    /// Sentiment score between -1.0 (negative sentiment) and 1.0 (positive
    /// sentiment).
    pub score: f32,

    /// A non-negative number in the [0, +inf) range, which represents the absolute
    /// magnitude of sentiment, regardless of score (positive or negative).
    pub magnitude: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl SentimentAnalysisResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::SentimentAnalysisResult::score].
    pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [magnitude][crate::model::SentimentAnalysisResult::magnitude].
    pub fn set_magnitude<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.magnitude = v.into();
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for SentimentAnalysisResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.SentimentAnalysisResult"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SentimentAnalysisResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __score,
            __magnitude,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SentimentAnalysisResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "score" => Ok(__FieldTag::__score),
                            "magnitude" => Ok(__FieldTag::__magnitude),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SentimentAnalysisResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SentimentAnalysisResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__magnitude => {
                            if !fields.insert(__FieldTag::__magnitude) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for magnitude",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.magnitude = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for SentimentAnalysisResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("score", &__With(&self.score))?;
        }
        if !wkt::internal::is_default(&self.magnitude) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("magnitude", &__With(&self.magnitude))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Session entity types are referred to as **User** entity types and are
/// entities that are built for an individual user such as favorites,
/// preferences, playlists, and so on.
///
/// You can redefine a session entity type at the session level to extend or
/// replace a [custom entity type][google.cloud.dialogflow.cx.v3.EntityType] at
/// the user session level (we refer to the entity types defined at the agent
/// level as "custom entity types").
///
/// Note: session entity types apply to all queries, regardless of the language.
///
/// For more information about entity types, see the [Dialogflow
/// documentation](https://cloud.google.com/dialogflow/docs/entities-overview).
///
/// [google.cloud.dialogflow.cx.v3.EntityType]: crate::model::EntityType
#[cfg(any(feature = "session-entity-types", feature = "sessions",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SessionEntityType {
    /// Required. The unique identifier of the session entity type.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/sessions/<SessionID>/entityTypes/<EntityTypeID>`
    /// or
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>/sessions/<SessionID>/entityTypes/<EntityTypeID>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment.
    pub name: std::string::String,

    /// Required. Indicates whether the additional data should override or
    /// supplement the custom entity type definition.
    pub entity_override_mode: crate::model::session_entity_type::EntityOverrideMode,

    /// Required. The collection of entities to override or supplement the custom
    /// entity type.
    pub entities: std::vec::Vec<crate::model::entity_type::Entity>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "session-entity-types", feature = "sessions",))]
impl SessionEntityType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SessionEntityType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [entity_override_mode][crate::model::SessionEntityType::entity_override_mode].
    pub fn set_entity_override_mode<
        T: std::convert::Into<crate::model::session_entity_type::EntityOverrideMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_override_mode = v.into();
        self
    }

    /// Sets the value of [entities][crate::model::SessionEntityType::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::entity_type::Entity>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(feature = "session-entity-types", feature = "sessions",))]
impl wkt::message::Message for SessionEntityType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.SessionEntityType"
    }
}

#[cfg(any(feature = "session-entity-types", feature = "sessions",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SessionEntityType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __entity_override_mode,
            __entities,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SessionEntityType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "entityOverrideMode" => Ok(__FieldTag::__entity_override_mode),
                            "entity_override_mode" => Ok(__FieldTag::__entity_override_mode),
                            "entities" => Ok(__FieldTag::__entities),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SessionEntityType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SessionEntityType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_override_mode => {
                            if !fields.insert(__FieldTag::__entity_override_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_override_mode",
                                ));
                            }
                            result.entity_override_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::session_entity_type::EntityOverrideMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entities => {
                            if !fields.insert(__FieldTag::__entities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entities",
                                ));
                            }
                            result.entities = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::entity_type::Entity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "session-entity-types", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for SessionEntityType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.entity_override_mode) {
            state.serialize_entry("entityOverrideMode", &self.entity_override_mode)?;
        }
        if !self.entities.is_empty() {
            state.serialize_entry("entities", &self.entities)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SessionEntityType].
#[cfg(any(feature = "session-entity-types", feature = "sessions",))]
pub mod session_entity_type {
    #[allow(unused_imports)]
    use super::*;

    /// The types of modifications for the session entity type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "session-entity-types", feature = "sessions",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EntityOverrideMode {
        /// Not specified. This value should be never used.
        Unspecified,
        /// The collection of session entities overrides the collection of entities
        /// in the corresponding custom entity type.
        Override,
        /// The collection of session entities extends the collection of entities in
        /// the corresponding custom entity type.
        ///
        /// Note: Even in this override mode calls to `ListSessionEntityTypes`,
        /// `GetSessionEntityType`, `CreateSessionEntityType` and
        /// `UpdateSessionEntityType` only return the additional entities added in
        /// this session entity type. If you want to get the supplemented list,
        /// please call
        /// [EntityTypes.GetEntityType][google.cloud.dialogflow.cx.v3.EntityTypes.GetEntityType]
        /// on the custom entity type and merge.
        ///
        /// [google.cloud.dialogflow.cx.v3.EntityTypes.GetEntityType]: crate::client::EntityTypes::get_entity_type
        Supplement,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EntityOverrideMode::value] or
        /// [EntityOverrideMode::name].
        UnknownValue(entity_override_mode::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "session-entity-types", feature = "sessions",))]
    pub mod entity_override_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "session-entity-types", feature = "sessions",))]
    impl EntityOverrideMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Override => std::option::Option::Some(1),
                Self::Supplement => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ENTITY_OVERRIDE_MODE_UNSPECIFIED"),
                Self::Override => std::option::Option::Some("ENTITY_OVERRIDE_MODE_OVERRIDE"),
                Self::Supplement => std::option::Option::Some("ENTITY_OVERRIDE_MODE_SUPPLEMENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "session-entity-types", feature = "sessions",))]
    impl std::default::Default for EntityOverrideMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "session-entity-types", feature = "sessions",))]
    impl std::fmt::Display for EntityOverrideMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "session-entity-types", feature = "sessions",))]
    impl std::convert::From<i32> for EntityOverrideMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Override,
                2 => Self::Supplement,
                _ => Self::UnknownValue(entity_override_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "session-entity-types", feature = "sessions",))]
    impl std::convert::From<&str> for EntityOverrideMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ENTITY_OVERRIDE_MODE_UNSPECIFIED" => Self::Unspecified,
                "ENTITY_OVERRIDE_MODE_OVERRIDE" => Self::Override,
                "ENTITY_OVERRIDE_MODE_SUPPLEMENT" => Self::Supplement,
                _ => Self::UnknownValue(entity_override_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "session-entity-types", feature = "sessions",))]
    impl serde::ser::Serialize for EntityOverrideMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Override => serializer.serialize_i32(1),
                Self::Supplement => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "session-entity-types", feature = "sessions",))]
    impl<'de> serde::de::Deserialize<'de> for EntityOverrideMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EntityOverrideMode>::new(
                ".google.cloud.dialogflow.cx.v3.SessionEntityType.EntityOverrideMode",
            ))
        }
    }
}

/// The request message for
/// [SessionEntityTypes.ListSessionEntityTypes][google.cloud.dialogflow.cx.v3.SessionEntityTypes.ListSessionEntityTypes].
///
/// [google.cloud.dialogflow.cx.v3.SessionEntityTypes.ListSessionEntityTypes]: crate::client::SessionEntityTypes::list_session_entity_types
#[cfg(feature = "session-entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSessionEntityTypesRequest {
    /// Required. The session to list all session entity types from.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/sessions/<SessionID>`
    /// or
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>/sessions/<SessionID>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment.
    pub parent: std::string::String,

    /// The maximum number of items to return in a single page. By default 100 and
    /// at most 1000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "session-entity-types")]
impl ListSessionEntityTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSessionEntityTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSessionEntityTypesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSessionEntityTypesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "session-entity-types")]
impl wkt::message::Message for ListSessionEntityTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListSessionEntityTypesRequest"
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSessionEntityTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSessionEntityTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSessionEntityTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSessionEntityTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for ListSessionEntityTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [SessionEntityTypes.ListSessionEntityTypes][google.cloud.dialogflow.cx.v3.SessionEntityTypes.ListSessionEntityTypes].
///
/// [google.cloud.dialogflow.cx.v3.SessionEntityTypes.ListSessionEntityTypes]: crate::client::SessionEntityTypes::list_session_entity_types
#[cfg(feature = "session-entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSessionEntityTypesResponse {
    /// The list of session entity types. There will be a maximum number of items
    /// returned based on the page_size field in the request.
    pub session_entity_types: std::vec::Vec<crate::model::SessionEntityType>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "session-entity-types")]
impl ListSessionEntityTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session_entity_types][crate::model::ListSessionEntityTypesResponse::session_entity_types].
    pub fn set_session_entity_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SessionEntityType>,
    {
        use std::iter::Iterator;
        self.session_entity_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSessionEntityTypesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "session-entity-types")]
impl wkt::message::Message for ListSessionEntityTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListSessionEntityTypesResponse"
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSessionEntityTypesResponse {
    type PageItem = crate::model::SessionEntityType;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.session_entity_types
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSessionEntityTypesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session_entity_types,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSessionEntityTypesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sessionEntityTypes" => Ok(__FieldTag::__session_entity_types),
                            "session_entity_types" => Ok(__FieldTag::__session_entity_types),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSessionEntityTypesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSessionEntityTypesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session_entity_types => {
                            if !fields.insert(__FieldTag::__session_entity_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_entity_types",
                                ));
                            }
                            result.session_entity_types =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SessionEntityType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for ListSessionEntityTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session_entity_types.is_empty() {
            state.serialize_entry("sessionEntityTypes", &self.session_entity_types)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [SessionEntityTypes.GetSessionEntityType][google.cloud.dialogflow.cx.v3.SessionEntityTypes.GetSessionEntityType].
///
/// [google.cloud.dialogflow.cx.v3.SessionEntityTypes.GetSessionEntityType]: crate::client::SessionEntityTypes::get_session_entity_type
#[cfg(feature = "session-entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSessionEntityTypeRequest {
    /// Required. The name of the session entity type.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/sessions/<SessionID>/entityTypes/<EntityTypeID>`
    /// or
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>/sessions/<SessionID>/entityTypes/<EntityTypeID>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "session-entity-types")]
impl GetSessionEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSessionEntityTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "session-entity-types")]
impl wkt::message::Message for GetSessionEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetSessionEntityTypeRequest"
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSessionEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSessionEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSessionEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSessionEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for GetSessionEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [SessionEntityTypes.CreateSessionEntityType][google.cloud.dialogflow.cx.v3.SessionEntityTypes.CreateSessionEntityType].
///
/// [google.cloud.dialogflow.cx.v3.SessionEntityTypes.CreateSessionEntityType]: crate::client::SessionEntityTypes::create_session_entity_type
#[cfg(feature = "session-entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSessionEntityTypeRequest {
    /// Required. The session to create a session entity type for.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/sessions/<SessionID>`
    /// or
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>/sessions/<SessionID>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment.
    pub parent: std::string::String,

    /// Required. The session entity type to create.
    pub session_entity_type: std::option::Option<crate::model::SessionEntityType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "session-entity-types")]
impl CreateSessionEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSessionEntityTypeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [session_entity_type][crate::model::CreateSessionEntityTypeRequest::session_entity_type].
    pub fn set_session_entity_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SessionEntityType>,
    {
        self.session_entity_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session_entity_type][crate::model::CreateSessionEntityTypeRequest::session_entity_type].
    pub fn set_or_clear_session_entity_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SessionEntityType>,
    {
        self.session_entity_type = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "session-entity-types")]
impl wkt::message::Message for CreateSessionEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CreateSessionEntityTypeRequest"
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSessionEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __session_entity_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSessionEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "sessionEntityType" => Ok(__FieldTag::__session_entity_type),
                            "session_entity_type" => Ok(__FieldTag::__session_entity_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSessionEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSessionEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__session_entity_type => {
                            if !fields.insert(__FieldTag::__session_entity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_entity_type",
                                ));
                            }
                            result.session_entity_type = map
                                .next_value::<std::option::Option<crate::model::SessionEntityType>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateSessionEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.session_entity_type.is_some() {
            state.serialize_entry("sessionEntityType", &self.session_entity_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [SessionEntityTypes.UpdateSessionEntityType][google.cloud.dialogflow.cx.v3.SessionEntityTypes.UpdateSessionEntityType].
///
/// [google.cloud.dialogflow.cx.v3.SessionEntityTypes.UpdateSessionEntityType]: crate::client::SessionEntityTypes::update_session_entity_type
#[cfg(feature = "session-entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSessionEntityTypeRequest {
    /// Required. The session entity type to update.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/sessions/<SessionID>/entityTypes/<EntityTypeID>`
    /// or
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>/sessions/<SessionID>/entityTypes/<EntityTypeID>`.
    /// If `Environment ID` is not specified,
    /// we assume default 'draft' environment.
    pub session_entity_type: std::option::Option<crate::model::SessionEntityType>,

    /// The mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "session-entity-types")]
impl UpdateSessionEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session_entity_type][crate::model::UpdateSessionEntityTypeRequest::session_entity_type].
    pub fn set_session_entity_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SessionEntityType>,
    {
        self.session_entity_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session_entity_type][crate::model::UpdateSessionEntityTypeRequest::session_entity_type].
    pub fn set_or_clear_session_entity_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SessionEntityType>,
    {
        self.session_entity_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSessionEntityTypeRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSessionEntityTypeRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "session-entity-types")]
impl wkt::message::Message for UpdateSessionEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.UpdateSessionEntityTypeRequest"
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSessionEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session_entity_type,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSessionEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sessionEntityType" => Ok(__FieldTag::__session_entity_type),
                            "session_entity_type" => Ok(__FieldTag::__session_entity_type),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSessionEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSessionEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session_entity_type => {
                            if !fields.insert(__FieldTag::__session_entity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_entity_type",
                                ));
                            }
                            result.session_entity_type = map
                                .next_value::<std::option::Option<crate::model::SessionEntityType>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateSessionEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.session_entity_type.is_some() {
            state.serialize_entry("sessionEntityType", &self.session_entity_type)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [SessionEntityTypes.DeleteSessionEntityType][google.cloud.dialogflow.cx.v3.SessionEntityTypes.DeleteSessionEntityType].
///
/// [google.cloud.dialogflow.cx.v3.SessionEntityTypes.DeleteSessionEntityType]: crate::client::SessionEntityTypes::delete_session_entity_type
#[cfg(feature = "session-entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSessionEntityTypeRequest {
    /// Required. The name of the session entity type to delete.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/sessions/<SessionID>/entityTypes/<EntityTypeID>`
    /// or
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>/sessions/<SessionID>/entityTypes/<EntityTypeID>`.
    /// If `Environment ID` is not specified,
    /// we assume default 'draft' environment.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "session-entity-types")]
impl DeleteSessionEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSessionEntityTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "session-entity-types")]
impl wkt::message::Message for DeleteSessionEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DeleteSessionEntityTypeRequest"
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSessionEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSessionEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSessionEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSessionEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteSessionEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a test case.
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TestCase {
    /// The unique identifier of the test case.
    /// [TestCases.CreateTestCase][google.cloud.dialogflow.cx.v3.TestCases.CreateTestCase]
    /// will populate the name automatically. Otherwise use format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/testCases/<TestCaseID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.TestCases.CreateTestCase]: crate::client::TestCases::create_test_case
    pub name: std::string::String,

    /// Tags are short descriptions that users may apply to test cases for
    /// organizational and filtering purposes. Each tag should start with "#" and
    /// has a limit of 30 characters.
    pub tags: std::vec::Vec<std::string::String>,

    /// Required. The human-readable name of the test case, unique within the
    /// agent. Limit of 200 characters.
    pub display_name: std::string::String,

    /// Additional freeform notes about the test case. Limit of 400 characters.
    pub notes: std::string::String,

    /// Config for the test case.
    pub test_config: std::option::Option<crate::model::TestConfig>,

    /// The conversation turns uttered when the test case was created, in
    /// chronological order. These include the canonical set of agent utterances
    /// that should occur when the agent is working properly.
    pub test_case_conversation_turns: std::vec::Vec<crate::model::ConversationTurn>,

    /// Output only. When the test was created.
    pub creation_time: std::option::Option<wkt::Timestamp>,

    /// The latest test result.
    pub last_test_result: std::option::Option<crate::model::TestCaseResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl TestCase {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TestCase::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::TestCase::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [display_name][crate::model::TestCase::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [notes][crate::model::TestCase::notes].
    pub fn set_notes<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.notes = v.into();
        self
    }

    /// Sets the value of [test_config][crate::model::TestCase::test_config].
    pub fn set_test_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TestConfig>,
    {
        self.test_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [test_config][crate::model::TestCase::test_config].
    pub fn set_or_clear_test_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TestConfig>,
    {
        self.test_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [test_case_conversation_turns][crate::model::TestCase::test_case_conversation_turns].
    pub fn set_test_case_conversation_turns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConversationTurn>,
    {
        use std::iter::Iterator;
        self.test_case_conversation_turns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [creation_time][crate::model::TestCase::creation_time].
    pub fn set_creation_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.creation_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_time][crate::model::TestCase::creation_time].
    pub fn set_or_clear_creation_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.creation_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_test_result][crate::model::TestCase::last_test_result].
    pub fn set_last_test_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TestCaseResult>,
    {
        self.last_test_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_test_result][crate::model::TestCase::last_test_result].
    pub fn set_or_clear_last_test_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TestCaseResult>,
    {
        self.last_test_result = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for TestCase {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.TestCase"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TestCase {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __tags,
            __display_name,
            __notes,
            __test_config,
            __test_case_conversation_turns,
            __creation_time,
            __last_test_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TestCase")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "tags" => Ok(__FieldTag::__tags),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "notes" => Ok(__FieldTag::__notes),
                            "testConfig" => Ok(__FieldTag::__test_config),
                            "test_config" => Ok(__FieldTag::__test_config),
                            "testCaseConversationTurns" => {
                                Ok(__FieldTag::__test_case_conversation_turns)
                            }
                            "test_case_conversation_turns" => {
                                Ok(__FieldTag::__test_case_conversation_turns)
                            }
                            "creationTime" => Ok(__FieldTag::__creation_time),
                            "creation_time" => Ok(__FieldTag::__creation_time),
                            "lastTestResult" => Ok(__FieldTag::__last_test_result),
                            "last_test_result" => Ok(__FieldTag::__last_test_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TestCase;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TestCase")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__notes => {
                            if !fields.insert(__FieldTag::__notes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notes",
                                ));
                            }
                            result.notes = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__test_config => {
                            if !fields.insert(__FieldTag::__test_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_config",
                                ));
                            }
                            result.test_config =
                                map.next_value::<std::option::Option<crate::model::TestConfig>>()?;
                        }
                        __FieldTag::__test_case_conversation_turns => {
                            if !fields.insert(__FieldTag::__test_case_conversation_turns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_case_conversation_turns",
                                ));
                            }
                            result.test_case_conversation_turns =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConversationTurn>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__creation_time => {
                            if !fields.insert(__FieldTag::__creation_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creation_time",
                                ));
                            }
                            result.creation_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_test_result => {
                            if !fields.insert(__FieldTag::__last_test_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_test_result",
                                ));
                            }
                            result.last_test_result = map
                                .next_value::<std::option::Option<crate::model::TestCaseResult>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for TestCase {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.notes.is_empty() {
            state.serialize_entry("notes", &self.notes)?;
        }
        if self.test_config.is_some() {
            state.serialize_entry("testConfig", &self.test_config)?;
        }
        if !self.test_case_conversation_turns.is_empty() {
            state.serialize_entry(
                "testCaseConversationTurns",
                &self.test_case_conversation_turns,
            )?;
        }
        if self.creation_time.is_some() {
            state.serialize_entry("creationTime", &self.creation_time)?;
        }
        if self.last_test_result.is_some() {
            state.serialize_entry("lastTestResult", &self.last_test_result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a result from running a test case in an agent environment.
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TestCaseResult {
    /// The resource name for the test case result. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/testCases/<TestCaseID>/results/<TestCaseResultID>`.
    pub name: std::string::String,

    /// Environment where the test was run. If not set, it indicates the draft
    /// environment.
    pub environment: std::string::String,

    /// The conversation turns uttered during the test case replay in chronological
    /// order.
    pub conversation_turns: std::vec::Vec<crate::model::ConversationTurn>,

    /// Whether the test case passed in the agent environment.
    pub test_result: crate::model::TestResult,

    /// The time that the test was run.
    pub test_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl TestCaseResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TestCaseResult::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::TestCaseResult::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [conversation_turns][crate::model::TestCaseResult::conversation_turns].
    pub fn set_conversation_turns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConversationTurn>,
    {
        use std::iter::Iterator;
        self.conversation_turns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [test_result][crate::model::TestCaseResult::test_result].
    pub fn set_test_result<T: std::convert::Into<crate::model::TestResult>>(
        mut self,
        v: T,
    ) -> Self {
        self.test_result = v.into();
        self
    }

    /// Sets the value of [test_time][crate::model::TestCaseResult::test_time].
    pub fn set_test_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.test_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [test_time][crate::model::TestCaseResult::test_time].
    pub fn set_or_clear_test_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.test_time = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for TestCaseResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.TestCaseResult"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TestCaseResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __environment,
            __conversation_turns,
            __test_result,
            __test_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TestCaseResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "environment" => Ok(__FieldTag::__environment),
                            "conversationTurns" => Ok(__FieldTag::__conversation_turns),
                            "conversation_turns" => Ok(__FieldTag::__conversation_turns),
                            "testResult" => Ok(__FieldTag::__test_result),
                            "test_result" => Ok(__FieldTag::__test_result),
                            "testTime" => Ok(__FieldTag::__test_time),
                            "test_time" => Ok(__FieldTag::__test_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TestCaseResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TestCaseResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversation_turns => {
                            if !fields.insert(__FieldTag::__conversation_turns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_turns",
                                ));
                            }
                            result.conversation_turns =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConversationTurn>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__test_result => {
                            if !fields.insert(__FieldTag::__test_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_result",
                                ));
                            }
                            result.test_result = map
                                .next_value::<std::option::Option<crate::model::TestResult>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__test_time => {
                            if !fields.insert(__FieldTag::__test_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_time",
                                ));
                            }
                            result.test_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for TestCaseResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self.conversation_turns.is_empty() {
            state.serialize_entry("conversationTurns", &self.conversation_turns)?;
        }
        if !wkt::internal::is_default(&self.test_result) {
            state.serialize_entry("testResult", &self.test_result)?;
        }
        if self.test_time.is_some() {
            state.serialize_entry("testTime", &self.test_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents configurations for a test case.
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TestConfig {
    /// Session parameters to be compared when calculating differences.
    pub tracking_parameters: std::vec::Vec<std::string::String>,

    /// Flow name to start the test case with.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>`.
    ///
    /// Only one of `flow` and `page` should be set to indicate the starting point
    /// of the test case. If neither is set, the test case will start with start
    /// page on the default start flow.
    pub flow: std::string::String,

    /// The [page][google.cloud.dialogflow.cx.v3.Page] to start the test case with.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/pages/<PageID>`.
    ///
    /// Only one of `flow` and `page` should be set to indicate the starting point
    /// of the test case. If neither is set, the test case will start with start
    /// page on the default start flow.
    ///
    /// [google.cloud.dialogflow.cx.v3.Page]: crate::model::Page
    pub page: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl TestConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tracking_parameters][crate::model::TestConfig::tracking_parameters].
    pub fn set_tracking_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tracking_parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [flow][crate::model::TestConfig::flow].
    pub fn set_flow<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.flow = v.into();
        self
    }

    /// Sets the value of [page][crate::model::TestConfig::page].
    pub fn set_page<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page = v.into();
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for TestConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.TestConfig"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TestConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tracking_parameters,
            __flow,
            __page,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TestConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "trackingParameters" => Ok(__FieldTag::__tracking_parameters),
                            "tracking_parameters" => Ok(__FieldTag::__tracking_parameters),
                            "flow" => Ok(__FieldTag::__flow),
                            "page" => Ok(__FieldTag::__page),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TestConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TestConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tracking_parameters => {
                            if !fields.insert(__FieldTag::__tracking_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tracking_parameters",
                                ));
                            }
                            result.tracking_parameters = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__flow => {
                            if !fields.insert(__FieldTag::__flow) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flow",
                                ));
                            }
                            result.flow = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page => {
                            if !fields.insert(__FieldTag::__page) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page",
                                ));
                            }
                            result.page = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for TestConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tracking_parameters.is_empty() {
            state.serialize_entry("trackingParameters", &self.tracking_parameters)?;
        }
        if !self.flow.is_empty() {
            state.serialize_entry("flow", &self.flow)?;
        }
        if !self.page.is_empty() {
            state.serialize_entry("page", &self.page)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// One interaction between a human and virtual agent. The human provides some
/// input and the virtual agent provides a response.
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ConversationTurn {
    /// The user input.
    pub user_input: std::option::Option<crate::model::conversation_turn::UserInput>,

    /// The virtual agent output.
    pub virtual_agent_output:
        std::option::Option<crate::model::conversation_turn::VirtualAgentOutput>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl ConversationTurn {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_input][crate::model::ConversationTurn::user_input].
    pub fn set_user_input<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::conversation_turn::UserInput>,
    {
        self.user_input = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_input][crate::model::ConversationTurn::user_input].
    pub fn set_or_clear_user_input<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::conversation_turn::UserInput>,
    {
        self.user_input = v.map(|x| x.into());
        self
    }

    /// Sets the value of [virtual_agent_output][crate::model::ConversationTurn::virtual_agent_output].
    pub fn set_virtual_agent_output<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::conversation_turn::VirtualAgentOutput>,
    {
        self.virtual_agent_output = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [virtual_agent_output][crate::model::ConversationTurn::virtual_agent_output].
    pub fn set_or_clear_virtual_agent_output<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::conversation_turn::VirtualAgentOutput>,
    {
        self.virtual_agent_output = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for ConversationTurn {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ConversationTurn"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConversationTurn {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __user_input,
            __virtual_agent_output,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationTurn")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "userInput" => Ok(__FieldTag::__user_input),
                            "user_input" => Ok(__FieldTag::__user_input),
                            "virtualAgentOutput" => Ok(__FieldTag::__virtual_agent_output),
                            "virtual_agent_output" => Ok(__FieldTag::__virtual_agent_output),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConversationTurn;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationTurn")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__user_input => {
                            if !fields.insert(__FieldTag::__user_input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_input",
                                ));
                            }
                            result.user_input = map.next_value::<std::option::Option<crate::model::conversation_turn::UserInput>>()?
                                ;
                        }
                        __FieldTag::__virtual_agent_output => {
                            if !fields.insert(__FieldTag::__virtual_agent_output) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for virtual_agent_output",
                                ));
                            }
                            result.virtual_agent_output = map.next_value::<std::option::Option<
                                crate::model::conversation_turn::VirtualAgentOutput,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for ConversationTurn {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.user_input.is_some() {
            state.serialize_entry("userInput", &self.user_input)?;
        }
        if self.virtual_agent_output.is_some() {
            state.serialize_entry("virtualAgentOutput", &self.virtual_agent_output)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ConversationTurn].
#[cfg(feature = "test-cases")]
pub mod conversation_turn {
    #[allow(unused_imports)]
    use super::*;

    /// The input from the human user.
    #[cfg(feature = "test-cases")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UserInput {
        /// Supports [text input][google.cloud.dialogflow.cx.v3.QueryInput.text],
        /// [event input][google.cloud.dialogflow.cx.v3.QueryInput.event], [dtmf
        /// input][google.cloud.dialogflow.cx.v3.QueryInput.dtmf] in the test case.
        ///
        /// [google.cloud.dialogflow.cx.v3.QueryInput.dtmf]: crate::model::QueryInput::input
        /// [google.cloud.dialogflow.cx.v3.QueryInput.event]: crate::model::QueryInput::input
        /// [google.cloud.dialogflow.cx.v3.QueryInput.text]: crate::model::QueryInput::input
        pub input: std::option::Option<crate::model::QueryInput>,

        /// Parameters that need to be injected into the conversation during intent
        /// detection.
        pub injected_parameters: std::option::Option<wkt::Struct>,

        /// If webhooks should be allowed to trigger in response to the user
        /// utterance. Often if parameters are injected, webhooks should not be
        /// enabled.
        pub is_webhook_enabled: bool,

        /// Whether sentiment analysis is enabled.
        pub enable_sentiment_analysis: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "test-cases")]
    impl UserInput {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [input][crate::model::conversation_turn::UserInput::input].
        pub fn set_input<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::QueryInput>,
        {
            self.input = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [input][crate::model::conversation_turn::UserInput::input].
        pub fn set_or_clear_input<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::QueryInput>,
        {
            self.input = v.map(|x| x.into());
            self
        }

        /// Sets the value of [injected_parameters][crate::model::conversation_turn::UserInput::injected_parameters].
        pub fn set_injected_parameters<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.injected_parameters = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [injected_parameters][crate::model::conversation_turn::UserInput::injected_parameters].
        pub fn set_or_clear_injected_parameters<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.injected_parameters = v.map(|x| x.into());
            self
        }

        /// Sets the value of [is_webhook_enabled][crate::model::conversation_turn::UserInput::is_webhook_enabled].
        pub fn set_is_webhook_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.is_webhook_enabled = v.into();
            self
        }

        /// Sets the value of [enable_sentiment_analysis][crate::model::conversation_turn::UserInput::enable_sentiment_analysis].
        pub fn set_enable_sentiment_analysis<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_sentiment_analysis = v.into();
            self
        }
    }

    #[cfg(feature = "test-cases")]
    impl wkt::message::Message for UserInput {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.ConversationTurn.UserInput"
        }
    }

    #[cfg(feature = "test-cases")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for UserInput {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __input,
                __injected_parameters,
                __is_webhook_enabled,
                __enable_sentiment_analysis,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for UserInput")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "input" => Ok(__FieldTag::__input),
                                "injectedParameters" => Ok(__FieldTag::__injected_parameters),
                                "injected_parameters" => Ok(__FieldTag::__injected_parameters),
                                "isWebhookEnabled" => Ok(__FieldTag::__is_webhook_enabled),
                                "is_webhook_enabled" => Ok(__FieldTag::__is_webhook_enabled),
                                "enableSentimentAnalysis" => {
                                    Ok(__FieldTag::__enable_sentiment_analysis)
                                }
                                "enable_sentiment_analysis" => {
                                    Ok(__FieldTag::__enable_sentiment_analysis)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = UserInput;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct UserInput")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__input => {
                                if !fields.insert(__FieldTag::__input) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for input",
                                    ));
                                }
                                result.input = map
                                    .next_value::<std::option::Option<crate::model::QueryInput>>(
                                    )?;
                            }
                            __FieldTag::__injected_parameters => {
                                if !fields.insert(__FieldTag::__injected_parameters) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for injected_parameters",
                                    ));
                                }
                                result.injected_parameters =
                                    map.next_value::<std::option::Option<wkt::Struct>>()?;
                            }
                            __FieldTag::__is_webhook_enabled => {
                                if !fields.insert(__FieldTag::__is_webhook_enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for is_webhook_enabled",
                                    ));
                                }
                                result.is_webhook_enabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__enable_sentiment_analysis => {
                                if !fields.insert(__FieldTag::__enable_sentiment_analysis) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_sentiment_analysis",
                                    ));
                                }
                                result.enable_sentiment_analysis = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "test-cases")]
    #[doc(hidden)]
    impl serde::ser::Serialize for UserInput {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.input.is_some() {
                state.serialize_entry("input", &self.input)?;
            }
            if self.injected_parameters.is_some() {
                state.serialize_entry("injectedParameters", &self.injected_parameters)?;
            }
            if !wkt::internal::is_default(&self.is_webhook_enabled) {
                state.serialize_entry("isWebhookEnabled", &self.is_webhook_enabled)?;
            }
            if !wkt::internal::is_default(&self.enable_sentiment_analysis) {
                state
                    .serialize_entry("enableSentimentAnalysis", &self.enable_sentiment_analysis)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The output from the virtual agent.
    #[cfg(feature = "test-cases")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct VirtualAgentOutput {
        /// The session parameters available to the bot at this point.
        pub session_parameters: std::option::Option<wkt::Struct>,

        /// Output only. If this is part of a [result conversation
        /// turn][TestCaseResult.conversation_turns], the list of differences
        /// between the original run and the replay for this output, if any.
        ///
        /// [TestCaseResult.conversation_turns]: crate::model::TestCaseResult::conversation_turns
        pub differences: std::vec::Vec<crate::model::TestRunDifference>,

        /// Required. Input only. The diagnostic
        /// [info][Session.DetectIntentResponse.QueryResult.diagnostic_info]
        /// output for the turn. Required to calculate the testing coverage.
        pub diagnostic_info: std::option::Option<wkt::Struct>,

        /// The [Intent][google.cloud.dialogflow.cx.v3.Intent] that triggered the
        /// response. Only name and displayName will be set.
        ///
        /// [google.cloud.dialogflow.cx.v3.Intent]: crate::model::Intent
        pub triggered_intent: std::option::Option<crate::model::Intent>,

        /// The [Page][google.cloud.dialogflow.cx.v3.Page] on which the utterance was
        /// spoken. Only name and displayName will be set.
        ///
        /// [google.cloud.dialogflow.cx.v3.Page]: crate::model::Page
        pub current_page: std::option::Option<crate::model::Page>,

        /// The [text][google.cloud.dialogflow.cx.v3.ResponseMessage.Text] responses
        /// from the agent for the turn.
        ///
        /// [google.cloud.dialogflow.cx.v3.ResponseMessage.Text]: crate::model::response_message::Text
        pub text_responses: std::vec::Vec<crate::model::response_message::Text>,

        /// Response error from the agent in the test result. If set, other output
        /// is empty.
        pub status: std::option::Option<rpc::model::Status>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "test-cases")]
    impl VirtualAgentOutput {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [session_parameters][crate::model::conversation_turn::VirtualAgentOutput::session_parameters].
        pub fn set_session_parameters<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.session_parameters = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [session_parameters][crate::model::conversation_turn::VirtualAgentOutput::session_parameters].
        pub fn set_or_clear_session_parameters<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.session_parameters = v.map(|x| x.into());
            self
        }

        /// Sets the value of [differences][crate::model::conversation_turn::VirtualAgentOutput::differences].
        pub fn set_differences<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::TestRunDifference>,
        {
            use std::iter::Iterator;
            self.differences = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [diagnostic_info][crate::model::conversation_turn::VirtualAgentOutput::diagnostic_info].
        pub fn set_diagnostic_info<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.diagnostic_info = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [diagnostic_info][crate::model::conversation_turn::VirtualAgentOutput::diagnostic_info].
        pub fn set_or_clear_diagnostic_info<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.diagnostic_info = v.map(|x| x.into());
            self
        }

        /// Sets the value of [triggered_intent][crate::model::conversation_turn::VirtualAgentOutput::triggered_intent].
        pub fn set_triggered_intent<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Intent>,
        {
            self.triggered_intent = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [triggered_intent][crate::model::conversation_turn::VirtualAgentOutput::triggered_intent].
        pub fn set_or_clear_triggered_intent<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Intent>,
        {
            self.triggered_intent = v.map(|x| x.into());
            self
        }

        /// Sets the value of [current_page][crate::model::conversation_turn::VirtualAgentOutput::current_page].
        pub fn set_current_page<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Page>,
        {
            self.current_page = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [current_page][crate::model::conversation_turn::VirtualAgentOutput::current_page].
        pub fn set_or_clear_current_page<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Page>,
        {
            self.current_page = v.map(|x| x.into());
            self
        }

        /// Sets the value of [text_responses][crate::model::conversation_turn::VirtualAgentOutput::text_responses].
        pub fn set_text_responses<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::response_message::Text>,
        {
            use std::iter::Iterator;
            self.text_responses = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [status][crate::model::conversation_turn::VirtualAgentOutput::status].
        pub fn set_status<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.status = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [status][crate::model::conversation_turn::VirtualAgentOutput::status].
        pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.status = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "test-cases")]
    impl wkt::message::Message for VirtualAgentOutput {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.ConversationTurn.VirtualAgentOutput"
        }
    }

    #[cfg(feature = "test-cases")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for VirtualAgentOutput {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __session_parameters,
                __differences,
                __diagnostic_info,
                __triggered_intent,
                __current_page,
                __text_responses,
                __status,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for VirtualAgentOutput")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sessionParameters" => Ok(__FieldTag::__session_parameters),
                                "session_parameters" => Ok(__FieldTag::__session_parameters),
                                "differences" => Ok(__FieldTag::__differences),
                                "diagnosticInfo" => Ok(__FieldTag::__diagnostic_info),
                                "diagnostic_info" => Ok(__FieldTag::__diagnostic_info),
                                "triggeredIntent" => Ok(__FieldTag::__triggered_intent),
                                "triggered_intent" => Ok(__FieldTag::__triggered_intent),
                                "currentPage" => Ok(__FieldTag::__current_page),
                                "current_page" => Ok(__FieldTag::__current_page),
                                "textResponses" => Ok(__FieldTag::__text_responses),
                                "text_responses" => Ok(__FieldTag::__text_responses),
                                "status" => Ok(__FieldTag::__status),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = VirtualAgentOutput;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct VirtualAgentOutput")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__session_parameters => {
                                if !fields.insert(__FieldTag::__session_parameters) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for session_parameters",
                                    ));
                                }
                                result.session_parameters =
                                    map.next_value::<std::option::Option<wkt::Struct>>()?;
                            }
                            __FieldTag::__differences => {
                                if !fields.insert(__FieldTag::__differences) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for differences",
                                    ));
                                }
                                result.differences = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::TestRunDifference>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__diagnostic_info => {
                                if !fields.insert(__FieldTag::__diagnostic_info) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for diagnostic_info",
                                    ));
                                }
                                result.diagnostic_info =
                                    map.next_value::<std::option::Option<wkt::Struct>>()?;
                            }
                            __FieldTag::__triggered_intent => {
                                if !fields.insert(__FieldTag::__triggered_intent) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for triggered_intent",
                                    ));
                                }
                                result.triggered_intent =
                                    map.next_value::<std::option::Option<crate::model::Intent>>()?;
                            }
                            __FieldTag::__current_page => {
                                if !fields.insert(__FieldTag::__current_page) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for current_page",
                                    ));
                                }
                                result.current_page =
                                    map.next_value::<std::option::Option<crate::model::Page>>()?;
                            }
                            __FieldTag::__text_responses => {
                                if !fields.insert(__FieldTag::__text_responses) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text_responses",
                                    ));
                                }
                                result.text_responses = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::response_message::Text>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__status => {
                                if !fields.insert(__FieldTag::__status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for status",
                                    ));
                                }
                                result.status =
                                    map.next_value::<std::option::Option<rpc::model::Status>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "test-cases")]
    #[doc(hidden)]
    impl serde::ser::Serialize for VirtualAgentOutput {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.session_parameters.is_some() {
                state.serialize_entry("sessionParameters", &self.session_parameters)?;
            }
            if !self.differences.is_empty() {
                state.serialize_entry("differences", &self.differences)?;
            }
            if self.diagnostic_info.is_some() {
                state.serialize_entry("diagnosticInfo", &self.diagnostic_info)?;
            }
            if self.triggered_intent.is_some() {
                state.serialize_entry("triggeredIntent", &self.triggered_intent)?;
            }
            if self.current_page.is_some() {
                state.serialize_entry("currentPage", &self.current_page)?;
            }
            if !self.text_responses.is_empty() {
                state.serialize_entry("textResponses", &self.text_responses)?;
            }
            if self.status.is_some() {
                state.serialize_entry("status", &self.status)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// The description of differences between original and replayed agent output.
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TestRunDifference {
    /// The type of diff.
    pub r#type: crate::model::test_run_difference::DiffType,

    /// A human readable description of the diff, showing the actual output vs
    /// expected output.
    pub description: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl TestRunDifference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::TestRunDifference::type].
    pub fn set_type<T: std::convert::Into<crate::model::test_run_difference::DiffType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TestRunDifference::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for TestRunDifference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.TestRunDifference"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TestRunDifference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TestRunDifference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TestRunDifference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TestRunDifference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type =
                                map.next_value::<std::option::Option<
                                    crate::model::test_run_difference::DiffType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for TestRunDifference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TestRunDifference].
#[cfg(feature = "test-cases")]
pub mod test_run_difference {
    #[allow(unused_imports)]
    use super::*;

    /// What part of the message replay differs from the test case.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "test-cases")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DiffType {
        /// Should never be used.
        Unspecified,
        /// The intent.
        Intent,
        /// The page.
        Page,
        /// The parameters.
        Parameters,
        /// The message utterance.
        Utterance,
        /// The flow.
        Flow,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DiffType::value] or
        /// [DiffType::name].
        UnknownValue(diff_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "test-cases")]
    pub mod diff_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "test-cases")]
    impl DiffType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Intent => std::option::Option::Some(1),
                Self::Page => std::option::Option::Some(2),
                Self::Parameters => std::option::Option::Some(3),
                Self::Utterance => std::option::Option::Some(4),
                Self::Flow => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DIFF_TYPE_UNSPECIFIED"),
                Self::Intent => std::option::Option::Some("INTENT"),
                Self::Page => std::option::Option::Some("PAGE"),
                Self::Parameters => std::option::Option::Some("PARAMETERS"),
                Self::Utterance => std::option::Option::Some("UTTERANCE"),
                Self::Flow => std::option::Option::Some("FLOW"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "test-cases")]
    impl std::default::Default for DiffType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "test-cases")]
    impl std::fmt::Display for DiffType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "test-cases")]
    impl std::convert::From<i32> for DiffType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Intent,
                2 => Self::Page,
                3 => Self::Parameters,
                4 => Self::Utterance,
                5 => Self::Flow,
                _ => Self::UnknownValue(diff_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "test-cases")]
    impl std::convert::From<&str> for DiffType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DIFF_TYPE_UNSPECIFIED" => Self::Unspecified,
                "INTENT" => Self::Intent,
                "PAGE" => Self::Page,
                "PARAMETERS" => Self::Parameters,
                "UTTERANCE" => Self::Utterance,
                "FLOW" => Self::Flow,
                _ => Self::UnknownValue(diff_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "test-cases")]
    impl serde::ser::Serialize for DiffType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Intent => serializer.serialize_i32(1),
                Self::Page => serializer.serialize_i32(2),
                Self::Parameters => serializer.serialize_i32(3),
                Self::Utterance => serializer.serialize_i32(4),
                Self::Flow => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "test-cases")]
    impl<'de> serde::de::Deserialize<'de> for DiffType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DiffType>::new(
                ".google.cloud.dialogflow.cx.v3.TestRunDifference.DiffType",
            ))
        }
    }
}

/// Transition coverage represents the percentage of all possible page
/// transitions (page-level transition routes and event handlers, excluding
/// transition route groups) present within any of a parent's test cases.
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TransitionCoverage {
    /// The list of Transitions present in the agent.
    pub transitions: std::vec::Vec<crate::model::transition_coverage::Transition>,

    /// The percent of transitions in the agent that are covered.
    pub coverage_score: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl TransitionCoverage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transitions][crate::model::TransitionCoverage::transitions].
    pub fn set_transitions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::transition_coverage::Transition>,
    {
        use std::iter::Iterator;
        self.transitions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [coverage_score][crate::model::TransitionCoverage::coverage_score].
    pub fn set_coverage_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.coverage_score = v.into();
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for TransitionCoverage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.TransitionCoverage"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransitionCoverage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transitions,
            __coverage_score,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransitionCoverage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transitions" => Ok(__FieldTag::__transitions),
                            "coverageScore" => Ok(__FieldTag::__coverage_score),
                            "coverage_score" => Ok(__FieldTag::__coverage_score),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransitionCoverage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransitionCoverage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transitions => {
                            if !fields.insert(__FieldTag::__transitions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transitions",
                                ));
                            }
                            result.transitions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::transition_coverage::Transition>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__coverage_score => {
                            if !fields.insert(__FieldTag::__coverage_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for coverage_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.coverage_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for TransitionCoverage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.transitions.is_empty() {
            state.serialize_entry("transitions", &self.transitions)?;
        }
        if !wkt::internal::is_default(&self.coverage_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("coverageScore", &__With(&self.coverage_score))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TransitionCoverage].
#[cfg(feature = "test-cases")]
pub mod transition_coverage {
    #[allow(unused_imports)]
    use super::*;

    /// The source or target of a transition.
    #[cfg(feature = "test-cases")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TransitionNode {
        /// A TransitionNode can be either a page or a flow.
        pub kind: std::option::Option<crate::model::transition_coverage::transition_node::Kind>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "test-cases")]
    impl TransitionNode {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kind][crate::model::transition_coverage::TransitionNode::kind].
        ///
        /// Note that all the setters affecting `kind` are mutually
        /// exclusive.
        pub fn set_kind<
            T: std::convert::Into<
                    std::option::Option<crate::model::transition_coverage::transition_node::Kind>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.kind = v.into();
            self
        }

        /// The value of [kind][crate::model::transition_coverage::TransitionNode::kind]
        /// if it holds a `Page`, `None` if the field is not set or
        /// holds a different branch.
        pub fn page(&self) -> std::option::Option<&std::boxed::Box<crate::model::Page>> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::transition_coverage::transition_node::Kind::Page(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::transition_coverage::TransitionNode::kind]
        /// to hold a `Page`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_page<T: std::convert::Into<std::boxed::Box<crate::model::Page>>>(
            mut self,
            v: T,
        ) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::transition_coverage::transition_node::Kind::Page(v.into()),
            );
            self
        }

        /// The value of [kind][crate::model::transition_coverage::TransitionNode::kind]
        /// if it holds a `Flow`, `None` if the field is not set or
        /// holds a different branch.
        pub fn flow(&self) -> std::option::Option<&std::boxed::Box<crate::model::Flow>> {
            #[allow(unreachable_patterns)]
            self.kind.as_ref().and_then(|v| match v {
                crate::model::transition_coverage::transition_node::Kind::Flow(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [kind][crate::model::transition_coverage::TransitionNode::kind]
        /// to hold a `Flow`.
        ///
        /// Note that all the setters affecting `kind` are
        /// mutually exclusive.
        pub fn set_flow<T: std::convert::Into<std::boxed::Box<crate::model::Flow>>>(
            mut self,
            v: T,
        ) -> Self {
            self.kind = std::option::Option::Some(
                crate::model::transition_coverage::transition_node::Kind::Flow(v.into()),
            );
            self
        }
    }

    #[cfg(feature = "test-cases")]
    impl wkt::message::Message for TransitionNode {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.TransitionCoverage.TransitionNode"
        }
    }

    #[cfg(feature = "test-cases")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TransitionNode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __page,
                __flow,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TransitionNode")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "page" => Ok(__FieldTag::__page),
                                "flow" => Ok(__FieldTag::__flow),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TransitionNode;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TransitionNode")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__page => {
                                if !fields.insert(__FieldTag::__page) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for page",
                                    ));
                                }
                                if result.kind.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `kind`, a oneof with full ID .google.cloud.dialogflow.cx.v3.TransitionCoverage.TransitionNode.page, latest field was page",
                                    ));
                                }
                                result.kind = std::option::Option::Some(
                                    crate::model::transition_coverage::transition_node::Kind::Page(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Page>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__flow => {
                                if !fields.insert(__FieldTag::__flow) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for flow",
                                    ));
                                }
                                if result.kind.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `kind`, a oneof with full ID .google.cloud.dialogflow.cx.v3.TransitionCoverage.TransitionNode.flow, latest field was flow",
                                    ));
                                }
                                result.kind = std::option::Option::Some(
                                    crate::model::transition_coverage::transition_node::Kind::Flow(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Flow>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "test-cases")]
    #[doc(hidden)]
    impl serde::ser::Serialize for TransitionNode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.page() {
                state.serialize_entry("page", value)?;
            }
            if let Some(value) = self.flow() {
                state.serialize_entry("flow", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [TransitionNode].
    #[cfg(feature = "test-cases")]
    pub mod transition_node {
        #[allow(unused_imports)]
        use super::*;

        /// A TransitionNode can be either a page or a flow.
        #[cfg(feature = "test-cases")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Kind {
            /// Indicates a transition to a [Page][google.cloud.dialogflow.cx.v3.Page].
            /// Only some fields such as name and displayname will be set.
            ///
            /// [google.cloud.dialogflow.cx.v3.Page]: crate::model::Page
            Page(std::boxed::Box<crate::model::Page>),
            /// Indicates a transition to a [Flow][google.cloud.dialogflow.cx.v3.Flow].
            /// Only some fields such as name and displayname will be set.
            ///
            /// [google.cloud.dialogflow.cx.v3.Flow]: crate::model::Flow
            Flow(std::boxed::Box<crate::model::Flow>),
        }
    }

    /// A transition in a page.
    #[cfg(feature = "test-cases")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Transition {
        /// The start node of a transition.
        pub source: std::option::Option<crate::model::transition_coverage::TransitionNode>,

        /// The index of a transition in the transition list. Starting from 0.
        pub index: i32,

        /// The end node of a transition.
        pub target: std::option::Option<crate::model::transition_coverage::TransitionNode>,

        /// Whether the transition is covered by at least one of the
        /// agent's test cases.
        pub covered: bool,

        /// The detailed transition.
        pub detail: std::option::Option<crate::model::transition_coverage::transition::Detail>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "test-cases")]
    impl Transition {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source][crate::model::transition_coverage::Transition::source].
        pub fn set_source<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::transition_coverage::TransitionNode>,
        {
            self.source = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [source][crate::model::transition_coverage::Transition::source].
        pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::transition_coverage::TransitionNode>,
        {
            self.source = v.map(|x| x.into());
            self
        }

        /// Sets the value of [index][crate::model::transition_coverage::Transition::index].
        pub fn set_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.index = v.into();
            self
        }

        /// Sets the value of [target][crate::model::transition_coverage::Transition::target].
        pub fn set_target<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::transition_coverage::TransitionNode>,
        {
            self.target = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [target][crate::model::transition_coverage::Transition::target].
        pub fn set_or_clear_target<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::transition_coverage::TransitionNode>,
        {
            self.target = v.map(|x| x.into());
            self
        }

        /// Sets the value of [covered][crate::model::transition_coverage::Transition::covered].
        pub fn set_covered<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.covered = v.into();
            self
        }

        /// Sets the value of [detail][crate::model::transition_coverage::Transition::detail].
        ///
        /// Note that all the setters affecting `detail` are mutually
        /// exclusive.
        pub fn set_detail<
            T: std::convert::Into<
                    std::option::Option<crate::model::transition_coverage::transition::Detail>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.detail = v.into();
            self
        }

        /// The value of [detail][crate::model::transition_coverage::Transition::detail]
        /// if it holds a `TransitionRoute`, `None` if the field is not set or
        /// holds a different branch.
        pub fn transition_route(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::TransitionRoute>> {
            #[allow(unreachable_patterns)]
            self.detail.as_ref().and_then(|v| match v {
                crate::model::transition_coverage::transition::Detail::TransitionRoute(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [detail][crate::model::transition_coverage::Transition::detail]
        /// to hold a `TransitionRoute`.
        ///
        /// Note that all the setters affecting `detail` are
        /// mutually exclusive.
        pub fn set_transition_route<
            T: std::convert::Into<std::boxed::Box<crate::model::TransitionRoute>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.detail = std::option::Option::Some(
                crate::model::transition_coverage::transition::Detail::TransitionRoute(v.into()),
            );
            self
        }

        /// The value of [detail][crate::model::transition_coverage::Transition::detail]
        /// if it holds a `EventHandler`, `None` if the field is not set or
        /// holds a different branch.
        pub fn event_handler(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::EventHandler>> {
            #[allow(unreachable_patterns)]
            self.detail.as_ref().and_then(|v| match v {
                crate::model::transition_coverage::transition::Detail::EventHandler(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [detail][crate::model::transition_coverage::Transition::detail]
        /// to hold a `EventHandler`.
        ///
        /// Note that all the setters affecting `detail` are
        /// mutually exclusive.
        pub fn set_event_handler<
            T: std::convert::Into<std::boxed::Box<crate::model::EventHandler>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.detail = std::option::Option::Some(
                crate::model::transition_coverage::transition::Detail::EventHandler(v.into()),
            );
            self
        }
    }

    #[cfg(feature = "test-cases")]
    impl wkt::message::Message for Transition {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.TransitionCoverage.Transition"
        }
    }

    #[cfg(feature = "test-cases")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Transition {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __source,
                __index,
                __target,
                __covered,
                __transition_route,
                __event_handler,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Transition")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "source" => Ok(__FieldTag::__source),
                                "index" => Ok(__FieldTag::__index),
                                "target" => Ok(__FieldTag::__target),
                                "covered" => Ok(__FieldTag::__covered),
                                "transitionRoute" => Ok(__FieldTag::__transition_route),
                                "transition_route" => Ok(__FieldTag::__transition_route),
                                "eventHandler" => Ok(__FieldTag::__event_handler),
                                "event_handler" => Ok(__FieldTag::__event_handler),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Transition;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Transition")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__source => {
                                if !fields.insert(__FieldTag::__source) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source",
                                    ));
                                }
                                result.source = map.next_value::<std::option::Option<
                                    crate::model::transition_coverage::TransitionNode,
                                >>()?;
                            }
                            __FieldTag::__index => {
                                if !fields.insert(__FieldTag::__index) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for index",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.index = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__target => {
                                if !fields.insert(__FieldTag::__target) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for target",
                                    ));
                                }
                                result.target = map.next_value::<std::option::Option<
                                    crate::model::transition_coverage::TransitionNode,
                                >>()?;
                            }
                            __FieldTag::__covered => {
                                if !fields.insert(__FieldTag::__covered) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for covered",
                                    ));
                                }
                                result.covered = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__transition_route => {
                                if !fields.insert(__FieldTag::__transition_route) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for transition_route",
                                    ));
                                }
                                if result.detail.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `detail`, a oneof with full ID .google.cloud.dialogflow.cx.v3.TransitionCoverage.Transition.transition_route, latest field was transitionRoute",
                                    ));
                                }
                                result.detail = std::option::Option::Some(
                                    crate::model::transition_coverage::transition::Detail::TransitionRoute(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::TransitionRoute>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__event_handler => {
                                if !fields.insert(__FieldTag::__event_handler) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for event_handler",
                                    ));
                                }
                                if result.detail.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `detail`, a oneof with full ID .google.cloud.dialogflow.cx.v3.TransitionCoverage.Transition.event_handler, latest field was eventHandler",
                                    ));
                                }
                                result.detail = std::option::Option::Some(
                                    crate::model::transition_coverage::transition::Detail::EventHandler(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::EventHandler>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "test-cases")]
    #[doc(hidden)]
    impl serde::ser::Serialize for Transition {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.source.is_some() {
                state.serialize_entry("source", &self.source)?;
            }
            if !wkt::internal::is_default(&self.index) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("index", &__With(&self.index))?;
            }
            if self.target.is_some() {
                state.serialize_entry("target", &self.target)?;
            }
            if !wkt::internal::is_default(&self.covered) {
                state.serialize_entry("covered", &self.covered)?;
            }
            if let Some(value) = self.transition_route() {
                state.serialize_entry("transitionRoute", value)?;
            }
            if let Some(value) = self.event_handler() {
                state.serialize_entry("eventHandler", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Transition].
    #[cfg(feature = "test-cases")]
    pub mod transition {
        #[allow(unused_imports)]
        use super::*;

        /// The detailed transition.
        #[cfg(feature = "test-cases")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Detail {
            /// Intent route or condition route.
            TransitionRoute(std::boxed::Box<crate::model::TransitionRoute>),
            /// Event handler.
            EventHandler(std::boxed::Box<crate::model::EventHandler>),
        }
    }
}

/// Transition route group coverage represents the percentage of all possible
/// transition routes present within any of a parent's test cases. The results
/// are grouped by the transition route group.
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TransitionRouteGroupCoverage {
    /// Transition route group coverages.
    pub coverages: std::vec::Vec<crate::model::transition_route_group_coverage::Coverage>,

    /// The percent of transition routes in all the transition route groups that
    /// are covered.
    pub coverage_score: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl TransitionRouteGroupCoverage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [coverages][crate::model::TransitionRouteGroupCoverage::coverages].
    pub fn set_coverages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::transition_route_group_coverage::Coverage>,
    {
        use std::iter::Iterator;
        self.coverages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [coverage_score][crate::model::TransitionRouteGroupCoverage::coverage_score].
    pub fn set_coverage_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.coverage_score = v.into();
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for TransitionRouteGroupCoverage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.TransitionRouteGroupCoverage"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransitionRouteGroupCoverage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __coverages,
            __coverage_score,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransitionRouteGroupCoverage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "coverages" => Ok(__FieldTag::__coverages),
                            "coverageScore" => Ok(__FieldTag::__coverage_score),
                            "coverage_score" => Ok(__FieldTag::__coverage_score),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransitionRouteGroupCoverage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransitionRouteGroupCoverage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__coverages => {
                            if !fields.insert(__FieldTag::__coverages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for coverages",
                                ));
                            }
                            result.coverages = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::transition_route_group_coverage::Coverage,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__coverage_score => {
                            if !fields.insert(__FieldTag::__coverage_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for coverage_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.coverage_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for TransitionRouteGroupCoverage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.coverages.is_empty() {
            state.serialize_entry("coverages", &self.coverages)?;
        }
        if !wkt::internal::is_default(&self.coverage_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("coverageScore", &__With(&self.coverage_score))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [TransitionRouteGroupCoverage].
#[cfg(feature = "test-cases")]
pub mod transition_route_group_coverage {
    #[allow(unused_imports)]
    use super::*;

    /// Coverage result message for one transition route group.
    #[cfg(feature = "test-cases")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Coverage {
        /// Transition route group metadata. Only name and displayName will be set.
        pub route_group: std::option::Option<crate::model::TransitionRouteGroup>,

        /// The list of transition routes and coverage in the transition route group.
        pub transitions:
            std::vec::Vec<crate::model::transition_route_group_coverage::coverage::Transition>,

        /// The percent of transition routes in the transition route group that are
        /// covered.
        pub coverage_score: f32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "test-cases")]
    impl Coverage {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [route_group][crate::model::transition_route_group_coverage::Coverage::route_group].
        pub fn set_route_group<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TransitionRouteGroup>,
        {
            self.route_group = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [route_group][crate::model::transition_route_group_coverage::Coverage::route_group].
        pub fn set_or_clear_route_group<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TransitionRouteGroup>,
        {
            self.route_group = v.map(|x| x.into());
            self
        }

        /// Sets the value of [transitions][crate::model::transition_route_group_coverage::Coverage::transitions].
        pub fn set_transitions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::transition_route_group_coverage::coverage::Transition,
                >,
        {
            use std::iter::Iterator;
            self.transitions = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [coverage_score][crate::model::transition_route_group_coverage::Coverage::coverage_score].
        pub fn set_coverage_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.coverage_score = v.into();
            self
        }
    }

    #[cfg(feature = "test-cases")]
    impl wkt::message::Message for Coverage {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.TransitionRouteGroupCoverage.Coverage"
        }
    }

    #[cfg(feature = "test-cases")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Coverage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __route_group,
                __transitions,
                __coverage_score,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Coverage")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "routeGroup" => Ok(__FieldTag::__route_group),
                                "route_group" => Ok(__FieldTag::__route_group),
                                "transitions" => Ok(__FieldTag::__transitions),
                                "coverageScore" => Ok(__FieldTag::__coverage_score),
                                "coverage_score" => Ok(__FieldTag::__coverage_score),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Coverage;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Coverage")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__route_group => {
                                if !fields.insert(__FieldTag::__route_group) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for route_group",
                                    ));
                                }
                                result.route_group = map.next_value::<std::option::Option<crate::model::TransitionRouteGroup>>()?
                                    ;
                            }
                            __FieldTag::__transitions => {
                                if !fields.insert(__FieldTag::__transitions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for transitions",
                                    ));
                                }
                                result.transitions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::transition_route_group_coverage::coverage::Transition>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__coverage_score => {
                                if !fields.insert(__FieldTag::__coverage_score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for coverage_score",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.coverage_score =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "test-cases")]
    #[doc(hidden)]
    impl serde::ser::Serialize for Coverage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.route_group.is_some() {
                state.serialize_entry("routeGroup", &self.route_group)?;
            }
            if !self.transitions.is_empty() {
                state.serialize_entry("transitions", &self.transitions)?;
            }
            if !wkt::internal::is_default(&self.coverage_score) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("coverageScore", &__With(&self.coverage_score))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Coverage].
    #[cfg(feature = "test-cases")]
    pub mod coverage {
        #[allow(unused_imports)]
        use super::*;

        /// A transition coverage in a transition route group.
        #[cfg(feature = "test-cases")]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Transition {
            /// Intent route or condition route.
            pub transition_route: std::option::Option<crate::model::TransitionRoute>,

            /// Whether the transition route is covered by at least one of the
            /// agent's test cases.
            pub covered: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "test-cases")]
        impl Transition {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [transition_route][crate::model::transition_route_group_coverage::coverage::Transition::transition_route].
            pub fn set_transition_route<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::TransitionRoute>,
            {
                self.transition_route = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [transition_route][crate::model::transition_route_group_coverage::coverage::Transition::transition_route].
            pub fn set_or_clear_transition_route<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::TransitionRoute>,
            {
                self.transition_route = v.map(|x| x.into());
                self
            }

            /// Sets the value of [covered][crate::model::transition_route_group_coverage::coverage::Transition::covered].
            pub fn set_covered<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.covered = v.into();
                self
            }
        }

        #[cfg(feature = "test-cases")]
        impl wkt::message::Message for Transition {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.cx.v3.TransitionRouteGroupCoverage.Coverage.Transition"
            }
        }

        #[cfg(feature = "test-cases")]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Transition {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __transition_route,
                    __covered,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Transition")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "transitionRoute" => Ok(__FieldTag::__transition_route),
                                    "transition_route" => Ok(__FieldTag::__transition_route),
                                    "covered" => Ok(__FieldTag::__covered),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Transition;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Transition")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__transition_route => {
                                    if !fields.insert(__FieldTag::__transition_route) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for transition_route",
                                            ),
                                        );
                                    }
                                    result.transition_route = map.next_value::<std::option::Option<crate::model::TransitionRoute>>()?
                                        ;
                                }
                                __FieldTag::__covered => {
                                    if !fields.insert(__FieldTag::__covered) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for covered",
                                            ),
                                        );
                                    }
                                    result.covered = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(feature = "test-cases")]
        #[doc(hidden)]
        impl serde::ser::Serialize for Transition {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.transition_route.is_some() {
                    state.serialize_entry("transitionRoute", &self.transition_route)?;
                }
                if !wkt::internal::is_default(&self.covered) {
                    state.serialize_entry("covered", &self.covered)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }
}

/// Intent coverage represents the percentage of all possible intents in the
/// agent that are triggered in any of a parent's test cases.
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct IntentCoverage {
    /// The list of Intents present in the agent
    pub intents: std::vec::Vec<crate::model::intent_coverage::Intent>,

    /// The percent of intents in the agent that are covered.
    pub coverage_score: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl IntentCoverage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [intents][crate::model::IntentCoverage::intents].
    pub fn set_intents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::intent_coverage::Intent>,
    {
        use std::iter::Iterator;
        self.intents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [coverage_score][crate::model::IntentCoverage::coverage_score].
    pub fn set_coverage_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.coverage_score = v.into();
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for IntentCoverage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.IntentCoverage"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IntentCoverage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __intents,
            __coverage_score,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IntentCoverage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "intents" => Ok(__FieldTag::__intents),
                            "coverageScore" => Ok(__FieldTag::__coverage_score),
                            "coverage_score" => Ok(__FieldTag::__coverage_score),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IntentCoverage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IntentCoverage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__intents => {
                            if !fields.insert(__FieldTag::__intents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intents",
                                ));
                            }
                            result.intents = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::intent_coverage::Intent>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__coverage_score => {
                            if !fields.insert(__FieldTag::__coverage_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for coverage_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.coverage_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for IntentCoverage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.intents.is_empty() {
            state.serialize_entry("intents", &self.intents)?;
        }
        if !wkt::internal::is_default(&self.coverage_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("coverageScore", &__With(&self.coverage_score))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [IntentCoverage].
#[cfg(feature = "test-cases")]
pub mod intent_coverage {
    #[allow(unused_imports)]
    use super::*;

    /// The agent's intent.
    #[cfg(feature = "test-cases")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Intent {
        /// The intent full resource name
        pub intent: std::string::String,

        /// Whether the intent is covered by at least one of the agent's
        /// test cases.
        pub covered: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "test-cases")]
    impl Intent {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [intent][crate::model::intent_coverage::Intent::intent].
        pub fn set_intent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.intent = v.into();
            self
        }

        /// Sets the value of [covered][crate::model::intent_coverage::Intent::covered].
        pub fn set_covered<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.covered = v.into();
            self
        }
    }

    #[cfg(feature = "test-cases")]
    impl wkt::message::Message for Intent {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.IntentCoverage.Intent"
        }
    }

    #[cfg(feature = "test-cases")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Intent {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __intent,
                __covered,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Intent")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "intent" => Ok(__FieldTag::__intent),
                                "covered" => Ok(__FieldTag::__covered),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Intent;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Intent")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__intent => {
                                if !fields.insert(__FieldTag::__intent) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for intent",
                                    ));
                                }
                                result.intent = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__covered => {
                                if !fields.insert(__FieldTag::__covered) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for covered",
                                    ));
                                }
                                result.covered = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "test-cases")]
    #[doc(hidden)]
    impl serde::ser::Serialize for Intent {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.intent.is_empty() {
                state.serialize_entry("intent", &self.intent)?;
            }
            if !wkt::internal::is_default(&self.covered) {
                state.serialize_entry("covered", &self.covered)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// The request message for
/// [TestCases.CalculateCoverage][google.cloud.dialogflow.cx.v3.TestCases.CalculateCoverage].
///
/// [google.cloud.dialogflow.cx.v3.TestCases.CalculateCoverage]: crate::client::TestCases::calculate_coverage
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CalculateCoverageRequest {
    /// Required. The agent to calculate coverage for.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub agent: std::string::String,

    /// Required. The type of coverage requested.
    pub r#type: crate::model::calculate_coverage_request::CoverageType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl CalculateCoverageRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [agent][crate::model::CalculateCoverageRequest::agent].
    pub fn set_agent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.agent = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::CalculateCoverageRequest::type].
    pub fn set_type<
        T: std::convert::Into<crate::model::calculate_coverage_request::CoverageType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for CalculateCoverageRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CalculateCoverageRequest"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CalculateCoverageRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agent,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CalculateCoverageRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agent" => Ok(__FieldTag::__agent),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CalculateCoverageRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CalculateCoverageRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agent => {
                            if !fields.insert(__FieldTag::__agent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent",
                                ));
                            }
                            result.agent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<
                                    crate::model::calculate_coverage_request::CoverageType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for CalculateCoverageRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.agent.is_empty() {
            state.serialize_entry("agent", &self.agent)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CalculateCoverageRequest].
#[cfg(feature = "test-cases")]
pub mod calculate_coverage_request {
    #[allow(unused_imports)]
    use super::*;

    /// The type of coverage score requested.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "test-cases")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CoverageType {
        /// Should never be used.
        Unspecified,
        /// Intent coverage.
        Intent,
        /// Page transition coverage.
        PageTransition,
        /// Transition route group coverage.
        TransitionRouteGroup,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CoverageType::value] or
        /// [CoverageType::name].
        UnknownValue(coverage_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "test-cases")]
    pub mod coverage_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "test-cases")]
    impl CoverageType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Intent => std::option::Option::Some(1),
                Self::PageTransition => std::option::Option::Some(2),
                Self::TransitionRouteGroup => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COVERAGE_TYPE_UNSPECIFIED"),
                Self::Intent => std::option::Option::Some("INTENT"),
                Self::PageTransition => std::option::Option::Some("PAGE_TRANSITION"),
                Self::TransitionRouteGroup => std::option::Option::Some("TRANSITION_ROUTE_GROUP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "test-cases")]
    impl std::default::Default for CoverageType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "test-cases")]
    impl std::fmt::Display for CoverageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "test-cases")]
    impl std::convert::From<i32> for CoverageType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Intent,
                2 => Self::PageTransition,
                3 => Self::TransitionRouteGroup,
                _ => Self::UnknownValue(coverage_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "test-cases")]
    impl std::convert::From<&str> for CoverageType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COVERAGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "INTENT" => Self::Intent,
                "PAGE_TRANSITION" => Self::PageTransition,
                "TRANSITION_ROUTE_GROUP" => Self::TransitionRouteGroup,
                _ => Self::UnknownValue(coverage_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "test-cases")]
    impl serde::ser::Serialize for CoverageType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Intent => serializer.serialize_i32(1),
                Self::PageTransition => serializer.serialize_i32(2),
                Self::TransitionRouteGroup => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "test-cases")]
    impl<'de> serde::de::Deserialize<'de> for CoverageType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CoverageType>::new(
                ".google.cloud.dialogflow.cx.v3.CalculateCoverageRequest.CoverageType",
            ))
        }
    }
}

/// The response message for
/// [TestCases.CalculateCoverage][google.cloud.dialogflow.cx.v3.TestCases.CalculateCoverage].
///
/// [google.cloud.dialogflow.cx.v3.TestCases.CalculateCoverage]: crate::client::TestCases::calculate_coverage
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CalculateCoverageResponse {
    /// The agent to calculate coverage for.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub agent: std::string::String,

    /// The type of coverage requested.
    pub coverage_type: std::option::Option<crate::model::calculate_coverage_response::CoverageType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl CalculateCoverageResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [agent][crate::model::CalculateCoverageResponse::agent].
    pub fn set_agent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.agent = v.into();
        self
    }

    /// Sets the value of [coverage_type][crate::model::CalculateCoverageResponse::coverage_type].
    ///
    /// Note that all the setters affecting `coverage_type` are mutually
    /// exclusive.
    pub fn set_coverage_type<
        T: std::convert::Into<
                std::option::Option<crate::model::calculate_coverage_response::CoverageType>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.coverage_type = v.into();
        self
    }

    /// The value of [coverage_type][crate::model::CalculateCoverageResponse::coverage_type]
    /// if it holds a `IntentCoverage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn intent_coverage(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IntentCoverage>> {
        #[allow(unreachable_patterns)]
        self.coverage_type.as_ref().and_then(|v| match v {
            crate::model::calculate_coverage_response::CoverageType::IntentCoverage(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [coverage_type][crate::model::CalculateCoverageResponse::coverage_type]
    /// to hold a `IntentCoverage`.
    ///
    /// Note that all the setters affecting `coverage_type` are
    /// mutually exclusive.
    pub fn set_intent_coverage<
        T: std::convert::Into<std::boxed::Box<crate::model::IntentCoverage>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.coverage_type = std::option::Option::Some(
            crate::model::calculate_coverage_response::CoverageType::IntentCoverage(v.into()),
        );
        self
    }

    /// The value of [coverage_type][crate::model::CalculateCoverageResponse::coverage_type]
    /// if it holds a `TransitionCoverage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn transition_coverage(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TransitionCoverage>> {
        #[allow(unreachable_patterns)]
        self.coverage_type.as_ref().and_then(|v| match v {
            crate::model::calculate_coverage_response::CoverageType::TransitionCoverage(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [coverage_type][crate::model::CalculateCoverageResponse::coverage_type]
    /// to hold a `TransitionCoverage`.
    ///
    /// Note that all the setters affecting `coverage_type` are
    /// mutually exclusive.
    pub fn set_transition_coverage<
        T: std::convert::Into<std::boxed::Box<crate::model::TransitionCoverage>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.coverage_type = std::option::Option::Some(
            crate::model::calculate_coverage_response::CoverageType::TransitionCoverage(v.into()),
        );
        self
    }

    /// The value of [coverage_type][crate::model::CalculateCoverageResponse::coverage_type]
    /// if it holds a `RouteGroupCoverage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn route_group_coverage(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TransitionRouteGroupCoverage>> {
        #[allow(unreachable_patterns)]
        self.coverage_type.as_ref().and_then(|v| match v {
            crate::model::calculate_coverage_response::CoverageType::RouteGroupCoverage(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [coverage_type][crate::model::CalculateCoverageResponse::coverage_type]
    /// to hold a `RouteGroupCoverage`.
    ///
    /// Note that all the setters affecting `coverage_type` are
    /// mutually exclusive.
    pub fn set_route_group_coverage<
        T: std::convert::Into<std::boxed::Box<crate::model::TransitionRouteGroupCoverage>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.coverage_type = std::option::Option::Some(
            crate::model::calculate_coverage_response::CoverageType::RouteGroupCoverage(v.into()),
        );
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for CalculateCoverageResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CalculateCoverageResponse"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CalculateCoverageResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agent,
            __intent_coverage,
            __transition_coverage,
            __route_group_coverage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CalculateCoverageResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agent" => Ok(__FieldTag::__agent),
                            "intentCoverage" => Ok(__FieldTag::__intent_coverage),
                            "intent_coverage" => Ok(__FieldTag::__intent_coverage),
                            "transitionCoverage" => Ok(__FieldTag::__transition_coverage),
                            "transition_coverage" => Ok(__FieldTag::__transition_coverage),
                            "routeGroupCoverage" => Ok(__FieldTag::__route_group_coverage),
                            "route_group_coverage" => Ok(__FieldTag::__route_group_coverage),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CalculateCoverageResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CalculateCoverageResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agent => {
                            if !fields.insert(__FieldTag::__agent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent",
                                ));
                            }
                            result.agent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__intent_coverage => {
                            if !fields.insert(__FieldTag::__intent_coverage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent_coverage",
                                ));
                            }
                            if result.coverage_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `coverage_type`, a oneof with full ID .google.cloud.dialogflow.cx.v3.CalculateCoverageResponse.intent_coverage, latest field was intentCoverage",
                                ));
                            }
                            result.coverage_type = std::option::Option::Some(
                                crate::model::calculate_coverage_response::CoverageType::IntentCoverage(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::IntentCoverage>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__transition_coverage => {
                            if !fields.insert(__FieldTag::__transition_coverage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transition_coverage",
                                ));
                            }
                            if result.coverage_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `coverage_type`, a oneof with full ID .google.cloud.dialogflow.cx.v3.CalculateCoverageResponse.transition_coverage, latest field was transitionCoverage",
                                ));
                            }
                            result.coverage_type = std::option::Option::Some(
                                crate::model::calculate_coverage_response::CoverageType::TransitionCoverage(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::TransitionCoverage>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__route_group_coverage => {
                            if !fields.insert(__FieldTag::__route_group_coverage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for route_group_coverage",
                                ));
                            }
                            if result.coverage_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `coverage_type`, a oneof with full ID .google.cloud.dialogflow.cx.v3.CalculateCoverageResponse.route_group_coverage, latest field was routeGroupCoverage",
                                ));
                            }
                            result.coverage_type = std::option::Option::Some(
                                crate::model::calculate_coverage_response::CoverageType::RouteGroupCoverage(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::TransitionRouteGroupCoverage>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for CalculateCoverageResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.agent.is_empty() {
            state.serialize_entry("agent", &self.agent)?;
        }
        if let Some(value) = self.intent_coverage() {
            state.serialize_entry("intentCoverage", value)?;
        }
        if let Some(value) = self.transition_coverage() {
            state.serialize_entry("transitionCoverage", value)?;
        }
        if let Some(value) = self.route_group_coverage() {
            state.serialize_entry("routeGroupCoverage", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CalculateCoverageResponse].
#[cfg(feature = "test-cases")]
pub mod calculate_coverage_response {
    #[allow(unused_imports)]
    use super::*;

    /// The type of coverage requested.
    #[cfg(feature = "test-cases")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CoverageType {
        /// Intent coverage.
        IntentCoverage(std::boxed::Box<crate::model::IntentCoverage>),
        /// Transition (excluding transition route groups) coverage.
        TransitionCoverage(std::boxed::Box<crate::model::TransitionCoverage>),
        /// Transition route group coverage.
        RouteGroupCoverage(std::boxed::Box<crate::model::TransitionRouteGroupCoverage>),
    }
}

/// The request message for
/// [TestCases.ListTestCases][google.cloud.dialogflow.cx.v3.TestCases.ListTestCases].
///
/// [google.cloud.dialogflow.cx.v3.TestCases.ListTestCases]: crate::client::TestCases::list_test_cases
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTestCasesRequest {
    /// Required. The agent to list all pages for.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// The maximum number of items to return in a single page. By default 20.
    /// Note that when TestCaseView = FULL, the maximum page size allowed is 20.
    /// When TestCaseView = BASIC, the maximum page size allowed is 500.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    /// Specifies whether response should include all fields or just the metadata.
    pub view: crate::model::list_test_cases_request::TestCaseView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl ListTestCasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTestCasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTestCasesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTestCasesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListTestCasesRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::list_test_cases_request::TestCaseView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for ListTestCasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListTestCasesRequest"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTestCasesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTestCasesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTestCasesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTestCasesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<
                                    crate::model::list_test_cases_request::TestCaseView,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for ListTestCasesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ListTestCasesRequest].
#[cfg(feature = "test-cases")]
pub mod list_test_cases_request {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies how much test case information to include in the response.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "test-cases")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TestCaseView {
        /// The default / unset value.
        /// The API will default to the BASIC view.
        Unspecified,
        /// Include basic metadata about the test case, but not the conversation
        /// turns. This is the default value.
        Basic,
        /// Include everything.
        Full,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TestCaseView::value] or
        /// [TestCaseView::name].
        UnknownValue(test_case_view::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "test-cases")]
    pub mod test_case_view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "test-cases")]
    impl TestCaseView {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Basic => std::option::Option::Some(1),
                Self::Full => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TEST_CASE_VIEW_UNSPECIFIED"),
                Self::Basic => std::option::Option::Some("BASIC"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "test-cases")]
    impl std::default::Default for TestCaseView {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "test-cases")]
    impl std::fmt::Display for TestCaseView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "test-cases")]
    impl std::convert::From<i32> for TestCaseView {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Basic,
                2 => Self::Full,
                _ => Self::UnknownValue(test_case_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "test-cases")]
    impl std::convert::From<&str> for TestCaseView {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TEST_CASE_VIEW_UNSPECIFIED" => Self::Unspecified,
                "BASIC" => Self::Basic,
                "FULL" => Self::Full,
                _ => Self::UnknownValue(test_case_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "test-cases")]
    impl serde::ser::Serialize for TestCaseView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Basic => serializer.serialize_i32(1),
                Self::Full => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "test-cases")]
    impl<'de> serde::de::Deserialize<'de> for TestCaseView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TestCaseView>::new(
                ".google.cloud.dialogflow.cx.v3.ListTestCasesRequest.TestCaseView",
            ))
        }
    }
}

/// The response message for
/// [TestCases.ListTestCases][google.cloud.dialogflow.cx.v3.TestCases.ListTestCases].
///
/// [google.cloud.dialogflow.cx.v3.TestCases.ListTestCases]: crate::client::TestCases::list_test_cases
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTestCasesResponse {
    /// The list of test cases. There will be a maximum number of items returned
    /// based on the page_size field in the request.
    pub test_cases: std::vec::Vec<crate::model::TestCase>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl ListTestCasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [test_cases][crate::model::ListTestCasesResponse::test_cases].
    pub fn set_test_cases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TestCase>,
    {
        use std::iter::Iterator;
        self.test_cases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTestCasesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for ListTestCasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListTestCasesResponse"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTestCasesResponse {
    type PageItem = crate::model::TestCase;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.test_cases
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTestCasesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __test_cases,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTestCasesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "testCases" => Ok(__FieldTag::__test_cases),
                            "test_cases" => Ok(__FieldTag::__test_cases),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTestCasesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTestCasesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__test_cases => {
                            if !fields.insert(__FieldTag::__test_cases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_cases",
                                ));
                            }
                            result.test_cases = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TestCase>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for ListTestCasesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.test_cases.is_empty() {
            state.serialize_entry("testCases", &self.test_cases)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [TestCases.BatchDeleteTestCases][google.cloud.dialogflow.cx.v3.TestCases.BatchDeleteTestCases].
///
/// [google.cloud.dialogflow.cx.v3.TestCases.BatchDeleteTestCases]: crate::client::TestCases::batch_delete_test_cases
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchDeleteTestCasesRequest {
    /// Required. The agent to delete test cases from.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// Required. Format of test case names:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/testCases/<TestCaseID>`.
    pub names: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl BatchDeleteTestCasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchDeleteTestCasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [names][crate::model::BatchDeleteTestCasesRequest::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for BatchDeleteTestCasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.BatchDeleteTestCasesRequest"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchDeleteTestCasesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchDeleteTestCasesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "names" => Ok(__FieldTag::__names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchDeleteTestCasesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchDeleteTestCasesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__names => {
                            if !fields.insert(__FieldTag::__names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for names",
                                ));
                            }
                            result.names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for BatchDeleteTestCasesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.names.is_empty() {
            state.serialize_entry("names", &self.names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [TestCases.CreateTestCase][google.cloud.dialogflow.cx.v3.TestCases.CreateTestCase].
///
/// [google.cloud.dialogflow.cx.v3.TestCases.CreateTestCase]: crate::client::TestCases::create_test_case
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTestCaseRequest {
    /// Required. The agent to create the test case for.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// Required. The test case to create.
    pub test_case: std::option::Option<crate::model::TestCase>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl CreateTestCaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTestCaseRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [test_case][crate::model::CreateTestCaseRequest::test_case].
    pub fn set_test_case<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TestCase>,
    {
        self.test_case = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [test_case][crate::model::CreateTestCaseRequest::test_case].
    pub fn set_or_clear_test_case<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TestCase>,
    {
        self.test_case = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for CreateTestCaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CreateTestCaseRequest"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTestCaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __test_case,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTestCaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "testCase" => Ok(__FieldTag::__test_case),
                            "test_case" => Ok(__FieldTag::__test_case),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTestCaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTestCaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__test_case => {
                            if !fields.insert(__FieldTag::__test_case) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_case",
                                ));
                            }
                            result.test_case =
                                map.next_value::<std::option::Option<crate::model::TestCase>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateTestCaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.test_case.is_some() {
            state.serialize_entry("testCase", &self.test_case)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [TestCases.UpdateTestCase][google.cloud.dialogflow.cx.v3.TestCases.UpdateTestCase].
///
/// [google.cloud.dialogflow.cx.v3.TestCases.UpdateTestCase]: crate::client::TestCases::update_test_case
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTestCaseRequest {
    /// Required. The test case to update.
    pub test_case: std::option::Option<crate::model::TestCase>,

    /// Required. The mask to specify which fields should be updated. The
    /// [`creationTime`][google.cloud.dialogflow.cx.v3.TestCase.creation_time] and
    /// [`lastTestResult`][google.cloud.dialogflow.cx.v3.TestCase.last_test_result]
    /// cannot be updated.
    ///
    /// [google.cloud.dialogflow.cx.v3.TestCase.creation_time]: crate::model::TestCase::creation_time
    /// [google.cloud.dialogflow.cx.v3.TestCase.last_test_result]: crate::model::TestCase::last_test_result
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl UpdateTestCaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [test_case][crate::model::UpdateTestCaseRequest::test_case].
    pub fn set_test_case<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TestCase>,
    {
        self.test_case = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [test_case][crate::model::UpdateTestCaseRequest::test_case].
    pub fn set_or_clear_test_case<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TestCase>,
    {
        self.test_case = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTestCaseRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTestCaseRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for UpdateTestCaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.UpdateTestCaseRequest"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateTestCaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __test_case,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTestCaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "testCase" => Ok(__FieldTag::__test_case),
                            "test_case" => Ok(__FieldTag::__test_case),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateTestCaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTestCaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__test_case => {
                            if !fields.insert(__FieldTag::__test_case) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_case",
                                ));
                            }
                            result.test_case =
                                map.next_value::<std::option::Option<crate::model::TestCase>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateTestCaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.test_case.is_some() {
            state.serialize_entry("testCase", &self.test_case)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [TestCases.GetTestCase][google.cloud.dialogflow.cx.v3.TestCases.GetTestCase].
///
/// [google.cloud.dialogflow.cx.v3.TestCases.GetTestCase]: crate::client::TestCases::get_test_case
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTestCaseRequest {
    /// Required. The name of the testcase.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/testCases/<TestCaseID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl GetTestCaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTestCaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for GetTestCaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetTestCaseRequest"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTestCaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTestCaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTestCaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTestCaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for GetTestCaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [TestCases.RunTestCase][google.cloud.dialogflow.cx.v3.TestCases.RunTestCase].
///
/// [google.cloud.dialogflow.cx.v3.TestCases.RunTestCase]: crate::client::TestCases::run_test_case
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RunTestCaseRequest {
    /// Required. Format of test case name to run:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/testCases/<TestCaseID>`.
    pub name: std::string::String,

    /// Optional. Environment name. If not set, draft environment is assumed.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>`.
    pub environment: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl RunTestCaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RunTestCaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::RunTestCaseRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for RunTestCaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.RunTestCaseRequest"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunTestCaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __environment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunTestCaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "environment" => Ok(__FieldTag::__environment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunTestCaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunTestCaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for RunTestCaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [TestCases.RunTestCase][google.cloud.dialogflow.cx.v3.TestCases.RunTestCase].
///
/// [google.cloud.dialogflow.cx.v3.TestCases.RunTestCase]: crate::client::TestCases::run_test_case
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RunTestCaseResponse {
    /// The result.
    pub result: std::option::Option<crate::model::TestCaseResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl RunTestCaseResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result][crate::model::RunTestCaseResponse::result].
    pub fn set_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TestCaseResult>,
    {
        self.result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [result][crate::model::RunTestCaseResponse::result].
    pub fn set_or_clear_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TestCaseResult>,
    {
        self.result = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for RunTestCaseResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.RunTestCaseResponse"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunTestCaseResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunTestCaseResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "result" => Ok(__FieldTag::__result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunTestCaseResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunTestCaseResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__result => {
                            if !fields.insert(__FieldTag::__result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result",
                                ));
                            }
                            result.result = map
                                .next_value::<std::option::Option<crate::model::TestCaseResult>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for RunTestCaseResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.result.is_some() {
            state.serialize_entry("result", &self.result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata returned for the
/// [TestCases.RunTestCase][google.cloud.dialogflow.cx.v3.TestCases.RunTestCase]
/// long running operation. This message currently has no fields.
///
/// [google.cloud.dialogflow.cx.v3.TestCases.RunTestCase]: crate::client::TestCases::run_test_case
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RunTestCaseMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl RunTestCaseMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for RunTestCaseMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.RunTestCaseMetadata"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunTestCaseMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunTestCaseMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunTestCaseMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunTestCaseMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for RunTestCaseMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [TestCases.BatchRunTestCases][google.cloud.dialogflow.cx.v3.TestCases.BatchRunTestCases].
///
/// [google.cloud.dialogflow.cx.v3.TestCases.BatchRunTestCases]: crate::client::TestCases::batch_run_test_cases
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchRunTestCasesRequest {
    /// Required. Agent name. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// Optional. If not set, draft environment is assumed. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>`.
    pub environment: std::string::String,

    /// Required. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/testCases/<TestCaseID>`.
    pub test_cases: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl BatchRunTestCasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchRunTestCasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::BatchRunTestCasesRequest::environment].
    pub fn set_environment<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment = v.into();
        self
    }

    /// Sets the value of [test_cases][crate::model::BatchRunTestCasesRequest::test_cases].
    pub fn set_test_cases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.test_cases = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for BatchRunTestCasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.BatchRunTestCasesRequest"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchRunTestCasesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __environment,
            __test_cases,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchRunTestCasesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "environment" => Ok(__FieldTag::__environment),
                            "testCases" => Ok(__FieldTag::__test_cases),
                            "test_cases" => Ok(__FieldTag::__test_cases),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchRunTestCasesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchRunTestCasesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__test_cases => {
                            if !fields.insert(__FieldTag::__test_cases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_cases",
                                ));
                            }
                            result.test_cases = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for BatchRunTestCasesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.environment.is_empty() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self.test_cases.is_empty() {
            state.serialize_entry("testCases", &self.test_cases)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [TestCases.BatchRunTestCases][google.cloud.dialogflow.cx.v3.TestCases.BatchRunTestCases].
///
/// [google.cloud.dialogflow.cx.v3.TestCases.BatchRunTestCases]: crate::client::TestCases::batch_run_test_cases
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchRunTestCasesResponse {
    /// The test case results. The detailed
    /// [conversation
    /// turns][google.cloud.dialogflow.cx.v3.TestCaseResult.conversation_turns] are
    /// empty in this response.
    ///
    /// [google.cloud.dialogflow.cx.v3.TestCaseResult.conversation_turns]: crate::model::TestCaseResult::conversation_turns
    pub results: std::vec::Vec<crate::model::TestCaseResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl BatchRunTestCasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [results][crate::model::BatchRunTestCasesResponse::results].
    pub fn set_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TestCaseResult>,
    {
        use std::iter::Iterator;
        self.results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for BatchRunTestCasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.BatchRunTestCasesResponse"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchRunTestCasesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchRunTestCasesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "results" => Ok(__FieldTag::__results),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchRunTestCasesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchRunTestCasesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__results => {
                            if !fields.insert(__FieldTag::__results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for results",
                                ));
                            }
                            result.results =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TestCaseResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for BatchRunTestCasesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.results.is_empty() {
            state.serialize_entry("results", &self.results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata returned for the
/// [TestCases.BatchRunTestCases][google.cloud.dialogflow.cx.v3.TestCases.BatchRunTestCases]
/// long running operation.
///
/// [google.cloud.dialogflow.cx.v3.TestCases.BatchRunTestCases]: crate::client::TestCases::batch_run_test_cases
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchRunTestCasesMetadata {
    /// The test errors.
    pub errors: std::vec::Vec<crate::model::TestError>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl BatchRunTestCasesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [errors][crate::model::BatchRunTestCasesMetadata::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TestError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for BatchRunTestCasesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.BatchRunTestCasesMetadata"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchRunTestCasesMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchRunTestCasesMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "errors" => Ok(__FieldTag::__errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchRunTestCasesMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchRunTestCasesMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TestError>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for BatchRunTestCasesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Error info for running a test.
#[cfg(any(feature = "environments", feature = "test-cases",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TestError {
    /// The test case resource name.
    pub test_case: std::string::String,

    /// The status associated with the test.
    pub status: std::option::Option<rpc::model::Status>,

    /// The timestamp when the test was completed.
    pub test_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "environments", feature = "test-cases",))]
impl TestError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [test_case][crate::model::TestError::test_case].
    pub fn set_test_case<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.test_case = v.into();
        self
    }

    /// Sets the value of [status][crate::model::TestError::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::TestError::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [test_time][crate::model::TestError::test_time].
    pub fn set_test_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.test_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [test_time][crate::model::TestError::test_time].
    pub fn set_or_clear_test_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.test_time = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "environments", feature = "test-cases",))]
impl wkt::message::Message for TestError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.TestError"
    }
}

#[cfg(any(feature = "environments", feature = "test-cases",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TestError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __test_case,
            __status,
            __test_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TestError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "testCase" => Ok(__FieldTag::__test_case),
                            "test_case" => Ok(__FieldTag::__test_case),
                            "status" => Ok(__FieldTag::__status),
                            "testTime" => Ok(__FieldTag::__test_time),
                            "test_time" => Ok(__FieldTag::__test_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TestError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TestError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__test_case => {
                            if !fields.insert(__FieldTag::__test_case) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_case",
                                ));
                            }
                            result.test_case = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__test_time => {
                            if !fields.insert(__FieldTag::__test_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_time",
                                ));
                            }
                            result.test_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "environments", feature = "test-cases",))]
#[doc(hidden)]
impl serde::ser::Serialize for TestError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.test_case.is_empty() {
            state.serialize_entry("testCase", &self.test_case)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.test_time.is_some() {
            state.serialize_entry("testTime", &self.test_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [TestCases.ImportTestCases][google.cloud.dialogflow.cx.v3.TestCases.ImportTestCases].
///
/// [google.cloud.dialogflow.cx.v3.TestCases.ImportTestCases]: crate::client::TestCases::import_test_cases
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportTestCasesRequest {
    /// Required. The agent to import test cases to.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// Required. The source to import.
    pub source: std::option::Option<crate::model::import_test_cases_request::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl ImportTestCasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportTestCasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ImportTestCasesRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::import_test_cases_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportTestCasesRequest::source]
    /// if it holds a `GcsUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_test_cases_request::Source::GcsUri(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportTestCasesRequest::source]
    /// to hold a `GcsUri`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_test_cases_request::Source::GcsUri(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::ImportTestCasesRequest::source]
    /// if it holds a `Content`, `None` if the field is not set or
    /// holds a different branch.
    pub fn content(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_test_cases_request::Source::Content(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportTestCasesRequest::source]
    /// to hold a `Content`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_test_cases_request::Source::Content(v.into()),
        );
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for ImportTestCasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ImportTestCasesRequest"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportTestCasesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __gcs_uri,
            __content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportTestCasesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "gcsUri" => Ok(__FieldTag::__gcs_uri),
                            "gcs_uri" => Ok(__FieldTag::__gcs_uri),
                            "content" => Ok(__FieldTag::__content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportTestCasesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportTestCasesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcs_uri => {
                            if !fields.insert(__FieldTag::__gcs_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_uri",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ImportTestCasesRequest.gcs_uri, latest field was gcsUri",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::import_test_cases_request::Source::GcsUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ImportTestCasesRequest.content, latest field was content",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::import_test_cases_request::Source::Content(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for ImportTestCasesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.gcs_uri() {
            state.serialize_entry("gcsUri", value)?;
        }
        if let Some(value) = self.content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("content", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ImportTestCasesRequest].
#[cfg(feature = "test-cases")]
pub mod import_test_cases_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The source to import.
    #[cfg(feature = "test-cases")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI
        /// to import test cases from. The format of this URI must be
        /// `gs://<bucket-name>/<object-name>`.
        ///
        /// Dialogflow performs a read operation for the Cloud Storage object
        /// on the caller's behalf, so your request authentication must
        /// have read permissions for the object. For more information, see
        /// [Dialogflow access
        /// control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
        GcsUri(std::string::String),
        /// Uncompressed raw byte content for test cases.
        Content(::bytes::Bytes),
    }
}

/// The response message for
/// [TestCases.ImportTestCases][google.cloud.dialogflow.cx.v3.TestCases.ImportTestCases].
///
/// [google.cloud.dialogflow.cx.v3.TestCases.ImportTestCases]: crate::client::TestCases::import_test_cases
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportTestCasesResponse {
    /// The unique identifiers of the new test cases.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/testCases/<TestCaseID>`.
    pub names: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl ImportTestCasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [names][crate::model::ImportTestCasesResponse::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for ImportTestCasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ImportTestCasesResponse"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportTestCasesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportTestCasesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "names" => Ok(__FieldTag::__names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportTestCasesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportTestCasesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__names => {
                            if !fields.insert(__FieldTag::__names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for names",
                                ));
                            }
                            result.names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for ImportTestCasesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.names.is_empty() {
            state.serialize_entry("names", &self.names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata returned for the
/// [TestCases.ImportTestCases][google.cloud.dialogflow.cx.v3.TestCases.ImportTestCases]
/// long running operation.
///
/// [google.cloud.dialogflow.cx.v3.TestCases.ImportTestCases]: crate::client::TestCases::import_test_cases
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportTestCasesMetadata {
    /// Errors for failed test cases.
    pub errors: std::vec::Vec<crate::model::TestCaseError>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl ImportTestCasesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [errors][crate::model::ImportTestCasesMetadata::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TestCaseError>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for ImportTestCasesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ImportTestCasesMetadata"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportTestCasesMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportTestCasesMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "errors" => Ok(__FieldTag::__errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportTestCasesMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportTestCasesMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TestCaseError>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for ImportTestCasesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Error info for importing a test.
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TestCaseError {
    /// The test case.
    pub test_case: std::option::Option<crate::model::TestCase>,

    /// The status associated with the test case.
    pub status: std::option::Option<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl TestCaseError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [test_case][crate::model::TestCaseError::test_case].
    pub fn set_test_case<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TestCase>,
    {
        self.test_case = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [test_case][crate::model::TestCaseError::test_case].
    pub fn set_or_clear_test_case<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TestCase>,
    {
        self.test_case = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::TestCaseError::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::TestCaseError::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for TestCaseError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.TestCaseError"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TestCaseError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __test_case,
            __status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TestCaseError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "testCase" => Ok(__FieldTag::__test_case),
                            "test_case" => Ok(__FieldTag::__test_case),
                            "status" => Ok(__FieldTag::__status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TestCaseError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TestCaseError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__test_case => {
                            if !fields.insert(__FieldTag::__test_case) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_case",
                                ));
                            }
                            result.test_case =
                                map.next_value::<std::option::Option<crate::model::TestCase>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for TestCaseError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.test_case.is_some() {
            state.serialize_entry("testCase", &self.test_case)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [TestCases.ExportTestCases][google.cloud.dialogflow.cx.v3.TestCases.ExportTestCases].
///
/// [google.cloud.dialogflow.cx.v3.TestCases.ExportTestCases]: crate::client::TestCases::export_test_cases
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportTestCasesRequest {
    /// Required. The agent where to export test cases from.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// The data format of the exported test cases. If not specified, `BLOB` is
    /// assumed.
    pub data_format: crate::model::export_test_cases_request::DataFormat,

    /// The filter expression used to filter exported test cases, see
    /// [API Filtering](https://aip.dev/160). The expression is case insensitive
    /// and supports the following syntax:
    ///
    /// name = \<value\> [OR name = \<value\>] ...
    ///
    /// For example:
    ///
    /// * "name = t1 OR name = t2" matches the test case with the exact resource
    ///   name "t1" or "t2".
    pub filter: std::string::String,

    /// The destination to export.
    pub destination: std::option::Option<crate::model::export_test_cases_request::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl ExportTestCasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ExportTestCasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [data_format][crate::model::ExportTestCasesRequest::data_format].
    pub fn set_data_format<
        T: std::convert::Into<crate::model::export_test_cases_request::DataFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.data_format = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ExportTestCasesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ExportTestCasesRequest::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<
                std::option::Option<crate::model::export_test_cases_request::Destination>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportTestCasesRequest::destination]
    /// if it holds a `GcsUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_test_cases_request::Destination::GcsUri(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportTestCasesRequest::destination]
    /// to hold a `GcsUri`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_test_cases_request::Destination::GcsUri(v.into()),
        );
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for ExportTestCasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ExportTestCasesRequest"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportTestCasesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __gcs_uri,
            __data_format,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportTestCasesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "gcsUri" => Ok(__FieldTag::__gcs_uri),
                            "gcs_uri" => Ok(__FieldTag::__gcs_uri),
                            "dataFormat" => Ok(__FieldTag::__data_format),
                            "data_format" => Ok(__FieldTag::__data_format),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportTestCasesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportTestCasesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcs_uri => {
                            if !fields.insert(__FieldTag::__gcs_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_uri",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ExportTestCasesRequest.gcs_uri, latest field was gcsUri",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::export_test_cases_request::Destination::GcsUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_format => {
                            if !fields.insert(__FieldTag::__data_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_format",
                                ));
                            }
                            result.data_format = map
                                .next_value::<std::option::Option<
                                    crate::model::export_test_cases_request::DataFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for ExportTestCasesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.gcs_uri() {
            state.serialize_entry("gcsUri", value)?;
        }
        if !wkt::internal::is_default(&self.data_format) {
            state.serialize_entry("dataFormat", &self.data_format)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExportTestCasesRequest].
#[cfg(feature = "test-cases")]
pub mod export_test_cases_request {
    #[allow(unused_imports)]
    use super::*;

    /// Data format of the exported test cases.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "test-cases")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DataFormat {
        /// Unspecified format.
        Unspecified,
        /// Raw bytes.
        Blob,
        /// JSON format.
        Json,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DataFormat::value] or
        /// [DataFormat::name].
        UnknownValue(data_format::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "test-cases")]
    pub mod data_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "test-cases")]
    impl DataFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Blob => std::option::Option::Some(1),
                Self::Json => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DATA_FORMAT_UNSPECIFIED"),
                Self::Blob => std::option::Option::Some("BLOB"),
                Self::Json => std::option::Option::Some("JSON"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "test-cases")]
    impl std::default::Default for DataFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "test-cases")]
    impl std::fmt::Display for DataFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "test-cases")]
    impl std::convert::From<i32> for DataFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Blob,
                2 => Self::Json,
                _ => Self::UnknownValue(data_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "test-cases")]
    impl std::convert::From<&str> for DataFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DATA_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "BLOB" => Self::Blob,
                "JSON" => Self::Json,
                _ => Self::UnknownValue(data_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "test-cases")]
    impl serde::ser::Serialize for DataFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Blob => serializer.serialize_i32(1),
                Self::Json => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "test-cases")]
    impl<'de> serde::de::Deserialize<'de> for DataFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataFormat>::new(
                ".google.cloud.dialogflow.cx.v3.ExportTestCasesRequest.DataFormat",
            ))
        }
    }

    /// The destination to export.
    #[cfg(feature = "test-cases")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI to
        /// export the test cases to. The format of this URI must be
        /// `gs://<bucket-name>/<object-name>`. If unspecified, the serialized test
        /// cases is returned inline.
        ///
        /// Dialogflow performs a write operation for the Cloud Storage object
        /// on the caller's behalf, so your request authentication must
        /// have write permissions for the object. For more information, see
        /// [Dialogflow access
        /// control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
        GcsUri(std::string::String),
    }
}

/// The response message for
/// [TestCases.ExportTestCases][google.cloud.dialogflow.cx.v3.TestCases.ExportTestCases].
///
/// [google.cloud.dialogflow.cx.v3.TestCases.ExportTestCases]: crate::client::TestCases::export_test_cases
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportTestCasesResponse {
    /// The exported test cases.
    pub destination: std::option::Option<crate::model::export_test_cases_response::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl ExportTestCasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [destination][crate::model::ExportTestCasesResponse::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<
                std::option::Option<crate::model::export_test_cases_response::Destination>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportTestCasesResponse::destination]
    /// if it holds a `GcsUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_test_cases_response::Destination::GcsUri(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportTestCasesResponse::destination]
    /// to hold a `GcsUri`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_test_cases_response::Destination::GcsUri(v.into()),
        );
        self
    }

    /// The value of [destination][crate::model::ExportTestCasesResponse::destination]
    /// if it holds a `Content`, `None` if the field is not set or
    /// holds a different branch.
    pub fn content(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_test_cases_response::Destination::Content(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportTestCasesResponse::destination]
    /// to hold a `Content`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_test_cases_response::Destination::Content(v.into()),
        );
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for ExportTestCasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ExportTestCasesResponse"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportTestCasesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_uri,
            __content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportTestCasesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsUri" => Ok(__FieldTag::__gcs_uri),
                            "gcs_uri" => Ok(__FieldTag::__gcs_uri),
                            "content" => Ok(__FieldTag::__content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportTestCasesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportTestCasesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_uri => {
                            if !fields.insert(__FieldTag::__gcs_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_uri",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ExportTestCasesResponse.gcs_uri, latest field was gcsUri",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::export_test_cases_response::Destination::GcsUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.dialogflow.cx.v3.ExportTestCasesResponse.content, latest field was content",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::export_test_cases_response::Destination::Content(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for ExportTestCasesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_uri() {
            state.serialize_entry("gcsUri", value)?;
        }
        if let Some(value) = self.content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("content", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExportTestCasesResponse].
#[cfg(feature = "test-cases")]
pub mod export_test_cases_response {
    #[allow(unused_imports)]
    use super::*;

    /// The exported test cases.
    #[cfg(feature = "test-cases")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// The URI to a file containing the exported test cases. This field is
        /// populated only if `gcs_uri` is specified in
        /// [ExportTestCasesRequest][google.cloud.dialogflow.cx.v3.ExportTestCasesRequest].
        ///
        /// [google.cloud.dialogflow.cx.v3.ExportTestCasesRequest]: crate::model::ExportTestCasesRequest
        GcsUri(std::string::String),
        /// Uncompressed raw byte content for test cases.
        Content(::bytes::Bytes),
    }
}

/// Metadata returned for the
/// [TestCases.ExportTestCases][google.cloud.dialogflow.cx.v3.TestCases.ExportTestCases]
/// long running operation. This message currently has no fields.
///
/// [google.cloud.dialogflow.cx.v3.TestCases.ExportTestCases]: crate::client::TestCases::export_test_cases
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportTestCasesMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl ExportTestCasesMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for ExportTestCasesMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ExportTestCasesMetadata"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportTestCasesMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportTestCasesMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportTestCasesMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportTestCasesMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for ExportTestCasesMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [TestCases.ListTestCaseResults][google.cloud.dialogflow.cx.v3.TestCases.ListTestCaseResults].
///
/// [google.cloud.dialogflow.cx.v3.TestCases.ListTestCaseResults]: crate::client::TestCases::list_test_case_results
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTestCaseResultsRequest {
    /// Required. The test case to list results for.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/testCases/<TestCaseID>`.
    /// Specify a `-` as a wildcard for TestCase ID to
    /// list results across multiple test cases.
    pub parent: std::string::String,

    /// The maximum number of items to return in a single page. By default 100 and
    /// at most 1000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    /// The filter expression used to filter test case results. See
    /// [API Filtering](https://aip.dev/160).
    ///
    /// The expression is case insensitive. Only 'AND' is supported for logical
    /// operators. The supported syntax is listed below in detail:
    ///
    /// \<field\> \<operator\> \<value\> [AND \<field\> \<operator\> \<value\>] ...
    /// [AND latest]
    ///
    /// The supported fields and operators are:
    /// field                 operator
    /// `environment`         `=`, `IN`  (Use value `draft` for draft environment)
    /// `test_time`           `>`, `<`
    ///
    /// `latest` only returns the latest test result in all results for each test
    /// case.
    ///
    /// Examples:
    ///
    /// * "environment=draft AND latest" matches the latest test result for each
    ///   test case in the draft environment.
    /// * "environment IN (e1,e2)" matches any test case results with an
    ///   environment resource name of either "e1" or "e2".
    /// * "test_time > 1602540713" matches any test case results with test time
    ///   later than a unix timestamp in seconds 1602540713.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl ListTestCaseResultsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTestCaseResultsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTestCaseResultsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTestCaseResultsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTestCaseResultsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for ListTestCaseResultsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListTestCaseResultsRequest"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTestCaseResultsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTestCaseResultsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTestCaseResultsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTestCaseResultsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for ListTestCaseResultsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [TestCases.ListTestCaseResults][google.cloud.dialogflow.cx.v3.TestCases.ListTestCaseResults].
///
/// [google.cloud.dialogflow.cx.v3.TestCases.ListTestCaseResults]: crate::client::TestCases::list_test_case_results
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTestCaseResultsResponse {
    /// The list of test case results.
    pub test_case_results: std::vec::Vec<crate::model::TestCaseResult>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl ListTestCaseResultsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [test_case_results][crate::model::ListTestCaseResultsResponse::test_case_results].
    pub fn set_test_case_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TestCaseResult>,
    {
        use std::iter::Iterator;
        self.test_case_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTestCaseResultsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for ListTestCaseResultsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListTestCaseResultsResponse"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTestCaseResultsResponse {
    type PageItem = crate::model::TestCaseResult;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.test_case_results
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTestCaseResultsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __test_case_results,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTestCaseResultsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "testCaseResults" => Ok(__FieldTag::__test_case_results),
                            "test_case_results" => Ok(__FieldTag::__test_case_results),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTestCaseResultsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTestCaseResultsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__test_case_results => {
                            if !fields.insert(__FieldTag::__test_case_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_case_results",
                                ));
                            }
                            result.test_case_results =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TestCaseResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for ListTestCaseResultsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.test_case_results.is_empty() {
            state.serialize_entry("testCaseResults", &self.test_case_results)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [TestCases.GetTestCaseResult][google.cloud.dialogflow.cx.v3.TestCases.GetTestCaseResult].
///
/// [google.cloud.dialogflow.cx.v3.TestCases.GetTestCaseResult]: crate::client::TestCases::get_test_case_result
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTestCaseResultRequest {
    /// Required. The name of the testcase.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/testCases/<TestCaseID>/results/<TestCaseResultID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "test-cases")]
impl GetTestCaseResultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTestCaseResultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "test-cases")]
impl wkt::message::Message for GetTestCaseResultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetTestCaseResultRequest"
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTestCaseResultRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTestCaseResultRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTestCaseResultRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTestCaseResultRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "test-cases")]
#[doc(hidden)]
impl serde::ser::Serialize for GetTestCaseResultRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A TransitionRouteGroup represents a group of
/// [`TransitionRoutes`][google.cloud.dialogflow.cx.v3.TransitionRoute] to be
/// used by a [Page][google.cloud.dialogflow.cx.v3.Page].
///
/// [google.cloud.dialogflow.cx.v3.Page]: crate::model::Page
/// [google.cloud.dialogflow.cx.v3.TransitionRoute]: crate::model::TransitionRoute
#[cfg(any(feature = "test-cases", feature = "transition-route-groups",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TransitionRouteGroup {
    /// The unique identifier of the transition route group.
    /// [TransitionRouteGroups.CreateTransitionRouteGroup][google.cloud.dialogflow.cx.v3.TransitionRouteGroups.CreateTransitionRouteGroup]
    /// populates the name automatically. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/transitionRouteGroups/<TransitionRouteGroupID>`
    /// .
    ///
    /// [google.cloud.dialogflow.cx.v3.TransitionRouteGroups.CreateTransitionRouteGroup]: crate::client::TransitionRouteGroups::create_transition_route_group
    pub name: std::string::String,

    /// Required. The human-readable name of the transition route group, unique
    /// within the flow. The display name can be no longer than 30 characters.
    pub display_name: std::string::String,

    /// Transition routes associated with the
    /// [TransitionRouteGroup][google.cloud.dialogflow.cx.v3.TransitionRouteGroup].
    ///
    /// [google.cloud.dialogflow.cx.v3.TransitionRouteGroup]: crate::model::TransitionRouteGroup
    pub transition_routes: std::vec::Vec<crate::model::TransitionRoute>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "test-cases", feature = "transition-route-groups",))]
impl TransitionRouteGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TransitionRouteGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::TransitionRouteGroup::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [transition_routes][crate::model::TransitionRouteGroup::transition_routes].
    pub fn set_transition_routes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransitionRoute>,
    {
        use std::iter::Iterator;
        self.transition_routes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(feature = "test-cases", feature = "transition-route-groups",))]
impl wkt::message::Message for TransitionRouteGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.TransitionRouteGroup"
    }
}

#[cfg(any(feature = "test-cases", feature = "transition-route-groups",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TransitionRouteGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __transition_routes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TransitionRouteGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "transitionRoutes" => Ok(__FieldTag::__transition_routes),
                            "transition_routes" => Ok(__FieldTag::__transition_routes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TransitionRouteGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TransitionRouteGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transition_routes => {
                            if !fields.insert(__FieldTag::__transition_routes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transition_routes",
                                ));
                            }
                            result.transition_routes =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TransitionRoute>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "test-cases", feature = "transition-route-groups",))]
#[doc(hidden)]
impl serde::ser::Serialize for TransitionRouteGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.transition_routes.is_empty() {
            state.serialize_entry("transitionRoutes", &self.transition_routes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [TransitionRouteGroups.ListTransitionRouteGroups][google.cloud.dialogflow.cx.v3.TransitionRouteGroups.ListTransitionRouteGroups].
///
/// [google.cloud.dialogflow.cx.v3.TransitionRouteGroups.ListTransitionRouteGroups]: crate::client::TransitionRouteGroups::list_transition_route_groups
#[cfg(feature = "transition-route-groups")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTransitionRouteGroupsRequest {
    /// Required. The flow to list all transition route groups for.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>`
    /// or `projects/\<ProjectID\>/locations/\<LocationID\>/agents/\<AgentID\>.
    pub parent: std::string::String,

    /// The maximum number of items to return in a single page. By default 100 and
    /// at most 1000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    /// The language to list transition route groups for. The following fields are
    /// language dependent:
    ///
    /// * `TransitionRouteGroup.transition_routes.trigger_fulfillment.messages`
    ///
    /// `TransitionRouteGroup.transition_routes.trigger_fulfillment.conditional_cases`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "transition-route-groups")]
impl ListTransitionRouteGroupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTransitionRouteGroupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTransitionRouteGroupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTransitionRouteGroupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::ListTransitionRouteGroupsRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "transition-route-groups")]
impl wkt::message::Message for ListTransitionRouteGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListTransitionRouteGroupsRequest"
    }
}

#[cfg(feature = "transition-route-groups")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTransitionRouteGroupsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTransitionRouteGroupsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTransitionRouteGroupsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTransitionRouteGroupsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "transition-route-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for ListTransitionRouteGroupsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [TransitionRouteGroups.ListTransitionRouteGroups][google.cloud.dialogflow.cx.v3.TransitionRouteGroups.ListTransitionRouteGroups].
///
/// [google.cloud.dialogflow.cx.v3.TransitionRouteGroups.ListTransitionRouteGroups]: crate::client::TransitionRouteGroups::list_transition_route_groups
#[cfg(feature = "transition-route-groups")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTransitionRouteGroupsResponse {
    /// The list of transition route groups. There will be a maximum number of
    /// items returned based on the page_size field in the request. The list may in
    /// some cases be empty or contain fewer entries than page_size even if this
    /// isn't the last page.
    pub transition_route_groups: std::vec::Vec<crate::model::TransitionRouteGroup>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "transition-route-groups")]
impl ListTransitionRouteGroupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transition_route_groups][crate::model::ListTransitionRouteGroupsResponse::transition_route_groups].
    pub fn set_transition_route_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TransitionRouteGroup>,
    {
        use std::iter::Iterator;
        self.transition_route_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTransitionRouteGroupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "transition-route-groups")]
impl wkt::message::Message for ListTransitionRouteGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListTransitionRouteGroupsResponse"
    }
}

#[cfg(feature = "transition-route-groups")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTransitionRouteGroupsResponse {
    type PageItem = crate::model::TransitionRouteGroup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.transition_route_groups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "transition-route-groups")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTransitionRouteGroupsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transition_route_groups,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTransitionRouteGroupsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transitionRouteGroups" => Ok(__FieldTag::__transition_route_groups),
                            "transition_route_groups" => Ok(__FieldTag::__transition_route_groups),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTransitionRouteGroupsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTransitionRouteGroupsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transition_route_groups => {
                            if !fields.insert(__FieldTag::__transition_route_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transition_route_groups",
                                ));
                            }
                            result.transition_route_groups = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::TransitionRouteGroup>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "transition-route-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for ListTransitionRouteGroupsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.transition_route_groups.is_empty() {
            state.serialize_entry("transitionRouteGroups", &self.transition_route_groups)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [TransitionRouteGroups.GetTransitionRouteGroup][google.cloud.dialogflow.cx.v3.TransitionRouteGroups.GetTransitionRouteGroup].
///
/// [google.cloud.dialogflow.cx.v3.TransitionRouteGroups.GetTransitionRouteGroup]: crate::client::TransitionRouteGroups::get_transition_route_group
#[cfg(feature = "transition-route-groups")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTransitionRouteGroupRequest {
    /// Required. The name of the
    /// [TransitionRouteGroup][google.cloud.dialogflow.cx.v3.TransitionRouteGroup].
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/transitionRouteGroups/<TransitionRouteGroupID>`
    /// or
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/transitionRouteGroups/<TransitionRouteGroupID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.TransitionRouteGroup]: crate::model::TransitionRouteGroup
    pub name: std::string::String,

    /// The language to retrieve the transition route group for. The following
    /// fields are language dependent:
    ///
    /// * `TransitionRouteGroup.transition_routes.trigger_fulfillment.messages`
    ///
    /// `TransitionRouteGroup.transition_routes.trigger_fulfillment.conditional_cases`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "transition-route-groups")]
impl GetTransitionRouteGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTransitionRouteGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::GetTransitionRouteGroupRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "transition-route-groups")]
impl wkt::message::Message for GetTransitionRouteGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetTransitionRouteGroupRequest"
    }
}

#[cfg(feature = "transition-route-groups")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTransitionRouteGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTransitionRouteGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTransitionRouteGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTransitionRouteGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "transition-route-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for GetTransitionRouteGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [TransitionRouteGroups.CreateTransitionRouteGroup][google.cloud.dialogflow.cx.v3.TransitionRouteGroups.CreateTransitionRouteGroup].
///
/// [google.cloud.dialogflow.cx.v3.TransitionRouteGroups.CreateTransitionRouteGroup]: crate::client::TransitionRouteGroups::create_transition_route_group
#[cfg(feature = "transition-route-groups")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTransitionRouteGroupRequest {
    /// Required. The flow to create an
    /// [TransitionRouteGroup][google.cloud.dialogflow.cx.v3.TransitionRouteGroup]
    /// for. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>`
    /// or `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`
    /// for agent-level groups.
    ///
    /// [google.cloud.dialogflow.cx.v3.TransitionRouteGroup]: crate::model::TransitionRouteGroup
    pub parent: std::string::String,

    /// Required. The transition route group to create.
    pub transition_route_group: std::option::Option<crate::model::TransitionRouteGroup>,

    /// The language of the following fields in `TransitionRouteGroup`:
    ///
    /// * `TransitionRouteGroup.transition_routes.trigger_fulfillment.messages`
    ///
    /// `TransitionRouteGroup.transition_routes.trigger_fulfillment.conditional_cases`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "transition-route-groups")]
impl CreateTransitionRouteGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTransitionRouteGroupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [transition_route_group][crate::model::CreateTransitionRouteGroupRequest::transition_route_group].
    pub fn set_transition_route_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransitionRouteGroup>,
    {
        self.transition_route_group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transition_route_group][crate::model::CreateTransitionRouteGroupRequest::transition_route_group].
    pub fn set_or_clear_transition_route_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransitionRouteGroup>,
    {
        self.transition_route_group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::CreateTransitionRouteGroupRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "transition-route-groups")]
impl wkt::message::Message for CreateTransitionRouteGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CreateTransitionRouteGroupRequest"
    }
}

#[cfg(feature = "transition-route-groups")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTransitionRouteGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __transition_route_group,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTransitionRouteGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "transitionRouteGroup" => Ok(__FieldTag::__transition_route_group),
                            "transition_route_group" => Ok(__FieldTag::__transition_route_group),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTransitionRouteGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTransitionRouteGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transition_route_group => {
                            if !fields.insert(__FieldTag::__transition_route_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transition_route_group",
                                ));
                            }
                            result.transition_route_group = map.next_value::<std::option::Option<crate::model::TransitionRouteGroup>>()?
                                ;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "transition-route-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateTransitionRouteGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.transition_route_group.is_some() {
            state.serialize_entry("transitionRouteGroup", &self.transition_route_group)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [TransitionRouteGroups.UpdateTransitionRouteGroup][google.cloud.dialogflow.cx.v3.TransitionRouteGroups.UpdateTransitionRouteGroup].
///
/// [google.cloud.dialogflow.cx.v3.TransitionRouteGroups.UpdateTransitionRouteGroup]: crate::client::TransitionRouteGroups::update_transition_route_group
#[cfg(feature = "transition-route-groups")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTransitionRouteGroupRequest {
    /// Required. The transition route group to update.
    pub transition_route_group: std::option::Option<crate::model::TransitionRouteGroup>,

    /// The mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// The language of the following fields in `TransitionRouteGroup`:
    ///
    /// * `TransitionRouteGroup.transition_routes.trigger_fulfillment.messages`
    ///
    /// `TransitionRouteGroup.transition_routes.trigger_fulfillment.conditional_cases`
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/cx/docs/reference/language)
    /// are supported.
    /// Note: languages must be enabled in the agent before they can be used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "transition-route-groups")]
impl UpdateTransitionRouteGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [transition_route_group][crate::model::UpdateTransitionRouteGroupRequest::transition_route_group].
    pub fn set_transition_route_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TransitionRouteGroup>,
    {
        self.transition_route_group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [transition_route_group][crate::model::UpdateTransitionRouteGroupRequest::transition_route_group].
    pub fn set_or_clear_transition_route_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TransitionRouteGroup>,
    {
        self.transition_route_group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTransitionRouteGroupRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTransitionRouteGroupRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::UpdateTransitionRouteGroupRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "transition-route-groups")]
impl wkt::message::Message for UpdateTransitionRouteGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.UpdateTransitionRouteGroupRequest"
    }
}

#[cfg(feature = "transition-route-groups")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateTransitionRouteGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __transition_route_group,
            __update_mask,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTransitionRouteGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "transitionRouteGroup" => Ok(__FieldTag::__transition_route_group),
                            "transition_route_group" => Ok(__FieldTag::__transition_route_group),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateTransitionRouteGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTransitionRouteGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__transition_route_group => {
                            if !fields.insert(__FieldTag::__transition_route_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transition_route_group",
                                ));
                            }
                            result.transition_route_group = map.next_value::<std::option::Option<crate::model::TransitionRouteGroup>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "transition-route-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateTransitionRouteGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.transition_route_group.is_some() {
            state.serialize_entry("transitionRouteGroup", &self.transition_route_group)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [TransitionRouteGroups.DeleteTransitionRouteGroup][google.cloud.dialogflow.cx.v3.TransitionRouteGroups.DeleteTransitionRouteGroup].
///
/// [google.cloud.dialogflow.cx.v3.TransitionRouteGroups.DeleteTransitionRouteGroup]: crate::client::TransitionRouteGroups::delete_transition_route_group
#[cfg(feature = "transition-route-groups")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTransitionRouteGroupRequest {
    /// Required. The name of the
    /// [TransitionRouteGroup][google.cloud.dialogflow.cx.v3.TransitionRouteGroup]
    /// to delete. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/transitionRouteGroups/<TransitionRouteGroupID>`
    /// or
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/transitionRouteGroups/<TransitionRouteGroupID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.TransitionRouteGroup]: crate::model::TransitionRouteGroup
    pub name: std::string::String,

    /// This field has no effect for transition route group that no page is using.
    /// If the transition route group is referenced by any page:
    ///
    /// * If `force` is set to false, an error will be returned with message
    ///   indicating pages that reference the transition route group.
    /// * If `force` is set to true, Dialogflow will remove the transition route
    ///   group, as well as any reference to it.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "transition-route-groups")]
impl DeleteTransitionRouteGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTransitionRouteGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteTransitionRouteGroupRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

#[cfg(feature = "transition-route-groups")]
impl wkt::message::Message for DeleteTransitionRouteGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DeleteTransitionRouteGroupRequest"
    }
}

#[cfg(feature = "transition-route-groups")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTransitionRouteGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTransitionRouteGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTransitionRouteGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTransitionRouteGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "transition-route-groups")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteTransitionRouteGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Agent/flow validation message.
#[cfg(any(feature = "agents", feature = "flows",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidationMessage {
    /// The type of the resources where the message is found.
    pub resource_type: crate::model::validation_message::ResourceType,

    /// The names of the resources where the message is found.
    #[deprecated]
    pub resources: std::vec::Vec<std::string::String>,

    /// The resource names of the resources where the message is found.
    pub resource_names: std::vec::Vec<crate::model::ResourceName>,

    /// Indicates the severity of the message.
    pub severity: crate::model::validation_message::Severity,

    /// The message detail.
    pub detail: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "agents", feature = "flows",))]
impl ValidationMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_type][crate::model::ValidationMessage::resource_type].
    pub fn set_resource_type<
        T: std::convert::Into<crate::model::validation_message::ResourceType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [resources][crate::model::ValidationMessage::resources].
    #[deprecated]
    pub fn set_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resource_names][crate::model::ValidationMessage::resource_names].
    pub fn set_resource_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResourceName>,
    {
        use std::iter::Iterator;
        self.resource_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [severity][crate::model::ValidationMessage::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::validation_message::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [detail][crate::model::ValidationMessage::detail].
    pub fn set_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.detail = v.into();
        self
    }
}

#[cfg(any(feature = "agents", feature = "flows",))]
impl wkt::message::Message for ValidationMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ValidationMessage"
    }
}

#[cfg(any(feature = "agents", feature = "flows",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValidationMessage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_type,
            __resources,
            __resource_names,
            __severity,
            __detail,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValidationMessage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceType" => Ok(__FieldTag::__resource_type),
                            "resource_type" => Ok(__FieldTag::__resource_type),
                            "resources" => Ok(__FieldTag::__resources),
                            "resourceNames" => Ok(__FieldTag::__resource_names),
                            "resource_names" => Ok(__FieldTag::__resource_names),
                            "severity" => Ok(__FieldTag::__severity),
                            "detail" => Ok(__FieldTag::__detail),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValidationMessage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValidationMessage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_type => {
                            if !fields.insert(__FieldTag::__resource_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_type",
                                ));
                            }
                            result.resource_type =
                                map.next_value::<std::option::Option<
                                    crate::model::validation_message::ResourceType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resources => {
                            if !fields.insert(__FieldTag::__resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resources",
                                ));
                            }
                            result.resources = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__resource_names => {
                            if !fields.insert(__FieldTag::__resource_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_names",
                                ));
                            }
                            result.resource_names = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ResourceName>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map.next_value::<std::option::Option<crate::model::validation_message::Severity>>()?.unwrap_or_default();
                        }
                        __FieldTag::__detail => {
                            if !fields.insert(__FieldTag::__detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detail",
                                ));
                            }
                            result.detail = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "agents", feature = "flows",))]
#[doc(hidden)]
impl serde::ser::Serialize for ValidationMessage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.resource_type) {
            state.serialize_entry("resourceType", &self.resource_type)?;
        }
        if !self.resources.is_empty() {
            state.serialize_entry("resources", &self.resources)?;
        }
        if !self.resource_names.is_empty() {
            state.serialize_entry("resourceNames", &self.resource_names)?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self.detail.is_empty() {
            state.serialize_entry("detail", &self.detail)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ValidationMessage].
#[cfg(any(feature = "agents", feature = "flows",))]
pub mod validation_message {
    #[allow(unused_imports)]
    use super::*;

    /// Resource types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "agents", feature = "flows",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ResourceType {
        /// Unspecified.
        Unspecified,
        /// Agent.
        Agent,
        /// Intent.
        Intent,
        /// Intent training phrase.
        IntentTrainingPhrase,
        /// Intent parameter.
        IntentParameter,
        /// Multiple intents.
        Intents,
        /// Multiple training phrases.
        IntentTrainingPhrases,
        /// Entity type.
        EntityType,
        /// Multiple entity types.
        EntityTypes,
        /// Webhook.
        Webhook,
        /// Flow.
        Flow,
        /// Page.
        Page,
        /// Multiple pages.
        Pages,
        /// Transition route group.
        TransitionRouteGroup,
        /// Agent transition route group.
        AgentTransitionRouteGroup,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ResourceType::value] or
        /// [ResourceType::name].
        UnknownValue(resource_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "agents", feature = "flows",))]
    pub mod resource_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "agents", feature = "flows",))]
    impl ResourceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Agent => std::option::Option::Some(1),
                Self::Intent => std::option::Option::Some(2),
                Self::IntentTrainingPhrase => std::option::Option::Some(8),
                Self::IntentParameter => std::option::Option::Some(9),
                Self::Intents => std::option::Option::Some(10),
                Self::IntentTrainingPhrases => std::option::Option::Some(11),
                Self::EntityType => std::option::Option::Some(3),
                Self::EntityTypes => std::option::Option::Some(12),
                Self::Webhook => std::option::Option::Some(4),
                Self::Flow => std::option::Option::Some(5),
                Self::Page => std::option::Option::Some(6),
                Self::Pages => std::option::Option::Some(13),
                Self::TransitionRouteGroup => std::option::Option::Some(7),
                Self::AgentTransitionRouteGroup => std::option::Option::Some(14),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESOURCE_TYPE_UNSPECIFIED"),
                Self::Agent => std::option::Option::Some("AGENT"),
                Self::Intent => std::option::Option::Some("INTENT"),
                Self::IntentTrainingPhrase => std::option::Option::Some("INTENT_TRAINING_PHRASE"),
                Self::IntentParameter => std::option::Option::Some("INTENT_PARAMETER"),
                Self::Intents => std::option::Option::Some("INTENTS"),
                Self::IntentTrainingPhrases => std::option::Option::Some("INTENT_TRAINING_PHRASES"),
                Self::EntityType => std::option::Option::Some("ENTITY_TYPE"),
                Self::EntityTypes => std::option::Option::Some("ENTITY_TYPES"),
                Self::Webhook => std::option::Option::Some("WEBHOOK"),
                Self::Flow => std::option::Option::Some("FLOW"),
                Self::Page => std::option::Option::Some("PAGE"),
                Self::Pages => std::option::Option::Some("PAGES"),
                Self::TransitionRouteGroup => std::option::Option::Some("TRANSITION_ROUTE_GROUP"),
                Self::AgentTransitionRouteGroup => {
                    std::option::Option::Some("AGENT_TRANSITION_ROUTE_GROUP")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "agents", feature = "flows",))]
    impl std::default::Default for ResourceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "agents", feature = "flows",))]
    impl std::fmt::Display for ResourceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "agents", feature = "flows",))]
    impl std::convert::From<i32> for ResourceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Agent,
                2 => Self::Intent,
                3 => Self::EntityType,
                4 => Self::Webhook,
                5 => Self::Flow,
                6 => Self::Page,
                7 => Self::TransitionRouteGroup,
                8 => Self::IntentTrainingPhrase,
                9 => Self::IntentParameter,
                10 => Self::Intents,
                11 => Self::IntentTrainingPhrases,
                12 => Self::EntityTypes,
                13 => Self::Pages,
                14 => Self::AgentTransitionRouteGroup,
                _ => Self::UnknownValue(resource_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "agents", feature = "flows",))]
    impl std::convert::From<&str> for ResourceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "AGENT" => Self::Agent,
                "INTENT" => Self::Intent,
                "INTENT_TRAINING_PHRASE" => Self::IntentTrainingPhrase,
                "INTENT_PARAMETER" => Self::IntentParameter,
                "INTENTS" => Self::Intents,
                "INTENT_TRAINING_PHRASES" => Self::IntentTrainingPhrases,
                "ENTITY_TYPE" => Self::EntityType,
                "ENTITY_TYPES" => Self::EntityTypes,
                "WEBHOOK" => Self::Webhook,
                "FLOW" => Self::Flow,
                "PAGE" => Self::Page,
                "PAGES" => Self::Pages,
                "TRANSITION_ROUTE_GROUP" => Self::TransitionRouteGroup,
                "AGENT_TRANSITION_ROUTE_GROUP" => Self::AgentTransitionRouteGroup,
                _ => Self::UnknownValue(resource_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "agents", feature = "flows",))]
    impl serde::ser::Serialize for ResourceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Agent => serializer.serialize_i32(1),
                Self::Intent => serializer.serialize_i32(2),
                Self::IntentTrainingPhrase => serializer.serialize_i32(8),
                Self::IntentParameter => serializer.serialize_i32(9),
                Self::Intents => serializer.serialize_i32(10),
                Self::IntentTrainingPhrases => serializer.serialize_i32(11),
                Self::EntityType => serializer.serialize_i32(3),
                Self::EntityTypes => serializer.serialize_i32(12),
                Self::Webhook => serializer.serialize_i32(4),
                Self::Flow => serializer.serialize_i32(5),
                Self::Page => serializer.serialize_i32(6),
                Self::Pages => serializer.serialize_i32(13),
                Self::TransitionRouteGroup => serializer.serialize_i32(7),
                Self::AgentTransitionRouteGroup => serializer.serialize_i32(14),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "agents", feature = "flows",))]
    impl<'de> serde::de::Deserialize<'de> for ResourceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResourceType>::new(
                ".google.cloud.dialogflow.cx.v3.ValidationMessage.ResourceType",
            ))
        }
    }

    /// Severity level.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "agents", feature = "flows",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Severity {
        /// Unspecified.
        Unspecified,
        /// The agent doesn't follow Dialogflow best practices.
        Info,
        /// The agent may not behave as expected.
        Warning,
        /// The agent may experience failures.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Severity::value] or
        /// [Severity::name].
        UnknownValue(severity::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "agents", feature = "flows",))]
    pub mod severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "agents", feature = "flows",))]
    impl Severity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Info => std::option::Option::Some(1),
                Self::Warning => std::option::Option::Some(2),
                Self::Error => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
                Self::Info => std::option::Option::Some("INFO"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "agents", feature = "flows",))]
    impl std::default::Default for Severity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "agents", feature = "flows",))]
    impl std::fmt::Display for Severity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "agents", feature = "flows",))]
    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Info,
                2 => Self::Warning,
                3 => Self::Error,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "agents", feature = "flows",))]
    impl std::convert::From<&str> for Severity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "INFO" => Self::Info,
                "WARNING" => Self::Warning,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "agents", feature = "flows",))]
    impl serde::ser::Serialize for Severity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Info => serializer.serialize_i32(1),
                Self::Warning => serializer.serialize_i32(2),
                Self::Error => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "agents", feature = "flows",))]
    impl<'de> serde::de::Deserialize<'de> for Severity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
                ".google.cloud.dialogflow.cx.v3.ValidationMessage.Severity",
            ))
        }
    }
}

/// Resource name and display name.
#[cfg(any(feature = "agents", feature = "flows",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceName {
    /// Name.
    pub name: std::string::String,

    /// Display name.
    pub display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "agents", feature = "flows",))]
impl ResourceName {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResourceName::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ResourceName::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

#[cfg(any(feature = "agents", feature = "flows",))]
impl wkt::message::Message for ResourceName {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ResourceName"
    }
}

#[cfg(any(feature = "agents", feature = "flows",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResourceName {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceName")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResourceName;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceName")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "agents", feature = "flows",))]
#[doc(hidden)]
impl serde::ser::Serialize for ResourceName {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata associated with the long running operation for
/// [Versions.CreateVersion][google.cloud.dialogflow.cx.v3.Versions.CreateVersion].
///
/// [google.cloud.dialogflow.cx.v3.Versions.CreateVersion]: crate::client::Versions::create_version
#[cfg(feature = "versions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateVersionOperationMetadata {
    /// Name of the created version.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/versions/<VersionID>`.
    pub version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "versions")]
impl CreateVersionOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::CreateVersionOperationMetadata::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

#[cfg(feature = "versions")]
impl wkt::message::Message for CreateVersionOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CreateVersionOperationMetadata"
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateVersionOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateVersionOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateVersionOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateVersionOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateVersionOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a version of a flow.
#[cfg(feature = "versions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Version {
    /// Format:
    /// projects/\<ProjectID\>/locations/\<LocationID\>/agents/\<AgentID\>/flows/\<FlowID\>/versions/\<VersionID\>.
    /// Version ID is a self-increasing number generated by Dialogflow upon version
    /// creation.
    pub name: std::string::String,

    /// Required. The human-readable name of the version. Limit of 64 characters.
    pub display_name: std::string::String,

    /// The description of the version. The maximum length is 500 characters. If
    /// exceeded, the request is rejected.
    pub description: std::string::String,

    /// Output only. The NLU settings of the flow at version creation.
    pub nlu_settings: std::option::Option<crate::model::NluSettings>,

    /// Output only. Create time of the version.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The state of this version. This field is read-only and cannot
    /// be set by create and update methods.
    pub state: crate::model::version::State,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "versions")]
impl Version {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Version::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Version::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Version::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [nlu_settings][crate::model::Version::nlu_settings].
    pub fn set_nlu_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NluSettings>,
    {
        self.nlu_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [nlu_settings][crate::model::Version::nlu_settings].
    pub fn set_or_clear_nlu_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NluSettings>,
    {
        self.nlu_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::Version::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Version::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Version::state].
    pub fn set_state<T: std::convert::Into<crate::model::version::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }
}

#[cfg(feature = "versions")]
impl wkt::message::Message for Version {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.Version"
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Version {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __nlu_settings,
            __create_time,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Version")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "nluSettings" => Ok(__FieldTag::__nlu_settings),
                            "nlu_settings" => Ok(__FieldTag::__nlu_settings),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Version;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Version")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nlu_settings => {
                            if !fields.insert(__FieldTag::__nlu_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nlu_settings",
                                ));
                            }
                            result.nlu_settings =
                                map.next_value::<std::option::Option<crate::model::NluSettings>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::version::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for Version {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.nlu_settings.is_some() {
            state.serialize_entry("nluSettings", &self.nlu_settings)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Version].
#[cfg(feature = "versions")]
pub mod version {
    #[allow(unused_imports)]
    use super::*;

    /// The state of the version.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "versions")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not specified. This value is not used.
        Unspecified,
        /// Version is not ready to serve (e.g. training is running).
        Running,
        /// Training has succeeded and this version is ready to serve.
        Succeeded,
        /// Version training failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "versions")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "versions")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "versions")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "versions")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "versions")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Succeeded,
                3 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "versions")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "versions")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "versions")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dialogflow.cx.v3.Version.State",
            ))
        }
    }
}

/// The request message for
/// [Versions.ListVersions][google.cloud.dialogflow.cx.v3.Versions.ListVersions].
///
/// [google.cloud.dialogflow.cx.v3.Versions.ListVersions]: crate::client::Versions::list_versions
#[cfg(feature = "versions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVersionsRequest {
    /// Required. The [Flow][google.cloud.dialogflow.cx.v3.Flow] to list all
    /// versions for. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Flow]: crate::model::Flow
    pub parent: std::string::String,

    /// The maximum number of items to return in a single page. By default 20 and
    /// at most 100.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "versions")]
impl ListVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "versions")]
impl wkt::message::Message for ListVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListVersionsRequest"
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVersionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVersionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVersionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVersionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for ListVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Versions.ListVersions][google.cloud.dialogflow.cx.v3.Versions.ListVersions].
///
/// [google.cloud.dialogflow.cx.v3.Versions.ListVersions]: crate::client::Versions::list_versions
#[cfg(feature = "versions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVersionsResponse {
    /// A list of versions. There will be a maximum number of items returned based
    /// on the page_size field in the request. The list may in some cases be empty
    /// or contain fewer entries than page_size even if this isn't the last page.
    pub versions: std::vec::Vec<crate::model::Version>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "versions")]
impl ListVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [versions][crate::model::ListVersionsResponse::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Version>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "versions")]
impl wkt::message::Message for ListVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListVersionsResponse"
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVersionsResponse {
    type PageItem = crate::model::Version;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVersionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __versions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVersionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "versions" => Ok(__FieldTag::__versions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVersionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVersionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__versions => {
                            if !fields.insert(__FieldTag::__versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for versions",
                                ));
                            }
                            result.versions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Version>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for ListVersionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.versions.is_empty() {
            state.serialize_entry("versions", &self.versions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Versions.GetVersion][google.cloud.dialogflow.cx.v3.Versions.GetVersion].
///
/// [google.cloud.dialogflow.cx.v3.Versions.GetVersion]: crate::client::Versions::get_version
#[cfg(feature = "versions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVersionRequest {
    /// Required. The name of the [Version][google.cloud.dialogflow.cx.v3.Version].
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/versions/<VersionID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Version]: crate::model::Version
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "versions")]
impl GetVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "versions")]
impl wkt::message::Message for GetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetVersionRequest"
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for GetVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Versions.CreateVersion][google.cloud.dialogflow.cx.v3.Versions.CreateVersion].
///
/// [google.cloud.dialogflow.cx.v3.Versions.CreateVersion]: crate::client::Versions::create_version
#[cfg(feature = "versions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateVersionRequest {
    /// Required. The [Flow][google.cloud.dialogflow.cx.v3.Flow] to create an
    /// [Version][google.cloud.dialogflow.cx.v3.Version] for. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Flow]: crate::model::Flow
    /// [google.cloud.dialogflow.cx.v3.Version]: crate::model::Version
    pub parent: std::string::String,

    /// Required. The version to create.
    pub version: std::option::Option<crate::model::Version>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "versions")]
impl CreateVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVersionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [version][crate::model::CreateVersionRequest::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::CreateVersionRequest::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "versions")]
impl wkt::message::Message for CreateVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CreateVersionRequest"
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Versions.UpdateVersion][google.cloud.dialogflow.cx.v3.Versions.UpdateVersion].
///
/// [google.cloud.dialogflow.cx.v3.Versions.UpdateVersion]: crate::client::Versions::update_version
#[cfg(feature = "versions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateVersionRequest {
    /// Required. The version to update.
    pub version: std::option::Option<crate::model::Version>,

    /// Required. The mask to control which fields get updated. Currently only
    /// `description` and `display_name` can be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "versions")]
impl UpdateVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::UpdateVersionRequest::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::UpdateVersionRequest::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateVersionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateVersionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "versions")]
impl wkt::message::Message for UpdateVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.UpdateVersionRequest"
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Versions.DeleteVersion][google.cloud.dialogflow.cx.v3.Versions.DeleteVersion].
///
/// [google.cloud.dialogflow.cx.v3.Versions.DeleteVersion]: crate::client::Versions::delete_version
#[cfg(feature = "versions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteVersionRequest {
    /// Required. The name of the [Version][google.cloud.dialogflow.cx.v3.Version]
    /// to delete. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/versions/<VersionID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Version]: crate::model::Version
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "versions")]
impl DeleteVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "versions")]
impl wkt::message::Message for DeleteVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DeleteVersionRequest"
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Versions.LoadVersion][google.cloud.dialogflow.cx.v3.Versions.LoadVersion].
///
/// [google.cloud.dialogflow.cx.v3.Versions.LoadVersion]: crate::client::Versions::load_version
#[cfg(feature = "versions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LoadVersionRequest {
    /// Required. The [Version][google.cloud.dialogflow.cx.v3.Version] to be loaded
    /// to draft flow. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/versions/<VersionID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Version]: crate::model::Version
    pub name: std::string::String,

    /// This field is used to prevent accidental overwrite of other agent
    /// resources, which can potentially impact other flow's behavior. If
    /// `allow_override_agent_resources` is false, conflicted agent-level resources
    /// will not be overridden (i.e. intents, entities, webhooks).
    pub allow_override_agent_resources: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "versions")]
impl LoadVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LoadVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [allow_override_agent_resources][crate::model::LoadVersionRequest::allow_override_agent_resources].
    pub fn set_allow_override_agent_resources<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_override_agent_resources = v.into();
        self
    }
}

#[cfg(feature = "versions")]
impl wkt::message::Message for LoadVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.LoadVersionRequest"
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LoadVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __allow_override_agent_resources,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoadVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "allowOverrideAgentResources" => {
                                Ok(__FieldTag::__allow_override_agent_resources)
                            }
                            "allow_override_agent_resources" => {
                                Ok(__FieldTag::__allow_override_agent_resources)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LoadVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoadVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_override_agent_resources => {
                            if !fields.insert(__FieldTag::__allow_override_agent_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_override_agent_resources",
                                ));
                            }
                            result.allow_override_agent_resources = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for LoadVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.allow_override_agent_resources) {
            state.serialize_entry(
                "allowOverrideAgentResources",
                &self.allow_override_agent_resources,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Versions.CompareVersions][google.cloud.dialogflow.cx.v3.Versions.CompareVersions].
///
/// [google.cloud.dialogflow.cx.v3.Versions.CompareVersions]: crate::client::Versions::compare_versions
#[cfg(feature = "versions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CompareVersionsRequest {
    /// Required. Name of the base flow version to compare with the target version.
    /// Use version ID `0` to indicate the draft version of the specified flow.
    ///
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/versions/<VersionID>`.
    pub base_version: std::string::String,

    /// Required. Name of the target flow version to compare with the
    /// base version. Use version ID `0` to indicate the draft version of the
    /// specified flow. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/versions/<VersionID>`.
    pub target_version: std::string::String,

    /// The language to compare the flow versions for.
    ///
    /// If not specified, the agent's default language is used.
    /// [Many
    /// languages](https://cloud.google.com/dialogflow/docs/reference/language) are
    /// supported. Note: languages must be enabled in the agent before they can be
    /// used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "versions")]
impl CompareVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [base_version][crate::model::CompareVersionsRequest::base_version].
    pub fn set_base_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.base_version = v.into();
        self
    }

    /// Sets the value of [target_version][crate::model::CompareVersionsRequest::target_version].
    pub fn set_target_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_version = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::CompareVersionsRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "versions")]
impl wkt::message::Message for CompareVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CompareVersionsRequest"
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CompareVersionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __base_version,
            __target_version,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompareVersionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "baseVersion" => Ok(__FieldTag::__base_version),
                            "base_version" => Ok(__FieldTag::__base_version),
                            "targetVersion" => Ok(__FieldTag::__target_version),
                            "target_version" => Ok(__FieldTag::__target_version),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CompareVersionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompareVersionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__base_version => {
                            if !fields.insert(__FieldTag::__base_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_version",
                                ));
                            }
                            result.base_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_version => {
                            if !fields.insert(__FieldTag::__target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_version",
                                ));
                            }
                            result.target_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for CompareVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.base_version.is_empty() {
            state.serialize_entry("baseVersion", &self.base_version)?;
        }
        if !self.target_version.is_empty() {
            state.serialize_entry("targetVersion", &self.target_version)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Versions.CompareVersions][google.cloud.dialogflow.cx.v3.Versions.CompareVersions].
///
/// [google.cloud.dialogflow.cx.v3.Versions.CompareVersions]: crate::client::Versions::compare_versions
#[cfg(feature = "versions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CompareVersionsResponse {
    /// JSON representation of the base version content.
    pub base_version_content_json: std::string::String,

    /// JSON representation of the target version content.
    pub target_version_content_json: std::string::String,

    /// The timestamp when the two version compares.
    pub compare_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "versions")]
impl CompareVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [base_version_content_json][crate::model::CompareVersionsResponse::base_version_content_json].
    pub fn set_base_version_content_json<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.base_version_content_json = v.into();
        self
    }

    /// Sets the value of [target_version_content_json][crate::model::CompareVersionsResponse::target_version_content_json].
    pub fn set_target_version_content_json<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_version_content_json = v.into();
        self
    }

    /// Sets the value of [compare_time][crate::model::CompareVersionsResponse::compare_time].
    pub fn set_compare_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.compare_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [compare_time][crate::model::CompareVersionsResponse::compare_time].
    pub fn set_or_clear_compare_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.compare_time = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "versions")]
impl wkt::message::Message for CompareVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CompareVersionsResponse"
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CompareVersionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __base_version_content_json,
            __target_version_content_json,
            __compare_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompareVersionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "baseVersionContentJson" => Ok(__FieldTag::__base_version_content_json),
                            "base_version_content_json" => {
                                Ok(__FieldTag::__base_version_content_json)
                            }
                            "targetVersionContentJson" => {
                                Ok(__FieldTag::__target_version_content_json)
                            }
                            "target_version_content_json" => {
                                Ok(__FieldTag::__target_version_content_json)
                            }
                            "compareTime" => Ok(__FieldTag::__compare_time),
                            "compare_time" => Ok(__FieldTag::__compare_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CompareVersionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompareVersionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__base_version_content_json => {
                            if !fields.insert(__FieldTag::__base_version_content_json) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for base_version_content_json",
                                ));
                            }
                            result.base_version_content_json = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_version_content_json => {
                            if !fields.insert(__FieldTag::__target_version_content_json) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_version_content_json",
                                ));
                            }
                            result.target_version_content_json = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__compare_time => {
                            if !fields.insert(__FieldTag::__compare_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compare_time",
                                ));
                            }
                            result.compare_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for CompareVersionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.base_version_content_json.is_empty() {
            state.serialize_entry("baseVersionContentJson", &self.base_version_content_json)?;
        }
        if !self.target_version_content_json.is_empty() {
            state.serialize_entry(
                "targetVersionContentJson",
                &self.target_version_content_json,
            )?;
        }
        if self.compare_time.is_some() {
            state.serialize_entry("compareTime", &self.compare_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Webhooks host the developer's business logic. During a session, webhooks
/// allow the developer to use the data extracted by Dialogflow's natural
/// language processing to generate dynamic responses, validate collected data,
/// or trigger actions on the backend.
#[cfg(any(feature = "environments", feature = "webhooks",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Webhook {
    /// The unique identifier of the webhook.
    /// Required for the
    /// [Webhooks.UpdateWebhook][google.cloud.dialogflow.cx.v3.Webhooks.UpdateWebhook]
    /// method.
    /// [Webhooks.CreateWebhook][google.cloud.dialogflow.cx.v3.Webhooks.CreateWebhook]
    /// populates the name automatically. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/webhooks/<WebhookID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.Webhooks.CreateWebhook]: crate::client::Webhooks::create_webhook
    /// [google.cloud.dialogflow.cx.v3.Webhooks.UpdateWebhook]: crate::client::Webhooks::update_webhook
    pub name: std::string::String,

    /// Required. The human-readable name of the webhook, unique within the agent.
    pub display_name: std::string::String,

    /// Webhook execution timeout. Execution is considered failed if Dialogflow
    /// doesn't receive a response from webhook at the end of the timeout period.
    /// Defaults to 5 seconds, maximum allowed timeout is 30 seconds.
    pub timeout: std::option::Option<wkt::Duration>,

    /// Indicates whether the webhook is disabled.
    pub disabled: bool,

    /// Required. The webhook configuration.
    pub webhook: std::option::Option<crate::model::webhook::Webhook>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "environments", feature = "webhooks",))]
impl Webhook {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Webhook::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Webhook::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [timeout][crate::model::Webhook::timeout].
    pub fn set_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeout][crate::model::Webhook::timeout].
    pub fn set_or_clear_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disabled][crate::model::Webhook::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [webhook][crate::model::Webhook::webhook].
    ///
    /// Note that all the setters affecting `webhook` are mutually
    /// exclusive.
    pub fn set_webhook<
        T: std::convert::Into<std::option::Option<crate::model::webhook::Webhook>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.webhook = v.into();
        self
    }

    /// The value of [webhook][crate::model::Webhook::webhook]
    /// if it holds a `GenericWebService`, `None` if the field is not set or
    /// holds a different branch.
    pub fn generic_web_service(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::webhook::GenericWebService>> {
        #[allow(unreachable_patterns)]
        self.webhook.as_ref().and_then(|v| match v {
            crate::model::webhook::Webhook::GenericWebService(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [webhook][crate::model::Webhook::webhook]
    /// to hold a `GenericWebService`.
    ///
    /// Note that all the setters affecting `webhook` are
    /// mutually exclusive.
    pub fn set_generic_web_service<
        T: std::convert::Into<std::boxed::Box<crate::model::webhook::GenericWebService>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.webhook =
            std::option::Option::Some(crate::model::webhook::Webhook::GenericWebService(v.into()));
        self
    }

    /// The value of [webhook][crate::model::Webhook::webhook]
    /// if it holds a `ServiceDirectory`, `None` if the field is not set or
    /// holds a different branch.
    pub fn service_directory(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::webhook::ServiceDirectoryConfig>> {
        #[allow(unreachable_patterns)]
        self.webhook.as_ref().and_then(|v| match v {
            crate::model::webhook::Webhook::ServiceDirectory(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [webhook][crate::model::Webhook::webhook]
    /// to hold a `ServiceDirectory`.
    ///
    /// Note that all the setters affecting `webhook` are
    /// mutually exclusive.
    pub fn set_service_directory<
        T: std::convert::Into<std::boxed::Box<crate::model::webhook::ServiceDirectoryConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.webhook =
            std::option::Option::Some(crate::model::webhook::Webhook::ServiceDirectory(v.into()));
        self
    }
}

#[cfg(any(feature = "environments", feature = "webhooks",))]
impl wkt::message::Message for Webhook {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.Webhook"
    }
}

#[cfg(any(feature = "environments", feature = "webhooks",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Webhook {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __generic_web_service,
            __service_directory,
            __timeout,
            __disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Webhook")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "genericWebService" => Ok(__FieldTag::__generic_web_service),
                            "generic_web_service" => Ok(__FieldTag::__generic_web_service),
                            "serviceDirectory" => Ok(__FieldTag::__service_directory),
                            "service_directory" => Ok(__FieldTag::__service_directory),
                            "timeout" => Ok(__FieldTag::__timeout),
                            "disabled" => Ok(__FieldTag::__disabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Webhook;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Webhook")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generic_web_service => {
                            if !fields.insert(__FieldTag::__generic_web_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generic_web_service",
                                ));
                            }
                            if result.webhook.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `webhook`, a oneof with full ID .google.cloud.dialogflow.cx.v3.Webhook.generic_web_service, latest field was genericWebService",
                                ));
                            }
                            result.webhook = std::option::Option::Some(
                                crate::model::webhook::Webhook::GenericWebService(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::webhook::GenericWebService>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__service_directory => {
                            if !fields.insert(__FieldTag::__service_directory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_directory",
                                ));
                            }
                            if result.webhook.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `webhook`, a oneof with full ID .google.cloud.dialogflow.cx.v3.Webhook.service_directory, latest field was serviceDirectory",
                                ));
                            }
                            result.webhook = std::option::Option::Some(
                                crate::model::webhook::Webhook::ServiceDirectory(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::webhook::ServiceDirectoryConfig,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__timeout => {
                            if !fields.insert(__FieldTag::__timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout",
                                ));
                            }
                            result.timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "environments", feature = "webhooks",))]
#[doc(hidden)]
impl serde::ser::Serialize for Webhook {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if let Some(value) = self.generic_web_service() {
            state.serialize_entry("genericWebService", value)?;
        }
        if let Some(value) = self.service_directory() {
            state.serialize_entry("serviceDirectory", value)?;
        }
        if self.timeout.is_some() {
            state.serialize_entry("timeout", &self.timeout)?;
        }
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Webhook].
#[cfg(any(feature = "environments", feature = "webhooks",))]
pub mod webhook {
    #[allow(unused_imports)]
    use super::*;

    /// Represents configuration for a generic web service.
    #[cfg(any(feature = "environments", feature = "webhooks",))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GenericWebService {
        /// Required. The webhook URI for receiving POST requests. It must use https
        /// protocol.
        pub uri: std::string::String,

        /// The user name for HTTP Basic authentication.
        #[deprecated]
        pub username: std::string::String,

        /// The password for HTTP Basic authentication.
        #[deprecated]
        pub password: std::string::String,

        /// The HTTP request headers to send together with webhook requests.
        pub request_headers: std::collections::HashMap<std::string::String, std::string::String>,

        /// Optional. Specifies a list of allowed custom CA certificates (in DER
        /// format) for HTTPS verification. This overrides the default SSL trust
        /// store. If this is empty or unspecified, Dialogflow will use Google's
        /// default trust store to verify certificates. N.B. Make sure the HTTPS
        /// server certificates are signed with "subject alt name". For instance a
        /// certificate can be self-signed using the following command,
        ///
        /// ```norust
        ///    openssl x509 -req -days 200 -in example.com.csr \
        ///      -signkey example.com.key \
        ///      -out example.com.crt \
        ///      -extfile <(printf "\nsubjectAltName='DNS:www.example.com'")
        /// ```
        pub allowed_ca_certs: std::vec::Vec<::bytes::Bytes>,

        /// Optional. The OAuth configuration of the webhook. If specified,
        /// Dialogflow will initiate the OAuth client credential flow to exchange an
        /// access token from the 3rd party platform and put it in the auth header.
        pub oauth_config:
            std::option::Option<crate::model::webhook::generic_web_service::OAuthConfig>,

        /// Optional. Indicate the auth token type generated from the [Diglogflow
        /// service
        /// agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent).
        /// The generated token is sent in the Authorization header.
        pub service_agent_auth: crate::model::webhook::generic_web_service::ServiceAgentAuth,

        /// Optional. Type of the webhook.
        pub webhook_type: crate::model::webhook::generic_web_service::WebhookType,

        /// Optional. HTTP method for the flexible webhook calls. Standard webhook
        /// always uses POST.
        pub http_method: crate::model::webhook::generic_web_service::HttpMethod,

        /// Optional. Defines a custom JSON object as request body to send to
        /// flexible webhook.
        pub request_body: std::string::String,

        /// Optional. Maps the values extracted from specific fields of the flexible
        /// webhook response into session parameters.
        ///
        /// - Key: session parameter name
        /// - Value: field path in the webhook response
        pub parameter_mapping: std::collections::HashMap<std::string::String, std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "environments", feature = "webhooks",))]
    impl GenericWebService {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::webhook::GenericWebService::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [username][crate::model::webhook::GenericWebService::username].
        #[deprecated]
        pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.username = v.into();
            self
        }

        /// Sets the value of [password][crate::model::webhook::GenericWebService::password].
        #[deprecated]
        pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.password = v.into();
            self
        }

        /// Sets the value of [request_headers][crate::model::webhook::GenericWebService::request_headers].
        pub fn set_request_headers<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.request_headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [allowed_ca_certs][crate::model::webhook::GenericWebService::allowed_ca_certs].
        pub fn set_allowed_ca_certs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<::bytes::Bytes>,
        {
            use std::iter::Iterator;
            self.allowed_ca_certs = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [oauth_config][crate::model::webhook::GenericWebService::oauth_config].
        pub fn set_oauth_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::webhook::generic_web_service::OAuthConfig>,
        {
            self.oauth_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [oauth_config][crate::model::webhook::GenericWebService::oauth_config].
        pub fn set_or_clear_oauth_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::webhook::generic_web_service::OAuthConfig>,
        {
            self.oauth_config = v.map(|x| x.into());
            self
        }

        /// Sets the value of [service_agent_auth][crate::model::webhook::GenericWebService::service_agent_auth].
        pub fn set_service_agent_auth<
            T: std::convert::Into<crate::model::webhook::generic_web_service::ServiceAgentAuth>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.service_agent_auth = v.into();
            self
        }

        /// Sets the value of [webhook_type][crate::model::webhook::GenericWebService::webhook_type].
        pub fn set_webhook_type<
            T: std::convert::Into<crate::model::webhook::generic_web_service::WebhookType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.webhook_type = v.into();
            self
        }

        /// Sets the value of [http_method][crate::model::webhook::GenericWebService::http_method].
        pub fn set_http_method<
            T: std::convert::Into<crate::model::webhook::generic_web_service::HttpMethod>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.http_method = v.into();
            self
        }

        /// Sets the value of [request_body][crate::model::webhook::GenericWebService::request_body].
        pub fn set_request_body<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.request_body = v.into();
            self
        }

        /// Sets the value of [parameter_mapping][crate::model::webhook::GenericWebService::parameter_mapping].
        pub fn set_parameter_mapping<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.parameter_mapping = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    #[cfg(any(feature = "environments", feature = "webhooks",))]
    impl wkt::message::Message for GenericWebService {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Webhook.GenericWebService"
        }
    }

    #[cfg(any(feature = "environments", feature = "webhooks",))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GenericWebService {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __uri,
                __username,
                __password,
                __request_headers,
                __allowed_ca_certs,
                __oauth_config,
                __service_agent_auth,
                __webhook_type,
                __http_method,
                __request_body,
                __parameter_mapping,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GenericWebService")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "uri" => Ok(__FieldTag::__uri),
                                "username" => Ok(__FieldTag::__username),
                                "password" => Ok(__FieldTag::__password),
                                "requestHeaders" => Ok(__FieldTag::__request_headers),
                                "request_headers" => Ok(__FieldTag::__request_headers),
                                "allowedCaCerts" => Ok(__FieldTag::__allowed_ca_certs),
                                "allowed_ca_certs" => Ok(__FieldTag::__allowed_ca_certs),
                                "oauthConfig" => Ok(__FieldTag::__oauth_config),
                                "oauth_config" => Ok(__FieldTag::__oauth_config),
                                "serviceAgentAuth" => Ok(__FieldTag::__service_agent_auth),
                                "service_agent_auth" => Ok(__FieldTag::__service_agent_auth),
                                "webhookType" => Ok(__FieldTag::__webhook_type),
                                "webhook_type" => Ok(__FieldTag::__webhook_type),
                                "httpMethod" => Ok(__FieldTag::__http_method),
                                "http_method" => Ok(__FieldTag::__http_method),
                                "requestBody" => Ok(__FieldTag::__request_body),
                                "request_body" => Ok(__FieldTag::__request_body),
                                "parameterMapping" => Ok(__FieldTag::__parameter_mapping),
                                "parameter_mapping" => Ok(__FieldTag::__parameter_mapping),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GenericWebService;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GenericWebService")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__uri => {
                                if !fields.insert(__FieldTag::__uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uri",
                                    ));
                                }
                                result.uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__username => {
                                if !fields.insert(__FieldTag::__username) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for username",
                                    ));
                                }
                                result.username = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__password => {
                                if !fields.insert(__FieldTag::__password) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for password",
                                    ));
                                }
                                result.password = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__request_headers => {
                                if !fields.insert(__FieldTag::__request_headers) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for request_headers",
                                    ));
                                }
                                result.request_headers = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__allowed_ca_certs => {
                                if !fields.insert(__FieldTag::__allowed_ca_certs) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allowed_ca_certs",
                                    ));
                                }
                                struct __With(std::option::Option<std::vec::Vec<::bytes::Bytes>>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<
                                                std::vec::Vec<serde_with::base64::Base64>,
                                            >,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.allowed_ca_certs =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__oauth_config => {
                                if !fields.insert(__FieldTag::__oauth_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for oauth_config",
                                    ));
                                }
                                result.oauth_config = map.next_value::<std::option::Option<
                                    crate::model::webhook::generic_web_service::OAuthConfig,
                                >>()?;
                            }
                            __FieldTag::__service_agent_auth => {
                                if !fields.insert(__FieldTag::__service_agent_auth) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service_agent_auth",
                                    ));
                                }
                                result.service_agent_auth = map.next_value::<std::option::Option<crate::model::webhook::generic_web_service::ServiceAgentAuth>>()?.unwrap_or_default();
                            }
                            __FieldTag::__webhook_type => {
                                if !fields.insert(__FieldTag::__webhook_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for webhook_type",
                                    ));
                                }
                                result.webhook_type = map
                                    .next_value::<std::option::Option<
                                        crate::model::webhook::generic_web_service::WebhookType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__http_method => {
                                if !fields.insert(__FieldTag::__http_method) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for http_method",
                                    ));
                                }
                                result.http_method = map
                                    .next_value::<std::option::Option<
                                        crate::model::webhook::generic_web_service::HttpMethod,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__request_body => {
                                if !fields.insert(__FieldTag::__request_body) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for request_body",
                                    ));
                                }
                                result.request_body = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__parameter_mapping => {
                                if !fields.insert(__FieldTag::__parameter_mapping) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parameter_mapping",
                                    ));
                                }
                                result.parameter_mapping = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(feature = "environments", feature = "webhooks",))]
    #[doc(hidden)]
    impl serde::ser::Serialize for GenericWebService {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.uri.is_empty() {
                state.serialize_entry("uri", &self.uri)?;
            }
            if !self.username.is_empty() {
                state.serialize_entry("username", &self.username)?;
            }
            if !self.password.is_empty() {
                state.serialize_entry("password", &self.password)?;
            }
            if !self.request_headers.is_empty() {
                state.serialize_entry("requestHeaders", &self.request_headers)?;
            }
            if !self.allowed_ca_certs.is_empty() {
                struct __With<'a>(&'a std::vec::Vec<::bytes::Bytes>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::vec::Vec<serde_with::base64::Base64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("allowedCaCerts", &__With(&self.allowed_ca_certs))?;
            }
            if self.oauth_config.is_some() {
                state.serialize_entry("oauthConfig", &self.oauth_config)?;
            }
            if !wkt::internal::is_default(&self.service_agent_auth) {
                state.serialize_entry("serviceAgentAuth", &self.service_agent_auth)?;
            }
            if !wkt::internal::is_default(&self.webhook_type) {
                state.serialize_entry("webhookType", &self.webhook_type)?;
            }
            if !wkt::internal::is_default(&self.http_method) {
                state.serialize_entry("httpMethod", &self.http_method)?;
            }
            if !self.request_body.is_empty() {
                state.serialize_entry("requestBody", &self.request_body)?;
            }
            if !self.parameter_mapping.is_empty() {
                state.serialize_entry("parameterMapping", &self.parameter_mapping)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [GenericWebService].
    #[cfg(any(feature = "environments", feature = "webhooks",))]
    pub mod generic_web_service {
        #[allow(unused_imports)]
        use super::*;

        /// Represents configuration of OAuth client credential flow for 3rd party
        /// API authentication.
        #[cfg(any(feature = "environments", feature = "webhooks",))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct OAuthConfig {
            /// Required. The client ID provided by the 3rd party platform.
            pub client_id: std::string::String,

            /// Optional. The client secret provided by the 3rd party platform.
            pub client_secret: std::string::String,

            /// Required. The token endpoint provided by the 3rd party platform to
            /// exchange an access token.
            pub token_endpoint: std::string::String,

            /// Optional. The OAuth scopes to grant.
            pub scopes: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl OAuthConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [client_id][crate::model::webhook::generic_web_service::OAuthConfig::client_id].
            pub fn set_client_id<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.client_id = v.into();
                self
            }

            /// Sets the value of [client_secret][crate::model::webhook::generic_web_service::OAuthConfig::client_secret].
            pub fn set_client_secret<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.client_secret = v.into();
                self
            }

            /// Sets the value of [token_endpoint][crate::model::webhook::generic_web_service::OAuthConfig::token_endpoint].
            pub fn set_token_endpoint<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.token_endpoint = v.into();
                self
            }

            /// Sets the value of [scopes][crate::model::webhook::generic_web_service::OAuthConfig::scopes].
            pub fn set_scopes<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.scopes = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl wkt::message::Message for OAuthConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.cx.v3.Webhook.GenericWebService.OAuthConfig"
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for OAuthConfig {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __client_id,
                    __client_secret,
                    __token_endpoint,
                    __scopes,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for OAuthConfig")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "clientId" => Ok(__FieldTag::__client_id),
                                    "client_id" => Ok(__FieldTag::__client_id),
                                    "clientSecret" => Ok(__FieldTag::__client_secret),
                                    "client_secret" => Ok(__FieldTag::__client_secret),
                                    "tokenEndpoint" => Ok(__FieldTag::__token_endpoint),
                                    "token_endpoint" => Ok(__FieldTag::__token_endpoint),
                                    "scopes" => Ok(__FieldTag::__scopes),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = OAuthConfig;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct OAuthConfig")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__client_id => {
                                    if !fields.insert(__FieldTag::__client_id) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for client_id",
                                            ),
                                        );
                                    }
                                    result.client_id = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__client_secret => {
                                    if !fields.insert(__FieldTag::__client_secret) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for client_secret",
                                            ),
                                        );
                                    }
                                    result.client_secret = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__token_endpoint => {
                                    if !fields.insert(__FieldTag::__token_endpoint) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for token_endpoint",
                                            ),
                                        );
                                    }
                                    result.token_endpoint = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__scopes => {
                                    if !fields.insert(__FieldTag::__scopes) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for scopes"),
                                        );
                                    }
                                    result.scopes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        #[doc(hidden)]
        impl serde::ser::Serialize for OAuthConfig {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.client_id.is_empty() {
                    state.serialize_entry("clientId", &self.client_id)?;
                }
                if !self.client_secret.is_empty() {
                    state.serialize_entry("clientSecret", &self.client_secret)?;
                }
                if !self.token_endpoint.is_empty() {
                    state.serialize_entry("tokenEndpoint", &self.token_endpoint)?;
                }
                if !self.scopes.is_empty() {
                    state.serialize_entry("scopes", &self.scopes)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Indicate the auth token type generated from the [Diglogflow service
        /// agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent).
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(any(feature = "environments", feature = "webhooks",))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ServiceAgentAuth {
            /// Service agent auth type unspecified. Default to ID_TOKEN.
            Unspecified,
            /// No token used.
            None,
            /// Use [ID
            /// token](https://cloud.google.com/docs/authentication/token-types#id)
            /// generated from service agent. This can be used to access Cloud Function
            /// and Cloud Run after you grant Invoker role to
            /// `service-<PROJECT-NUMBER>@gcp-sa-dialogflow.iam.gserviceaccount.com`.
            IdToken,
            /// Use [access
            /// token](https://cloud.google.com/docs/authentication/token-types#access)
            /// generated from service agent. This can be used to access other Google
            /// Cloud APIs after you grant required roles to
            /// `service-<PROJECT-NUMBER>@gcp-sa-dialogflow.iam.gserviceaccount.com`.
            AccessToken,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ServiceAgentAuth::value] or
            /// [ServiceAgentAuth::name].
            UnknownValue(service_agent_auth::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(any(feature = "environments", feature = "webhooks",))]
        pub mod service_agent_auth {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl ServiceAgentAuth {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::None => std::option::Option::Some(1),
                    Self::IdToken => std::option::Option::Some(2),
                    Self::AccessToken => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("SERVICE_AGENT_AUTH_UNSPECIFIED")
                    }
                    Self::None => std::option::Option::Some("NONE"),
                    Self::IdToken => std::option::Option::Some("ID_TOKEN"),
                    Self::AccessToken => std::option::Option::Some("ACCESS_TOKEN"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl std::default::Default for ServiceAgentAuth {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl std::fmt::Display for ServiceAgentAuth {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl std::convert::From<i32> for ServiceAgentAuth {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::None,
                    2 => Self::IdToken,
                    3 => Self::AccessToken,
                    _ => Self::UnknownValue(service_agent_auth::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl std::convert::From<&str> for ServiceAgentAuth {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SERVICE_AGENT_AUTH_UNSPECIFIED" => Self::Unspecified,
                    "NONE" => Self::None,
                    "ID_TOKEN" => Self::IdToken,
                    "ACCESS_TOKEN" => Self::AccessToken,
                    _ => Self::UnknownValue(service_agent_auth::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl serde::ser::Serialize for ServiceAgentAuth {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::None => serializer.serialize_i32(1),
                    Self::IdToken => serializer.serialize_i32(2),
                    Self::AccessToken => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl<'de> serde::de::Deserialize<'de> for ServiceAgentAuth {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ServiceAgentAuth>::new(
                    ".google.cloud.dialogflow.cx.v3.Webhook.GenericWebService.ServiceAgentAuth",
                ))
            }
        }

        /// Represents the type of webhook configuration.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(any(feature = "environments", feature = "webhooks",))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum WebhookType {
            /// Default value. This value is unused.
            Unspecified,
            /// Represents a standard webhook.
            Standard,
            /// Represents a flexible webhook.
            Flexible,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [WebhookType::value] or
            /// [WebhookType::name].
            UnknownValue(webhook_type::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(any(feature = "environments", feature = "webhooks",))]
        pub mod webhook_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl WebhookType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Standard => std::option::Option::Some(1),
                    Self::Flexible => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("WEBHOOK_TYPE_UNSPECIFIED"),
                    Self::Standard => std::option::Option::Some("STANDARD"),
                    Self::Flexible => std::option::Option::Some("FLEXIBLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl std::default::Default for WebhookType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl std::fmt::Display for WebhookType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl std::convert::From<i32> for WebhookType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Standard,
                    2 => Self::Flexible,
                    _ => Self::UnknownValue(webhook_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl std::convert::From<&str> for WebhookType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "WEBHOOK_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "STANDARD" => Self::Standard,
                    "FLEXIBLE" => Self::Flexible,
                    _ => Self::UnknownValue(webhook_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl serde::ser::Serialize for WebhookType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Standard => serializer.serialize_i32(1),
                    Self::Flexible => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl<'de> serde::de::Deserialize<'de> for WebhookType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<WebhookType>::new(
                    ".google.cloud.dialogflow.cx.v3.Webhook.GenericWebService.WebhookType",
                ))
            }
        }

        /// HTTP method to use when calling webhooks.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(any(feature = "environments", feature = "webhooks",))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum HttpMethod {
            /// HTTP method not specified.
            Unspecified,
            /// HTTP POST Method.
            Post,
            /// HTTP GET Method.
            Get,
            /// HTTP HEAD Method.
            Head,
            /// HTTP PUT Method.
            Put,
            /// HTTP DELETE Method.
            Delete,
            /// HTTP PATCH Method.
            Patch,
            /// HTTP OPTIONS Method.
            Options,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [HttpMethod::value] or
            /// [HttpMethod::name].
            UnknownValue(http_method::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(any(feature = "environments", feature = "webhooks",))]
        pub mod http_method {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl HttpMethod {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Post => std::option::Option::Some(1),
                    Self::Get => std::option::Option::Some(2),
                    Self::Head => std::option::Option::Some(3),
                    Self::Put => std::option::Option::Some(4),
                    Self::Delete => std::option::Option::Some(5),
                    Self::Patch => std::option::Option::Some(6),
                    Self::Options => std::option::Option::Some(7),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("HTTP_METHOD_UNSPECIFIED"),
                    Self::Post => std::option::Option::Some("POST"),
                    Self::Get => std::option::Option::Some("GET"),
                    Self::Head => std::option::Option::Some("HEAD"),
                    Self::Put => std::option::Option::Some("PUT"),
                    Self::Delete => std::option::Option::Some("DELETE"),
                    Self::Patch => std::option::Option::Some("PATCH"),
                    Self::Options => std::option::Option::Some("OPTIONS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl std::default::Default for HttpMethod {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl std::fmt::Display for HttpMethod {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl std::convert::From<i32> for HttpMethod {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Post,
                    2 => Self::Get,
                    3 => Self::Head,
                    4 => Self::Put,
                    5 => Self::Delete,
                    6 => Self::Patch,
                    7 => Self::Options,
                    _ => Self::UnknownValue(http_method::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl std::convert::From<&str> for HttpMethod {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "HTTP_METHOD_UNSPECIFIED" => Self::Unspecified,
                    "POST" => Self::Post,
                    "GET" => Self::Get,
                    "HEAD" => Self::Head,
                    "PUT" => Self::Put,
                    "DELETE" => Self::Delete,
                    "PATCH" => Self::Patch,
                    "OPTIONS" => Self::Options,
                    _ => Self::UnknownValue(http_method::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl serde::ser::Serialize for HttpMethod {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Post => serializer.serialize_i32(1),
                    Self::Get => serializer.serialize_i32(2),
                    Self::Head => serializer.serialize_i32(3),
                    Self::Put => serializer.serialize_i32(4),
                    Self::Delete => serializer.serialize_i32(5),
                    Self::Patch => serializer.serialize_i32(6),
                    Self::Options => serializer.serialize_i32(7),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(any(feature = "environments", feature = "webhooks",))]
        impl<'de> serde::de::Deserialize<'de> for HttpMethod {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<HttpMethod>::new(
                    ".google.cloud.dialogflow.cx.v3.Webhook.GenericWebService.HttpMethod",
                ))
            }
        }
    }

    /// Represents configuration for a [Service
    /// Directory](https://cloud.google.com/service-directory) service.
    #[cfg(any(feature = "environments", feature = "webhooks",))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ServiceDirectoryConfig {
        /// Required. The name of [Service
        /// Directory](https://cloud.google.com/service-directory) service.
        /// Format:
        /// `projects/<ProjectID>/locations/<LocationID>/namespaces/<NamespaceID>/services/<ServiceID>`.
        /// `Location ID` of the service directory must be the same as the location
        /// of the agent.
        pub service: std::string::String,

        /// Generic Service configuration of this webhook.
        pub generic_web_service: std::option::Option<crate::model::webhook::GenericWebService>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "environments", feature = "webhooks",))]
    impl ServiceDirectoryConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service][crate::model::webhook::ServiceDirectoryConfig::service].
        pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.service = v.into();
            self
        }

        /// Sets the value of [generic_web_service][crate::model::webhook::ServiceDirectoryConfig::generic_web_service].
        pub fn set_generic_web_service<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::webhook::GenericWebService>,
        {
            self.generic_web_service = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [generic_web_service][crate::model::webhook::ServiceDirectoryConfig::generic_web_service].
        pub fn set_or_clear_generic_web_service<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::webhook::GenericWebService>,
        {
            self.generic_web_service = v.map(|x| x.into());
            self
        }
    }

    #[cfg(any(feature = "environments", feature = "webhooks",))]
    impl wkt::message::Message for ServiceDirectoryConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.Webhook.ServiceDirectoryConfig"
        }
    }

    #[cfg(any(feature = "environments", feature = "webhooks",))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ServiceDirectoryConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __service,
                __generic_web_service,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ServiceDirectoryConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "service" => Ok(__FieldTag::__service),
                                "genericWebService" => Ok(__FieldTag::__generic_web_service),
                                "generic_web_service" => Ok(__FieldTag::__generic_web_service),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ServiceDirectoryConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ServiceDirectoryConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__service => {
                                if !fields.insert(__FieldTag::__service) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service",
                                    ));
                                }
                                result.service = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__generic_web_service => {
                                if !fields.insert(__FieldTag::__generic_web_service) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for generic_web_service",
                                    ));
                                }
                                result.generic_web_service =
                                    map.next_value::<std::option::Option<
                                        crate::model::webhook::GenericWebService,
                                    >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(feature = "environments", feature = "webhooks",))]
    #[doc(hidden)]
    impl serde::ser::Serialize for ServiceDirectoryConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.service.is_empty() {
                state.serialize_entry("service", &self.service)?;
            }
            if self.generic_web_service.is_some() {
                state.serialize_entry("genericWebService", &self.generic_web_service)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Required. The webhook configuration.
    #[cfg(any(feature = "environments", feature = "webhooks",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Webhook {
        /// Configuration for a generic web service.
        GenericWebService(std::boxed::Box<crate::model::webhook::GenericWebService>),
        /// Configuration for a [Service
        /// Directory](https://cloud.google.com/service-directory) service.
        ServiceDirectory(std::boxed::Box<crate::model::webhook::ServiceDirectoryConfig>),
    }
}

/// The request message for
/// [Webhooks.ListWebhooks][google.cloud.dialogflow.cx.v3.Webhooks.ListWebhooks].
///
/// [google.cloud.dialogflow.cx.v3.Webhooks.ListWebhooks]: crate::client::Webhooks::list_webhooks
#[cfg(feature = "webhooks")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWebhooksRequest {
    /// Required. The agent to list all webhooks for.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// The maximum number of items to return in a single page. By default 100 and
    /// at most 1000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "webhooks")]
impl ListWebhooksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWebhooksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWebhooksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWebhooksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "webhooks")]
impl wkt::message::Message for ListWebhooksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListWebhooksRequest"
    }
}

#[cfg(feature = "webhooks")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWebhooksRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWebhooksRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWebhooksRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWebhooksRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "webhooks")]
#[doc(hidden)]
impl serde::ser::Serialize for ListWebhooksRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Webhooks.ListWebhooks][google.cloud.dialogflow.cx.v3.Webhooks.ListWebhooks].
///
/// [google.cloud.dialogflow.cx.v3.Webhooks.ListWebhooks]: crate::client::Webhooks::list_webhooks
#[cfg(feature = "webhooks")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWebhooksResponse {
    /// The list of webhooks. There will be a maximum number of items returned
    /// based on the page_size field in the request.
    pub webhooks: std::vec::Vec<crate::model::Webhook>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "webhooks")]
impl ListWebhooksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [webhooks][crate::model::ListWebhooksResponse::webhooks].
    pub fn set_webhooks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Webhook>,
    {
        use std::iter::Iterator;
        self.webhooks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListWebhooksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "webhooks")]
impl wkt::message::Message for ListWebhooksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.ListWebhooksResponse"
    }
}

#[cfg(feature = "webhooks")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListWebhooksResponse {
    type PageItem = crate::model::Webhook;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.webhooks
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "webhooks")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWebhooksResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __webhooks,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWebhooksResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "webhooks" => Ok(__FieldTag::__webhooks),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWebhooksResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWebhooksResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__webhooks => {
                            if !fields.insert(__FieldTag::__webhooks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhooks",
                                ));
                            }
                            result.webhooks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Webhook>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "webhooks")]
#[doc(hidden)]
impl serde::ser::Serialize for ListWebhooksResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.webhooks.is_empty() {
            state.serialize_entry("webhooks", &self.webhooks)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Webhooks.GetWebhook][google.cloud.dialogflow.cx.v3.Webhooks.GetWebhook].
///
/// [google.cloud.dialogflow.cx.v3.Webhooks.GetWebhook]: crate::client::Webhooks::get_webhook
#[cfg(feature = "webhooks")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetWebhookRequest {
    /// Required. The name of the webhook.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/webhooks/<WebhookID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "webhooks")]
impl GetWebhookRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetWebhookRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "webhooks")]
impl wkt::message::Message for GetWebhookRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.GetWebhookRequest"
    }
}

#[cfg(feature = "webhooks")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetWebhookRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetWebhookRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetWebhookRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetWebhookRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "webhooks")]
#[doc(hidden)]
impl serde::ser::Serialize for GetWebhookRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Webhooks.CreateWebhook][google.cloud.dialogflow.cx.v3.Webhooks.CreateWebhook].
///
/// [google.cloud.dialogflow.cx.v3.Webhooks.CreateWebhook]: crate::client::Webhooks::create_webhook
#[cfg(feature = "webhooks")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateWebhookRequest {
    /// Required. The agent to create a webhook for.
    /// Format: `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>`.
    pub parent: std::string::String,

    /// Required. The webhook to create.
    pub webhook: std::option::Option<crate::model::Webhook>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "webhooks")]
impl CreateWebhookRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateWebhookRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [webhook][crate::model::CreateWebhookRequest::webhook].
    pub fn set_webhook<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Webhook>,
    {
        self.webhook = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [webhook][crate::model::CreateWebhookRequest::webhook].
    pub fn set_or_clear_webhook<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Webhook>,
    {
        self.webhook = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "webhooks")]
impl wkt::message::Message for CreateWebhookRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.CreateWebhookRequest"
    }
}

#[cfg(feature = "webhooks")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateWebhookRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __webhook,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateWebhookRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "webhook" => Ok(__FieldTag::__webhook),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateWebhookRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateWebhookRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__webhook => {
                            if !fields.insert(__FieldTag::__webhook) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook",
                                ));
                            }
                            result.webhook =
                                map.next_value::<std::option::Option<crate::model::Webhook>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "webhooks")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateWebhookRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.webhook.is_some() {
            state.serialize_entry("webhook", &self.webhook)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Webhooks.UpdateWebhook][google.cloud.dialogflow.cx.v3.Webhooks.UpdateWebhook].
///
/// [google.cloud.dialogflow.cx.v3.Webhooks.UpdateWebhook]: crate::client::Webhooks::update_webhook
#[cfg(feature = "webhooks")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateWebhookRequest {
    /// Required. The webhook to update.
    pub webhook: std::option::Option<crate::model::Webhook>,

    /// The mask to control which fields get updated. If the mask is not present,
    /// all fields will be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "webhooks")]
impl UpdateWebhookRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [webhook][crate::model::UpdateWebhookRequest::webhook].
    pub fn set_webhook<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Webhook>,
    {
        self.webhook = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [webhook][crate::model::UpdateWebhookRequest::webhook].
    pub fn set_or_clear_webhook<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Webhook>,
    {
        self.webhook = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateWebhookRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateWebhookRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "webhooks")]
impl wkt::message::Message for UpdateWebhookRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.UpdateWebhookRequest"
    }
}

#[cfg(feature = "webhooks")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateWebhookRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __webhook,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateWebhookRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "webhook" => Ok(__FieldTag::__webhook),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateWebhookRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateWebhookRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__webhook => {
                            if !fields.insert(__FieldTag::__webhook) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook",
                                ));
                            }
                            result.webhook =
                                map.next_value::<std::option::Option<crate::model::Webhook>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "webhooks")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateWebhookRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.webhook.is_some() {
            state.serialize_entry("webhook", &self.webhook)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Webhooks.DeleteWebhook][google.cloud.dialogflow.cx.v3.Webhooks.DeleteWebhook].
///
/// [google.cloud.dialogflow.cx.v3.Webhooks.DeleteWebhook]: crate::client::Webhooks::delete_webhook
#[cfg(feature = "webhooks")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteWebhookRequest {
    /// Required. The name of the webhook to delete.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/webhooks/<WebhookID>`.
    pub name: std::string::String,

    /// This field has no effect for webhook not being used.
    /// For webhooks that are used by pages/flows/transition route groups:
    ///
    /// * If `force` is set to false, an error will be returned with message
    ///   indicating the referenced resources.
    /// * If `force` is set to true, Dialogflow will remove the webhook, as well
    ///   as any references to the webhook (i.e.
    ///   [Webhook][google.cloud.dialogflow.cx.v3.Fulfillment.webhook] and
    ///   [tag][google.cloud.dialogflow.cx.v3.Fulfillment.tag]in fulfillments that
    ///   point to this webhook will be removed).
    ///
    /// [google.cloud.dialogflow.cx.v3.Fulfillment.tag]: crate::model::Fulfillment::tag
    /// [google.cloud.dialogflow.cx.v3.Fulfillment.webhook]: crate::model::Fulfillment::webhook
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "webhooks")]
impl DeleteWebhookRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteWebhookRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteWebhookRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

#[cfg(feature = "webhooks")]
impl wkt::message::Message for DeleteWebhookRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.DeleteWebhookRequest"
    }
}

#[cfg(feature = "webhooks")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteWebhookRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteWebhookRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteWebhookRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteWebhookRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "webhooks")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteWebhookRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for a webhook call. The request is sent as a JSON object
/// and the field names will be presented in camel cases.
///
/// You may see undocumented fields in an actual request. These fields are used
/// internally by Dialogflow and should be ignored.
#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WebhookRequest {
    /// Always present. The unique identifier of the
    /// [DetectIntentResponse][google.cloud.dialogflow.cx.v3.DetectIntentResponse]
    /// that will be returned to the API caller.
    ///
    /// [google.cloud.dialogflow.cx.v3.DetectIntentResponse]: crate::model::DetectIntentResponse
    pub detect_intent_response_id: std::string::String,

    /// The language code specified in the [original
    /// request][QueryInput.language_code].
    ///
    /// [QueryInput.language_code]: crate::model::QueryInput::language_code
    pub language_code: std::string::String,

    /// Always present. Information about the fulfillment that triggered this
    /// webhook call.
    pub fulfillment_info: std::option::Option<crate::model::webhook_request::FulfillmentInfo>,

    /// Information about the last matched intent.
    pub intent_info: std::option::Option<crate::model::webhook_request::IntentInfo>,

    /// Information about page status.
    pub page_info: std::option::Option<crate::model::PageInfo>,

    /// Information about session status.
    pub session_info: std::option::Option<crate::model::SessionInfo>,

    /// The list of rich message responses to present to the user. Webhook can
    /// choose to append or replace this list in
    /// [WebhookResponse.fulfillment_response][google.cloud.dialogflow.cx.v3.WebhookResponse.fulfillment_response];
    ///
    /// [google.cloud.dialogflow.cx.v3.WebhookResponse.fulfillment_response]: crate::model::WebhookResponse::fulfillment_response
    pub messages: std::vec::Vec<crate::model::ResponseMessage>,

    /// Custom data set in
    /// [QueryParameters.payload][google.cloud.dialogflow.cx.v3.QueryParameters.payload].
    ///
    /// [google.cloud.dialogflow.cx.v3.QueryParameters.payload]: crate::model::QueryParameters::payload
    pub payload: std::option::Option<wkt::Struct>,

    /// The sentiment analysis result of the current user request. The field is
    /// filled when sentiment analysis is configured to be enabled for the request.
    pub sentiment_analysis_result:
        std::option::Option<crate::model::webhook_request::SentimentAnalysisResult>,

    /// Information about the language of the request.
    pub language_info: std::option::Option<crate::model::LanguageInfo>,

    /// The original conversational query.
    pub query: std::option::Option<crate::model::webhook_request::Query>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl WebhookRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [detect_intent_response_id][crate::model::WebhookRequest::detect_intent_response_id].
    pub fn set_detect_intent_response_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.detect_intent_response_id = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::WebhookRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [fulfillment_info][crate::model::WebhookRequest::fulfillment_info].
    pub fn set_fulfillment_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::webhook_request::FulfillmentInfo>,
    {
        self.fulfillment_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fulfillment_info][crate::model::WebhookRequest::fulfillment_info].
    pub fn set_or_clear_fulfillment_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::webhook_request::FulfillmentInfo>,
    {
        self.fulfillment_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [intent_info][crate::model::WebhookRequest::intent_info].
    pub fn set_intent_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::webhook_request::IntentInfo>,
    {
        self.intent_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [intent_info][crate::model::WebhookRequest::intent_info].
    pub fn set_or_clear_intent_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::webhook_request::IntentInfo>,
    {
        self.intent_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_info][crate::model::WebhookRequest::page_info].
    pub fn set_page_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PageInfo>,
    {
        self.page_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [page_info][crate::model::WebhookRequest::page_info].
    pub fn set_or_clear_page_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PageInfo>,
    {
        self.page_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [session_info][crate::model::WebhookRequest::session_info].
    pub fn set_session_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SessionInfo>,
    {
        self.session_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session_info][crate::model::WebhookRequest::session_info].
    pub fn set_or_clear_session_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SessionInfo>,
    {
        self.session_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [messages][crate::model::WebhookRequest::messages].
    pub fn set_messages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResponseMessage>,
    {
        use std::iter::Iterator;
        self.messages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [payload][crate::model::WebhookRequest::payload].
    pub fn set_payload<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.payload = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [payload][crate::model::WebhookRequest::payload].
    pub fn set_or_clear_payload<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.payload = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sentiment_analysis_result][crate::model::WebhookRequest::sentiment_analysis_result].
    pub fn set_sentiment_analysis_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::webhook_request::SentimentAnalysisResult>,
    {
        self.sentiment_analysis_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sentiment_analysis_result][crate::model::WebhookRequest::sentiment_analysis_result].
    pub fn set_or_clear_sentiment_analysis_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::webhook_request::SentimentAnalysisResult>,
    {
        self.sentiment_analysis_result = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_info][crate::model::WebhookRequest::language_info].
    pub fn set_language_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LanguageInfo>,
    {
        self.language_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [language_info][crate::model::WebhookRequest::language_info].
    pub fn set_or_clear_language_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LanguageInfo>,
    {
        self.language_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query][crate::model::WebhookRequest::query].
    ///
    /// Note that all the setters affecting `query` are mutually
    /// exclusive.
    pub fn set_query<
        T: std::convert::Into<std::option::Option<crate::model::webhook_request::Query>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.query = v.into();
        self
    }

    /// The value of [query][crate::model::WebhookRequest::query]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.query.as_ref().and_then(|v| match v {
            crate::model::webhook_request::Query::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [query][crate::model::WebhookRequest::query]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `query` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query =
            std::option::Option::Some(crate::model::webhook_request::Query::Text(v.into()));
        self
    }

    /// The value of [query][crate::model::WebhookRequest::query]
    /// if it holds a `TriggerIntent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn trigger_intent(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.query.as_ref().and_then(|v| match v {
            crate::model::webhook_request::Query::TriggerIntent(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [query][crate::model::WebhookRequest::query]
    /// to hold a `TriggerIntent`.
    ///
    /// Note that all the setters affecting `query` are
    /// mutually exclusive.
    pub fn set_trigger_intent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = std::option::Option::Some(
            crate::model::webhook_request::Query::TriggerIntent(v.into()),
        );
        self
    }

    /// The value of [query][crate::model::WebhookRequest::query]
    /// if it holds a `Transcript`, `None` if the field is not set or
    /// holds a different branch.
    pub fn transcript(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.query.as_ref().and_then(|v| match v {
            crate::model::webhook_request::Query::Transcript(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [query][crate::model::WebhookRequest::query]
    /// to hold a `Transcript`.
    ///
    /// Note that all the setters affecting `query` are
    /// mutually exclusive.
    pub fn set_transcript<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query =
            std::option::Option::Some(crate::model::webhook_request::Query::Transcript(v.into()));
        self
    }

    /// The value of [query][crate::model::WebhookRequest::query]
    /// if it holds a `TriggerEvent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn trigger_event(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.query.as_ref().and_then(|v| match v {
            crate::model::webhook_request::Query::TriggerEvent(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [query][crate::model::WebhookRequest::query]
    /// to hold a `TriggerEvent`.
    ///
    /// Note that all the setters affecting `query` are
    /// mutually exclusive.
    pub fn set_trigger_event<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query =
            std::option::Option::Some(crate::model::webhook_request::Query::TriggerEvent(v.into()));
        self
    }

    /// The value of [query][crate::model::WebhookRequest::query]
    /// if it holds a `DtmfDigits`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dtmf_digits(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.query.as_ref().and_then(|v| match v {
            crate::model::webhook_request::Query::DtmfDigits(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [query][crate::model::WebhookRequest::query]
    /// to hold a `DtmfDigits`.
    ///
    /// Note that all the setters affecting `query` are
    /// mutually exclusive.
    pub fn set_dtmf_digits<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query =
            std::option::Option::Some(crate::model::webhook_request::Query::DtmfDigits(v.into()));
        self
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl wkt::message::Message for WebhookRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.WebhookRequest"
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WebhookRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __detect_intent_response_id,
            __text,
            __trigger_intent,
            __transcript,
            __trigger_event,
            __dtmf_digits,
            __language_code,
            __fulfillment_info,
            __intent_info,
            __page_info,
            __session_info,
            __messages,
            __payload,
            __sentiment_analysis_result,
            __language_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WebhookRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "detectIntentResponseId" => Ok(__FieldTag::__detect_intent_response_id),
                            "detect_intent_response_id" => {
                                Ok(__FieldTag::__detect_intent_response_id)
                            }
                            "text" => Ok(__FieldTag::__text),
                            "triggerIntent" => Ok(__FieldTag::__trigger_intent),
                            "trigger_intent" => Ok(__FieldTag::__trigger_intent),
                            "transcript" => Ok(__FieldTag::__transcript),
                            "triggerEvent" => Ok(__FieldTag::__trigger_event),
                            "trigger_event" => Ok(__FieldTag::__trigger_event),
                            "dtmfDigits" => Ok(__FieldTag::__dtmf_digits),
                            "dtmf_digits" => Ok(__FieldTag::__dtmf_digits),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "fulfillmentInfo" => Ok(__FieldTag::__fulfillment_info),
                            "fulfillment_info" => Ok(__FieldTag::__fulfillment_info),
                            "intentInfo" => Ok(__FieldTag::__intent_info),
                            "intent_info" => Ok(__FieldTag::__intent_info),
                            "pageInfo" => Ok(__FieldTag::__page_info),
                            "page_info" => Ok(__FieldTag::__page_info),
                            "sessionInfo" => Ok(__FieldTag::__session_info),
                            "session_info" => Ok(__FieldTag::__session_info),
                            "messages" => Ok(__FieldTag::__messages),
                            "payload" => Ok(__FieldTag::__payload),
                            "sentimentAnalysisResult" => {
                                Ok(__FieldTag::__sentiment_analysis_result)
                            }
                            "sentiment_analysis_result" => {
                                Ok(__FieldTag::__sentiment_analysis_result)
                            }
                            "languageInfo" => Ok(__FieldTag::__language_info),
                            "language_info" => Ok(__FieldTag::__language_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WebhookRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WebhookRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__detect_intent_response_id => {
                            if !fields.insert(__FieldTag::__detect_intent_response_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detect_intent_response_id",
                                ));
                            }
                            result.detect_intent_response_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            if result.query.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query`, a oneof with full ID .google.cloud.dialogflow.cx.v3.WebhookRequest.text, latest field was text",
                                ));
                            }
                            result.query = std::option::Option::Some(
                                crate::model::webhook_request::Query::Text(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__trigger_intent => {
                            if !fields.insert(__FieldTag::__trigger_intent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_intent",
                                ));
                            }
                            if result.query.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query`, a oneof with full ID .google.cloud.dialogflow.cx.v3.WebhookRequest.trigger_intent, latest field was triggerIntent",
                                ));
                            }
                            result.query = std::option::Option::Some(
                                crate::model::webhook_request::Query::TriggerIntent(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__transcript => {
                            if !fields.insert(__FieldTag::__transcript) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transcript",
                                ));
                            }
                            if result.query.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query`, a oneof with full ID .google.cloud.dialogflow.cx.v3.WebhookRequest.transcript, latest field was transcript",
                                ));
                            }
                            result.query = std::option::Option::Some(
                                crate::model::webhook_request::Query::Transcript(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__trigger_event => {
                            if !fields.insert(__FieldTag::__trigger_event) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_event",
                                ));
                            }
                            if result.query.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query`, a oneof with full ID .google.cloud.dialogflow.cx.v3.WebhookRequest.trigger_event, latest field was triggerEvent",
                                ));
                            }
                            result.query = std::option::Option::Some(
                                crate::model::webhook_request::Query::TriggerEvent(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__dtmf_digits => {
                            if !fields.insert(__FieldTag::__dtmf_digits) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dtmf_digits",
                                ));
                            }
                            if result.query.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `query`, a oneof with full ID .google.cloud.dialogflow.cx.v3.WebhookRequest.dtmf_digits, latest field was dtmfDigits",
                                ));
                            }
                            result.query = std::option::Option::Some(
                                crate::model::webhook_request::Query::DtmfDigits(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fulfillment_info => {
                            if !fields.insert(__FieldTag::__fulfillment_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fulfillment_info",
                                ));
                            }
                            result.fulfillment_info = map.next_value::<std::option::Option<
                                crate::model::webhook_request::FulfillmentInfo,
                            >>()?;
                        }
                        __FieldTag::__intent_info => {
                            if !fields.insert(__FieldTag::__intent_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent_info",
                                ));
                            }
                            result.intent_info = map.next_value::<std::option::Option<crate::model::webhook_request::IntentInfo>>()?
                                ;
                        }
                        __FieldTag::__page_info => {
                            if !fields.insert(__FieldTag::__page_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_info",
                                ));
                            }
                            result.page_info =
                                map.next_value::<std::option::Option<crate::model::PageInfo>>()?;
                        }
                        __FieldTag::__session_info => {
                            if !fields.insert(__FieldTag::__session_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_info",
                                ));
                            }
                            result.session_info =
                                map.next_value::<std::option::Option<crate::model::SessionInfo>>()?;
                        }
                        __FieldTag::__messages => {
                            if !fields.insert(__FieldTag::__messages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for messages",
                                ));
                            }
                            result.messages =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ResponseMessage>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__payload => {
                            if !fields.insert(__FieldTag::__payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload",
                                ));
                            }
                            result.payload =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__sentiment_analysis_result => {
                            if !fields.insert(__FieldTag::__sentiment_analysis_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sentiment_analysis_result",
                                ));
                            }
                            result.sentiment_analysis_result = map
                                .next_value::<std::option::Option<
                                    crate::model::webhook_request::SentimentAnalysisResult,
                                >>()?;
                        }
                        __FieldTag::__language_info => {
                            if !fields.insert(__FieldTag::__language_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_info",
                                ));
                            }
                            result.language_info = map
                                .next_value::<std::option::Option<crate::model::LanguageInfo>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for WebhookRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.detect_intent_response_id.is_empty() {
            state.serialize_entry("detectIntentResponseId", &self.detect_intent_response_id)?;
        }
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.trigger_intent() {
            state.serialize_entry("triggerIntent", value)?;
        }
        if let Some(value) = self.transcript() {
            state.serialize_entry("transcript", value)?;
        }
        if let Some(value) = self.trigger_event() {
            state.serialize_entry("triggerEvent", value)?;
        }
        if let Some(value) = self.dtmf_digits() {
            state.serialize_entry("dtmfDigits", value)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.fulfillment_info.is_some() {
            state.serialize_entry("fulfillmentInfo", &self.fulfillment_info)?;
        }
        if self.intent_info.is_some() {
            state.serialize_entry("intentInfo", &self.intent_info)?;
        }
        if self.page_info.is_some() {
            state.serialize_entry("pageInfo", &self.page_info)?;
        }
        if self.session_info.is_some() {
            state.serialize_entry("sessionInfo", &self.session_info)?;
        }
        if !self.messages.is_empty() {
            state.serialize_entry("messages", &self.messages)?;
        }
        if self.payload.is_some() {
            state.serialize_entry("payload", &self.payload)?;
        }
        if self.sentiment_analysis_result.is_some() {
            state.serialize_entry("sentimentAnalysisResult", &self.sentiment_analysis_result)?;
        }
        if self.language_info.is_some() {
            state.serialize_entry("languageInfo", &self.language_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [WebhookRequest].
#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
pub mod webhook_request {
    #[allow(unused_imports)]
    use super::*;

    /// Represents fulfillment information communicated to the webhook.
    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FulfillmentInfo {
        /// Always present.
        /// The value of the
        /// [Fulfillment.tag][google.cloud.dialogflow.cx.v3.Fulfillment.tag] field
        /// will be populated in this field by Dialogflow when the associated webhook
        /// is called. The tag is typically used by the webhook service to identify
        /// which fulfillment is being called, but it could be used for other
        /// purposes.
        ///
        /// [google.cloud.dialogflow.cx.v3.Fulfillment.tag]: crate::model::Fulfillment::tag
        pub tag: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    impl FulfillmentInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [tag][crate::model::webhook_request::FulfillmentInfo::tag].
        pub fn set_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.tag = v.into();
            self
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    impl wkt::message::Message for FulfillmentInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.WebhookRequest.FulfillmentInfo"
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FulfillmentInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __tag,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FulfillmentInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "tag" => Ok(__FieldTag::__tag),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FulfillmentInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FulfillmentInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__tag => {
                                if !fields.insert(__FieldTag::__tag) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tag",
                                    ));
                                }
                                result.tag = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for FulfillmentInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.tag.is_empty() {
                state.serialize_entry("tag", &self.tag)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Represents intent information communicated to the webhook.
    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IntentInfo {
        /// Always present. The unique identifier of the last matched
        /// [intent][google.cloud.dialogflow.cx.v3.Intent].
        /// Format:
        /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/intents/<IntentID>`.
        ///
        /// [google.cloud.dialogflow.cx.v3.Intent]: crate::model::Intent
        pub last_matched_intent: std::string::String,

        /// Always present. The display name of the last matched
        /// [intent][google.cloud.dialogflow.cx.v3.Intent].
        ///
        /// [google.cloud.dialogflow.cx.v3.Intent]: crate::model::Intent
        pub display_name: std::string::String,

        /// Parameters identified as a result of intent matching. This is a map of
        /// the name of the identified parameter to the value of the parameter
        /// identified from the user's utterance. All parameters defined in the
        /// matched intent that are identified will be surfaced here.
        pub parameters: std::collections::HashMap<
            std::string::String,
            crate::model::webhook_request::intent_info::IntentParameterValue,
        >,

        /// The confidence of the matched intent. Values range from 0.0 (completely
        /// uncertain) to 1.0 (completely certain).
        pub confidence: f32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    impl IntentInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [last_matched_intent][crate::model::webhook_request::IntentInfo::last_matched_intent].
        pub fn set_last_matched_intent<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.last_matched_intent = v.into();
            self
        }

        /// Sets the value of [display_name][crate::model::webhook_request::IntentInfo::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [parameters][crate::model::webhook_request::IntentInfo::parameters].
        pub fn set_parameters<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::webhook_request::intent_info::IntentParameterValue>,
        {
            use std::iter::Iterator;
            self.parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [confidence][crate::model::webhook_request::IntentInfo::confidence].
        pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.confidence = v.into();
            self
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    impl wkt::message::Message for IntentInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.WebhookRequest.IntentInfo"
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IntentInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __last_matched_intent,
                __display_name,
                __parameters,
                __confidence,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IntentInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "lastMatchedIntent" => Ok(__FieldTag::__last_matched_intent),
                                "last_matched_intent" => Ok(__FieldTag::__last_matched_intent),
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                "parameters" => Ok(__FieldTag::__parameters),
                                "confidence" => Ok(__FieldTag::__confidence),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IntentInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IntentInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__last_matched_intent => {
                                if !fields.insert(__FieldTag::__last_matched_intent) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for last_matched_intent",
                                    ));
                                }
                                result.last_matched_intent = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__parameters => {
                                if !fields.insert(__FieldTag::__parameters) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parameters",
                                    ));
                                }
                                result.parameters = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::model::webhook_request::intent_info::IntentParameterValue>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__confidence => {
                                if !fields.insert(__FieldTag::__confidence) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for confidence",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.confidence =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for IntentInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.last_matched_intent.is_empty() {
                state.serialize_entry("lastMatchedIntent", &self.last_matched_intent)?;
            }
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self.parameters.is_empty() {
                state.serialize_entry("parameters", &self.parameters)?;
            }
            if !wkt::internal::is_default(&self.confidence) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("confidence", &__With(&self.confidence))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [IntentInfo].
    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    pub mod intent_info {
        #[allow(unused_imports)]
        use super::*;

        /// Represents a value for an intent parameter.
        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct IntentParameterValue {
            /// Always present. Original text value extracted from user utterance.
            pub original_value: std::string::String,

            /// Always present. Structured value for the parameter extracted from user
            /// utterance.
            pub resolved_value: std::option::Option<wkt::Value>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        impl IntentParameterValue {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [original_value][crate::model::webhook_request::intent_info::IntentParameterValue::original_value].
            pub fn set_original_value<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.original_value = v.into();
                self
            }

            /// Sets the value of [resolved_value][crate::model::webhook_request::intent_info::IntentParameterValue::resolved_value].
            pub fn set_resolved_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Value>,
            {
                self.resolved_value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [resolved_value][crate::model::webhook_request::intent_info::IntentParameterValue::resolved_value].
            pub fn set_or_clear_resolved_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Value>,
            {
                self.resolved_value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        impl wkt::message::Message for IntentParameterValue {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.cx.v3.WebhookRequest.IntentInfo.IntentParameterValue"
            }
        }

        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for IntentParameterValue {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __original_value,
                    __resolved_value,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for IntentParameterValue")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "originalValue" => Ok(__FieldTag::__original_value),
                                    "original_value" => Ok(__FieldTag::__original_value),
                                    "resolvedValue" => Ok(__FieldTag::__resolved_value),
                                    "resolved_value" => Ok(__FieldTag::__resolved_value),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = IntentParameterValue;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct IntentParameterValue")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__original_value => {
                                    if !fields.insert(__FieldTag::__original_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for original_value",
                                            ),
                                        );
                                    }
                                    result.original_value = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__resolved_value => {
                                    if !fields.insert(__FieldTag::__resolved_value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for resolved_value",
                                            ),
                                        );
                                    }
                                    result.resolved_value = map
                                        .next_value::<std::option::Option<wkt::Value>>()?
                                        .or(Some(wkt::Value::Null));
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for IntentParameterValue {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.original_value.is_empty() {
                    state.serialize_entry("originalValue", &self.original_value)?;
                }
                if self.resolved_value.is_some() {
                    state.serialize_entry("resolvedValue", &self.resolved_value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Represents the result of sentiment analysis.
    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SentimentAnalysisResult {
        /// Sentiment score between -1.0 (negative sentiment) and 1.0 (positive
        /// sentiment).
        pub score: f32,

        /// A non-negative number in the [0, +inf) range, which represents the
        /// absolute magnitude of sentiment, regardless of score (positive or
        /// negative).
        pub magnitude: f32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    impl SentimentAnalysisResult {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [score][crate::model::webhook_request::SentimentAnalysisResult::score].
        pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.score = v.into();
            self
        }

        /// Sets the value of [magnitude][crate::model::webhook_request::SentimentAnalysisResult::magnitude].
        pub fn set_magnitude<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.magnitude = v.into();
            self
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    impl wkt::message::Message for SentimentAnalysisResult {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.WebhookRequest.SentimentAnalysisResult"
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SentimentAnalysisResult {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __score,
                __magnitude,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SentimentAnalysisResult")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "score" => Ok(__FieldTag::__score),
                                "magnitude" => Ok(__FieldTag::__magnitude),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SentimentAnalysisResult;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SentimentAnalysisResult")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__score => {
                                if !fields.insert(__FieldTag::__score) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for score",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.score = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__magnitude => {
                                if !fields.insert(__FieldTag::__magnitude) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for magnitude",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.magnitude =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for SentimentAnalysisResult {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.score) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("score", &__With(&self.score))?;
            }
            if !wkt::internal::is_default(&self.magnitude) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("magnitude", &__With(&self.magnitude))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The original conversational query.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Query {
        /// If [natural language text][google.cloud.dialogflow.cx.v3.TextInput] was
        /// provided as input, this field will contain a copy of the text.
        ///
        /// [google.cloud.dialogflow.cx.v3.TextInput]: crate::model::TextInput
        Text(std::string::String),
        /// If an [intent][google.cloud.dialogflow.cx.v3.IntentInput] was provided as
        /// input, this field will contain a copy of the intent identifier. Format:
        /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/intents/<IntentID>`.
        ///
        /// [google.cloud.dialogflow.cx.v3.IntentInput]: crate::model::IntentInput
        TriggerIntent(std::string::String),
        /// If [natural language speech
        /// audio][google.cloud.dialogflow.cx.v3.AudioInput] was provided as input,
        /// this field will contain the transcript for the audio.
        ///
        /// [google.cloud.dialogflow.cx.v3.AudioInput]: crate::model::AudioInput
        Transcript(std::string::String),
        /// If an [event][google.cloud.dialogflow.cx.v3.EventInput] was provided as
        /// input, this field will contain the name of the event.
        ///
        /// [google.cloud.dialogflow.cx.v3.EventInput]: crate::model::EventInput
        TriggerEvent(std::string::String),
        /// If [DTMF][google.cloud.dialogflow.cx.v3.DtmfInput] was provided as input,
        /// this field will contain the DTMF digits.
        ///
        /// [google.cloud.dialogflow.cx.v3.DtmfInput]: crate::model::DtmfInput
        DtmfDigits(std::string::String),
    }
}

/// The response message for a webhook call.
#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WebhookResponse {
    /// The fulfillment response to send to the user. This field can be omitted by
    /// the webhook if it does not intend to send any response to the user.
    pub fulfillment_response:
        std::option::Option<crate::model::webhook_response::FulfillmentResponse>,

    /// Information about page status. This field can be omitted by the webhook if
    /// it does not intend to modify page status.
    pub page_info: std::option::Option<crate::model::PageInfo>,

    /// Information about session status. This field can be omitted by the webhook
    /// if it does not intend to modify session status.
    pub session_info: std::option::Option<crate::model::SessionInfo>,

    /// Value to append directly to
    /// [QueryResult.webhook_payloads][google.cloud.dialogflow.cx.v3.QueryResult.webhook_payloads].
    ///
    /// [google.cloud.dialogflow.cx.v3.QueryResult.webhook_payloads]: crate::model::QueryResult::webhook_payloads
    pub payload: std::option::Option<wkt::Struct>,

    /// The target to transition to. This can be set optionally to indicate an
    /// immediate transition to a different page in the same host flow, or a
    /// different flow in the same agent.
    pub transition: std::option::Option<crate::model::webhook_response::Transition>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl WebhookResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fulfillment_response][crate::model::WebhookResponse::fulfillment_response].
    pub fn set_fulfillment_response<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::webhook_response::FulfillmentResponse>,
    {
        self.fulfillment_response = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fulfillment_response][crate::model::WebhookResponse::fulfillment_response].
    pub fn set_or_clear_fulfillment_response<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::webhook_response::FulfillmentResponse>,
    {
        self.fulfillment_response = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_info][crate::model::WebhookResponse::page_info].
    pub fn set_page_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PageInfo>,
    {
        self.page_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [page_info][crate::model::WebhookResponse::page_info].
    pub fn set_or_clear_page_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PageInfo>,
    {
        self.page_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [session_info][crate::model::WebhookResponse::session_info].
    pub fn set_session_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SessionInfo>,
    {
        self.session_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session_info][crate::model::WebhookResponse::session_info].
    pub fn set_or_clear_session_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SessionInfo>,
    {
        self.session_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [payload][crate::model::WebhookResponse::payload].
    pub fn set_payload<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.payload = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [payload][crate::model::WebhookResponse::payload].
    pub fn set_or_clear_payload<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.payload = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transition][crate::model::WebhookResponse::transition].
    ///
    /// Note that all the setters affecting `transition` are mutually
    /// exclusive.
    pub fn set_transition<
        T: std::convert::Into<std::option::Option<crate::model::webhook_response::Transition>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transition = v.into();
        self
    }

    /// The value of [transition][crate::model::WebhookResponse::transition]
    /// if it holds a `TargetPage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn target_page(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.transition.as_ref().and_then(|v| match v {
            crate::model::webhook_response::Transition::TargetPage(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transition][crate::model::WebhookResponse::transition]
    /// to hold a `TargetPage`.
    ///
    /// Note that all the setters affecting `transition` are
    /// mutually exclusive.
    pub fn set_target_page<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.transition = std::option::Option::Some(
            crate::model::webhook_response::Transition::TargetPage(v.into()),
        );
        self
    }

    /// The value of [transition][crate::model::WebhookResponse::transition]
    /// if it holds a `TargetFlow`, `None` if the field is not set or
    /// holds a different branch.
    pub fn target_flow(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.transition.as_ref().and_then(|v| match v {
            crate::model::webhook_response::Transition::TargetFlow(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [transition][crate::model::WebhookResponse::transition]
    /// to hold a `TargetFlow`.
    ///
    /// Note that all the setters affecting `transition` are
    /// mutually exclusive.
    pub fn set_target_flow<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.transition = std::option::Option::Some(
            crate::model::webhook_response::Transition::TargetFlow(v.into()),
        );
        self
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl wkt::message::Message for WebhookResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.WebhookResponse"
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WebhookResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fulfillment_response,
            __page_info,
            __session_info,
            __payload,
            __target_page,
            __target_flow,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WebhookResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fulfillmentResponse" => Ok(__FieldTag::__fulfillment_response),
                            "fulfillment_response" => Ok(__FieldTag::__fulfillment_response),
                            "pageInfo" => Ok(__FieldTag::__page_info),
                            "page_info" => Ok(__FieldTag::__page_info),
                            "sessionInfo" => Ok(__FieldTag::__session_info),
                            "session_info" => Ok(__FieldTag::__session_info),
                            "payload" => Ok(__FieldTag::__payload),
                            "targetPage" => Ok(__FieldTag::__target_page),
                            "target_page" => Ok(__FieldTag::__target_page),
                            "targetFlow" => Ok(__FieldTag::__target_flow),
                            "target_flow" => Ok(__FieldTag::__target_flow),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WebhookResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WebhookResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fulfillment_response => {
                            if !fields.insert(__FieldTag::__fulfillment_response) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fulfillment_response",
                                ));
                            }
                            result.fulfillment_response = map.next_value::<std::option::Option<
                                crate::model::webhook_response::FulfillmentResponse,
                            >>()?;
                        }
                        __FieldTag::__page_info => {
                            if !fields.insert(__FieldTag::__page_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_info",
                                ));
                            }
                            result.page_info =
                                map.next_value::<std::option::Option<crate::model::PageInfo>>()?;
                        }
                        __FieldTag::__session_info => {
                            if !fields.insert(__FieldTag::__session_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_info",
                                ));
                            }
                            result.session_info =
                                map.next_value::<std::option::Option<crate::model::SessionInfo>>()?;
                        }
                        __FieldTag::__payload => {
                            if !fields.insert(__FieldTag::__payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload",
                                ));
                            }
                            result.payload =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__target_page => {
                            if !fields.insert(__FieldTag::__target_page) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_page",
                                ));
                            }
                            if result.transition.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transition`, a oneof with full ID .google.cloud.dialogflow.cx.v3.WebhookResponse.target_page, latest field was targetPage",
                                ));
                            }
                            result.transition = std::option::Option::Some(
                                crate::model::webhook_response::Transition::TargetPage(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__target_flow => {
                            if !fields.insert(__FieldTag::__target_flow) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_flow",
                                ));
                            }
                            if result.transition.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `transition`, a oneof with full ID .google.cloud.dialogflow.cx.v3.WebhookResponse.target_flow, latest field was targetFlow",
                                ));
                            }
                            result.transition = std::option::Option::Some(
                                crate::model::webhook_response::Transition::TargetFlow(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for WebhookResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.fulfillment_response.is_some() {
            state.serialize_entry("fulfillmentResponse", &self.fulfillment_response)?;
        }
        if self.page_info.is_some() {
            state.serialize_entry("pageInfo", &self.page_info)?;
        }
        if self.session_info.is_some() {
            state.serialize_entry("sessionInfo", &self.session_info)?;
        }
        if self.payload.is_some() {
            state.serialize_entry("payload", &self.payload)?;
        }
        if let Some(value) = self.target_page() {
            state.serialize_entry("targetPage", value)?;
        }
        if let Some(value) = self.target_flow() {
            state.serialize_entry("targetFlow", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [WebhookResponse].
#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
pub mod webhook_response {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a fulfillment response to the user.
    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FulfillmentResponse {
        /// The list of rich message responses to present to the user.
        pub messages: std::vec::Vec<crate::model::ResponseMessage>,

        /// Merge behavior for `messages`.
        pub merge_behavior: crate::model::webhook_response::fulfillment_response::MergeBehavior,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    impl FulfillmentResponse {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [messages][crate::model::webhook_response::FulfillmentResponse::messages].
        pub fn set_messages<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::ResponseMessage>,
        {
            use std::iter::Iterator;
            self.messages = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [merge_behavior][crate::model::webhook_response::FulfillmentResponse::merge_behavior].
        pub fn set_merge_behavior<
            T: std::convert::Into<crate::model::webhook_response::fulfillment_response::MergeBehavior>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.merge_behavior = v.into();
            self
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    impl wkt::message::Message for FulfillmentResponse {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.WebhookResponse.FulfillmentResponse"
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FulfillmentResponse {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __messages,
                __merge_behavior,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FulfillmentResponse")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "messages" => Ok(__FieldTag::__messages),
                                "mergeBehavior" => Ok(__FieldTag::__merge_behavior),
                                "merge_behavior" => Ok(__FieldTag::__merge_behavior),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FulfillmentResponse;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FulfillmentResponse")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__messages => {
                                if !fields.insert(__FieldTag::__messages) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for messages",
                                    ));
                                }
                                result.messages = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::ResponseMessage>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__merge_behavior => {
                                if !fields.insert(__FieldTag::__merge_behavior) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for merge_behavior",
                                    ));
                                }
                                result.merge_behavior = map.next_value::<std::option::Option<crate::model::webhook_response::fulfillment_response::MergeBehavior>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for FulfillmentResponse {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.messages.is_empty() {
                state.serialize_entry("messages", &self.messages)?;
            }
            if !wkt::internal::is_default(&self.merge_behavior) {
                state.serialize_entry("mergeBehavior", &self.merge_behavior)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [FulfillmentResponse].
    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    pub mod fulfillment_response {
        #[allow(unused_imports)]
        use super::*;

        /// Defines merge behavior for `messages`.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum MergeBehavior {
            /// Not specified. `APPEND` will be used.
            Unspecified,
            /// `messages` will be appended to the list of messages waiting to be sent
            /// to the user.
            Append,
            /// `messages` will replace the list of messages waiting to be sent to the
            /// user.
            Replace,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [MergeBehavior::value] or
            /// [MergeBehavior::name].
            UnknownValue(merge_behavior::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        pub mod merge_behavior {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        impl MergeBehavior {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Append => std::option::Option::Some(1),
                    Self::Replace => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("MERGE_BEHAVIOR_UNSPECIFIED"),
                    Self::Append => std::option::Option::Some("APPEND"),
                    Self::Replace => std::option::Option::Some("REPLACE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        impl std::default::Default for MergeBehavior {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        impl std::fmt::Display for MergeBehavior {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        impl std::convert::From<i32> for MergeBehavior {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Append,
                    2 => Self::Replace,
                    _ => Self::UnknownValue(merge_behavior::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        impl std::convert::From<&str> for MergeBehavior {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "MERGE_BEHAVIOR_UNSPECIFIED" => Self::Unspecified,
                    "APPEND" => Self::Append,
                    "REPLACE" => Self::Replace,
                    _ => Self::UnknownValue(merge_behavior::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        impl serde::ser::Serialize for MergeBehavior {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Append => serializer.serialize_i32(1),
                    Self::Replace => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        impl<'de> serde::de::Deserialize<'de> for MergeBehavior {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<MergeBehavior>::new(
                    ".google.cloud.dialogflow.cx.v3.WebhookResponse.FulfillmentResponse.MergeBehavior"))
            }
        }
    }

    /// The target to transition to. This can be set optionally to indicate an
    /// immediate transition to a different page in the same host flow, or a
    /// different flow in the same agent.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Transition {
        /// The target page to transition to.
        /// Format:
        /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/pages/<PageID>`.
        TargetPage(std::string::String),
        /// The target flow to transition to.
        /// Format:
        /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>`.
        TargetFlow(std::string::String),
    }
}

/// Represents page information communicated to and from the webhook.
#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PageInfo {
    /// Always present for
    /// [WebhookRequest][google.cloud.dialogflow.cx.v3.WebhookRequest]. Ignored for
    /// [WebhookResponse][google.cloud.dialogflow.cx.v3.WebhookResponse]. The
    /// unique identifier of the current page. Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/pages/<PageID>`.
    ///
    /// [google.cloud.dialogflow.cx.v3.WebhookRequest]: crate::model::WebhookRequest
    /// [google.cloud.dialogflow.cx.v3.WebhookResponse]: crate::model::WebhookResponse
    pub current_page: std::string::String,

    /// Always present for
    /// [WebhookRequest][google.cloud.dialogflow.cx.v3.WebhookRequest]. Ignored for
    /// [WebhookResponse][google.cloud.dialogflow.cx.v3.WebhookResponse]. The
    /// display name of the current page.
    ///
    /// [google.cloud.dialogflow.cx.v3.WebhookRequest]: crate::model::WebhookRequest
    /// [google.cloud.dialogflow.cx.v3.WebhookResponse]: crate::model::WebhookResponse
    pub display_name: std::string::String,

    /// Optional for both
    /// [WebhookRequest][google.cloud.dialogflow.cx.v3.WebhookRequest] and
    /// [WebhookResponse][google.cloud.dialogflow.cx.v3.WebhookResponse].
    /// Information about the form.
    ///
    /// [google.cloud.dialogflow.cx.v3.WebhookRequest]: crate::model::WebhookRequest
    /// [google.cloud.dialogflow.cx.v3.WebhookResponse]: crate::model::WebhookResponse
    pub form_info: std::option::Option<crate::model::page_info::FormInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl PageInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [current_page][crate::model::PageInfo::current_page].
    pub fn set_current_page<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.current_page = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::PageInfo::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [form_info][crate::model::PageInfo::form_info].
    pub fn set_form_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::page_info::FormInfo>,
    {
        self.form_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [form_info][crate::model::PageInfo::form_info].
    pub fn set_or_clear_form_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::page_info::FormInfo>,
    {
        self.form_info = v.map(|x| x.into());
        self
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl wkt::message::Message for PageInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.PageInfo"
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PageInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __current_page,
            __display_name,
            __form_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PageInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "currentPage" => Ok(__FieldTag::__current_page),
                            "current_page" => Ok(__FieldTag::__current_page),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "formInfo" => Ok(__FieldTag::__form_info),
                            "form_info" => Ok(__FieldTag::__form_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PageInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PageInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__current_page => {
                            if !fields.insert(__FieldTag::__current_page) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_page",
                                ));
                            }
                            result.current_page = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__form_info => {
                            if !fields.insert(__FieldTag::__form_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for form_info",
                                ));
                            }
                            result.form_info = map.next_value::<std::option::Option<crate::model::page_info::FormInfo>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for PageInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.current_page.is_empty() {
            state.serialize_entry("currentPage", &self.current_page)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.form_info.is_some() {
            state.serialize_entry("formInfo", &self.form_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [PageInfo].
#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
pub mod page_info {
    #[allow(unused_imports)]
    use super::*;

    /// Represents form information.
    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FormInfo {
        /// Optional for both
        /// [WebhookRequest][google.cloud.dialogflow.cx.v3.WebhookRequest] and
        /// [WebhookResponse][google.cloud.dialogflow.cx.v3.WebhookResponse]. The
        /// parameters contained in the form. Note that the webhook cannot add or
        /// remove any form parameter.
        ///
        /// [google.cloud.dialogflow.cx.v3.WebhookRequest]: crate::model::WebhookRequest
        /// [google.cloud.dialogflow.cx.v3.WebhookResponse]: crate::model::WebhookResponse
        pub parameter_info: std::vec::Vec<crate::model::page_info::form_info::ParameterInfo>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    impl FormInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [parameter_info][crate::model::page_info::FormInfo::parameter_info].
        pub fn set_parameter_info<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::page_info::form_info::ParameterInfo>,
        {
            use std::iter::Iterator;
            self.parameter_info = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    impl wkt::message::Message for FormInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.cx.v3.PageInfo.FormInfo"
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FormInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __parameter_info,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FormInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "parameterInfo" => Ok(__FieldTag::__parameter_info),
                                "parameter_info" => Ok(__FieldTag::__parameter_info),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FormInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FormInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__parameter_info => {
                                if !fields.insert(__FieldTag::__parameter_info) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parameter_info",
                                    ));
                                }
                                result.parameter_info = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::page_info::form_info::ParameterInfo,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for FormInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.parameter_info.is_empty() {
                state.serialize_entry("parameterInfo", &self.parameter_info)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [FormInfo].
    #[cfg(all(
        feature = "agents",
        feature = "changelogs",
        feature = "deployments",
        feature = "entity-types",
        feature = "environments",
        feature = "experiments",
        feature = "flows",
        feature = "generators",
        feature = "intents",
        feature = "pages",
        feature = "security-settings-service",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "test-cases",
        feature = "transition-route-groups",
        feature = "versions",
        feature = "webhooks",
    ))]
    pub mod form_info {
        #[allow(unused_imports)]
        use super::*;

        /// Represents parameter information.
        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ParameterInfo {
            /// Always present for
            /// [WebhookRequest][google.cloud.dialogflow.cx.v3.WebhookRequest].
            /// Required for
            /// [WebhookResponse][google.cloud.dialogflow.cx.v3.WebhookResponse].
            /// The human-readable name of the parameter, unique within the form. This
            /// field cannot be modified by the webhook.
            ///
            /// [google.cloud.dialogflow.cx.v3.WebhookRequest]: crate::model::WebhookRequest
            /// [google.cloud.dialogflow.cx.v3.WebhookResponse]: crate::model::WebhookResponse
            pub display_name: std::string::String,

            /// Optional for both
            /// [WebhookRequest][google.cloud.dialogflow.cx.v3.WebhookRequest] and
            /// [WebhookResponse][google.cloud.dialogflow.cx.v3.WebhookResponse].
            /// Indicates whether the parameter is required. Optional parameters will
            /// not trigger prompts; however, they are filled if the user specifies
            /// them. Required parameters must be filled before form filling concludes.
            ///
            /// [google.cloud.dialogflow.cx.v3.WebhookRequest]: crate::model::WebhookRequest
            /// [google.cloud.dialogflow.cx.v3.WebhookResponse]: crate::model::WebhookResponse
            pub required: bool,

            /// Always present for
            /// [WebhookRequest][google.cloud.dialogflow.cx.v3.WebhookRequest].
            /// Required for
            /// [WebhookResponse][google.cloud.dialogflow.cx.v3.WebhookResponse]. The
            /// state of the parameter. This field can be set to
            /// [INVALID][google.cloud.dialogflow.cx.v3.PageInfo.FormInfo.ParameterInfo.ParameterState.INVALID]
            /// by the webhook to invalidate the parameter; other values set by the
            /// webhook will be ignored.
            ///
            /// [google.cloud.dialogflow.cx.v3.PageInfo.FormInfo.ParameterInfo.ParameterState.INVALID]: crate::model::page_info::form_info::parameter_info::ParameterState::Invalid
            /// [google.cloud.dialogflow.cx.v3.WebhookRequest]: crate::model::WebhookRequest
            /// [google.cloud.dialogflow.cx.v3.WebhookResponse]: crate::model::WebhookResponse
            pub state: crate::model::page_info::form_info::parameter_info::ParameterState,

            /// Optional for both
            /// [WebhookRequest][google.cloud.dialogflow.cx.v3.WebhookRequest] and
            /// [WebhookResponse][google.cloud.dialogflow.cx.v3.WebhookResponse]. The
            /// value of the parameter. This field can be set by the webhook to change
            /// the parameter value.
            ///
            /// [google.cloud.dialogflow.cx.v3.WebhookRequest]: crate::model::WebhookRequest
            /// [google.cloud.dialogflow.cx.v3.WebhookResponse]: crate::model::WebhookResponse
            pub value: std::option::Option<wkt::Value>,

            /// Optional for
            /// [WebhookRequest][google.cloud.dialogflow.cx.v3.WebhookRequest]. Ignored
            /// for [WebhookResponse][google.cloud.dialogflow.cx.v3.WebhookResponse].
            /// Indicates if the parameter value was just collected on the last
            /// conversation turn.
            ///
            /// [google.cloud.dialogflow.cx.v3.WebhookRequest]: crate::model::WebhookRequest
            /// [google.cloud.dialogflow.cx.v3.WebhookResponse]: crate::model::WebhookResponse
            pub just_collected: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        impl ParameterInfo {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [display_name][crate::model::page_info::form_info::ParameterInfo::display_name].
            pub fn set_display_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.display_name = v.into();
                self
            }

            /// Sets the value of [required][crate::model::page_info::form_info::ParameterInfo::required].
            pub fn set_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.required = v.into();
                self
            }

            /// Sets the value of [state][crate::model::page_info::form_info::ParameterInfo::state].
            pub fn set_state<
                T: std::convert::Into<
                        crate::model::page_info::form_info::parameter_info::ParameterState,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.state = v.into();
                self
            }

            /// Sets the value of [value][crate::model::page_info::form_info::ParameterInfo::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Value>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::page_info::form_info::ParameterInfo::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Value>,
            {
                self.value = v.map(|x| x.into());
                self
            }

            /// Sets the value of [just_collected][crate::model::page_info::form_info::ParameterInfo::just_collected].
            pub fn set_just_collected<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.just_collected = v.into();
                self
            }
        }

        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        impl wkt::message::Message for ParameterInfo {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.cx.v3.PageInfo.FormInfo.ParameterInfo"
            }
        }

        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ParameterInfo {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __display_name,
                    __required,
                    __state,
                    __value,
                    __just_collected,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ParameterInfo")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "displayName" => Ok(__FieldTag::__display_name),
                                    "display_name" => Ok(__FieldTag::__display_name),
                                    "required" => Ok(__FieldTag::__required),
                                    "state" => Ok(__FieldTag::__state),
                                    "value" => Ok(__FieldTag::__value),
                                    "justCollected" => Ok(__FieldTag::__just_collected),
                                    "just_collected" => Ok(__FieldTag::__just_collected),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ParameterInfo;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ParameterInfo")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__display_name => {
                                    if !fields.insert(__FieldTag::__display_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for display_name",
                                            ),
                                        );
                                    }
                                    result.display_name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__required => {
                                    if !fields.insert(__FieldTag::__required) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for required",
                                            ),
                                        );
                                    }
                                    result.required = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__state => {
                                    if !fields.insert(__FieldTag::__state) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for state"),
                                        );
                                    }
                                    result.state = map.next_value::<std::option::Option<crate::model::page_info::form_info::parameter_info::ParameterState>>()?.unwrap_or_default();
                                }
                                __FieldTag::__value => {
                                    if !fields.insert(__FieldTag::__value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for value"),
                                        );
                                    }
                                    result.value = map
                                        .next_value::<std::option::Option<wkt::Value>>()?
                                        .or(Some(wkt::Value::Null));
                                }
                                __FieldTag::__just_collected => {
                                    if !fields.insert(__FieldTag::__just_collected) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for just_collected",
                                            ),
                                        );
                                    }
                                    result.just_collected = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for ParameterInfo {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.display_name.is_empty() {
                    state.serialize_entry("displayName", &self.display_name)?;
                }
                if !wkt::internal::is_default(&self.required) {
                    state.serialize_entry("required", &self.required)?;
                }
                if !wkt::internal::is_default(&self.state) {
                    state.serialize_entry("state", &self.state)?;
                }
                if self.value.is_some() {
                    state.serialize_entry("value", &self.value)?;
                }
                if !wkt::internal::is_default(&self.just_collected) {
                    state.serialize_entry("justCollected", &self.just_collected)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [ParameterInfo].
        #[cfg(all(
            feature = "agents",
            feature = "changelogs",
            feature = "deployments",
            feature = "entity-types",
            feature = "environments",
            feature = "experiments",
            feature = "flows",
            feature = "generators",
            feature = "intents",
            feature = "pages",
            feature = "security-settings-service",
            feature = "session-entity-types",
            feature = "sessions",
            feature = "test-cases",
            feature = "transition-route-groups",
            feature = "versions",
            feature = "webhooks",
        ))]
        pub mod parameter_info {
            #[allow(unused_imports)]
            use super::*;

            /// Represents the state of a parameter.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[cfg(all(
                feature = "agents",
                feature = "changelogs",
                feature = "deployments",
                feature = "entity-types",
                feature = "environments",
                feature = "experiments",
                feature = "flows",
                feature = "generators",
                feature = "intents",
                feature = "pages",
                feature = "security-settings-service",
                feature = "session-entity-types",
                feature = "sessions",
                feature = "test-cases",
                feature = "transition-route-groups",
                feature = "versions",
                feature = "webhooks",
            ))]
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum ParameterState {
                /// Not specified. This value should be never used.
                Unspecified,
                /// Indicates that the parameter does not have a value.
                Empty,
                /// Indicates that the parameter value is invalid. This field can be used
                /// by the webhook to invalidate the parameter and ask the server to
                /// collect it from the user again.
                Invalid,
                /// Indicates that the parameter has a value.
                Filled,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [ParameterState::value] or
                /// [ParameterState::name].
                UnknownValue(parameter_state::UnknownValue),
            }

            #[doc(hidden)]
            #[cfg(all(
                feature = "agents",
                feature = "changelogs",
                feature = "deployments",
                feature = "entity-types",
                feature = "environments",
                feature = "experiments",
                feature = "flows",
                feature = "generators",
                feature = "intents",
                feature = "pages",
                feature = "security-settings-service",
                feature = "session-entity-types",
                feature = "sessions",
                feature = "test-cases",
                feature = "transition-route-groups",
                feature = "versions",
                feature = "webhooks",
            ))]
            pub mod parameter_state {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            #[cfg(all(
                feature = "agents",
                feature = "changelogs",
                feature = "deployments",
                feature = "entity-types",
                feature = "environments",
                feature = "experiments",
                feature = "flows",
                feature = "generators",
                feature = "intents",
                feature = "pages",
                feature = "security-settings-service",
                feature = "session-entity-types",
                feature = "sessions",
                feature = "test-cases",
                feature = "transition-route-groups",
                feature = "versions",
                feature = "webhooks",
            ))]
            impl ParameterState {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Empty => std::option::Option::Some(1),
                        Self::Invalid => std::option::Option::Some(2),
                        Self::Filled => std::option::Option::Some(3),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("PARAMETER_STATE_UNSPECIFIED")
                        }
                        Self::Empty => std::option::Option::Some("EMPTY"),
                        Self::Invalid => std::option::Option::Some("INVALID"),
                        Self::Filled => std::option::Option::Some("FILLED"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            #[cfg(all(
                feature = "agents",
                feature = "changelogs",
                feature = "deployments",
                feature = "entity-types",
                feature = "environments",
                feature = "experiments",
                feature = "flows",
                feature = "generators",
                feature = "intents",
                feature = "pages",
                feature = "security-settings-service",
                feature = "session-entity-types",
                feature = "sessions",
                feature = "test-cases",
                feature = "transition-route-groups",
                feature = "versions",
                feature = "webhooks",
            ))]
            impl std::default::Default for ParameterState {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            #[cfg(all(
                feature = "agents",
                feature = "changelogs",
                feature = "deployments",
                feature = "entity-types",
                feature = "environments",
                feature = "experiments",
                feature = "flows",
                feature = "generators",
                feature = "intents",
                feature = "pages",
                feature = "security-settings-service",
                feature = "session-entity-types",
                feature = "sessions",
                feature = "test-cases",
                feature = "transition-route-groups",
                feature = "versions",
                feature = "webhooks",
            ))]
            impl std::fmt::Display for ParameterState {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            #[cfg(all(
                feature = "agents",
                feature = "changelogs",
                feature = "deployments",
                feature = "entity-types",
                feature = "environments",
                feature = "experiments",
                feature = "flows",
                feature = "generators",
                feature = "intents",
                feature = "pages",
                feature = "security-settings-service",
                feature = "session-entity-types",
                feature = "sessions",
                feature = "test-cases",
                feature = "transition-route-groups",
                feature = "versions",
                feature = "webhooks",
            ))]
            impl std::convert::From<i32> for ParameterState {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Empty,
                        2 => Self::Invalid,
                        3 => Self::Filled,
                        _ => Self::UnknownValue(parameter_state::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            #[cfg(all(
                feature = "agents",
                feature = "changelogs",
                feature = "deployments",
                feature = "entity-types",
                feature = "environments",
                feature = "experiments",
                feature = "flows",
                feature = "generators",
                feature = "intents",
                feature = "pages",
                feature = "security-settings-service",
                feature = "session-entity-types",
                feature = "sessions",
                feature = "test-cases",
                feature = "transition-route-groups",
                feature = "versions",
                feature = "webhooks",
            ))]
            impl std::convert::From<&str> for ParameterState {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "PARAMETER_STATE_UNSPECIFIED" => Self::Unspecified,
                        "EMPTY" => Self::Empty,
                        "INVALID" => Self::Invalid,
                        "FILLED" => Self::Filled,
                        _ => Self::UnknownValue(parameter_state::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            #[cfg(all(
                feature = "agents",
                feature = "changelogs",
                feature = "deployments",
                feature = "entity-types",
                feature = "environments",
                feature = "experiments",
                feature = "flows",
                feature = "generators",
                feature = "intents",
                feature = "pages",
                feature = "security-settings-service",
                feature = "session-entity-types",
                feature = "sessions",
                feature = "test-cases",
                feature = "transition-route-groups",
                feature = "versions",
                feature = "webhooks",
            ))]
            impl serde::ser::Serialize for ParameterState {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Empty => serializer.serialize_i32(1),
                        Self::Invalid => serializer.serialize_i32(2),
                        Self::Filled => serializer.serialize_i32(3),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            #[cfg(all(
                feature = "agents",
                feature = "changelogs",
                feature = "deployments",
                feature = "entity-types",
                feature = "environments",
                feature = "experiments",
                feature = "flows",
                feature = "generators",
                feature = "intents",
                feature = "pages",
                feature = "security-settings-service",
                feature = "session-entity-types",
                feature = "sessions",
                feature = "test-cases",
                feature = "transition-route-groups",
                feature = "versions",
                feature = "webhooks",
            ))]
            impl<'de> serde::de::Deserialize<'de> for ParameterState {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<ParameterState>::new(
                        ".google.cloud.dialogflow.cx.v3.PageInfo.FormInfo.ParameterInfo.ParameterState"))
                }
            }
        }
    }
}

/// Represents session information communicated to and from the webhook.
#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SessionInfo {
    /// Always present for
    /// [WebhookRequest][google.cloud.dialogflow.cx.v3.WebhookRequest]. Ignored for
    /// [WebhookResponse][google.cloud.dialogflow.cx.v3.WebhookResponse]. The
    /// unique identifier of the
    /// [session][google.cloud.dialogflow.cx.v3.DetectIntentRequest.session]. This
    /// field can be used by the webhook to identify a session.
    /// Format:
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/sessions/<SessionID>`
    /// or
    /// `projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/environments/<EnvironmentID>/sessions/<SessionID>`
    /// if environment is specified.
    ///
    /// [google.cloud.dialogflow.cx.v3.DetectIntentRequest.session]: crate::model::DetectIntentRequest::session
    /// [google.cloud.dialogflow.cx.v3.WebhookRequest]: crate::model::WebhookRequest
    /// [google.cloud.dialogflow.cx.v3.WebhookResponse]: crate::model::WebhookResponse
    pub session: std::string::String,

    /// Optional for
    /// [WebhookRequest][google.cloud.dialogflow.cx.v3.WebhookRequest]. Optional
    /// for [WebhookResponse][google.cloud.dialogflow.cx.v3.WebhookResponse]. All
    /// parameters collected from forms and intents during the session. Parameters
    /// can be created, updated, or removed by the webhook. To remove a parameter
    /// from the session, the webhook should explicitly set the parameter value to
    /// null in [WebhookResponse][google.cloud.dialogflow.cx.v3.WebhookResponse].
    /// The map is keyed by parameters' display names.
    ///
    /// [google.cloud.dialogflow.cx.v3.WebhookRequest]: crate::model::WebhookRequest
    /// [google.cloud.dialogflow.cx.v3.WebhookResponse]: crate::model::WebhookResponse
    pub parameters: std::collections::HashMap<std::string::String, wkt::Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl SessionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session][crate::model::SessionInfo::session].
    pub fn set_session<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::SessionInfo::parameters].
    pub fn set_parameters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<wkt::Value>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl wkt::message::Message for SessionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.SessionInfo"
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SessionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session,
            __parameters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SessionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "session" => Ok(__FieldTag::__session),
                            "parameters" => Ok(__FieldTag::__parameters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SessionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SessionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session => {
                            if !fields.insert(__FieldTag::__session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session",
                                ));
                            }
                            result.session = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<std::string::String, wkt::Value>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for SessionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if !self.parameters.is_empty() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the language information of the request.
#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LanguageInfo {
    /// The language code specified in the original
    /// [request][google.cloud.dialogflow.cx.v3.QueryInput.language_code].
    ///
    /// [google.cloud.dialogflow.cx.v3.QueryInput.language_code]: crate::model::QueryInput::language_code
    pub input_language_code: std::string::String,

    /// The language code detected for this request based on the user
    /// conversation.
    pub resolved_language_code: std::string::String,

    /// The confidence score of the detected language between 0 and 1.
    pub confidence_score: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl LanguageInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input_language_code][crate::model::LanguageInfo::input_language_code].
    pub fn set_input_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.input_language_code = v.into();
        self
    }

    /// Sets the value of [resolved_language_code][crate::model::LanguageInfo::resolved_language_code].
    pub fn set_resolved_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resolved_language_code = v.into();
        self
    }

    /// Sets the value of [confidence_score][crate::model::LanguageInfo::confidence_score].
    pub fn set_confidence_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence_score = v.into();
        self
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
impl wkt::message::Message for LanguageInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.cx.v3.LanguageInfo"
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LanguageInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __input_language_code,
            __resolved_language_code,
            __confidence_score,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LanguageInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "inputLanguageCode" => Ok(__FieldTag::__input_language_code),
                            "input_language_code" => Ok(__FieldTag::__input_language_code),
                            "resolvedLanguageCode" => Ok(__FieldTag::__resolved_language_code),
                            "resolved_language_code" => Ok(__FieldTag::__resolved_language_code),
                            "confidenceScore" => Ok(__FieldTag::__confidence_score),
                            "confidence_score" => Ok(__FieldTag::__confidence_score),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LanguageInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LanguageInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__input_language_code => {
                            if !fields.insert(__FieldTag::__input_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_language_code",
                                ));
                            }
                            result.input_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resolved_language_code => {
                            if !fields.insert(__FieldTag::__resolved_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resolved_language_code",
                                ));
                            }
                            result.resolved_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidence_score => {
                            if !fields.insert(__FieldTag::__confidence_score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence_score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence_score =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(all(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
#[doc(hidden)]
impl serde::ser::Serialize for LanguageInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.input_language_code.is_empty() {
            state.serialize_entry("inputLanguageCode", &self.input_language_code)?;
        }
        if !self.resolved_language_code.is_empty() {
            state.serialize_entry("resolvedLanguageCode", &self.resolved_language_code)?;
        }
        if !wkt::internal::is_default(&self.confidence_score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidenceScore", &__With(&self.confidence_score))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Audio encoding of the audio content sent in the conversational query request.
/// Refer to the
/// [Cloud Speech API
/// documentation](https://cloud.google.com/speech-to-text/docs/basics) for more
/// details.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AudioEncoding {
    /// Not specified.
    Unspecified,
    /// Uncompressed 16-bit signed little-endian samples (Linear PCM).
    Linear16,
    /// [`FLAC`](https://xiph.org/flac/documentation.html) (Free Lossless Audio
    /// Codec) is the recommended encoding because it is lossless (therefore
    /// recognition is not compromised) and requires only about half the
    /// bandwidth of `LINEAR16`. `FLAC` stream encoding supports 16-bit and
    /// 24-bit samples, however, not all fields in `STREAMINFO` are supported.
    Flac,
    /// 8-bit samples that compand 14-bit audio samples using G.711 PCMU/mu-law.
    Mulaw,
    /// Adaptive Multi-Rate Narrowband codec. `sample_rate_hertz` must be 8000.
    Amr,
    /// Adaptive Multi-Rate Wideband codec. `sample_rate_hertz` must be 16000.
    AmrWb,
    /// Opus encoded audio frames in Ogg container
    /// ([OggOpus](https://wiki.xiph.org/OggOpus)).
    /// `sample_rate_hertz` must be 16000.
    OggOpus,
    /// Although the use of lossy encodings is not recommended, if a very low
    /// bitrate encoding is required, `OGG_OPUS` is highly preferred over
    /// Speex encoding. The [Speex](https://speex.org/) encoding supported by
    /// Dialogflow API has a header byte in each block, as in MIME type
    /// `audio/x-speex-with-header-byte`.
    /// It is a variant of the RTP Speex encoding defined in
    /// [RFC 5574](https://tools.ietf.org/html/rfc5574).
    /// The stream is a sequence of blocks, one block per RTP packet. Each block
    /// starts with a byte containing the length of the block, in bytes, followed
    /// by one or more frames of Speex data, padded to an integral number of
    /// bytes (octets) as specified in RFC 5574. In other words, each RTP header
    /// is replaced with a single byte containing the block length. Only Speex
    /// wideband is supported. `sample_rate_hertz` must be 16000.
    SpeexWithHeaderByte,
    /// 8-bit samples that compand 13-bit audio samples using G.711 PCMU/a-law.
    Alaw,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AudioEncoding::value] or
    /// [AudioEncoding::name].
    UnknownValue(audio_encoding::UnknownValue),
}

#[doc(hidden)]
#[cfg(any(feature = "sessions", feature = "test-cases",))]
pub mod audio_encoding {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl AudioEncoding {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Linear16 => std::option::Option::Some(1),
            Self::Flac => std::option::Option::Some(2),
            Self::Mulaw => std::option::Option::Some(3),
            Self::Amr => std::option::Option::Some(4),
            Self::AmrWb => std::option::Option::Some(5),
            Self::OggOpus => std::option::Option::Some(6),
            Self::SpeexWithHeaderByte => std::option::Option::Some(7),
            Self::Alaw => std::option::Option::Some(8),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("AUDIO_ENCODING_UNSPECIFIED"),
            Self::Linear16 => std::option::Option::Some("AUDIO_ENCODING_LINEAR_16"),
            Self::Flac => std::option::Option::Some("AUDIO_ENCODING_FLAC"),
            Self::Mulaw => std::option::Option::Some("AUDIO_ENCODING_MULAW"),
            Self::Amr => std::option::Option::Some("AUDIO_ENCODING_AMR"),
            Self::AmrWb => std::option::Option::Some("AUDIO_ENCODING_AMR_WB"),
            Self::OggOpus => std::option::Option::Some("AUDIO_ENCODING_OGG_OPUS"),
            Self::SpeexWithHeaderByte => {
                std::option::Option::Some("AUDIO_ENCODING_SPEEX_WITH_HEADER_BYTE")
            }
            Self::Alaw => std::option::Option::Some("AUDIO_ENCODING_ALAW"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl std::default::Default for AudioEncoding {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl std::fmt::Display for AudioEncoding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl std::convert::From<i32> for AudioEncoding {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Linear16,
            2 => Self::Flac,
            3 => Self::Mulaw,
            4 => Self::Amr,
            5 => Self::AmrWb,
            6 => Self::OggOpus,
            7 => Self::SpeexWithHeaderByte,
            8 => Self::Alaw,
            _ => Self::UnknownValue(audio_encoding::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl std::convert::From<&str> for AudioEncoding {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "AUDIO_ENCODING_UNSPECIFIED" => Self::Unspecified,
            "AUDIO_ENCODING_LINEAR_16" => Self::Linear16,
            "AUDIO_ENCODING_FLAC" => Self::Flac,
            "AUDIO_ENCODING_MULAW" => Self::Mulaw,
            "AUDIO_ENCODING_AMR" => Self::Amr,
            "AUDIO_ENCODING_AMR_WB" => Self::AmrWb,
            "AUDIO_ENCODING_OGG_OPUS" => Self::OggOpus,
            "AUDIO_ENCODING_SPEEX_WITH_HEADER_BYTE" => Self::SpeexWithHeaderByte,
            "AUDIO_ENCODING_ALAW" => Self::Alaw,
            _ => Self::UnknownValue(audio_encoding::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl serde::ser::Serialize for AudioEncoding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Linear16 => serializer.serialize_i32(1),
            Self::Flac => serializer.serialize_i32(2),
            Self::Mulaw => serializer.serialize_i32(3),
            Self::Amr => serializer.serialize_i32(4),
            Self::AmrWb => serializer.serialize_i32(5),
            Self::OggOpus => serializer.serialize_i32(6),
            Self::SpeexWithHeaderByte => serializer.serialize_i32(7),
            Self::Alaw => serializer.serialize_i32(8),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl<'de> serde::de::Deserialize<'de> for AudioEncoding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AudioEncoding>::new(
            ".google.cloud.dialogflow.cx.v3.AudioEncoding",
        ))
    }
}

/// Variant of the specified [Speech
/// model][google.cloud.dialogflow.cx.v3.InputAudioConfig.model] to use.
///
/// See the [Cloud Speech
/// documentation](https://cloud.google.com/speech-to-text/docs/enhanced-models)
/// for which models have different variants. For example, the "phone_call" model
/// has both a standard and an enhanced variant. When you use an enhanced model,
/// you will generally receive higher quality results than for a standard model.
///
/// [google.cloud.dialogflow.cx.v3.InputAudioConfig.model]: crate::model::InputAudioConfig::model
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(any(feature = "sessions", feature = "test-cases",))]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SpeechModelVariant {
    /// No model variant specified. In this case Dialogflow defaults to
    /// USE_BEST_AVAILABLE.
    Unspecified,
    /// Use the best available variant of the [Speech
    /// model][InputAudioConfig.model] that the caller is eligible for.
    ///
    /// [InputAudioConfig.model]: crate::model::InputAudioConfig::model
    UseBestAvailable,
    /// Use standard model variant even if an enhanced model is available.  See the
    /// [Cloud Speech
    /// documentation](https://cloud.google.com/speech-to-text/docs/enhanced-models)
    /// for details about enhanced models.
    UseStandard,
    /// Use an enhanced model variant:
    ///
    /// * If an enhanced variant does not exist for the given
    ///   [model][google.cloud.dialogflow.cx.v3.InputAudioConfig.model] and request
    ///   language, Dialogflow falls back to the standard variant.
    ///
    /// * The [Cloud Speech
    ///   documentation](https://cloud.google.com/speech-to-text/docs/enhanced-models)
    ///   describes which models have enhanced variants.
    ///
    ///
    /// [google.cloud.dialogflow.cx.v3.InputAudioConfig.model]: crate::model::InputAudioConfig::model
    UseEnhanced,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SpeechModelVariant::value] or
    /// [SpeechModelVariant::name].
    UnknownValue(speech_model_variant::UnknownValue),
}

#[doc(hidden)]
#[cfg(any(feature = "sessions", feature = "test-cases",))]
pub mod speech_model_variant {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl SpeechModelVariant {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::UseBestAvailable => std::option::Option::Some(1),
            Self::UseStandard => std::option::Option::Some(2),
            Self::UseEnhanced => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SPEECH_MODEL_VARIANT_UNSPECIFIED"),
            Self::UseBestAvailable => std::option::Option::Some("USE_BEST_AVAILABLE"),
            Self::UseStandard => std::option::Option::Some("USE_STANDARD"),
            Self::UseEnhanced => std::option::Option::Some("USE_ENHANCED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl std::default::Default for SpeechModelVariant {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl std::fmt::Display for SpeechModelVariant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl std::convert::From<i32> for SpeechModelVariant {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::UseBestAvailable,
            2 => Self::UseStandard,
            3 => Self::UseEnhanced,
            _ => Self::UnknownValue(speech_model_variant::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl std::convert::From<&str> for SpeechModelVariant {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SPEECH_MODEL_VARIANT_UNSPECIFIED" => Self::Unspecified,
            "USE_BEST_AVAILABLE" => Self::UseBestAvailable,
            "USE_STANDARD" => Self::UseStandard,
            "USE_ENHANCED" => Self::UseEnhanced,
            _ => Self::UnknownValue(speech_model_variant::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl serde::ser::Serialize for SpeechModelVariant {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::UseBestAvailable => serializer.serialize_i32(1),
            Self::UseStandard => serializer.serialize_i32(2),
            Self::UseEnhanced => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(any(feature = "sessions", feature = "test-cases",))]
impl<'de> serde::de::Deserialize<'de> for SpeechModelVariant {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SpeechModelVariant>::new(
            ".google.cloud.dialogflow.cx.v3.SpeechModelVariant",
        ))
    }
}

/// Gender of the voice as described in
/// [SSML voice element](https://www.w3.org/TR/speech-synthesis11/#edef_voice).
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(any(feature = "agents", feature = "sessions",))]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SsmlVoiceGender {
    /// An unspecified gender, which means that the client doesn't care which
    /// gender the selected voice will have.
    Unspecified,
    /// A male voice.
    Male,
    /// A female voice.
    Female,
    /// A gender-neutral voice.
    Neutral,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SsmlVoiceGender::value] or
    /// [SsmlVoiceGender::name].
    UnknownValue(ssml_voice_gender::UnknownValue),
}

#[doc(hidden)]
#[cfg(any(feature = "agents", feature = "sessions",))]
pub mod ssml_voice_gender {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(any(feature = "agents", feature = "sessions",))]
impl SsmlVoiceGender {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Male => std::option::Option::Some(1),
            Self::Female => std::option::Option::Some(2),
            Self::Neutral => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SSML_VOICE_GENDER_UNSPECIFIED"),
            Self::Male => std::option::Option::Some("SSML_VOICE_GENDER_MALE"),
            Self::Female => std::option::Option::Some("SSML_VOICE_GENDER_FEMALE"),
            Self::Neutral => std::option::Option::Some("SSML_VOICE_GENDER_NEUTRAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(any(feature = "agents", feature = "sessions",))]
impl std::default::Default for SsmlVoiceGender {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(any(feature = "agents", feature = "sessions",))]
impl std::fmt::Display for SsmlVoiceGender {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(any(feature = "agents", feature = "sessions",))]
impl std::convert::From<i32> for SsmlVoiceGender {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Male,
            2 => Self::Female,
            3 => Self::Neutral,
            _ => Self::UnknownValue(ssml_voice_gender::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(any(feature = "agents", feature = "sessions",))]
impl std::convert::From<&str> for SsmlVoiceGender {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SSML_VOICE_GENDER_UNSPECIFIED" => Self::Unspecified,
            "SSML_VOICE_GENDER_MALE" => Self::Male,
            "SSML_VOICE_GENDER_FEMALE" => Self::Female,
            "SSML_VOICE_GENDER_NEUTRAL" => Self::Neutral,
            _ => Self::UnknownValue(ssml_voice_gender::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(any(feature = "agents", feature = "sessions",))]
impl serde::ser::Serialize for SsmlVoiceGender {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Male => serializer.serialize_i32(1),
            Self::Female => serializer.serialize_i32(2),
            Self::Neutral => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(any(feature = "agents", feature = "sessions",))]
impl<'de> serde::de::Deserialize<'de> for SsmlVoiceGender {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SsmlVoiceGender>::new(
            ".google.cloud.dialogflow.cx.v3.SsmlVoiceGender",
        ))
    }
}

/// Audio encoding of the output audio format in Text-To-Speech.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum OutputAudioEncoding {
    /// Not specified.
    Unspecified,
    /// Uncompressed 16-bit signed little-endian samples (Linear PCM).
    /// Audio content returned as LINEAR16 also contains a WAV header.
    Linear16,
    /// MP3 audio at 32kbps.
    Mp3,
    /// MP3 audio at 64kbps.
    Mp364Kbps,
    /// Opus encoded audio wrapped in an ogg container. The result will be a
    /// file which can be played natively on Android, and in browsers (at least
    /// Chrome and Firefox). The quality of the encoding is considerably higher
    /// than MP3 while using approximately the same bitrate.
    OggOpus,
    /// 8-bit samples that compand 14-bit audio samples using G.711 PCMU/mu-law.
    Mulaw,
    /// 8-bit samples that compand 13-bit audio samples using G.711 PCMU/a-law.
    Alaw,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [OutputAudioEncoding::value] or
    /// [OutputAudioEncoding::name].
    UnknownValue(output_audio_encoding::UnknownValue),
}

#[doc(hidden)]
#[cfg(feature = "sessions")]
pub mod output_audio_encoding {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(feature = "sessions")]
impl OutputAudioEncoding {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Linear16 => std::option::Option::Some(1),
            Self::Mp3 => std::option::Option::Some(2),
            Self::Mp364Kbps => std::option::Option::Some(4),
            Self::OggOpus => std::option::Option::Some(3),
            Self::Mulaw => std::option::Option::Some(5),
            Self::Alaw => std::option::Option::Some(6),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("OUTPUT_AUDIO_ENCODING_UNSPECIFIED"),
            Self::Linear16 => std::option::Option::Some("OUTPUT_AUDIO_ENCODING_LINEAR_16"),
            Self::Mp3 => std::option::Option::Some("OUTPUT_AUDIO_ENCODING_MP3"),
            Self::Mp364Kbps => std::option::Option::Some("OUTPUT_AUDIO_ENCODING_MP3_64_KBPS"),
            Self::OggOpus => std::option::Option::Some("OUTPUT_AUDIO_ENCODING_OGG_OPUS"),
            Self::Mulaw => std::option::Option::Some("OUTPUT_AUDIO_ENCODING_MULAW"),
            Self::Alaw => std::option::Option::Some("OUTPUT_AUDIO_ENCODING_ALAW"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(feature = "sessions")]
impl std::default::Default for OutputAudioEncoding {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(feature = "sessions")]
impl std::fmt::Display for OutputAudioEncoding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(feature = "sessions")]
impl std::convert::From<i32> for OutputAudioEncoding {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Linear16,
            2 => Self::Mp3,
            3 => Self::OggOpus,
            4 => Self::Mp364Kbps,
            5 => Self::Mulaw,
            6 => Self::Alaw,
            _ => Self::UnknownValue(output_audio_encoding::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(feature = "sessions")]
impl std::convert::From<&str> for OutputAudioEncoding {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "OUTPUT_AUDIO_ENCODING_UNSPECIFIED" => Self::Unspecified,
            "OUTPUT_AUDIO_ENCODING_LINEAR_16" => Self::Linear16,
            "OUTPUT_AUDIO_ENCODING_MP3" => Self::Mp3,
            "OUTPUT_AUDIO_ENCODING_MP3_64_KBPS" => Self::Mp364Kbps,
            "OUTPUT_AUDIO_ENCODING_OGG_OPUS" => Self::OggOpus,
            "OUTPUT_AUDIO_ENCODING_MULAW" => Self::Mulaw,
            "OUTPUT_AUDIO_ENCODING_ALAW" => Self::Alaw,
            _ => Self::UnknownValue(output_audio_encoding::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(feature = "sessions")]
impl serde::ser::Serialize for OutputAudioEncoding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Linear16 => serializer.serialize_i32(1),
            Self::Mp3 => serializer.serialize_i32(2),
            Self::Mp364Kbps => serializer.serialize_i32(4),
            Self::OggOpus => serializer.serialize_i32(3),
            Self::Mulaw => serializer.serialize_i32(5),
            Self::Alaw => serializer.serialize_i32(6),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(feature = "sessions")]
impl<'de> serde::de::Deserialize<'de> for OutputAudioEncoding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<OutputAudioEncoding>::new(
            ".google.cloud.dialogflow.cx.v3.OutputAudioEncoding",
        ))
    }
}

/// Type of a data store.
/// Determines how search is performed in the data store.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DataStoreType {
    /// Not specified. This value indicates that the data store type is not
    /// specified, so it will not be used during search.
    Unspecified,
    /// A data store that contains public web content.
    PublicWeb,
    /// A data store that contains unstructured private data.
    Unstructured,
    /// A data store that contains structured data (for example FAQ).
    Structured,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DataStoreType::value] or
    /// [DataStoreType::name].
    UnknownValue(data_store_type::UnknownValue),
}

#[doc(hidden)]
#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
pub mod data_store_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl DataStoreType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::PublicWeb => std::option::Option::Some(1),
            Self::Unstructured => std::option::Option::Some(2),
            Self::Structured => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DATA_STORE_TYPE_UNSPECIFIED"),
            Self::PublicWeb => std::option::Option::Some("PUBLIC_WEB"),
            Self::Unstructured => std::option::Option::Some("UNSTRUCTURED"),
            Self::Structured => std::option::Option::Some("STRUCTURED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl std::default::Default for DataStoreType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl std::fmt::Display for DataStoreType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl std::convert::From<i32> for DataStoreType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::PublicWeb,
            2 => Self::Unstructured,
            3 => Self::Structured,
            _ => Self::UnknownValue(data_store_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl std::convert::From<&str> for DataStoreType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DATA_STORE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "PUBLIC_WEB" => Self::PublicWeb,
            "UNSTRUCTURED" => Self::Unstructured,
            "STRUCTURED" => Self::Structured,
            _ => Self::UnknownValue(data_store_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl serde::ser::Serialize for DataStoreType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::PublicWeb => serializer.serialize_i32(1),
            Self::Unstructured => serializer.serialize_i32(2),
            Self::Structured => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl<'de> serde::de::Deserialize<'de> for DataStoreType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DataStoreType>::new(
            ".google.cloud.dialogflow.cx.v3.DataStoreType",
        ))
    }
}

/// The document processing mode of the data store.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DocumentProcessingMode {
    /// Not specified. This should be set for STRUCTURED type data stores. Due to
    /// legacy reasons this is considered as DOCUMENTS for STRUCTURED and
    /// PUBLIC_WEB data stores.
    Unspecified,
    /// Documents are processed as documents.
    Documents,
    /// Documents are converted to chunks.
    Chunks,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DocumentProcessingMode::value] or
    /// [DocumentProcessingMode::name].
    UnknownValue(document_processing_mode::UnknownValue),
}

#[doc(hidden)]
#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
pub mod document_processing_mode {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl DocumentProcessingMode {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Documents => std::option::Option::Some(1),
            Self::Chunks => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DOCUMENT_PROCESSING_MODE_UNSPECIFIED"),
            Self::Documents => std::option::Option::Some("DOCUMENTS"),
            Self::Chunks => std::option::Option::Some("CHUNKS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl std::default::Default for DocumentProcessingMode {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl std::fmt::Display for DocumentProcessingMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl std::convert::From<i32> for DocumentProcessingMode {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Documents,
            2 => Self::Chunks,
            _ => Self::UnknownValue(document_processing_mode::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl std::convert::From<&str> for DocumentProcessingMode {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DOCUMENT_PROCESSING_MODE_UNSPECIFIED" => Self::Unspecified,
            "DOCUMENTS" => Self::Documents,
            "CHUNKS" => Self::Chunks,
            _ => Self::UnknownValue(document_processing_mode::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl serde::ser::Serialize for DocumentProcessingMode {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Documents => serializer.serialize_i32(1),
            Self::Chunks => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(any(
    feature = "flows",
    feature = "pages",
    feature = "sessions",
    feature = "test-cases",
))]
impl<'de> serde::de::Deserialize<'de> for DocumentProcessingMode {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DocumentProcessingMode>::new(
            ".google.cloud.dialogflow.cx.v3.DocumentProcessingMode",
        ))
    }
}

/// Import strategies for the conflict resolution of resources (i.e. intents,
/// entities, and webhooks) with identical display names during import
/// operations.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(feature = "flows")]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ImportStrategy {
    /// Unspecified. Treated as 'CREATE_NEW'.
    Unspecified,
    /// Create a new resource with a numeric suffix appended to the end of the
    /// existing display name.
    CreateNew,
    /// Replace existing resource with incoming resource in the content to be
    /// imported.
    Replace,
    /// Keep existing resource and discard incoming resource in the content to be
    /// imported.
    Keep,
    /// Combine existing and incoming resources when a conflict is encountered.
    Merge,
    /// Throw error if a conflict is encountered.
    ThrowError,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ImportStrategy::value] or
    /// [ImportStrategy::name].
    UnknownValue(import_strategy::UnknownValue),
}

#[doc(hidden)]
#[cfg(feature = "flows")]
pub mod import_strategy {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(feature = "flows")]
impl ImportStrategy {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::CreateNew => std::option::Option::Some(1),
            Self::Replace => std::option::Option::Some(2),
            Self::Keep => std::option::Option::Some(3),
            Self::Merge => std::option::Option::Some(4),
            Self::ThrowError => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("IMPORT_STRATEGY_UNSPECIFIED"),
            Self::CreateNew => std::option::Option::Some("IMPORT_STRATEGY_CREATE_NEW"),
            Self::Replace => std::option::Option::Some("IMPORT_STRATEGY_REPLACE"),
            Self::Keep => std::option::Option::Some("IMPORT_STRATEGY_KEEP"),
            Self::Merge => std::option::Option::Some("IMPORT_STRATEGY_MERGE"),
            Self::ThrowError => std::option::Option::Some("IMPORT_STRATEGY_THROW_ERROR"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(feature = "flows")]
impl std::default::Default for ImportStrategy {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(feature = "flows")]
impl std::fmt::Display for ImportStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(feature = "flows")]
impl std::convert::From<i32> for ImportStrategy {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::CreateNew,
            2 => Self::Replace,
            3 => Self::Keep,
            4 => Self::Merge,
            5 => Self::ThrowError,
            _ => Self::UnknownValue(import_strategy::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(feature = "flows")]
impl std::convert::From<&str> for ImportStrategy {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "IMPORT_STRATEGY_UNSPECIFIED" => Self::Unspecified,
            "IMPORT_STRATEGY_CREATE_NEW" => Self::CreateNew,
            "IMPORT_STRATEGY_REPLACE" => Self::Replace,
            "IMPORT_STRATEGY_KEEP" => Self::Keep,
            "IMPORT_STRATEGY_MERGE" => Self::Merge,
            "IMPORT_STRATEGY_THROW_ERROR" => Self::ThrowError,
            _ => Self::UnknownValue(import_strategy::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(feature = "flows")]
impl serde::ser::Serialize for ImportStrategy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::CreateNew => serializer.serialize_i32(1),
            Self::Replace => serializer.serialize_i32(2),
            Self::Keep => serializer.serialize_i32(3),
            Self::Merge => serializer.serialize_i32(4),
            Self::ThrowError => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(feature = "flows")]
impl<'de> serde::de::Deserialize<'de> for ImportStrategy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ImportStrategy>::new(
            ".google.cloud.dialogflow.cx.v3.ImportStrategy",
        ))
    }
}

/// Represents the options for views of an intent.
/// An intent can be a sizable object. Therefore, we provide a resource view that
/// does not return training phrases in the response.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(feature = "intents")]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum IntentView {
    /// Not specified. Treated as INTENT_VIEW_FULL.
    Unspecified,
    /// Training phrases field is not populated in the response.
    Partial,
    /// All fields are populated.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [IntentView::value] or
    /// [IntentView::name].
    UnknownValue(intent_view::UnknownValue),
}

#[doc(hidden)]
#[cfg(feature = "intents")]
pub mod intent_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(feature = "intents")]
impl IntentView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Partial => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("INTENT_VIEW_UNSPECIFIED"),
            Self::Partial => std::option::Option::Some("INTENT_VIEW_PARTIAL"),
            Self::Full => std::option::Option::Some("INTENT_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(feature = "intents")]
impl std::default::Default for IntentView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(feature = "intents")]
impl std::fmt::Display for IntentView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(feature = "intents")]
impl std::convert::From<i32> for IntentView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Partial,
            2 => Self::Full,
            _ => Self::UnknownValue(intent_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(feature = "intents")]
impl std::convert::From<&str> for IntentView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "INTENT_VIEW_UNSPECIFIED" => Self::Unspecified,
            "INTENT_VIEW_PARTIAL" => Self::Partial,
            "INTENT_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(intent_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(feature = "intents")]
impl serde::ser::Serialize for IntentView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Partial => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(feature = "intents")]
impl<'de> serde::de::Deserialize<'de> for IntentView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<IntentView>::new(
            ".google.cloud.dialogflow.cx.v3.IntentView",
        ))
    }
}

/// The test result for a test case and an agent environment.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TestResult {
    /// Not specified. Should never be used.
    Unspecified,
    /// The test passed.
    Passed,
    /// The test did not pass.
    Failed,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TestResult::value] or
    /// [TestResult::name].
    UnknownValue(test_result::UnknownValue),
}

#[doc(hidden)]
#[cfg(feature = "test-cases")]
pub mod test_result {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(feature = "test-cases")]
impl TestResult {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Passed => std::option::Option::Some(1),
            Self::Failed => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TEST_RESULT_UNSPECIFIED"),
            Self::Passed => std::option::Option::Some("PASSED"),
            Self::Failed => std::option::Option::Some("FAILED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(feature = "test-cases")]
impl std::default::Default for TestResult {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(feature = "test-cases")]
impl std::fmt::Display for TestResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(feature = "test-cases")]
impl std::convert::From<i32> for TestResult {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Passed,
            2 => Self::Failed,
            _ => Self::UnknownValue(test_result::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(feature = "test-cases")]
impl std::convert::From<&str> for TestResult {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TEST_RESULT_UNSPECIFIED" => Self::Unspecified,
            "PASSED" => Self::Passed,
            "FAILED" => Self::Failed,
            _ => Self::UnknownValue(test_result::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(feature = "test-cases")]
impl serde::ser::Serialize for TestResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Passed => serializer.serialize_i32(1),
            Self::Failed => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(feature = "test-cases")]
impl<'de> serde::de::Deserialize<'de> for TestResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TestResult>::new(
            ".google.cloud.dialogflow.cx.v3.TestResult",
        ))
    }
}
