// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#[cfg(any(
    feature = "agents",
    feature = "changelogs",
    feature = "deployments",
    feature = "entity-types",
    feature = "environments",
    feature = "experiments",
    feature = "flows",
    feature = "generators",
    feature = "intents",
    feature = "pages",
    feature = "security-settings-service",
    feature = "sessions",
    feature = "session-entity-types",
    feature = "test-cases",
    feature = "transition-route-groups",
    feature = "versions",
    feature = "webhooks",
))]
use crate::Result;

/// Implements a [Agents](super::stub::Agents) decorator for logging and tracing.
#[cfg(feature = "agents")]
#[derive(Clone, Debug)]
pub struct Agents<T>
where
    T: super::stub::Agents + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "agents")]
impl<T> Agents<T>
where
    T: super::stub::Agents + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "agents")]
impl<T> super::stub::Agents for Agents<T>
where
    T: super::stub::Agents + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_agents(
        &self,
        req: crate::model::ListAgentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAgentsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Agents",
            "::list_agents"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_agents",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_agents(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_agents(
        &self,
        req: crate::model::ListAgentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAgentsResponse>> {
        self.inner.list_agents(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_agent(
        &self,
        req: crate::model::GetAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Agent>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Agents",
            "::get_agent"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_agent",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_agent(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_agent(
        &self,
        req: crate::model::GetAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Agent>> {
        self.inner.get_agent(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_agent(
        &self,
        req: crate::model::CreateAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Agent>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Agents",
            "::create_agent"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_agent",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_agent(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_agent(
        &self,
        req: crate::model::CreateAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Agent>> {
        self.inner.create_agent(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_agent(
        &self,
        req: crate::model::UpdateAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Agent>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Agents",
            "::update_agent"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_agent",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_agent(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_agent(
        &self,
        req: crate::model::UpdateAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Agent>> {
        self.inner.update_agent(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_agent(
        &self,
        req: crate::model::DeleteAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Agents",
            "::delete_agent"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_agent",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_agent(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_agent(
        &self,
        req: crate::model::DeleteAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_agent(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn export_agent(
        &self,
        req: crate::model::ExportAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Agents",
            "::export_agent"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "export_agent",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .export_agent(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn export_agent(
        &self,
        req: crate::model::ExportAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.export_agent(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn restore_agent(
        &self,
        req: crate::model::RestoreAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Agents",
            "::restore_agent"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "restore_agent",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .restore_agent(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn restore_agent(
        &self,
        req: crate::model::RestoreAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.restore_agent(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn validate_agent(
        &self,
        req: crate::model::ValidateAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AgentValidationResult>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Agents",
            "::validate_agent"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "validate_agent",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .validate_agent(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn validate_agent(
        &self,
        req: crate::model::ValidateAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AgentValidationResult>> {
        self.inner.validate_agent(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_agent_validation_result(
        &self,
        req: crate::model::GetAgentValidationResultRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AgentValidationResult>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Agents",
            "::get_agent_validation_result"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_agent_validation_result",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_agent_validation_result(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_agent_validation_result(
        &self,
        req: crate::model::GetAgentValidationResultRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AgentValidationResult>> {
        self.inner.get_agent_validation_result(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_generative_settings(
        &self,
        req: crate::model::GetGenerativeSettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerativeSettings>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Agents",
            "::get_generative_settings"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_generative_settings",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_generative_settings(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_generative_settings(
        &self,
        req: crate::model::GetGenerativeSettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerativeSettings>> {
        self.inner.get_generative_settings(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_generative_settings(
        &self,
        req: crate::model::UpdateGenerativeSettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerativeSettings>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Agents",
            "::update_generative_settings"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_generative_settings",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_generative_settings(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_generative_settings(
        &self,
        req: crate::model::UpdateGenerativeSettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerativeSettings>> {
        self.inner.update_generative_settings(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Agents",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Agents",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Agents",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Agents",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Agents",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [Changelogs](super::stub::Changelogs) decorator for logging and tracing.
#[cfg(feature = "changelogs")]
#[derive(Clone, Debug)]
pub struct Changelogs<T>
where
    T: super::stub::Changelogs + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "changelogs")]
impl<T> Changelogs<T>
where
    T: super::stub::Changelogs + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "changelogs")]
impl<T> super::stub::Changelogs for Changelogs<T>
where
    T: super::stub::Changelogs + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_changelogs(
        &self,
        req: crate::model::ListChangelogsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListChangelogsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Changelogs",
            "::list_changelogs"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_changelogs",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_changelogs(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_changelogs(
        &self,
        req: crate::model::ListChangelogsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListChangelogsResponse>> {
        self.inner.list_changelogs(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_changelog(
        &self,
        req: crate::model::GetChangelogRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Changelog>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Changelogs",
            "::get_changelog"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_changelog",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_changelog(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_changelog(
        &self,
        req: crate::model::GetChangelogRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Changelog>> {
        self.inner.get_changelog(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Changelogs",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Changelogs",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Changelogs",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Changelogs",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Changelogs",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [Deployments](super::stub::Deployments) decorator for logging and tracing.
#[cfg(feature = "deployments")]
#[derive(Clone, Debug)]
pub struct Deployments<T>
where
    T: super::stub::Deployments + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "deployments")]
impl<T> Deployments<T>
where
    T: super::stub::Deployments + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "deployments")]
impl<T> super::stub::Deployments for Deployments<T>
where
    T: super::stub::Deployments + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_deployments(
        &self,
        req: crate::model::ListDeploymentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDeploymentsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Deployments",
            "::list_deployments"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_deployments",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_deployments(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_deployments(
        &self,
        req: crate::model::ListDeploymentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDeploymentsResponse>> {
        self.inner.list_deployments(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_deployment(
        &self,
        req: crate::model::GetDeploymentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Deployment>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Deployments",
            "::get_deployment"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_deployment",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_deployment(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_deployment(
        &self,
        req: crate::model::GetDeploymentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Deployment>> {
        self.inner.get_deployment(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Deployments",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Deployments",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Deployments",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Deployments",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Deployments",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [EntityTypes](super::stub::EntityTypes) decorator for logging and tracing.
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug)]
pub struct EntityTypes<T>
where
    T: super::stub::EntityTypes + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "entity-types")]
impl<T> EntityTypes<T>
where
    T: super::stub::EntityTypes + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "entity-types")]
impl<T> super::stub::EntityTypes for EntityTypes<T>
where
    T: super::stub::EntityTypes + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_entity_type(
        &self,
        req: crate::model::GetEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntityType>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EntityTypes",
            "::get_entity_type"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_entity_type",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_entity_type(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_entity_type(
        &self,
        req: crate::model::GetEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntityType>> {
        self.inner.get_entity_type(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_entity_type(
        &self,
        req: crate::model::CreateEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntityType>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EntityTypes",
            "::create_entity_type"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_entity_type",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_entity_type(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_entity_type(
        &self,
        req: crate::model::CreateEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntityType>> {
        self.inner.create_entity_type(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_entity_type(
        &self,
        req: crate::model::UpdateEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntityType>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EntityTypes",
            "::update_entity_type"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_entity_type",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_entity_type(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_entity_type(
        &self,
        req: crate::model::UpdateEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntityType>> {
        self.inner.update_entity_type(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_entity_type(
        &self,
        req: crate::model::DeleteEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EntityTypes",
            "::delete_entity_type"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_entity_type",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_entity_type(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_entity_type(
        &self,
        req: crate::model::DeleteEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_entity_type(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_entity_types(
        &self,
        req: crate::model::ListEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEntityTypesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EntityTypes",
            "::list_entity_types"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_entity_types",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_entity_types(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_entity_types(
        &self,
        req: crate::model::ListEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEntityTypesResponse>> {
        self.inner.list_entity_types(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn export_entity_types(
        &self,
        req: crate::model::ExportEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EntityTypes",
            "::export_entity_types"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "export_entity_types",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .export_entity_types(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn export_entity_types(
        &self,
        req: crate::model::ExportEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.export_entity_types(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn import_entity_types(
        &self,
        req: crate::model::ImportEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EntityTypes",
            "::import_entity_types"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "import_entity_types",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .import_entity_types(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn import_entity_types(
        &self,
        req: crate::model::ImportEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_entity_types(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EntityTypes",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EntityTypes",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EntityTypes",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EntityTypes",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "EntityTypes",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [Environments](super::stub::Environments) decorator for logging and tracing.
#[cfg(feature = "environments")]
#[derive(Clone, Debug)]
pub struct Environments<T>
where
    T: super::stub::Environments + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "environments")]
impl<T> Environments<T>
where
    T: super::stub::Environments + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "environments")]
impl<T> super::stub::Environments for Environments<T>
where
    T: super::stub::Environments + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_environments(
        &self,
        req: crate::model::ListEnvironmentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEnvironmentsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Environments",
            "::list_environments"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_environments",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_environments(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_environments(
        &self,
        req: crate::model::ListEnvironmentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEnvironmentsResponse>> {
        self.inner.list_environments(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_environment(
        &self,
        req: crate::model::GetEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Environment>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Environments",
            "::get_environment"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_environment",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_environment(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_environment(
        &self,
        req: crate::model::GetEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Environment>> {
        self.inner.get_environment(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_environment(
        &self,
        req: crate::model::CreateEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Environments",
            "::create_environment"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_environment",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_environment(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_environment(
        &self,
        req: crate::model::CreateEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_environment(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_environment(
        &self,
        req: crate::model::UpdateEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Environments",
            "::update_environment"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_environment",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_environment(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_environment(
        &self,
        req: crate::model::UpdateEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_environment(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_environment(
        &self,
        req: crate::model::DeleteEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Environments",
            "::delete_environment"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_environment",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_environment(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_environment(
        &self,
        req: crate::model::DeleteEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_environment(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn lookup_environment_history(
        &self,
        req: crate::model::LookupEnvironmentHistoryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LookupEnvironmentHistoryResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Environments",
            "::lookup_environment_history"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "lookup_environment_history",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .lookup_environment_history(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn lookup_environment_history(
        &self,
        req: crate::model::LookupEnvironmentHistoryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LookupEnvironmentHistoryResponse>> {
        self.inner.lookup_environment_history(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn run_continuous_test(
        &self,
        req: crate::model::RunContinuousTestRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Environments",
            "::run_continuous_test"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "run_continuous_test",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .run_continuous_test(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn run_continuous_test(
        &self,
        req: crate::model::RunContinuousTestRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.run_continuous_test(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_continuous_test_results(
        &self,
        req: crate::model::ListContinuousTestResultsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListContinuousTestResultsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Environments",
            "::list_continuous_test_results"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_continuous_test_results",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_continuous_test_results(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_continuous_test_results(
        &self,
        req: crate::model::ListContinuousTestResultsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListContinuousTestResultsResponse>> {
        self.inner.list_continuous_test_results(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn deploy_flow(
        &self,
        req: crate::model::DeployFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Environments",
            "::deploy_flow"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "deploy_flow",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .deploy_flow(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn deploy_flow(
        &self,
        req: crate::model::DeployFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.deploy_flow(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Environments",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Environments",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Environments",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Environments",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Environments",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [Experiments](super::stub::Experiments) decorator for logging and tracing.
#[cfg(feature = "experiments")]
#[derive(Clone, Debug)]
pub struct Experiments<T>
where
    T: super::stub::Experiments + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "experiments")]
impl<T> Experiments<T>
where
    T: super::stub::Experiments + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "experiments")]
impl<T> super::stub::Experiments for Experiments<T>
where
    T: super::stub::Experiments + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_experiments(
        &self,
        req: crate::model::ListExperimentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListExperimentsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Experiments",
            "::list_experiments"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_experiments",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_experiments(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_experiments(
        &self,
        req: crate::model::ListExperimentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListExperimentsResponse>> {
        self.inner.list_experiments(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_experiment(
        &self,
        req: crate::model::GetExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Experiment>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Experiments",
            "::get_experiment"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_experiment",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_experiment(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_experiment(
        &self,
        req: crate::model::GetExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Experiment>> {
        self.inner.get_experiment(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_experiment(
        &self,
        req: crate::model::CreateExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Experiment>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Experiments",
            "::create_experiment"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_experiment",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_experiment(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_experiment(
        &self,
        req: crate::model::CreateExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Experiment>> {
        self.inner.create_experiment(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_experiment(
        &self,
        req: crate::model::UpdateExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Experiment>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Experiments",
            "::update_experiment"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_experiment",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_experiment(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_experiment(
        &self,
        req: crate::model::UpdateExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Experiment>> {
        self.inner.update_experiment(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_experiment(
        &self,
        req: crate::model::DeleteExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Experiments",
            "::delete_experiment"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_experiment",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_experiment(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_experiment(
        &self,
        req: crate::model::DeleteExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_experiment(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn start_experiment(
        &self,
        req: crate::model::StartExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Experiment>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Experiments",
            "::start_experiment"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "start_experiment",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .start_experiment(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn start_experiment(
        &self,
        req: crate::model::StartExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Experiment>> {
        self.inner.start_experiment(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn stop_experiment(
        &self,
        req: crate::model::StopExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Experiment>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Experiments",
            "::stop_experiment"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "stop_experiment",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .stop_experiment(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn stop_experiment(
        &self,
        req: crate::model::StopExperimentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Experiment>> {
        self.inner.stop_experiment(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Experiments",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Experiments",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Experiments",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Experiments",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Experiments",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [Flows](super::stub::Flows) decorator for logging and tracing.
#[cfg(feature = "flows")]
#[derive(Clone, Debug)]
pub struct Flows<T>
where
    T: super::stub::Flows + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "flows")]
impl<T> Flows<T>
where
    T: super::stub::Flows + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "flows")]
impl<T> super::stub::Flows for Flows<T>
where
    T: super::stub::Flows + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_flow(
        &self,
        req: crate::model::CreateFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Flow>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Flows",
            "::create_flow"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_flow",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_flow(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_flow(
        &self,
        req: crate::model::CreateFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Flow>> {
        self.inner.create_flow(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_flow(
        &self,
        req: crate::model::DeleteFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Flows",
            "::delete_flow"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_flow",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_flow(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_flow(
        &self,
        req: crate::model::DeleteFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_flow(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_flows(
        &self,
        req: crate::model::ListFlowsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFlowsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Flows",
            "::list_flows"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_flows",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_flows(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_flows(
        &self,
        req: crate::model::ListFlowsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListFlowsResponse>> {
        self.inner.list_flows(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_flow(
        &self,
        req: crate::model::GetFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Flow>> {
        use tracing::Instrument;
        let span_name = concat!(env!("CARGO_PKG_NAME"), "::client::", "Flows", "::get_flow");
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_flow",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_flow(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_flow(
        &self,
        req: crate::model::GetFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Flow>> {
        self.inner.get_flow(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_flow(
        &self,
        req: crate::model::UpdateFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Flow>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Flows",
            "::update_flow"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_flow",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_flow(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_flow(
        &self,
        req: crate::model::UpdateFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Flow>> {
        self.inner.update_flow(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn train_flow(
        &self,
        req: crate::model::TrainFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Flows",
            "::train_flow"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "train_flow",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .train_flow(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn train_flow(
        &self,
        req: crate::model::TrainFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.train_flow(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn validate_flow(
        &self,
        req: crate::model::ValidateFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FlowValidationResult>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Flows",
            "::validate_flow"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "validate_flow",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .validate_flow(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn validate_flow(
        &self,
        req: crate::model::ValidateFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FlowValidationResult>> {
        self.inner.validate_flow(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_flow_validation_result(
        &self,
        req: crate::model::GetFlowValidationResultRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FlowValidationResult>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Flows",
            "::get_flow_validation_result"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_flow_validation_result",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_flow_validation_result(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_flow_validation_result(
        &self,
        req: crate::model::GetFlowValidationResultRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FlowValidationResult>> {
        self.inner.get_flow_validation_result(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn import_flow(
        &self,
        req: crate::model::ImportFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Flows",
            "::import_flow"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "import_flow",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .import_flow(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn import_flow(
        &self,
        req: crate::model::ImportFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_flow(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn export_flow(
        &self,
        req: crate::model::ExportFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Flows",
            "::export_flow"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "export_flow",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .export_flow(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn export_flow(
        &self,
        req: crate::model::ExportFlowRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.export_flow(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Flows",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Flows",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Flows",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Flows",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Flows",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [Generators](super::stub::Generators) decorator for logging and tracing.
#[cfg(feature = "generators")]
#[derive(Clone, Debug)]
pub struct Generators<T>
where
    T: super::stub::Generators + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "generators")]
impl<T> Generators<T>
where
    T: super::stub::Generators + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "generators")]
impl<T> super::stub::Generators for Generators<T>
where
    T: super::stub::Generators + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_generators(
        &self,
        req: crate::model::ListGeneratorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListGeneratorsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Generators",
            "::list_generators"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_generators",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_generators(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_generators(
        &self,
        req: crate::model::ListGeneratorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListGeneratorsResponse>> {
        self.inner.list_generators(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_generator(
        &self,
        req: crate::model::GetGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Generator>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Generators",
            "::get_generator"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_generator",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_generator(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_generator(
        &self,
        req: crate::model::GetGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Generator>> {
        self.inner.get_generator(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_generator(
        &self,
        req: crate::model::CreateGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Generator>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Generators",
            "::create_generator"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_generator",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_generator(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_generator(
        &self,
        req: crate::model::CreateGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Generator>> {
        self.inner.create_generator(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_generator(
        &self,
        req: crate::model::UpdateGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Generator>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Generators",
            "::update_generator"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_generator",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_generator(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_generator(
        &self,
        req: crate::model::UpdateGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Generator>> {
        self.inner.update_generator(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_generator(
        &self,
        req: crate::model::DeleteGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Generators",
            "::delete_generator"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_generator",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_generator(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_generator(
        &self,
        req: crate::model::DeleteGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_generator(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Generators",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Generators",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Generators",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Generators",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Generators",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [Intents](super::stub::Intents) decorator for logging and tracing.
#[cfg(feature = "intents")]
#[derive(Clone, Debug)]
pub struct Intents<T>
where
    T: super::stub::Intents + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "intents")]
impl<T> Intents<T>
where
    T: super::stub::Intents + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "intents")]
impl<T> super::stub::Intents for Intents<T>
where
    T: super::stub::Intents + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_intents(
        &self,
        req: crate::model::ListIntentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListIntentsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Intents",
            "::list_intents"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_intents",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_intents(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_intents(
        &self,
        req: crate::model::ListIntentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListIntentsResponse>> {
        self.inner.list_intents(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_intent(
        &self,
        req: crate::model::GetIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Intent>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Intents",
            "::get_intent"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_intent",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_intent(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_intent(
        &self,
        req: crate::model::GetIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Intent>> {
        self.inner.get_intent(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_intent(
        &self,
        req: crate::model::CreateIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Intent>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Intents",
            "::create_intent"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_intent",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_intent(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_intent(
        &self,
        req: crate::model::CreateIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Intent>> {
        self.inner.create_intent(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_intent(
        &self,
        req: crate::model::UpdateIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Intent>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Intents",
            "::update_intent"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_intent",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_intent(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_intent(
        &self,
        req: crate::model::UpdateIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Intent>> {
        self.inner.update_intent(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_intent(
        &self,
        req: crate::model::DeleteIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Intents",
            "::delete_intent"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_intent",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_intent(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_intent(
        &self,
        req: crate::model::DeleteIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_intent(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn import_intents(
        &self,
        req: crate::model::ImportIntentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Intents",
            "::import_intents"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "import_intents",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .import_intents(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn import_intents(
        &self,
        req: crate::model::ImportIntentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_intents(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn export_intents(
        &self,
        req: crate::model::ExportIntentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Intents",
            "::export_intents"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "export_intents",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .export_intents(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn export_intents(
        &self,
        req: crate::model::ExportIntentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.export_intents(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Intents",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Intents",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Intents",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Intents",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Intents",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [Pages](super::stub::Pages) decorator for logging and tracing.
#[cfg(feature = "pages")]
#[derive(Clone, Debug)]
pub struct Pages<T>
where
    T: super::stub::Pages + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "pages")]
impl<T> Pages<T>
where
    T: super::stub::Pages + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "pages")]
impl<T> super::stub::Pages for Pages<T>
where
    T: super::stub::Pages + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_pages(
        &self,
        req: crate::model::ListPagesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListPagesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Pages",
            "::list_pages"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_pages",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_pages(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_pages(
        &self,
        req: crate::model::ListPagesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListPagesResponse>> {
        self.inner.list_pages(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_page(
        &self,
        req: crate::model::GetPageRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Page>> {
        use tracing::Instrument;
        let span_name = concat!(env!("CARGO_PKG_NAME"), "::client::", "Pages", "::get_page");
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_page",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_page(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_page(
        &self,
        req: crate::model::GetPageRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Page>> {
        self.inner.get_page(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_page(
        &self,
        req: crate::model::CreatePageRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Page>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Pages",
            "::create_page"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_page",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_page(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_page(
        &self,
        req: crate::model::CreatePageRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Page>> {
        self.inner.create_page(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_page(
        &self,
        req: crate::model::UpdatePageRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Page>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Pages",
            "::update_page"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_page",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_page(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_page(
        &self,
        req: crate::model::UpdatePageRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Page>> {
        self.inner.update_page(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_page(
        &self,
        req: crate::model::DeletePageRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Pages",
            "::delete_page"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_page",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_page(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_page(
        &self,
        req: crate::model::DeletePageRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_page(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Pages",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Pages",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Pages",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Pages",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Pages",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [SecuritySettingsService](super::stub::SecuritySettingsService) decorator for logging and tracing.
#[cfg(feature = "security-settings-service")]
#[derive(Clone, Debug)]
pub struct SecuritySettingsService<T>
where
    T: super::stub::SecuritySettingsService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "security-settings-service")]
impl<T> SecuritySettingsService<T>
where
    T: super::stub::SecuritySettingsService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "security-settings-service")]
impl<T> super::stub::SecuritySettingsService for SecuritySettingsService<T>
where
    T: super::stub::SecuritySettingsService + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_security_settings(
        &self,
        req: crate::model::CreateSecuritySettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecuritySettings>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SecuritySettingsService",
            "::create_security_settings"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_security_settings",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_security_settings(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_security_settings(
        &self,
        req: crate::model::CreateSecuritySettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecuritySettings>> {
        self.inner.create_security_settings(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_security_settings(
        &self,
        req: crate::model::GetSecuritySettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecuritySettings>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SecuritySettingsService",
            "::get_security_settings"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_security_settings",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_security_settings(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_security_settings(
        &self,
        req: crate::model::GetSecuritySettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecuritySettings>> {
        self.inner.get_security_settings(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_security_settings(
        &self,
        req: crate::model::UpdateSecuritySettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecuritySettings>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SecuritySettingsService",
            "::update_security_settings"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_security_settings",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_security_settings(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_security_settings(
        &self,
        req: crate::model::UpdateSecuritySettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecuritySettings>> {
        self.inner.update_security_settings(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_security_settings(
        &self,
        req: crate::model::ListSecuritySettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSecuritySettingsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SecuritySettingsService",
            "::list_security_settings"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_security_settings",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_security_settings(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_security_settings(
        &self,
        req: crate::model::ListSecuritySettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSecuritySettingsResponse>> {
        self.inner.list_security_settings(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_security_settings(
        &self,
        req: crate::model::DeleteSecuritySettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SecuritySettingsService",
            "::delete_security_settings"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_security_settings",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_security_settings(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_security_settings(
        &self,
        req: crate::model::DeleteSecuritySettingsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_security_settings(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SecuritySettingsService",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SecuritySettingsService",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SecuritySettingsService",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SecuritySettingsService",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SecuritySettingsService",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [Sessions](super::stub::Sessions) decorator for logging and tracing.
#[cfg(feature = "sessions")]
#[derive(Clone, Debug)]
pub struct Sessions<T>
where
    T: super::stub::Sessions + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "sessions")]
impl<T> Sessions<T>
where
    T: super::stub::Sessions + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "sessions")]
impl<T> super::stub::Sessions for Sessions<T>
where
    T: super::stub::Sessions + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn detect_intent(
        &self,
        req: crate::model::DetectIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DetectIntentResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Sessions",
            "::detect_intent"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "detect_intent",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .detect_intent(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn detect_intent(
        &self,
        req: crate::model::DetectIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DetectIntentResponse>> {
        self.inner.detect_intent(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn match_intent(
        &self,
        req: crate::model::MatchIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MatchIntentResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Sessions",
            "::match_intent"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "match_intent",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .match_intent(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn match_intent(
        &self,
        req: crate::model::MatchIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MatchIntentResponse>> {
        self.inner.match_intent(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn fulfill_intent(
        &self,
        req: crate::model::FulfillIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FulfillIntentResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Sessions",
            "::fulfill_intent"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "fulfill_intent",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .fulfill_intent(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn fulfill_intent(
        &self,
        req: crate::model::FulfillIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FulfillIntentResponse>> {
        self.inner.fulfill_intent(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn submit_answer_feedback(
        &self,
        req: crate::model::SubmitAnswerFeedbackRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AnswerFeedback>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Sessions",
            "::submit_answer_feedback"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "submit_answer_feedback",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .submit_answer_feedback(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn submit_answer_feedback(
        &self,
        req: crate::model::SubmitAnswerFeedbackRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AnswerFeedback>> {
        self.inner.submit_answer_feedback(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Sessions",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Sessions",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Sessions",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Sessions",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Sessions",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [SessionEntityTypes](super::stub::SessionEntityTypes) decorator for logging and tracing.
#[cfg(feature = "session-entity-types")]
#[derive(Clone, Debug)]
pub struct SessionEntityTypes<T>
where
    T: super::stub::SessionEntityTypes + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "session-entity-types")]
impl<T> SessionEntityTypes<T>
where
    T: super::stub::SessionEntityTypes + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "session-entity-types")]
impl<T> super::stub::SessionEntityTypes for SessionEntityTypes<T>
where
    T: super::stub::SessionEntityTypes + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_session_entity_types(
        &self,
        req: crate::model::ListSessionEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSessionEntityTypesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionEntityTypes",
            "::list_session_entity_types"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_session_entity_types",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_session_entity_types(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_session_entity_types(
        &self,
        req: crate::model::ListSessionEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSessionEntityTypesResponse>> {
        self.inner.list_session_entity_types(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_session_entity_type(
        &self,
        req: crate::model::GetSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SessionEntityType>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionEntityTypes",
            "::get_session_entity_type"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_session_entity_type",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_session_entity_type(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_session_entity_type(
        &self,
        req: crate::model::GetSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SessionEntityType>> {
        self.inner.get_session_entity_type(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_session_entity_type(
        &self,
        req: crate::model::CreateSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SessionEntityType>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionEntityTypes",
            "::create_session_entity_type"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_session_entity_type",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_session_entity_type(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_session_entity_type(
        &self,
        req: crate::model::CreateSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SessionEntityType>> {
        self.inner.create_session_entity_type(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_session_entity_type(
        &self,
        req: crate::model::UpdateSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SessionEntityType>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionEntityTypes",
            "::update_session_entity_type"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_session_entity_type",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_session_entity_type(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_session_entity_type(
        &self,
        req: crate::model::UpdateSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SessionEntityType>> {
        self.inner.update_session_entity_type(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_session_entity_type(
        &self,
        req: crate::model::DeleteSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionEntityTypes",
            "::delete_session_entity_type"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_session_entity_type",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_session_entity_type(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_session_entity_type(
        &self,
        req: crate::model::DeleteSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_session_entity_type(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionEntityTypes",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionEntityTypes",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionEntityTypes",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionEntityTypes",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "SessionEntityTypes",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [TestCases](super::stub::TestCases) decorator for logging and tracing.
#[cfg(feature = "test-cases")]
#[derive(Clone, Debug)]
pub struct TestCases<T>
where
    T: super::stub::TestCases + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "test-cases")]
impl<T> TestCases<T>
where
    T: super::stub::TestCases + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "test-cases")]
impl<T> super::stub::TestCases for TestCases<T>
where
    T: super::stub::TestCases + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_test_cases(
        &self,
        req: crate::model::ListTestCasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTestCasesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TestCases",
            "::list_test_cases"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_test_cases",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_test_cases(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_test_cases(
        &self,
        req: crate::model::ListTestCasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTestCasesResponse>> {
        self.inner.list_test_cases(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn batch_delete_test_cases(
        &self,
        req: crate::model::BatchDeleteTestCasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TestCases",
            "::batch_delete_test_cases"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "batch_delete_test_cases",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .batch_delete_test_cases(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn batch_delete_test_cases(
        &self,
        req: crate::model::BatchDeleteTestCasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.batch_delete_test_cases(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_test_case(
        &self,
        req: crate::model::GetTestCaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestCase>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TestCases",
            "::get_test_case"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_test_case",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_test_case(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_test_case(
        &self,
        req: crate::model::GetTestCaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestCase>> {
        self.inner.get_test_case(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_test_case(
        &self,
        req: crate::model::CreateTestCaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestCase>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TestCases",
            "::create_test_case"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_test_case",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_test_case(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_test_case(
        &self,
        req: crate::model::CreateTestCaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestCase>> {
        self.inner.create_test_case(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_test_case(
        &self,
        req: crate::model::UpdateTestCaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestCase>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TestCases",
            "::update_test_case"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_test_case",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_test_case(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_test_case(
        &self,
        req: crate::model::UpdateTestCaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestCase>> {
        self.inner.update_test_case(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn run_test_case(
        &self,
        req: crate::model::RunTestCaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TestCases",
            "::run_test_case"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "run_test_case",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .run_test_case(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn run_test_case(
        &self,
        req: crate::model::RunTestCaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.run_test_case(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn batch_run_test_cases(
        &self,
        req: crate::model::BatchRunTestCasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TestCases",
            "::batch_run_test_cases"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "batch_run_test_cases",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .batch_run_test_cases(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn batch_run_test_cases(
        &self,
        req: crate::model::BatchRunTestCasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_run_test_cases(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn calculate_coverage(
        &self,
        req: crate::model::CalculateCoverageRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CalculateCoverageResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TestCases",
            "::calculate_coverage"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "calculate_coverage",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .calculate_coverage(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn calculate_coverage(
        &self,
        req: crate::model::CalculateCoverageRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CalculateCoverageResponse>> {
        self.inner.calculate_coverage(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn import_test_cases(
        &self,
        req: crate::model::ImportTestCasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TestCases",
            "::import_test_cases"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "import_test_cases",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .import_test_cases(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn import_test_cases(
        &self,
        req: crate::model::ImportTestCasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_test_cases(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn export_test_cases(
        &self,
        req: crate::model::ExportTestCasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TestCases",
            "::export_test_cases"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "export_test_cases",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .export_test_cases(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn export_test_cases(
        &self,
        req: crate::model::ExportTestCasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.export_test_cases(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_test_case_results(
        &self,
        req: crate::model::ListTestCaseResultsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTestCaseResultsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TestCases",
            "::list_test_case_results"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_test_case_results",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_test_case_results(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_test_case_results(
        &self,
        req: crate::model::ListTestCaseResultsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTestCaseResultsResponse>> {
        self.inner.list_test_case_results(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_test_case_result(
        &self,
        req: crate::model::GetTestCaseResultRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestCaseResult>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TestCases",
            "::get_test_case_result"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_test_case_result",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_test_case_result(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_test_case_result(
        &self,
        req: crate::model::GetTestCaseResultRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestCaseResult>> {
        self.inner.get_test_case_result(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TestCases",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TestCases",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TestCases",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TestCases",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TestCases",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [TransitionRouteGroups](super::stub::TransitionRouteGroups) decorator for logging and tracing.
#[cfg(feature = "transition-route-groups")]
#[derive(Clone, Debug)]
pub struct TransitionRouteGroups<T>
where
    T: super::stub::TransitionRouteGroups + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "transition-route-groups")]
impl<T> TransitionRouteGroups<T>
where
    T: super::stub::TransitionRouteGroups + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "transition-route-groups")]
impl<T> super::stub::TransitionRouteGroups for TransitionRouteGroups<T>
where
    T: super::stub::TransitionRouteGroups + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_transition_route_groups(
        &self,
        req: crate::model::ListTransitionRouteGroupsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTransitionRouteGroupsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TransitionRouteGroups",
            "::list_transition_route_groups"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_transition_route_groups",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_transition_route_groups(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_transition_route_groups(
        &self,
        req: crate::model::ListTransitionRouteGroupsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTransitionRouteGroupsResponse>> {
        self.inner.list_transition_route_groups(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_transition_route_group(
        &self,
        req: crate::model::GetTransitionRouteGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TransitionRouteGroup>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TransitionRouteGroups",
            "::get_transition_route_group"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_transition_route_group",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_transition_route_group(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_transition_route_group(
        &self,
        req: crate::model::GetTransitionRouteGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TransitionRouteGroup>> {
        self.inner.get_transition_route_group(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_transition_route_group(
        &self,
        req: crate::model::CreateTransitionRouteGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TransitionRouteGroup>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TransitionRouteGroups",
            "::create_transition_route_group"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_transition_route_group",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_transition_route_group(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_transition_route_group(
        &self,
        req: crate::model::CreateTransitionRouteGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TransitionRouteGroup>> {
        self.inner.create_transition_route_group(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_transition_route_group(
        &self,
        req: crate::model::UpdateTransitionRouteGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TransitionRouteGroup>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TransitionRouteGroups",
            "::update_transition_route_group"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_transition_route_group",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_transition_route_group(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_transition_route_group(
        &self,
        req: crate::model::UpdateTransitionRouteGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TransitionRouteGroup>> {
        self.inner.update_transition_route_group(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_transition_route_group(
        &self,
        req: crate::model::DeleteTransitionRouteGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TransitionRouteGroups",
            "::delete_transition_route_group"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_transition_route_group",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_transition_route_group(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_transition_route_group(
        &self,
        req: crate::model::DeleteTransitionRouteGroupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_transition_route_group(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TransitionRouteGroups",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TransitionRouteGroups",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TransitionRouteGroups",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TransitionRouteGroups",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "TransitionRouteGroups",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [Versions](super::stub::Versions) decorator for logging and tracing.
#[cfg(feature = "versions")]
#[derive(Clone, Debug)]
pub struct Versions<T>
where
    T: super::stub::Versions + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "versions")]
impl<T> Versions<T>
where
    T: super::stub::Versions + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "versions")]
impl<T> super::stub::Versions for Versions<T>
where
    T: super::stub::Versions + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_versions(
        &self,
        req: crate::model::ListVersionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListVersionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Versions",
            "::list_versions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_versions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_versions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_versions(
        &self,
        req: crate::model::ListVersionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListVersionsResponse>> {
        self.inner.list_versions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_version(
        &self,
        req: crate::model::GetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Version>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Versions",
            "::get_version"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_version",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_version(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_version(
        &self,
        req: crate::model::GetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Version>> {
        self.inner.get_version(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_version(
        &self,
        req: crate::model::CreateVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Versions",
            "::create_version"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_version",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_version(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_version(
        &self,
        req: crate::model::CreateVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_version(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_version(
        &self,
        req: crate::model::UpdateVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Version>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Versions",
            "::update_version"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_version",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_version(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_version(
        &self,
        req: crate::model::UpdateVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Version>> {
        self.inner.update_version(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_version(
        &self,
        req: crate::model::DeleteVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Versions",
            "::delete_version"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_version",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_version(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_version(
        &self,
        req: crate::model::DeleteVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_version(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn load_version(
        &self,
        req: crate::model::LoadVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Versions",
            "::load_version"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "load_version",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .load_version(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn load_version(
        &self,
        req: crate::model::LoadVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.load_version(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn compare_versions(
        &self,
        req: crate::model::CompareVersionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CompareVersionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Versions",
            "::compare_versions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "compare_versions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .compare_versions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn compare_versions(
        &self,
        req: crate::model::CompareVersionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CompareVersionsResponse>> {
        self.inner.compare_versions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Versions",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Versions",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Versions",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Versions",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Versions",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [Webhooks](super::stub::Webhooks) decorator for logging and tracing.
#[cfg(feature = "webhooks")]
#[derive(Clone, Debug)]
pub struct Webhooks<T>
where
    T: super::stub::Webhooks + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

#[cfg(feature = "webhooks")]
impl<T> Webhooks<T>
where
    T: super::stub::Webhooks + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "webhooks")]
impl<T> super::stub::Webhooks for Webhooks<T>
where
    T: super::stub::Webhooks + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_webhooks(
        &self,
        req: crate::model::ListWebhooksRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListWebhooksResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Webhooks",
            "::list_webhooks"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_webhooks",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_webhooks(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_webhooks(
        &self,
        req: crate::model::ListWebhooksRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListWebhooksResponse>> {
        self.inner.list_webhooks(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_webhook(
        &self,
        req: crate::model::GetWebhookRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Webhook>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Webhooks",
            "::get_webhook"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_webhook",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_webhook(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_webhook(
        &self,
        req: crate::model::GetWebhookRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Webhook>> {
        self.inner.get_webhook(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_webhook(
        &self,
        req: crate::model::CreateWebhookRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Webhook>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Webhooks",
            "::create_webhook"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_webhook",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_webhook(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_webhook(
        &self,
        req: crate::model::CreateWebhookRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Webhook>> {
        self.inner.create_webhook(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_webhook(
        &self,
        req: crate::model::UpdateWebhookRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Webhook>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Webhooks",
            "::update_webhook"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_webhook",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_webhook(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_webhook(
        &self,
        req: crate::model::UpdateWebhookRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Webhook>> {
        self.inner.update_webhook(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_webhook(
        &self,
        req: crate::model::DeleteWebhookRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Webhooks",
            "::delete_webhook"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_webhook",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_webhook(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_webhook(
        &self,
        req: crate::model::DeleteWebhookRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_webhook(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Webhooks",
            "::list_locations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_locations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_locations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Webhooks",
            "::get_location"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_location",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_location(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Webhooks",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Webhooks",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "Webhooks",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }
}
