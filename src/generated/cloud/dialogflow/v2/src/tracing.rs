// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#[cfg(any(feature = "agents",feature = "answer-records",feature = "contexts",feature = "conversations",feature = "conversation-datasets",feature = "conversation-models",feature = "conversation-profiles",feature = "documents",feature = "encryption-spec-service",feature = "entity-types",feature = "environments",feature = "fulfillments",feature = "generators",feature = "intents",feature = "knowledge-bases",feature = "participants",feature = "sessions",feature = "session-entity-types",feature = "versions",))]
use crate::Result;

/// Implements a [Agents](super::stub::Agents) decorator for logging and tracing.
#[cfg(feature = "agents")]
#[derive(Clone, Debug)]
pub struct Agents<T>
where T: super::stub::Agents + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "agents")]
impl<T> Agents<T>
where T: super::stub::Agents + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "agents")]
impl<T> super::stub::Agents for Agents<T>
where T: super::stub::Agents + std::fmt::Debug + Send + Sync {
    #[tracing::instrument(ret)]
    async fn get_agent(
        &self,
        req: crate::model::GetAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Agent>> {
        self.inner.get_agent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_agent(
        &self,
        req: crate::model::SetAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Agent>> {
        self.inner.set_agent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_agent(
        &self,
        req: crate::model::DeleteAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_agent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn search_agents(
        &self,
        req: crate::model::SearchAgentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchAgentsResponse>> {
        self.inner.search_agents(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn train_agent(
        &self,
        req: crate::model::TrainAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.train_agent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn export_agent(
        &self,
        req: crate::model::ExportAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.export_agent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn import_agent(
        &self,
        req: crate::model::ImportAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_agent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn restore_agent(
        &self,
        req: crate::model::RestoreAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.restore_agent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_validation_result(
        &self,
        req: crate::model::GetValidationResultRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ValidationResult>> {
        self.inner.get_validation_result(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }


    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [AnswerRecords](super::stub::AnswerRecords) decorator for logging and tracing.
#[cfg(feature = "answer-records")]
#[derive(Clone, Debug)]
pub struct AnswerRecords<T>
where T: super::stub::AnswerRecords + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "answer-records")]
impl<T> AnswerRecords<T>
where T: super::stub::AnswerRecords + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "answer-records")]
impl<T> super::stub::AnswerRecords for AnswerRecords<T>
where T: super::stub::AnswerRecords + std::fmt::Debug + Send + Sync {
    #[tracing::instrument(ret)]
    async fn list_answer_records(
        &self,
        req: crate::model::ListAnswerRecordsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAnswerRecordsResponse>> {
        self.inner.list_answer_records(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_answer_record(
        &self,
        req: crate::model::UpdateAnswerRecordRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AnswerRecord>> {
        self.inner.update_answer_record(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

}

/// Implements a [Contexts](super::stub::Contexts) decorator for logging and tracing.
#[cfg(feature = "contexts")]
#[derive(Clone, Debug)]
pub struct Contexts<T>
where T: super::stub::Contexts + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "contexts")]
impl<T> Contexts<T>
where T: super::stub::Contexts + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "contexts")]
impl<T> super::stub::Contexts for Contexts<T>
where T: super::stub::Contexts + std::fmt::Debug + Send + Sync {
    #[tracing::instrument(ret)]
    async fn list_contexts(
        &self,
        req: crate::model::ListContextsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListContextsResponse>> {
        self.inner.list_contexts(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_context(
        &self,
        req: crate::model::GetContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Context>> {
        self.inner.get_context(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_context(
        &self,
        req: crate::model::CreateContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Context>> {
        self.inner.create_context(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_context(
        &self,
        req: crate::model::UpdateContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Context>> {
        self.inner.update_context(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_context(
        &self,
        req: crate::model::DeleteContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_context(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_all_contexts(
        &self,
        req: crate::model::DeleteAllContextsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_all_contexts(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

}

/// Implements a [Conversations](super::stub::Conversations) decorator for logging and tracing.
#[cfg(feature = "conversations")]
#[derive(Clone, Debug)]
pub struct Conversations<T>
where T: super::stub::Conversations + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "conversations")]
impl<T> Conversations<T>
where T: super::stub::Conversations + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "conversations")]
impl<T> super::stub::Conversations for Conversations<T>
where T: super::stub::Conversations + std::fmt::Debug + Send + Sync {
    #[tracing::instrument(ret)]
    async fn create_conversation(
        &self,
        req: crate::model::CreateConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Conversation>> {
        self.inner.create_conversation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_conversations(
        &self,
        req: crate::model::ListConversationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListConversationsResponse>> {
        self.inner.list_conversations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_conversation(
        &self,
        req: crate::model::GetConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Conversation>> {
        self.inner.get_conversation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn complete_conversation(
        &self,
        req: crate::model::CompleteConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Conversation>> {
        self.inner.complete_conversation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn ingest_context_references(
        &self,
        req: crate::model::IngestContextReferencesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::IngestContextReferencesResponse>> {
        self.inner.ingest_context_references(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_messages(
        &self,
        req: crate::model::ListMessagesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListMessagesResponse>> {
        self.inner.list_messages(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn suggest_conversation_summary(
        &self,
        req: crate::model::SuggestConversationSummaryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SuggestConversationSummaryResponse>> {
        self.inner.suggest_conversation_summary(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn generate_stateless_summary(
        &self,
        req: crate::model::GenerateStatelessSummaryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateStatelessSummaryResponse>> {
        self.inner.generate_stateless_summary(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn generate_stateless_suggestion(
        &self,
        req: crate::model::GenerateStatelessSuggestionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateStatelessSuggestionResponse>> {
        self.inner.generate_stateless_suggestion(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn search_knowledge(
        &self,
        req: crate::model::SearchKnowledgeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SearchKnowledgeResponse>> {
        self.inner.search_knowledge(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn generate_suggestions(
        &self,
        req: crate::model::GenerateSuggestionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateSuggestionsResponse>> {
        self.inner.generate_suggestions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

}

/// Implements a [ConversationDatasets](super::stub::ConversationDatasets) decorator for logging and tracing.
#[cfg(feature = "conversation-datasets")]
#[derive(Clone, Debug)]
pub struct ConversationDatasets<T>
where T: super::stub::ConversationDatasets + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "conversation-datasets")]
impl<T> ConversationDatasets<T>
where T: super::stub::ConversationDatasets + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "conversation-datasets")]
impl<T> super::stub::ConversationDatasets for ConversationDatasets<T>
where T: super::stub::ConversationDatasets + std::fmt::Debug + Send + Sync {
    #[tracing::instrument(ret)]
    async fn create_conversation_dataset(
        &self,
        req: crate::model::CreateConversationDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_conversation_dataset(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_conversation_dataset(
        &self,
        req: crate::model::GetConversationDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ConversationDataset>> {
        self.inner.get_conversation_dataset(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_conversation_datasets(
        &self,
        req: crate::model::ListConversationDatasetsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListConversationDatasetsResponse>> {
        self.inner.list_conversation_datasets(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_conversation_dataset(
        &self,
        req: crate::model::DeleteConversationDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_conversation_dataset(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn import_conversation_data(
        &self,
        req: crate::model::ImportConversationDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_conversation_data(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }


    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ConversationModels](super::stub::ConversationModels) decorator for logging and tracing.
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug)]
pub struct ConversationModels<T>
where T: super::stub::ConversationModels + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "conversation-models")]
impl<T> ConversationModels<T>
where T: super::stub::ConversationModels + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "conversation-models")]
impl<T> super::stub::ConversationModels for ConversationModels<T>
where T: super::stub::ConversationModels + std::fmt::Debug + Send + Sync {
    #[tracing::instrument(ret)]
    async fn create_conversation_model(
        &self,
        req: crate::model::CreateConversationModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_conversation_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_conversation_model(
        &self,
        req: crate::model::GetConversationModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ConversationModel>> {
        self.inner.get_conversation_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_conversation_models(
        &self,
        req: crate::model::ListConversationModelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListConversationModelsResponse>> {
        self.inner.list_conversation_models(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_conversation_model(
        &self,
        req: crate::model::DeleteConversationModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_conversation_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn deploy_conversation_model(
        &self,
        req: crate::model::DeployConversationModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.deploy_conversation_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn undeploy_conversation_model(
        &self,
        req: crate::model::UndeployConversationModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.undeploy_conversation_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_conversation_model_evaluation(
        &self,
        req: crate::model::GetConversationModelEvaluationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ConversationModelEvaluation>> {
        self.inner.get_conversation_model_evaluation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_conversation_model_evaluations(
        &self,
        req: crate::model::ListConversationModelEvaluationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListConversationModelEvaluationsResponse>> {
        self.inner.list_conversation_model_evaluations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_conversation_model_evaluation(
        &self,
        req: crate::model::CreateConversationModelEvaluationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_conversation_model_evaluation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }


    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ConversationProfiles](super::stub::ConversationProfiles) decorator for logging and tracing.
#[cfg(feature = "conversation-profiles")]
#[derive(Clone, Debug)]
pub struct ConversationProfiles<T>
where T: super::stub::ConversationProfiles + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "conversation-profiles")]
impl<T> ConversationProfiles<T>
where T: super::stub::ConversationProfiles + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "conversation-profiles")]
impl<T> super::stub::ConversationProfiles for ConversationProfiles<T>
where T: super::stub::ConversationProfiles + std::fmt::Debug + Send + Sync {
    #[tracing::instrument(ret)]
    async fn list_conversation_profiles(
        &self,
        req: crate::model::ListConversationProfilesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListConversationProfilesResponse>> {
        self.inner.list_conversation_profiles(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_conversation_profile(
        &self,
        req: crate::model::GetConversationProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ConversationProfile>> {
        self.inner.get_conversation_profile(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_conversation_profile(
        &self,
        req: crate::model::CreateConversationProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ConversationProfile>> {
        self.inner.create_conversation_profile(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_conversation_profile(
        &self,
        req: crate::model::UpdateConversationProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ConversationProfile>> {
        self.inner.update_conversation_profile(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_conversation_profile(
        &self,
        req: crate::model::DeleteConversationProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_conversation_profile(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_suggestion_feature_config(
        &self,
        req: crate::model::SetSuggestionFeatureConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.set_suggestion_feature_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn clear_suggestion_feature_config(
        &self,
        req: crate::model::ClearSuggestionFeatureConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.clear_suggestion_feature_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }


    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [Documents](super::stub::Documents) decorator for logging and tracing.
#[cfg(feature = "documents")]
#[derive(Clone, Debug)]
pub struct Documents<T>
where T: super::stub::Documents + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "documents")]
impl<T> Documents<T>
where T: super::stub::Documents + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "documents")]
impl<T> super::stub::Documents for Documents<T>
where T: super::stub::Documents + std::fmt::Debug + Send + Sync {
    #[tracing::instrument(ret)]
    async fn list_documents(
        &self,
        req: crate::model::ListDocumentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListDocumentsResponse>> {
        self.inner.list_documents(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_document(
        &self,
        req: crate::model::GetDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Document>> {
        self.inner.get_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_document(
        &self,
        req: crate::model::CreateDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn import_documents(
        &self,
        req: crate::model::ImportDocumentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.import_documents(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_document(
        &self,
        req: crate::model::DeleteDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.delete_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_document(
        &self,
        req: crate::model::UpdateDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn reload_document(
        &self,
        req: crate::model::ReloadDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.reload_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn export_document(
        &self,
        req: crate::model::ExportDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.export_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }


    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [EncryptionSpecService](super::stub::EncryptionSpecService) decorator for logging and tracing.
#[cfg(feature = "encryption-spec-service")]
#[derive(Clone, Debug)]
pub struct EncryptionSpecService<T>
where T: super::stub::EncryptionSpecService + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "encryption-spec-service")]
impl<T> EncryptionSpecService<T>
where T: super::stub::EncryptionSpecService + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "encryption-spec-service")]
impl<T> super::stub::EncryptionSpecService for EncryptionSpecService<T>
where T: super::stub::EncryptionSpecService + std::fmt::Debug + Send + Sync {
    #[tracing::instrument(ret)]
    async fn get_encryption_spec(
        &self,
        req: crate::model::GetEncryptionSpecRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EncryptionSpec>> {
        self.inner.get_encryption_spec(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn initialize_encryption_spec(
        &self,
        req: crate::model::InitializeEncryptionSpecRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.initialize_encryption_spec(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }


    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [EntityTypes](super::stub::EntityTypes) decorator for logging and tracing.
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug)]
pub struct EntityTypes<T>
where T: super::stub::EntityTypes + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "entity-types")]
impl<T> EntityTypes<T>
where T: super::stub::EntityTypes + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "entity-types")]
impl<T> super::stub::EntityTypes for EntityTypes<T>
where T: super::stub::EntityTypes + std::fmt::Debug + Send + Sync {
    #[tracing::instrument(ret)]
    async fn list_entity_types(
        &self,
        req: crate::model::ListEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEntityTypesResponse>> {
        self.inner.list_entity_types(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_entity_type(
        &self,
        req: crate::model::GetEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntityType>> {
        self.inner.get_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_entity_type(
        &self,
        req: crate::model::CreateEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntityType>> {
        self.inner.create_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_entity_type(
        &self,
        req: crate::model::UpdateEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EntityType>> {
        self.inner.update_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_entity_type(
        &self,
        req: crate::model::DeleteEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_update_entity_types(
        &self,
        req: crate::model::BatchUpdateEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_update_entity_types(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_delete_entity_types(
        &self,
        req: crate::model::BatchDeleteEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_delete_entity_types(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_create_entities(
        &self,
        req: crate::model::BatchCreateEntitiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_create_entities(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_update_entities(
        &self,
        req: crate::model::BatchUpdateEntitiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_update_entities(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_delete_entities(
        &self,
        req: crate::model::BatchDeleteEntitiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_delete_entities(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }


    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [Environments](super::stub::Environments) decorator for logging and tracing.
#[cfg(feature = "environments")]
#[derive(Clone, Debug)]
pub struct Environments<T>
where T: super::stub::Environments + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "environments")]
impl<T> Environments<T>
where T: super::stub::Environments + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "environments")]
impl<T> super::stub::Environments for Environments<T>
where T: super::stub::Environments + std::fmt::Debug + Send + Sync {
    #[tracing::instrument(ret)]
    async fn list_environments(
        &self,
        req: crate::model::ListEnvironmentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListEnvironmentsResponse>> {
        self.inner.list_environments(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_environment(
        &self,
        req: crate::model::GetEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Environment>> {
        self.inner.get_environment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_environment(
        &self,
        req: crate::model::CreateEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Environment>> {
        self.inner.create_environment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_environment(
        &self,
        req: crate::model::UpdateEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Environment>> {
        self.inner.update_environment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_environment(
        &self,
        req: crate::model::DeleteEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_environment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_environment_history(
        &self,
        req: crate::model::GetEnvironmentHistoryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EnvironmentHistory>> {
        self.inner.get_environment_history(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

}

/// Implements a [Fulfillments](super::stub::Fulfillments) decorator for logging and tracing.
#[cfg(feature = "fulfillments")]
#[derive(Clone, Debug)]
pub struct Fulfillments<T>
where T: super::stub::Fulfillments + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "fulfillments")]
impl<T> Fulfillments<T>
where T: super::stub::Fulfillments + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "fulfillments")]
impl<T> super::stub::Fulfillments for Fulfillments<T>
where T: super::stub::Fulfillments + std::fmt::Debug + Send + Sync {
    #[tracing::instrument(ret)]
    async fn get_fulfillment(
        &self,
        req: crate::model::GetFulfillmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Fulfillment>> {
        self.inner.get_fulfillment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_fulfillment(
        &self,
        req: crate::model::UpdateFulfillmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Fulfillment>> {
        self.inner.update_fulfillment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

}

/// Implements a [Generators](super::stub::Generators) decorator for logging and tracing.
#[cfg(feature = "generators")]
#[derive(Clone, Debug)]
pub struct Generators<T>
where T: super::stub::Generators + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "generators")]
impl<T> Generators<T>
where T: super::stub::Generators + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "generators")]
impl<T> super::stub::Generators for Generators<T>
where T: super::stub::Generators + std::fmt::Debug + Send + Sync {
    #[tracing::instrument(ret)]
    async fn create_generator(
        &self,
        req: crate::model::CreateGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Generator>> {
        self.inner.create_generator(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_generator(
        &self,
        req: crate::model::GetGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Generator>> {
        self.inner.get_generator(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_generators(
        &self,
        req: crate::model::ListGeneratorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListGeneratorsResponse>> {
        self.inner.list_generators(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_generator(
        &self,
        req: crate::model::DeleteGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_generator(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_generator(
        &self,
        req: crate::model::UpdateGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Generator>> {
        self.inner.update_generator(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

}

/// Implements a [Intents](super::stub::Intents) decorator for logging and tracing.
#[cfg(feature = "intents")]
#[derive(Clone, Debug)]
pub struct Intents<T>
where T: super::stub::Intents + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "intents")]
impl<T> Intents<T>
where T: super::stub::Intents + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "intents")]
impl<T> super::stub::Intents for Intents<T>
where T: super::stub::Intents + std::fmt::Debug + Send + Sync {
    #[tracing::instrument(ret)]
    async fn list_intents(
        &self,
        req: crate::model::ListIntentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListIntentsResponse>> {
        self.inner.list_intents(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_intent(
        &self,
        req: crate::model::GetIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Intent>> {
        self.inner.get_intent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_intent(
        &self,
        req: crate::model::CreateIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Intent>> {
        self.inner.create_intent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_intent(
        &self,
        req: crate::model::UpdateIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Intent>> {
        self.inner.update_intent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_intent(
        &self,
        req: crate::model::DeleteIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_intent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_update_intents(
        &self,
        req: crate::model::BatchUpdateIntentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_update_intents(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_delete_intents(
        &self,
        req: crate::model::BatchDeleteIntentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.batch_delete_intents(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }


    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [KnowledgeBases](super::stub::KnowledgeBases) decorator for logging and tracing.
#[cfg(feature = "knowledge-bases")]
#[derive(Clone, Debug)]
pub struct KnowledgeBases<T>
where T: super::stub::KnowledgeBases + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "knowledge-bases")]
impl<T> KnowledgeBases<T>
where T: super::stub::KnowledgeBases + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "knowledge-bases")]
impl<T> super::stub::KnowledgeBases for KnowledgeBases<T>
where T: super::stub::KnowledgeBases + std::fmt::Debug + Send + Sync {
    #[tracing::instrument(ret)]
    async fn list_knowledge_bases(
        &self,
        req: crate::model::ListKnowledgeBasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListKnowledgeBasesResponse>> {
        self.inner.list_knowledge_bases(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_knowledge_base(
        &self,
        req: crate::model::GetKnowledgeBaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::KnowledgeBase>> {
        self.inner.get_knowledge_base(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_knowledge_base(
        &self,
        req: crate::model::CreateKnowledgeBaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::KnowledgeBase>> {
        self.inner.create_knowledge_base(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_knowledge_base(
        &self,
        req: crate::model::DeleteKnowledgeBaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_knowledge_base(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_knowledge_base(
        &self,
        req: crate::model::UpdateKnowledgeBaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::KnowledgeBase>> {
        self.inner.update_knowledge_base(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

}

/// Implements a [Participants](super::stub::Participants) decorator for logging and tracing.
#[cfg(feature = "participants")]
#[derive(Clone, Debug)]
pub struct Participants<T>
where T: super::stub::Participants + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "participants")]
impl<T> Participants<T>
where T: super::stub::Participants + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "participants")]
impl<T> super::stub::Participants for Participants<T>
where T: super::stub::Participants + std::fmt::Debug + Send + Sync {
    #[tracing::instrument(ret)]
    async fn create_participant(
        &self,
        req: crate::model::CreateParticipantRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Participant>> {
        self.inner.create_participant(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_participant(
        &self,
        req: crate::model::GetParticipantRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Participant>> {
        self.inner.get_participant(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_participants(
        &self,
        req: crate::model::ListParticipantsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListParticipantsResponse>> {
        self.inner.list_participants(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_participant(
        &self,
        req: crate::model::UpdateParticipantRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Participant>> {
        self.inner.update_participant(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn analyze_content(
        &self,
        req: crate::model::AnalyzeContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AnalyzeContentResponse>> {
        self.inner.analyze_content(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn suggest_articles(
        &self,
        req: crate::model::SuggestArticlesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SuggestArticlesResponse>> {
        self.inner.suggest_articles(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn suggest_faq_answers(
        &self,
        req: crate::model::SuggestFaqAnswersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SuggestFaqAnswersResponse>> {
        self.inner.suggest_faq_answers(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn suggest_smart_replies(
        &self,
        req: crate::model::SuggestSmartRepliesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SuggestSmartRepliesResponse>> {
        self.inner.suggest_smart_replies(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn suggest_knowledge_assist(
        &self,
        req: crate::model::SuggestKnowledgeAssistRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SuggestKnowledgeAssistResponse>> {
        self.inner.suggest_knowledge_assist(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

}

/// Implements a [Sessions](super::stub::Sessions) decorator for logging and tracing.
#[cfg(feature = "sessions")]
#[derive(Clone, Debug)]
pub struct Sessions<T>
where T: super::stub::Sessions + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "sessions")]
impl<T> Sessions<T>
where T: super::stub::Sessions + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "sessions")]
impl<T> super::stub::Sessions for Sessions<T>
where T: super::stub::Sessions + std::fmt::Debug + Send + Sync {
    #[tracing::instrument(ret)]
    async fn detect_intent(
        &self,
        req: crate::model::DetectIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DetectIntentResponse>> {
        self.inner.detect_intent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

}

/// Implements a [SessionEntityTypes](super::stub::SessionEntityTypes) decorator for logging and tracing.
#[cfg(feature = "session-entity-types")]
#[derive(Clone, Debug)]
pub struct SessionEntityTypes<T>
where T: super::stub::SessionEntityTypes + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "session-entity-types")]
impl<T> SessionEntityTypes<T>
where T: super::stub::SessionEntityTypes + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "session-entity-types")]
impl<T> super::stub::SessionEntityTypes for SessionEntityTypes<T>
where T: super::stub::SessionEntityTypes + std::fmt::Debug + Send + Sync {
    #[tracing::instrument(ret)]
    async fn list_session_entity_types(
        &self,
        req: crate::model::ListSessionEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSessionEntityTypesResponse>> {
        self.inner.list_session_entity_types(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_session_entity_type(
        &self,
        req: crate::model::GetSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SessionEntityType>> {
        self.inner.get_session_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_session_entity_type(
        &self,
        req: crate::model::CreateSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SessionEntityType>> {
        self.inner.create_session_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_session_entity_type(
        &self,
        req: crate::model::UpdateSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SessionEntityType>> {
        self.inner.update_session_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_session_entity_type(
        &self,
        req: crate::model::DeleteSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_session_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

}

/// Implements a [Versions](super::stub::Versions) decorator for logging and tracing.
#[cfg(feature = "versions")]
#[derive(Clone, Debug)]
pub struct Versions<T>
where T: super::stub::Versions + std::fmt::Debug + Send + Sync {
    inner: T,
}

#[cfg(feature = "versions")]
impl<T> Versions<T>
where T: super::stub::Versions + std::fmt::Debug + Send + Sync {
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

#[cfg(feature = "versions")]
impl<T> super::stub::Versions for Versions<T>
where T: super::stub::Versions + std::fmt::Debug + Send + Sync {
    #[tracing::instrument(ret)]
    async fn list_versions(
        &self,
        req: crate::model::ListVersionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListVersionsResponse>> {
        self.inner.list_versions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_version(
        &self,
        req: crate::model::GetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Version>> {
        self.inner.get_version(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_version(
        &self,
        req: crate::model::CreateVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Version>> {
        self.inner.create_version(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_version(
        &self,
        req: crate::model::UpdateVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Version>> {
        self.inner.update_version(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_version(
        &self,
        req: crate::model::DeleteVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_version(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

}

