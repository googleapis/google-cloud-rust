// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
use crate::Result;

/// Implements a [Agents](crate::stubs::Agents) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct Agents<T>
where
    T: crate::stubs::Agents + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> Agents<T>
where
    T: crate::stubs::Agents + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::Agents for Agents<T>
where
    T: crate::stubs::Agents + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get_agent(
        &self,
        req: crate::model::GetAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Agent> {
        self.inner.get_agent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_agent(
        &self,
        req: crate::model::SetAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Agent> {
        self.inner.set_agent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_agent(
        &self,
        req: crate::model::DeleteAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.delete_agent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn search_agents(
        &self,
        req: crate::model::SearchAgentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::SearchAgentsResponse> {
        self.inner.search_agents(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn train_agent(
        &self,
        req: crate::model::TrainAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.train_agent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn export_agent(
        &self,
        req: crate::model::ExportAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.export_agent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn import_agent(
        &self,
        req: crate::model::ImportAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.import_agent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn restore_agent(
        &self,
        req: crate::model::RestoreAgentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.restore_agent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_validation_result(
        &self,
        req: crate::model::GetValidationResultRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ValidationResult> {
        self.inner.get_validation_result(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::ListLocationsResponse> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::Location> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_policy::PollingPolicy> {
        self.inner.get_polling_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [AnswerRecords](crate::stubs::AnswerRecords) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct AnswerRecords<T>
where
    T: crate::stubs::AnswerRecords + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> AnswerRecords<T>
where
    T: crate::stubs::AnswerRecords + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::AnswerRecords for AnswerRecords<T>
where
    T: crate::stubs::AnswerRecords + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn list_answer_records(
        &self,
        req: crate::model::ListAnswerRecordsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListAnswerRecordsResponse> {
        self.inner.list_answer_records(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_answer_record(
        &self,
        req: crate::model::UpdateAnswerRecordRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::AnswerRecord> {
        self.inner.update_answer_record(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::ListLocationsResponse> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::Location> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [Contexts](crate::stubs::Contexts) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct Contexts<T>
where
    T: crate::stubs::Contexts + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> Contexts<T>
where
    T: crate::stubs::Contexts + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::Contexts for Contexts<T>
where
    T: crate::stubs::Contexts + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn list_contexts(
        &self,
        req: crate::model::ListContextsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListContextsResponse> {
        self.inner.list_contexts(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_context(
        &self,
        req: crate::model::GetContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Context> {
        self.inner.get_context(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_context(
        &self,
        req: crate::model::CreateContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Context> {
        self.inner.create_context(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_context(
        &self,
        req: crate::model::UpdateContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Context> {
        self.inner.update_context(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_context(
        &self,
        req: crate::model::DeleteContextRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.delete_context(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_all_contexts(
        &self,
        req: crate::model::DeleteAllContextsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.delete_all_contexts(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::ListLocationsResponse> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::Location> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [Conversations](crate::stubs::Conversations) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct Conversations<T>
where
    T: crate::stubs::Conversations + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> Conversations<T>
where
    T: crate::stubs::Conversations + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::Conversations for Conversations<T>
where
    T: crate::stubs::Conversations + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_conversation(
        &self,
        req: crate::model::CreateConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Conversation> {
        self.inner.create_conversation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_conversations(
        &self,
        req: crate::model::ListConversationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListConversationsResponse> {
        self.inner.list_conversations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_conversation(
        &self,
        req: crate::model::GetConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Conversation> {
        self.inner.get_conversation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn complete_conversation(
        &self,
        req: crate::model::CompleteConversationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Conversation> {
        self.inner.complete_conversation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn ingest_context_references(
        &self,
        req: crate::model::IngestContextReferencesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::IngestContextReferencesResponse> {
        self.inner.ingest_context_references(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_messages(
        &self,
        req: crate::model::ListMessagesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListMessagesResponse> {
        self.inner.list_messages(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn suggest_conversation_summary(
        &self,
        req: crate::model::SuggestConversationSummaryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::SuggestConversationSummaryResponse> {
        self.inner.suggest_conversation_summary(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn generate_stateless_summary(
        &self,
        req: crate::model::GenerateStatelessSummaryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::GenerateStatelessSummaryResponse> {
        self.inner.generate_stateless_summary(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn generate_stateless_suggestion(
        &self,
        req: crate::model::GenerateStatelessSuggestionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::GenerateStatelessSuggestionResponse> {
        self.inner.generate_stateless_suggestion(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn search_knowledge(
        &self,
        req: crate::model::SearchKnowledgeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::SearchKnowledgeResponse> {
        self.inner.search_knowledge(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn generate_suggestions(
        &self,
        req: crate::model::GenerateSuggestionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::GenerateSuggestionsResponse> {
        self.inner.generate_suggestions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::ListLocationsResponse> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::Location> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [ConversationDatasets](crate::stubs::ConversationDatasets) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct ConversationDatasets<T>
where
    T: crate::stubs::ConversationDatasets + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> ConversationDatasets<T>
where
    T: crate::stubs::ConversationDatasets + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::ConversationDatasets for ConversationDatasets<T>
where
    T: crate::stubs::ConversationDatasets + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_conversation_dataset(
        &self,
        req: crate::model::CreateConversationDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.create_conversation_dataset(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_conversation_dataset(
        &self,
        req: crate::model::GetConversationDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ConversationDataset> {
        self.inner.get_conversation_dataset(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_conversation_datasets(
        &self,
        req: crate::model::ListConversationDatasetsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListConversationDatasetsResponse> {
        self.inner.list_conversation_datasets(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_conversation_dataset(
        &self,
        req: crate::model::DeleteConversationDatasetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.delete_conversation_dataset(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn import_conversation_data(
        &self,
        req: crate::model::ImportConversationDataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.import_conversation_data(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::ListLocationsResponse> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::Location> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_policy::PollingPolicy> {
        self.inner.get_polling_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ConversationModels](crate::stubs::ConversationModels) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct ConversationModels<T>
where
    T: crate::stubs::ConversationModels + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> ConversationModels<T>
where
    T: crate::stubs::ConversationModels + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::ConversationModels for ConversationModels<T>
where
    T: crate::stubs::ConversationModels + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_conversation_model(
        &self,
        req: crate::model::CreateConversationModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.create_conversation_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_conversation_model(
        &self,
        req: crate::model::GetConversationModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ConversationModel> {
        self.inner.get_conversation_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_conversation_models(
        &self,
        req: crate::model::ListConversationModelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListConversationModelsResponse> {
        self.inner.list_conversation_models(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_conversation_model(
        &self,
        req: crate::model::DeleteConversationModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.delete_conversation_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn deploy_conversation_model(
        &self,
        req: crate::model::DeployConversationModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.deploy_conversation_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn undeploy_conversation_model(
        &self,
        req: crate::model::UndeployConversationModelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.undeploy_conversation_model(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_conversation_model_evaluation(
        &self,
        req: crate::model::GetConversationModelEvaluationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ConversationModelEvaluation> {
        self.inner
            .get_conversation_model_evaluation(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn list_conversation_model_evaluations(
        &self,
        req: crate::model::ListConversationModelEvaluationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListConversationModelEvaluationsResponse> {
        self.inner
            .list_conversation_model_evaluations(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn create_conversation_model_evaluation(
        &self,
        req: crate::model::CreateConversationModelEvaluationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner
            .create_conversation_model_evaluation(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::ListLocationsResponse> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::Location> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_policy::PollingPolicy> {
        self.inner.get_polling_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [ConversationProfiles](crate::stubs::ConversationProfiles) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct ConversationProfiles<T>
where
    T: crate::stubs::ConversationProfiles + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> ConversationProfiles<T>
where
    T: crate::stubs::ConversationProfiles + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::ConversationProfiles for ConversationProfiles<T>
where
    T: crate::stubs::ConversationProfiles + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn list_conversation_profiles(
        &self,
        req: crate::model::ListConversationProfilesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListConversationProfilesResponse> {
        self.inner.list_conversation_profiles(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_conversation_profile(
        &self,
        req: crate::model::GetConversationProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ConversationProfile> {
        self.inner.get_conversation_profile(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_conversation_profile(
        &self,
        req: crate::model::CreateConversationProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ConversationProfile> {
        self.inner.create_conversation_profile(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_conversation_profile(
        &self,
        req: crate::model::UpdateConversationProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ConversationProfile> {
        self.inner.update_conversation_profile(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_conversation_profile(
        &self,
        req: crate::model::DeleteConversationProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.delete_conversation_profile(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn set_suggestion_feature_config(
        &self,
        req: crate::model::SetSuggestionFeatureConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.set_suggestion_feature_config(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn clear_suggestion_feature_config(
        &self,
        req: crate::model::ClearSuggestionFeatureConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner
            .clear_suggestion_feature_config(req, options)
            .await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::ListLocationsResponse> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::Location> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_policy::PollingPolicy> {
        self.inner.get_polling_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [Documents](crate::stubs::Documents) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct Documents<T>
where
    T: crate::stubs::Documents + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> Documents<T>
where
    T: crate::stubs::Documents + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::Documents for Documents<T>
where
    T: crate::stubs::Documents + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn list_documents(
        &self,
        req: crate::model::ListDocumentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListDocumentsResponse> {
        self.inner.list_documents(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_document(
        &self,
        req: crate::model::GetDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Document> {
        self.inner.get_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_document(
        &self,
        req: crate::model::CreateDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.create_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn import_documents(
        &self,
        req: crate::model::ImportDocumentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.import_documents(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_document(
        &self,
        req: crate::model::DeleteDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.delete_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_document(
        &self,
        req: crate::model::UpdateDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.update_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn reload_document(
        &self,
        req: crate::model::ReloadDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.reload_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn export_document(
        &self,
        req: crate::model::ExportDocumentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.export_document(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::ListLocationsResponse> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::Location> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_policy::PollingPolicy> {
        self.inner.get_polling_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [EncryptionSpecService](crate::stubs::EncryptionSpecService) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct EncryptionSpecService<T>
where
    T: crate::stubs::EncryptionSpecService + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> EncryptionSpecService<T>
where
    T: crate::stubs::EncryptionSpecService + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::EncryptionSpecService for EncryptionSpecService<T>
where
    T: crate::stubs::EncryptionSpecService + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get_encryption_spec(
        &self,
        req: crate::model::GetEncryptionSpecRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::EncryptionSpec> {
        self.inner.get_encryption_spec(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn initialize_encryption_spec(
        &self,
        req: crate::model::InitializeEncryptionSpecRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.initialize_encryption_spec(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::ListLocationsResponse> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::Location> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_policy::PollingPolicy> {
        self.inner.get_polling_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [EntityTypes](crate::stubs::EntityTypes) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct EntityTypes<T>
where
    T: crate::stubs::EntityTypes + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> EntityTypes<T>
where
    T: crate::stubs::EntityTypes + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::EntityTypes for EntityTypes<T>
where
    T: crate::stubs::EntityTypes + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn list_entity_types(
        &self,
        req: crate::model::ListEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListEntityTypesResponse> {
        self.inner.list_entity_types(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_entity_type(
        &self,
        req: crate::model::GetEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::EntityType> {
        self.inner.get_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_entity_type(
        &self,
        req: crate::model::CreateEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::EntityType> {
        self.inner.create_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_entity_type(
        &self,
        req: crate::model::UpdateEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::EntityType> {
        self.inner.update_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_entity_type(
        &self,
        req: crate::model::DeleteEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.delete_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_update_entity_types(
        &self,
        req: crate::model::BatchUpdateEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.batch_update_entity_types(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_delete_entity_types(
        &self,
        req: crate::model::BatchDeleteEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.batch_delete_entity_types(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_create_entities(
        &self,
        req: crate::model::BatchCreateEntitiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.batch_create_entities(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_update_entities(
        &self,
        req: crate::model::BatchUpdateEntitiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.batch_update_entities(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_delete_entities(
        &self,
        req: crate::model::BatchDeleteEntitiesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.batch_delete_entities(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::ListLocationsResponse> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::Location> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_policy::PollingPolicy> {
        self.inner.get_polling_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [Environments](crate::stubs::Environments) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct Environments<T>
where
    T: crate::stubs::Environments + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> Environments<T>
where
    T: crate::stubs::Environments + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::Environments for Environments<T>
where
    T: crate::stubs::Environments + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn list_environments(
        &self,
        req: crate::model::ListEnvironmentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListEnvironmentsResponse> {
        self.inner.list_environments(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_environment(
        &self,
        req: crate::model::GetEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Environment> {
        self.inner.get_environment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_environment(
        &self,
        req: crate::model::CreateEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Environment> {
        self.inner.create_environment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_environment(
        &self,
        req: crate::model::UpdateEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Environment> {
        self.inner.update_environment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_environment(
        &self,
        req: crate::model::DeleteEnvironmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.delete_environment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_environment_history(
        &self,
        req: crate::model::GetEnvironmentHistoryRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::EnvironmentHistory> {
        self.inner.get_environment_history(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::ListLocationsResponse> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::Location> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [Fulfillments](crate::stubs::Fulfillments) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct Fulfillments<T>
where
    T: crate::stubs::Fulfillments + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> Fulfillments<T>
where
    T: crate::stubs::Fulfillments + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::Fulfillments for Fulfillments<T>
where
    T: crate::stubs::Fulfillments + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn get_fulfillment(
        &self,
        req: crate::model::GetFulfillmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Fulfillment> {
        self.inner.get_fulfillment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_fulfillment(
        &self,
        req: crate::model::UpdateFulfillmentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Fulfillment> {
        self.inner.update_fulfillment(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::ListLocationsResponse> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::Location> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [Generators](crate::stubs::Generators) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct Generators<T>
where
    T: crate::stubs::Generators + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> Generators<T>
where
    T: crate::stubs::Generators + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::Generators for Generators<T>
where
    T: crate::stubs::Generators + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_generator(
        &self,
        req: crate::model::CreateGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Generator> {
        self.inner.create_generator(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_generator(
        &self,
        req: crate::model::GetGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Generator> {
        self.inner.get_generator(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_generators(
        &self,
        req: crate::model::ListGeneratorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListGeneratorsResponse> {
        self.inner.list_generators(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_generator(
        &self,
        req: crate::model::DeleteGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.delete_generator(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_generator(
        &self,
        req: crate::model::UpdateGeneratorRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Generator> {
        self.inner.update_generator(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::ListLocationsResponse> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::Location> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [Intents](crate::stubs::Intents) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct Intents<T>
where
    T: crate::stubs::Intents + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> Intents<T>
where
    T: crate::stubs::Intents + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::Intents for Intents<T>
where
    T: crate::stubs::Intents + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn list_intents(
        &self,
        req: crate::model::ListIntentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListIntentsResponse> {
        self.inner.list_intents(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_intent(
        &self,
        req: crate::model::GetIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Intent> {
        self.inner.get_intent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_intent(
        &self,
        req: crate::model::CreateIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Intent> {
        self.inner.create_intent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_intent(
        &self,
        req: crate::model::UpdateIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Intent> {
        self.inner.update_intent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_intent(
        &self,
        req: crate::model::DeleteIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.delete_intent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_update_intents(
        &self,
        req: crate::model::BatchUpdateIntentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.batch_update_intents(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn batch_delete_intents(
        &self,
        req: crate::model::BatchDeleteIntentsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.batch_delete_intents(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::ListLocationsResponse> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::Location> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_policy::PollingPolicy> {
        self.inner.get_polling_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [KnowledgeBases](crate::stubs::KnowledgeBases) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct KnowledgeBases<T>
where
    T: crate::stubs::KnowledgeBases + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> KnowledgeBases<T>
where
    T: crate::stubs::KnowledgeBases + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::KnowledgeBases for KnowledgeBases<T>
where
    T: crate::stubs::KnowledgeBases + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn list_knowledge_bases(
        &self,
        req: crate::model::ListKnowledgeBasesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListKnowledgeBasesResponse> {
        self.inner.list_knowledge_bases(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_knowledge_base(
        &self,
        req: crate::model::GetKnowledgeBaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::KnowledgeBase> {
        self.inner.get_knowledge_base(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_knowledge_base(
        &self,
        req: crate::model::CreateKnowledgeBaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::KnowledgeBase> {
        self.inner.create_knowledge_base(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_knowledge_base(
        &self,
        req: crate::model::DeleteKnowledgeBaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.delete_knowledge_base(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_knowledge_base(
        &self,
        req: crate::model::UpdateKnowledgeBaseRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::KnowledgeBase> {
        self.inner.update_knowledge_base(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::ListLocationsResponse> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::Location> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [Participants](crate::stubs::Participants) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct Participants<T>
where
    T: crate::stubs::Participants + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> Participants<T>
where
    T: crate::stubs::Participants + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::Participants for Participants<T>
where
    T: crate::stubs::Participants + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn create_participant(
        &self,
        req: crate::model::CreateParticipantRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Participant> {
        self.inner.create_participant(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_participant(
        &self,
        req: crate::model::GetParticipantRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Participant> {
        self.inner.get_participant(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_participants(
        &self,
        req: crate::model::ListParticipantsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListParticipantsResponse> {
        self.inner.list_participants(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_participant(
        &self,
        req: crate::model::UpdateParticipantRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Participant> {
        self.inner.update_participant(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn analyze_content(
        &self,
        req: crate::model::AnalyzeContentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::AnalyzeContentResponse> {
        self.inner.analyze_content(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn suggest_articles(
        &self,
        req: crate::model::SuggestArticlesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::SuggestArticlesResponse> {
        self.inner.suggest_articles(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn suggest_faq_answers(
        &self,
        req: crate::model::SuggestFaqAnswersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::SuggestFaqAnswersResponse> {
        self.inner.suggest_faq_answers(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn suggest_smart_replies(
        &self,
        req: crate::model::SuggestSmartRepliesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::SuggestSmartRepliesResponse> {
        self.inner.suggest_smart_replies(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn suggest_knowledge_assist(
        &self,
        req: crate::model::SuggestKnowledgeAssistRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::SuggestKnowledgeAssistResponse> {
        self.inner.suggest_knowledge_assist(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::ListLocationsResponse> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::Location> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [Sessions](crate::stubs::Sessions) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct Sessions<T>
where
    T: crate::stubs::Sessions + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> Sessions<T>
where
    T: crate::stubs::Sessions + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::Sessions for Sessions<T>
where
    T: crate::stubs::Sessions + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn detect_intent(
        &self,
        req: crate::model::DetectIntentRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::DetectIntentResponse> {
        self.inner.detect_intent(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::ListLocationsResponse> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::Location> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [SessionEntityTypes](crate::stubs::SessionEntityTypes) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct SessionEntityTypes<T>
where
    T: crate::stubs::SessionEntityTypes + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> SessionEntityTypes<T>
where
    T: crate::stubs::SessionEntityTypes + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::SessionEntityTypes for SessionEntityTypes<T>
where
    T: crate::stubs::SessionEntityTypes + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn list_session_entity_types(
        &self,
        req: crate::model::ListSessionEntityTypesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListSessionEntityTypesResponse> {
        self.inner.list_session_entity_types(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_session_entity_type(
        &self,
        req: crate::model::GetSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::SessionEntityType> {
        self.inner.get_session_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_session_entity_type(
        &self,
        req: crate::model::CreateSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::SessionEntityType> {
        self.inner.create_session_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_session_entity_type(
        &self,
        req: crate::model::UpdateSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::SessionEntityType> {
        self.inner.update_session_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_session_entity_type(
        &self,
        req: crate::model::DeleteSessionEntityTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.delete_session_entity_type(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::ListLocationsResponse> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::Location> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }
}

/// Implements a [Versions](crate::stubs::Versions) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct Versions<T>
where
    T: crate::stubs::Versions + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> Versions<T>
where
    T: crate::stubs::Versions + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> crate::stubs::Versions for Versions<T>
where
    T: crate::stubs::Versions + std::fmt::Debug + Send + Sync,
{
    #[tracing::instrument(ret)]
    async fn list_versions(
        &self,
        req: crate::model::ListVersionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::ListVersionsResponse> {
        self.inner.list_versions(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_version(
        &self,
        req: crate::model::GetVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Version> {
        self.inner.get_version(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn create_version(
        &self,
        req: crate::model::CreateVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Version> {
        self.inner.create_version(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn update_version(
        &self,
        req: crate::model::UpdateVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<crate::model::Version> {
        self.inner.update_version(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn delete_version(
        &self,
        req: crate::model::DeleteVersionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.delete_version(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::ListLocationsResponse> {
        self.inner.list_locations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<location::model::Location> {
        self.inner.get_location(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::ListOperationsResponse> {
        self.inner.list_operations(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<longrunning::model::Operation> {
        self.inner.get_operation(req, options).await
    }

    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<wkt::Empty> {
        self.inner.cancel_operation(req, options).await
    }
}
