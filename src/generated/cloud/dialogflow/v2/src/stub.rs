// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

//! Traits to mock the clients in this library.
//!
//! Application developers may need to mock the clients in this library to test
//! how their application works with different (and sometimes hard to trigger)
//! client and service behavior. Such test can define mocks implementing the
//! trait(s) defined in this module, initialize the client with an instance of
//! this mock in their tests, and verify their application responds as expected.

#![allow(rustdoc::broken_intra_doc_links)]

use gax::error::Error;

pub(crate) mod dynamic;

/// Defines the trait used to implement [super::client::Agents].
///
/// Application developers may need to implement this trait to mock
/// `client::Agents`.  In other use-cases, application developers only
/// use `client::Agents` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Agents: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::Agents::get_agent].
    fn get_agent(
        &self,
        _req: crate::model::GetAgentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Agent>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Agent>>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [super::client::Agents::set_agent].
    fn set_agent(
        &self,
        _req: crate::model::SetAgentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Agent>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Agent>>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [super::client::Agents::delete_agent].
    fn delete_agent(
        &self,
        _req: crate::model::DeleteAgentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::Agents::search_agents].
    fn search_agents(
        &self,
        _req: crate::model::SearchAgentsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::SearchAgentsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::SearchAgentsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Agents::train_agent].
    fn train_agent(
        &self,
        _req: crate::model::TrainAgentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Agents::export_agent].
    fn export_agent(
        &self,
        _req: crate::model::ExportAgentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Agents::import_agent].
    fn import_agent(
        &self,
        _req: crate::model::ImportAgentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Agents::restore_agent].
    fn restore_agent(
        &self,
        _req: crate::model::RestoreAgentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Agents::get_validation_result].
    fn get_validation_result(
        &self,
        _req: crate::model::GetValidationResultRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::ValidationResult>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::ValidationResult>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Agents::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Agents::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::Location>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<location::model::Location>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Agents::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Agents::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Agents::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns the polling error policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_error_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        std::sync::Arc::new(gax::polling_error_policy::Aip194Strict)
    }

    /// Returns the polling backoff policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_backoff_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        std::sync::Arc::new(gax::exponential_backoff::ExponentialBackoff::default())
    }
}

/// Defines the trait used to implement [super::client::AnswerRecords].
///
/// Application developers may need to implement this trait to mock
/// `client::AnswerRecords`.  In other use-cases, application developers only
/// use `client::AnswerRecords` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait AnswerRecords: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::AnswerRecords::list_answer_records].
    fn list_answer_records(
        &self,
        _req: crate::model::ListAnswerRecordsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::ListAnswerRecordsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ListAnswerRecordsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::AnswerRecords::update_answer_record].
    fn update_answer_record(
        &self,
        _req: crate::model::UpdateAnswerRecordRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::AnswerRecord>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::AnswerRecord>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::AnswerRecords::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::AnswerRecords::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::Location>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<location::model::Location>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::AnswerRecords::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::AnswerRecords::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::AnswerRecords::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }
}

/// Defines the trait used to implement [super::client::Contexts].
///
/// Application developers may need to implement this trait to mock
/// `client::Contexts`.  In other use-cases, application developers only
/// use `client::Contexts` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Contexts: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::Contexts::list_contexts].
    fn list_contexts(
        &self,
        _req: crate::model::ListContextsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::ListContextsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ListContextsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Contexts::get_context].
    fn get_context(
        &self,
        _req: crate::model::GetContextRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Context>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Context>>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [super::client::Contexts::create_context].
    fn create_context(
        &self,
        _req: crate::model::CreateContextRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Context>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Context>>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [super::client::Contexts::update_context].
    fn update_context(
        &self,
        _req: crate::model::UpdateContextRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Context>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Context>>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [super::client::Contexts::delete_context].
    fn delete_context(
        &self,
        _req: crate::model::DeleteContextRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::Contexts::delete_all_contexts].
    fn delete_all_contexts(
        &self,
        _req: crate::model::DeleteAllContextsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::Contexts::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Contexts::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::Location>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<location::model::Location>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Contexts::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Contexts::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Contexts::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }
}

/// Defines the trait used to implement [super::client::Conversations].
///
/// Application developers may need to implement this trait to mock
/// `client::Conversations`.  In other use-cases, application developers only
/// use `client::Conversations` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Conversations: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::Conversations::create_conversation].
    fn create_conversation(
        &self,
        _req: crate::model::CreateConversationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Conversation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Conversation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Conversations::list_conversations].
    fn list_conversations(
        &self,
        _req: crate::model::ListConversationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::ListConversationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ListConversationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Conversations::get_conversation].
    fn get_conversation(
        &self,
        _req: crate::model::GetConversationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Conversation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Conversation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Conversations::complete_conversation].
    fn complete_conversation(
        &self,
        _req: crate::model::CompleteConversationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Conversation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Conversation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Conversations::ingest_context_references].
    fn ingest_context_references(
        &self,
        _req: crate::model::IngestContextReferencesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<
            gax::response::Response<crate::model::IngestContextReferencesResponse>,
        >,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::IngestContextReferencesResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Conversations::list_messages].
    fn list_messages(
        &self,
        _req: crate::model::ListMessagesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::ListMessagesResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ListMessagesResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Conversations::suggest_conversation_summary].
    fn suggest_conversation_summary(
        &self,
        _req: crate::model::SuggestConversationSummaryRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<
            gax::response::Response<crate::model::SuggestConversationSummaryResponse>,
        >,
    > + Send {
        std::future::ready::<
            crate::Result<
                gax::response::Response<crate::model::SuggestConversationSummaryResponse>,
            >,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Conversations::generate_stateless_summary].
    fn generate_stateless_summary(
        &self,
        _req: crate::model::GenerateStatelessSummaryRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<
            gax::response::Response<crate::model::GenerateStatelessSummaryResponse>,
        >,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::GenerateStatelessSummaryResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Conversations::generate_stateless_suggestion].
    fn generate_stateless_suggestion(
        &self,
        _req: crate::model::GenerateStatelessSuggestionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<
            gax::response::Response<crate::model::GenerateStatelessSuggestionResponse>,
        >,
    > + Send {
        std::future::ready::<
            crate::Result<
                gax::response::Response<crate::model::GenerateStatelessSuggestionResponse>,
            >,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Conversations::search_knowledge].
    fn search_knowledge(
        &self,
        _req: crate::model::SearchKnowledgeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::SearchKnowledgeResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::SearchKnowledgeResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Conversations::generate_suggestions].
    fn generate_suggestions(
        &self,
        _req: crate::model::GenerateSuggestionsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::GenerateSuggestionsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::GenerateSuggestionsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Conversations::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Conversations::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::Location>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<location::model::Location>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Conversations::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Conversations::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Conversations::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }
}

/// Defines the trait used to implement [super::client::ConversationDatasets].
///
/// Application developers may need to implement this trait to mock
/// `client::ConversationDatasets`.  In other use-cases, application developers only
/// use `client::ConversationDatasets` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait ConversationDatasets: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::ConversationDatasets::create_conversation_dataset].
    fn create_conversation_dataset(
        &self,
        _req: crate::model::CreateConversationDatasetRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::ConversationDatasets::get_conversation_dataset].
    fn get_conversation_dataset(
        &self,
        _req: crate::model::GetConversationDatasetRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::ConversationDataset>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ConversationDataset>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::ConversationDatasets::list_conversation_datasets].
    fn list_conversation_datasets(
        &self,
        _req: crate::model::ListConversationDatasetsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<
            gax::response::Response<crate::model::ListConversationDatasetsResponse>,
        >,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ListConversationDatasetsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::ConversationDatasets::delete_conversation_dataset].
    fn delete_conversation_dataset(
        &self,
        _req: crate::model::DeleteConversationDatasetRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::ConversationDatasets::import_conversation_data].
    fn import_conversation_data(
        &self,
        _req: crate::model::ImportConversationDataRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::ConversationDatasets::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::ConversationDatasets::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::Location>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<location::model::Location>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::ConversationDatasets::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::ConversationDatasets::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::ConversationDatasets::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns the polling error policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_error_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        std::sync::Arc::new(gax::polling_error_policy::Aip194Strict)
    }

    /// Returns the polling backoff policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_backoff_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        std::sync::Arc::new(gax::exponential_backoff::ExponentialBackoff::default())
    }
}

/// Defines the trait used to implement [super::client::ConversationModels].
///
/// Application developers may need to implement this trait to mock
/// `client::ConversationModels`.  In other use-cases, application developers only
/// use `client::ConversationModels` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait ConversationModels: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::ConversationModels::create_conversation_model].
    fn create_conversation_model(
        &self,
        _req: crate::model::CreateConversationModelRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::ConversationModels::get_conversation_model].
    fn get_conversation_model(
        &self,
        _req: crate::model::GetConversationModelRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::ConversationModel>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::ConversationModel>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::ConversationModels::list_conversation_models].
    fn list_conversation_models(
        &self,
        _req: crate::model::ListConversationModelsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<
            gax::response::Response<crate::model::ListConversationModelsResponse>,
        >,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ListConversationModelsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::ConversationModels::delete_conversation_model].
    fn delete_conversation_model(
        &self,
        _req: crate::model::DeleteConversationModelRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::ConversationModels::deploy_conversation_model].
    fn deploy_conversation_model(
        &self,
        _req: crate::model::DeployConversationModelRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::ConversationModels::undeploy_conversation_model].
    fn undeploy_conversation_model(
        &self,
        _req: crate::model::UndeployConversationModelRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::ConversationModels::get_conversation_model_evaluation].
    fn get_conversation_model_evaluation(
        &self,
        _req: crate::model::GetConversationModelEvaluationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::ConversationModelEvaluation>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ConversationModelEvaluation>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::ConversationModels::list_conversation_model_evaluations].
    fn list_conversation_model_evaluations(
        &self,
        _req: crate::model::ListConversationModelEvaluationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<
            gax::response::Response<crate::model::ListConversationModelEvaluationsResponse>,
        >,
    > + Send {
        std::future::ready::<
            crate::Result<
                gax::response::Response<crate::model::ListConversationModelEvaluationsResponse>,
            >,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::ConversationModels::create_conversation_model_evaluation].
    fn create_conversation_model_evaluation(
        &self,
        _req: crate::model::CreateConversationModelEvaluationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::ConversationModels::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::ConversationModels::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::Location>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<location::model::Location>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::ConversationModels::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::ConversationModels::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::ConversationModels::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns the polling error policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_error_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        std::sync::Arc::new(gax::polling_error_policy::Aip194Strict)
    }

    /// Returns the polling backoff policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_backoff_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        std::sync::Arc::new(gax::exponential_backoff::ExponentialBackoff::default())
    }
}

/// Defines the trait used to implement [super::client::ConversationProfiles].
///
/// Application developers may need to implement this trait to mock
/// `client::ConversationProfiles`.  In other use-cases, application developers only
/// use `client::ConversationProfiles` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait ConversationProfiles: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::ConversationProfiles::list_conversation_profiles].
    fn list_conversation_profiles(
        &self,
        _req: crate::model::ListConversationProfilesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<
            gax::response::Response<crate::model::ListConversationProfilesResponse>,
        >,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ListConversationProfilesResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::ConversationProfiles::get_conversation_profile].
    fn get_conversation_profile(
        &self,
        _req: crate::model::GetConversationProfileRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::ConversationProfile>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ConversationProfile>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::ConversationProfiles::create_conversation_profile].
    fn create_conversation_profile(
        &self,
        _req: crate::model::CreateConversationProfileRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::ConversationProfile>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ConversationProfile>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::ConversationProfiles::update_conversation_profile].
    fn update_conversation_profile(
        &self,
        _req: crate::model::UpdateConversationProfileRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::ConversationProfile>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ConversationProfile>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::ConversationProfiles::delete_conversation_profile].
    fn delete_conversation_profile(
        &self,
        _req: crate::model::DeleteConversationProfileRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::ConversationProfiles::set_suggestion_feature_config].
    fn set_suggestion_feature_config(
        &self,
        _req: crate::model::SetSuggestionFeatureConfigRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::ConversationProfiles::clear_suggestion_feature_config].
    fn clear_suggestion_feature_config(
        &self,
        _req: crate::model::ClearSuggestionFeatureConfigRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::ConversationProfiles::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::ConversationProfiles::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::Location>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<location::model::Location>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::ConversationProfiles::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::ConversationProfiles::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::ConversationProfiles::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns the polling error policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_error_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        std::sync::Arc::new(gax::polling_error_policy::Aip194Strict)
    }

    /// Returns the polling backoff policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_backoff_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        std::sync::Arc::new(gax::exponential_backoff::ExponentialBackoff::default())
    }
}

/// Defines the trait used to implement [super::client::Documents].
///
/// Application developers may need to implement this trait to mock
/// `client::Documents`.  In other use-cases, application developers only
/// use `client::Documents` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Documents: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::Documents::list_documents].
    fn list_documents(
        &self,
        _req: crate::model::ListDocumentsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::ListDocumentsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ListDocumentsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Documents::get_document].
    fn get_document(
        &self,
        _req: crate::model::GetDocumentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Document>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Document>>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [super::client::Documents::create_document].
    fn create_document(
        &self,
        _req: crate::model::CreateDocumentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Documents::import_documents].
    fn import_documents(
        &self,
        _req: crate::model::ImportDocumentsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Documents::delete_document].
    fn delete_document(
        &self,
        _req: crate::model::DeleteDocumentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Documents::update_document].
    fn update_document(
        &self,
        _req: crate::model::UpdateDocumentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Documents::reload_document].
    fn reload_document(
        &self,
        _req: crate::model::ReloadDocumentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Documents::export_document].
    fn export_document(
        &self,
        _req: crate::model::ExportDocumentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Documents::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Documents::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::Location>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<location::model::Location>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Documents::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Documents::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Documents::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns the polling error policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_error_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        std::sync::Arc::new(gax::polling_error_policy::Aip194Strict)
    }

    /// Returns the polling backoff policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_backoff_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        std::sync::Arc::new(gax::exponential_backoff::ExponentialBackoff::default())
    }
}

/// Defines the trait used to implement [super::client::EncryptionSpecService].
///
/// Application developers may need to implement this trait to mock
/// `client::EncryptionSpecService`.  In other use-cases, application developers only
/// use `client::EncryptionSpecService` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait EncryptionSpecService: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::EncryptionSpecService::get_encryption_spec].
    fn get_encryption_spec(
        &self,
        _req: crate::model::GetEncryptionSpecRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::EncryptionSpec>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::EncryptionSpec>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::EncryptionSpecService::initialize_encryption_spec].
    fn initialize_encryption_spec(
        &self,
        _req: crate::model::InitializeEncryptionSpecRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::EncryptionSpecService::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::EncryptionSpecService::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::Location>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<location::model::Location>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::EncryptionSpecService::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::EncryptionSpecService::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::EncryptionSpecService::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns the polling error policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_error_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        std::sync::Arc::new(gax::polling_error_policy::Aip194Strict)
    }

    /// Returns the polling backoff policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_backoff_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        std::sync::Arc::new(gax::exponential_backoff::ExponentialBackoff::default())
    }
}

/// Defines the trait used to implement [super::client::EntityTypes].
///
/// Application developers may need to implement this trait to mock
/// `client::EntityTypes`.  In other use-cases, application developers only
/// use `client::EntityTypes` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait EntityTypes: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::EntityTypes::list_entity_types].
    fn list_entity_types(
        &self,
        _req: crate::model::ListEntityTypesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::ListEntityTypesResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ListEntityTypesResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::EntityTypes::get_entity_type].
    fn get_entity_type(
        &self,
        _req: crate::model::GetEntityTypeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::EntityType>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::EntityType>>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [super::client::EntityTypes::create_entity_type].
    fn create_entity_type(
        &self,
        _req: crate::model::CreateEntityTypeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::EntityType>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::EntityType>>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [super::client::EntityTypes::update_entity_type].
    fn update_entity_type(
        &self,
        _req: crate::model::UpdateEntityTypeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::EntityType>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::EntityType>>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [super::client::EntityTypes::delete_entity_type].
    fn delete_entity_type(
        &self,
        _req: crate::model::DeleteEntityTypeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::EntityTypes::batch_update_entity_types].
    fn batch_update_entity_types(
        &self,
        _req: crate::model::BatchUpdateEntityTypesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::EntityTypes::batch_delete_entity_types].
    fn batch_delete_entity_types(
        &self,
        _req: crate::model::BatchDeleteEntityTypesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::EntityTypes::batch_create_entities].
    fn batch_create_entities(
        &self,
        _req: crate::model::BatchCreateEntitiesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::EntityTypes::batch_update_entities].
    fn batch_update_entities(
        &self,
        _req: crate::model::BatchUpdateEntitiesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::EntityTypes::batch_delete_entities].
    fn batch_delete_entities(
        &self,
        _req: crate::model::BatchDeleteEntitiesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::EntityTypes::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::EntityTypes::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::Location>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<location::model::Location>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::EntityTypes::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::EntityTypes::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::EntityTypes::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns the polling error policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_error_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        std::sync::Arc::new(gax::polling_error_policy::Aip194Strict)
    }

    /// Returns the polling backoff policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_backoff_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        std::sync::Arc::new(gax::exponential_backoff::ExponentialBackoff::default())
    }
}

/// Defines the trait used to implement [super::client::Environments].
///
/// Application developers may need to implement this trait to mock
/// `client::Environments`.  In other use-cases, application developers only
/// use `client::Environments` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Environments: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::Environments::list_environments].
    fn list_environments(
        &self,
        _req: crate::model::ListEnvironmentsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::ListEnvironmentsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ListEnvironmentsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Environments::get_environment].
    fn get_environment(
        &self,
        _req: crate::model::GetEnvironmentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Environment>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Environment>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Environments::create_environment].
    fn create_environment(
        &self,
        _req: crate::model::CreateEnvironmentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Environment>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Environment>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Environments::update_environment].
    fn update_environment(
        &self,
        _req: crate::model::UpdateEnvironmentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Environment>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Environment>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Environments::delete_environment].
    fn delete_environment(
        &self,
        _req: crate::model::DeleteEnvironmentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::Environments::get_environment_history].
    fn get_environment_history(
        &self,
        _req: crate::model::GetEnvironmentHistoryRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::EnvironmentHistory>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::EnvironmentHistory>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Environments::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Environments::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::Location>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<location::model::Location>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Environments::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Environments::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Environments::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }
}

/// Defines the trait used to implement [super::client::Fulfillments].
///
/// Application developers may need to implement this trait to mock
/// `client::Fulfillments`.  In other use-cases, application developers only
/// use `client::Fulfillments` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Fulfillments: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::Fulfillments::get_fulfillment].
    fn get_fulfillment(
        &self,
        _req: crate::model::GetFulfillmentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Fulfillment>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Fulfillment>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Fulfillments::update_fulfillment].
    fn update_fulfillment(
        &self,
        _req: crate::model::UpdateFulfillmentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Fulfillment>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Fulfillment>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Fulfillments::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Fulfillments::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::Location>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<location::model::Location>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Fulfillments::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Fulfillments::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Fulfillments::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }
}

/// Defines the trait used to implement [super::client::Generators].
///
/// Application developers may need to implement this trait to mock
/// `client::Generators`.  In other use-cases, application developers only
/// use `client::Generators` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Generators: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::Generators::create_generator].
    fn create_generator(
        &self,
        _req: crate::model::CreateGeneratorRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Generator>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Generator>>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [super::client::Generators::get_generator].
    fn get_generator(
        &self,
        _req: crate::model::GetGeneratorRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Generator>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Generator>>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [super::client::Generators::list_generators].
    fn list_generators(
        &self,
        _req: crate::model::ListGeneratorsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::ListGeneratorsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ListGeneratorsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Generators::delete_generator].
    fn delete_generator(
        &self,
        _req: crate::model::DeleteGeneratorRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::Generators::update_generator].
    fn update_generator(
        &self,
        _req: crate::model::UpdateGeneratorRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Generator>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Generator>>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [super::client::Generators::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Generators::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::Location>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<location::model::Location>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Generators::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Generators::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Generators::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }
}

/// Defines the trait used to implement [super::client::Intents].
///
/// Application developers may need to implement this trait to mock
/// `client::Intents`.  In other use-cases, application developers only
/// use `client::Intents` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Intents: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::Intents::list_intents].
    fn list_intents(
        &self,
        _req: crate::model::ListIntentsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::ListIntentsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ListIntentsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Intents::get_intent].
    fn get_intent(
        &self,
        _req: crate::model::GetIntentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Intent>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Intent>>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [super::client::Intents::create_intent].
    fn create_intent(
        &self,
        _req: crate::model::CreateIntentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Intent>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Intent>>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [super::client::Intents::update_intent].
    fn update_intent(
        &self,
        _req: crate::model::UpdateIntentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Intent>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Intent>>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [super::client::Intents::delete_intent].
    fn delete_intent(
        &self,
        _req: crate::model::DeleteIntentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::Intents::batch_update_intents].
    fn batch_update_intents(
        &self,
        _req: crate::model::BatchUpdateIntentsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Intents::batch_delete_intents].
    fn batch_delete_intents(
        &self,
        _req: crate::model::BatchDeleteIntentsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Intents::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Intents::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::Location>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<location::model::Location>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Intents::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Intents::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Intents::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Returns the polling error policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_error_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        std::sync::Arc::new(gax::polling_error_policy::Aip194Strict)
    }

    /// Returns the polling backoff policy.
    ///
    /// When mocking, this method is typically irrelevant. Do not try to verify
    /// it is called by your mocks.
    fn get_polling_backoff_policy(
        &self,
        _options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        std::sync::Arc::new(gax::exponential_backoff::ExponentialBackoff::default())
    }
}

/// Defines the trait used to implement [super::client::KnowledgeBases].
///
/// Application developers may need to implement this trait to mock
/// `client::KnowledgeBases`.  In other use-cases, application developers only
/// use `client::KnowledgeBases` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait KnowledgeBases: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::KnowledgeBases::list_knowledge_bases].
    fn list_knowledge_bases(
        &self,
        _req: crate::model::ListKnowledgeBasesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::ListKnowledgeBasesResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ListKnowledgeBasesResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::KnowledgeBases::get_knowledge_base].
    fn get_knowledge_base(
        &self,
        _req: crate::model::GetKnowledgeBaseRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::KnowledgeBase>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::KnowledgeBase>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::KnowledgeBases::create_knowledge_base].
    fn create_knowledge_base(
        &self,
        _req: crate::model::CreateKnowledgeBaseRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::KnowledgeBase>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::KnowledgeBase>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::KnowledgeBases::delete_knowledge_base].
    fn delete_knowledge_base(
        &self,
        _req: crate::model::DeleteKnowledgeBaseRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::KnowledgeBases::update_knowledge_base].
    fn update_knowledge_base(
        &self,
        _req: crate::model::UpdateKnowledgeBaseRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::KnowledgeBase>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::KnowledgeBase>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::KnowledgeBases::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::KnowledgeBases::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::Location>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<location::model::Location>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::KnowledgeBases::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::KnowledgeBases::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::KnowledgeBases::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }
}

/// Defines the trait used to implement [super::client::Participants].
///
/// Application developers may need to implement this trait to mock
/// `client::Participants`.  In other use-cases, application developers only
/// use `client::Participants` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Participants: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::Participants::create_participant].
    fn create_participant(
        &self,
        _req: crate::model::CreateParticipantRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Participant>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Participant>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Participants::get_participant].
    fn get_participant(
        &self,
        _req: crate::model::GetParticipantRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Participant>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Participant>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Participants::list_participants].
    fn list_participants(
        &self,
        _req: crate::model::ListParticipantsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::ListParticipantsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ListParticipantsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Participants::update_participant].
    fn update_participant(
        &self,
        _req: crate::model::UpdateParticipantRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Participant>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Participant>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Participants::analyze_content].
    fn analyze_content(
        &self,
        _req: crate::model::AnalyzeContentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::AnalyzeContentResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::AnalyzeContentResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Participants::suggest_articles].
    fn suggest_articles(
        &self,
        _req: crate::model::SuggestArticlesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::SuggestArticlesResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::SuggestArticlesResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Participants::suggest_faq_answers].
    fn suggest_faq_answers(
        &self,
        _req: crate::model::SuggestFaqAnswersRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::SuggestFaqAnswersResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::SuggestFaqAnswersResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Participants::suggest_smart_replies].
    fn suggest_smart_replies(
        &self,
        _req: crate::model::SuggestSmartRepliesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::SuggestSmartRepliesResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::SuggestSmartRepliesResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Participants::suggest_knowledge_assist].
    fn suggest_knowledge_assist(
        &self,
        _req: crate::model::SuggestKnowledgeAssistRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<
            gax::response::Response<crate::model::SuggestKnowledgeAssistResponse>,
        >,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::SuggestKnowledgeAssistResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Participants::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Participants::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::Location>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<location::model::Location>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Participants::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Participants::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Participants::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }
}

/// Defines the trait used to implement [super::client::Sessions].
///
/// Application developers may need to implement this trait to mock
/// `client::Sessions`.  In other use-cases, application developers only
/// use `client::Sessions` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Sessions: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::Sessions::detect_intent].
    fn detect_intent(
        &self,
        _req: crate::model::DetectIntentRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::DetectIntentResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::DetectIntentResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Sessions::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Sessions::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::Location>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<location::model::Location>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Sessions::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Sessions::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Sessions::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }
}

/// Defines the trait used to implement [super::client::SessionEntityTypes].
///
/// Application developers may need to implement this trait to mock
/// `client::SessionEntityTypes`.  In other use-cases, application developers only
/// use `client::SessionEntityTypes` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait SessionEntityTypes: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::SessionEntityTypes::list_session_entity_types].
    fn list_session_entity_types(
        &self,
        _req: crate::model::ListSessionEntityTypesRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<
            gax::response::Response<crate::model::ListSessionEntityTypesResponse>,
        >,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ListSessionEntityTypesResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::SessionEntityTypes::get_session_entity_type].
    fn get_session_entity_type(
        &self,
        _req: crate::model::GetSessionEntityTypeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::SessionEntityType>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::SessionEntityType>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::SessionEntityTypes::create_session_entity_type].
    fn create_session_entity_type(
        &self,
        _req: crate::model::CreateSessionEntityTypeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::SessionEntityType>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::SessionEntityType>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::SessionEntityTypes::update_session_entity_type].
    fn update_session_entity_type(
        &self,
        _req: crate::model::UpdateSessionEntityTypeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::SessionEntityType>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::SessionEntityType>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::SessionEntityTypes::delete_session_entity_type].
    fn delete_session_entity_type(
        &self,
        _req: crate::model::DeleteSessionEntityTypeRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::SessionEntityTypes::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::SessionEntityTypes::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::Location>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<location::model::Location>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::SessionEntityTypes::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::SessionEntityTypes::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::SessionEntityTypes::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }
}

/// Defines the trait used to implement [super::client::Versions].
///
/// Application developers may need to implement this trait to mock
/// `client::Versions`.  In other use-cases, application developers only
/// use `client::Versions` and need not be concerned with this trait or
/// its implementations.
///
/// Services gain new RPCs routinely. Consequently, this trait gains new methods
/// too. To avoid breaking applications the trait provides a default
/// implementation of each method. Most of these implementations just return an
/// error.
pub trait Versions: std::fmt::Debug + Send + Sync {
    /// Implements [super::client::Versions::list_versions].
    fn list_versions(
        &self,
        _req: crate::model::ListVersionsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::ListVersionsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<crate::model::ListVersionsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Versions::get_version].
    fn get_version(
        &self,
        _req: crate::model::GetVersionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Version>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Version>>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [super::client::Versions::create_version].
    fn create_version(
        &self,
        _req: crate::model::CreateVersionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Version>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Version>>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [super::client::Versions::update_version].
    fn update_version(
        &self,
        _req: crate::model::UpdateVersionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<crate::model::Version>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<crate::model::Version>>>(Err(
            Error::other("unimplemented"),
        ))
    }

    /// Implements [super::client::Versions::delete_version].
    fn delete_version(
        &self,
        _req: crate::model::DeleteVersionRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }

    /// Implements [super::client::Versions::list_locations].
    fn list_locations(
        &self,
        _req: location::model::ListLocationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<location::model::ListLocationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Versions::get_location].
    fn get_location(
        &self,
        _req: location::model::GetLocationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<location::model::Location>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<location::model::Location>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Versions::list_operations].
    fn list_operations(
        &self,
        _req: longrunning::model::ListOperationsRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
    > + Send {
        std::future::ready::<
            crate::Result<gax::response::Response<longrunning::model::ListOperationsResponse>>,
        >(Err(Error::other("unimplemented")))
    }

    /// Implements [super::client::Versions::get_operation].
    fn get_operation(
        &self,
        _req: longrunning::model::GetOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<
        Output = crate::Result<gax::response::Response<longrunning::model::Operation>>,
    > + Send {
        std::future::ready::<crate::Result<gax::response::Response<longrunning::model::Operation>>>(
            Err(Error::other("unimplemented")),
        )
    }

    /// Implements [super::client::Versions::cancel_operation].
    fn cancel_operation(
        &self,
        _req: longrunning::model::CancelOperationRequest,
        _options: gax::options::RequestOptions,
    ) -> impl std::future::Future<Output = crate::Result<gax::response::Response<()>>> + Send {
        std::future::ready::<crate::Result<gax::response::Response<()>>>(Err(Error::other(
            "unimplemented",
        )))
    }
}
