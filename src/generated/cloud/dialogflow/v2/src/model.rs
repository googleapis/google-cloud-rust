// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A Dialogflow agent is a virtual agent that handles conversations with your
/// end-users. It is a natural language understanding module that understands the
/// nuances of human language. Dialogflow translates end-user text or audio
/// during a conversation to structured data that your apps and services can
/// understand. You design and build a Dialogflow agent to handle the types of
/// conversations required for your system.
///
/// For more information about agents, see the
/// [Agent guide](https://cloud.google.com/dialogflow/docs/agents-overview).
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Agent {
    /// Required. The project of this agent.
    /// Format: `projects/<Project ID>`.
    pub parent: std::string::String,

    /// Required. The name of this agent.
    pub display_name: std::string::String,

    /// Required. The default language of the agent as a language tag. See
    /// [Language
    /// Support](https://cloud.google.com/dialogflow/docs/reference/language)
    /// for a list of the currently supported language codes. This field cannot be
    /// set by the `Update` method.
    pub default_language_code: std::string::String,

    /// Optional. The list of all languages supported by this agent (except for the
    /// `default_language_code`).
    pub supported_language_codes: std::vec::Vec<std::string::String>,

    /// Required. The time zone of this agent from the
    /// [time zone database](https://www.iana.org/time-zones), e.g.,
    /// America/New_York, Europe/Paris.
    pub time_zone: std::string::String,

    /// Optional. The description of this agent.
    /// The maximum length is 500 characters. If exceeded, the request is rejected.
    pub description: std::string::String,

    /// Optional. The URI of the agent's avatar.
    /// Avatars are used throughout the Dialogflow console and in the self-hosted
    /// [Web
    /// Demo](https://cloud.google.com/dialogflow/docs/integrations/web-demo)
    /// integration.
    pub avatar_uri: std::string::String,

    /// Optional. Determines whether this agent should log conversation queries.
    pub enable_logging: bool,

    /// Optional. Determines how intents are detected from user queries.
    #[deprecated]
    pub match_mode: crate::model::agent::MatchMode,

    /// Optional. To filter out false positive results and still get variety in
    /// matched natural language inputs for your agent, you can tune the machine
    /// learning classification threshold. If the returned score value is less than
    /// the threshold value, then a fallback intent will be triggered or, if there
    /// are no fallback intents defined, no intent will be triggered. The score
    /// values range from 0.0 (completely uncertain) to 1.0 (completely certain).
    /// If set to 0.0, the default of 0.3 is used.
    pub classification_threshold: f32,

    /// Optional. API version displayed in Dialogflow console. If not specified,
    /// V2 API is assumed. Clients are free to query different service endpoints
    /// for different API versions. However, bots connectors and webhook calls will
    /// follow the specified API version.
    pub api_version: crate::model::agent::ApiVersion,

    /// Optional. The agent tier. If not specified, TIER_STANDARD is assumed.
    pub tier: crate::model::agent::Tier,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl Agent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::Agent::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Agent::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [default_language_code][crate::model::Agent::default_language_code].
    pub fn set_default_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_language_code = v.into();
        self
    }

    /// Sets the value of [supported_language_codes][crate::model::Agent::supported_language_codes].
    pub fn set_supported_language_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.supported_language_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [time_zone][crate::model::Agent::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Agent::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [avatar_uri][crate::model::Agent::avatar_uri].
    pub fn set_avatar_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.avatar_uri = v.into();
        self
    }

    /// Sets the value of [enable_logging][crate::model::Agent::enable_logging].
    pub fn set_enable_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_logging = v.into();
        self
    }

    /// Sets the value of [match_mode][crate::model::Agent::match_mode].
    #[deprecated]
    pub fn set_match_mode<T: std::convert::Into<crate::model::agent::MatchMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.match_mode = v.into();
        self
    }

    /// Sets the value of [classification_threshold][crate::model::Agent::classification_threshold].
    pub fn set_classification_threshold<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.classification_threshold = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::Agent::api_version].
    pub fn set_api_version<T: std::convert::Into<crate::model::agent::ApiVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of [tier][crate::model::Agent::tier].
    pub fn set_tier<T: std::convert::Into<crate::model::agent::Tier>>(mut self, v: T) -> Self {
        self.tier = v.into();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for Agent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.Agent"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Agent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __display_name,
            __default_language_code,
            __supported_language_codes,
            __time_zone,
            __description,
            __avatar_uri,
            __enable_logging,
            __match_mode,
            __classification_threshold,
            __api_version,
            __tier,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Agent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "defaultLanguageCode" => Ok(__FieldTag::__default_language_code),
                            "default_language_code" => Ok(__FieldTag::__default_language_code),
                            "supportedLanguageCodes" => Ok(__FieldTag::__supported_language_codes),
                            "supported_language_codes" => {
                                Ok(__FieldTag::__supported_language_codes)
                            }
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "description" => Ok(__FieldTag::__description),
                            "avatarUri" => Ok(__FieldTag::__avatar_uri),
                            "avatar_uri" => Ok(__FieldTag::__avatar_uri),
                            "enableLogging" => Ok(__FieldTag::__enable_logging),
                            "enable_logging" => Ok(__FieldTag::__enable_logging),
                            "matchMode" => Ok(__FieldTag::__match_mode),
                            "match_mode" => Ok(__FieldTag::__match_mode),
                            "classificationThreshold" => Ok(__FieldTag::__classification_threshold),
                            "classification_threshold" => {
                                Ok(__FieldTag::__classification_threshold)
                            }
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            "tier" => Ok(__FieldTag::__tier),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Agent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Agent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_language_code => {
                            if !fields.insert(__FieldTag::__default_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_language_code",
                                ));
                            }
                            result.default_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__supported_language_codes => {
                            if !fields.insert(__FieldTag::__supported_language_codes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for supported_language_codes",
                                ));
                            }
                            result.supported_language_codes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__avatar_uri => {
                            if !fields.insert(__FieldTag::__avatar_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for avatar_uri",
                                ));
                            }
                            result.avatar_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_logging => {
                            if !fields.insert(__FieldTag::__enable_logging) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_logging",
                                ));
                            }
                            result.enable_logging = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__match_mode => {
                            if !fields.insert(__FieldTag::__match_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for match_mode",
                                ));
                            }
                            result.match_mode = map
                                .next_value::<std::option::Option<crate::model::agent::MatchMode>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__classification_threshold => {
                            if !fields.insert(__FieldTag::__classification_threshold) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for classification_threshold",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.classification_threshold =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<crate::model::agent::ApiVersion>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tier => {
                            if !fields.insert(__FieldTag::__tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tier",
                                ));
                            }
                            result.tier = map
                                .next_value::<std::option::Option<crate::model::agent::Tier>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for Agent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.default_language_code.is_empty() {
            state.serialize_entry("defaultLanguageCode", &self.default_language_code)?;
        }
        if !self.supported_language_codes.is_empty() {
            state.serialize_entry("supportedLanguageCodes", &self.supported_language_codes)?;
        }
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.avatar_uri.is_empty() {
            state.serialize_entry("avatarUri", &self.avatar_uri)?;
        }
        if !wkt::internal::is_default(&self.enable_logging) {
            state.serialize_entry("enableLogging", &self.enable_logging)?;
        }
        if !wkt::internal::is_default(&self.match_mode) {
            state.serialize_entry("matchMode", &self.match_mode)?;
        }
        if !wkt::internal::is_default(&self.classification_threshold) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "classificationThreshold",
                &__With(&self.classification_threshold),
            )?;
        }
        if !wkt::internal::is_default(&self.api_version) {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !wkt::internal::is_default(&self.tier) {
            state.serialize_entry("tier", &self.tier)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Agent].
#[cfg(feature = "agents")]
pub mod agent {
    #[allow(unused_imports)]
    use super::*;

    /// Match mode determines how intents are detected from user queries.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MatchMode {
        /// Not specified.
        Unspecified,
        /// Best for agents with a small number of examples in intents and/or wide
        /// use of templates syntax and composite entities.
        Hybrid,
        /// Can be used for agents with a large number of examples in intents,
        /// especially the ones using @sys.any or very large custom entities.
        MlOnly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MatchMode::value] or
        /// [MatchMode::name].
        UnknownValue(match_mode::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "agents")]
    pub mod match_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "agents")]
    impl MatchMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Hybrid => std::option::Option::Some(1),
                Self::MlOnly => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MATCH_MODE_UNSPECIFIED"),
                Self::Hybrid => std::option::Option::Some("MATCH_MODE_HYBRID"),
                Self::MlOnly => std::option::Option::Some("MATCH_MODE_ML_ONLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl std::default::Default for MatchMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "agents")]
    impl std::fmt::Display for MatchMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "agents")]
    impl std::convert::From<i32> for MatchMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Hybrid,
                2 => Self::MlOnly,
                _ => Self::UnknownValue(match_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl std::convert::From<&str> for MatchMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MATCH_MODE_UNSPECIFIED" => Self::Unspecified,
                "MATCH_MODE_HYBRID" => Self::Hybrid,
                "MATCH_MODE_ML_ONLY" => Self::MlOnly,
                _ => Self::UnknownValue(match_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl serde::ser::Serialize for MatchMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Hybrid => serializer.serialize_i32(1),
                Self::MlOnly => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl<'de> serde::de::Deserialize<'de> for MatchMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MatchMode>::new(
                ".google.cloud.dialogflow.v2.Agent.MatchMode",
            ))
        }
    }

    /// API version for the agent.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ApiVersion {
        /// Not specified.
        Unspecified,
        /// Legacy V1 API.
        V1,
        /// V2 API.
        V2,
        /// V2beta1 API.
        V2Beta1,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ApiVersion::value] or
        /// [ApiVersion::name].
        UnknownValue(api_version::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "agents")]
    pub mod api_version {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "agents")]
    impl ApiVersion {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::V1 => std::option::Option::Some(1),
                Self::V2 => std::option::Option::Some(2),
                Self::V2Beta1 => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("API_VERSION_UNSPECIFIED"),
                Self::V1 => std::option::Option::Some("API_VERSION_V1"),
                Self::V2 => std::option::Option::Some("API_VERSION_V2"),
                Self::V2Beta1 => std::option::Option::Some("API_VERSION_V2_BETA_1"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl std::default::Default for ApiVersion {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "agents")]
    impl std::fmt::Display for ApiVersion {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "agents")]
    impl std::convert::From<i32> for ApiVersion {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::V1,
                2 => Self::V2,
                3 => Self::V2Beta1,
                _ => Self::UnknownValue(api_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl std::convert::From<&str> for ApiVersion {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "API_VERSION_UNSPECIFIED" => Self::Unspecified,
                "API_VERSION_V1" => Self::V1,
                "API_VERSION_V2" => Self::V2,
                "API_VERSION_V2_BETA_1" => Self::V2Beta1,
                _ => Self::UnknownValue(api_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl serde::ser::Serialize for ApiVersion {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::V1 => serializer.serialize_i32(1),
                Self::V2 => serializer.serialize_i32(2),
                Self::V2Beta1 => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl<'de> serde::de::Deserialize<'de> for ApiVersion {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ApiVersion>::new(
                ".google.cloud.dialogflow.v2.Agent.ApiVersion",
            ))
        }
    }

    /// Represents the agent tier.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Tier {
        /// Not specified. This value should never be used.
        Unspecified,
        /// Trial Edition, previously known as Standard Edition.
        Standard,
        /// Essentials Edition, previously known as Enterprise Essential Edition.
        Enterprise,
        /// Essentials Edition (same as TIER_ENTERPRISE), previously known as
        /// Enterprise Plus Edition.
        #[deprecated]
        EnterprisePlus,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Tier::value] or
        /// [Tier::name].
        UnknownValue(tier::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "agents")]
    pub mod tier {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "agents")]
    impl Tier {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Standard => std::option::Option::Some(1),
                Self::Enterprise => std::option::Option::Some(2),
                Self::EnterprisePlus => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TIER_UNSPECIFIED"),
                Self::Standard => std::option::Option::Some("TIER_STANDARD"),
                Self::Enterprise => std::option::Option::Some("TIER_ENTERPRISE"),
                Self::EnterprisePlus => std::option::Option::Some("TIER_ENTERPRISE_PLUS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl std::default::Default for Tier {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "agents")]
    impl std::fmt::Display for Tier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "agents")]
    impl std::convert::From<i32> for Tier {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Standard,
                2 => Self::Enterprise,
                3 => Self::EnterprisePlus,
                _ => Self::UnknownValue(tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl std::convert::From<&str> for Tier {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TIER_UNSPECIFIED" => Self::Unspecified,
                "TIER_STANDARD" => Self::Standard,
                "TIER_ENTERPRISE" => Self::Enterprise,
                "TIER_ENTERPRISE_PLUS" => Self::EnterprisePlus,
                _ => Self::UnknownValue(tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl serde::ser::Serialize for Tier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Standard => serializer.serialize_i32(1),
                Self::Enterprise => serializer.serialize_i32(2),
                Self::EnterprisePlus => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl<'de> serde::de::Deserialize<'de> for Tier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Tier>::new(
                ".google.cloud.dialogflow.v2.Agent.Tier",
            ))
        }
    }
}

/// The request message for
/// [Agents.GetAgent][google.cloud.dialogflow.v2.Agents.GetAgent].
///
/// [google.cloud.dialogflow.v2.Agents.GetAgent]: crate::client::Agents::get_agent
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAgentRequest {
    /// Required. The project that the agent to fetch is associated with.
    /// Format: `projects/<Project ID>`.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl GetAgentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GetAgentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for GetAgentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetAgentRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for GetAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Agents.SetAgent][google.cloud.dialogflow.v2.Agents.SetAgent].
///
/// [google.cloud.dialogflow.v2.Agents.SetAgent]: crate::client::Agents::set_agent
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SetAgentRequest {
    /// Required. The agent to update.
    pub agent: std::option::Option<crate::model::Agent>,

    /// Optional. The mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl SetAgentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [agent][crate::model::SetAgentRequest::agent].
    pub fn set_agent<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Agent>,
    {
        self.agent = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [agent][crate::model::SetAgentRequest::agent].
    pub fn set_or_clear_agent<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Agent>,
    {
        self.agent = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::SetAgentRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::SetAgentRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for SetAgentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SetAgentRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agent,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agent" => Ok(__FieldTag::__agent),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agent => {
                            if !fields.insert(__FieldTag::__agent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent",
                                ));
                            }
                            result.agent =
                                map.next_value::<std::option::Option<crate::model::Agent>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for SetAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.agent.is_some() {
            state.serialize_entry("agent", &self.agent)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Agents.DeleteAgent][google.cloud.dialogflow.v2.Agents.DeleteAgent].
///
/// [google.cloud.dialogflow.v2.Agents.DeleteAgent]: crate::client::Agents::delete_agent
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAgentRequest {
    /// Required. The project that the agent to delete is associated with.
    /// Format: `projects/<Project ID>`.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl DeleteAgentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::DeleteAgentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for DeleteAgentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DeleteAgentRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Agents.SearchAgents][google.cloud.dialogflow.v2.Agents.SearchAgents].
///
/// [google.cloud.dialogflow.v2.Agents.SearchAgents]: crate::client::Agents::search_agents
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchAgentsRequest {
    /// Required. The project to list agents from.
    /// Format: `projects/<Project ID or '-'>`.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl SearchAgentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchAgentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchAgentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchAgentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for SearchAgentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SearchAgentsRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchAgentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchAgentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchAgentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchAgentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for SearchAgentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Agents.SearchAgents][google.cloud.dialogflow.v2.Agents.SearchAgents].
///
/// [google.cloud.dialogflow.v2.Agents.SearchAgents]: crate::client::Agents::search_agents
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchAgentsResponse {
    /// The list of agents. There will be a maximum number of items returned based
    /// on the page_size field in the request.
    pub agents: std::vec::Vec<crate::model::Agent>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl SearchAgentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [agents][crate::model::SearchAgentsResponse::agents].
    pub fn set_agents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Agent>,
    {
        use std::iter::Iterator;
        self.agents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchAgentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for SearchAgentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SearchAgentsResponse"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchAgentsResponse {
    type PageItem = crate::model::Agent;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.agents
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchAgentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agents,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchAgentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agents" => Ok(__FieldTag::__agents),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchAgentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchAgentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agents => {
                            if !fields.insert(__FieldTag::__agents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agents",
                                ));
                            }
                            result.agents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Agent>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for SearchAgentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.agents.is_empty() {
            state.serialize_entry("agents", &self.agents)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Agents.TrainAgent][google.cloud.dialogflow.v2.Agents.TrainAgent].
///
/// [google.cloud.dialogflow.v2.Agents.TrainAgent]: crate::client::Agents::train_agent
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TrainAgentRequest {
    /// Required. The project that the agent to train is associated with.
    /// Format: `projects/<Project ID>`.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl TrainAgentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::TrainAgentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for TrainAgentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.TrainAgentRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TrainAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TrainAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TrainAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TrainAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for TrainAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Agents.ExportAgent][google.cloud.dialogflow.v2.Agents.ExportAgent].
///
/// [google.cloud.dialogflow.v2.Agents.ExportAgent]: crate::client::Agents::export_agent
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportAgentRequest {
    /// Required. The project that the agent to export is associated with.
    /// Format: `projects/<Project ID>`.
    pub parent: std::string::String,

    /// Required. The [Google Cloud
    /// Storage](https://cloud.google.com/storage/docs/) URI to export the agent
    /// to. The format of this URI must be `gs://<bucket-name>/<object-name>`. If
    /// left unspecified, the serialized agent is returned inline.
    ///
    /// Dialogflow performs a write operation for the Cloud Storage object
    /// on the caller's behalf, so your request authentication must
    /// have write permissions for the object. For more information, see
    /// [Dialogflow access
    /// control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
    pub agent_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl ExportAgentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ExportAgentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [agent_uri][crate::model::ExportAgentRequest::agent_uri].
    pub fn set_agent_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.agent_uri = v.into();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for ExportAgentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ExportAgentRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __agent_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "agentUri" => Ok(__FieldTag::__agent_uri),
                            "agent_uri" => Ok(__FieldTag::__agent_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__agent_uri => {
                            if !fields.insert(__FieldTag::__agent_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_uri",
                                ));
                            }
                            result.agent_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for ExportAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.agent_uri.is_empty() {
            state.serialize_entry("agentUri", &self.agent_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Agents.ExportAgent][google.cloud.dialogflow.v2.Agents.ExportAgent].
///
/// [google.cloud.dialogflow.v2.Agents.ExportAgent]: crate::client::Agents::export_agent
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportAgentResponse {
    /// The exported agent.
    pub agent: std::option::Option<crate::model::export_agent_response::Agent>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl ExportAgentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [agent][crate::model::ExportAgentResponse::agent].
    ///
    /// Note that all the setters affecting `agent` are mutually
    /// exclusive.
    pub fn set_agent<
        T: std::convert::Into<std::option::Option<crate::model::export_agent_response::Agent>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.agent = v.into();
        self
    }

    /// The value of [agent][crate::model::ExportAgentResponse::agent]
    /// if it holds a `AgentUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn agent_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.agent.as_ref().and_then(|v| match v {
            crate::model::export_agent_response::Agent::AgentUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [agent][crate::model::ExportAgentResponse::agent]
    /// to hold a `AgentUri`.
    ///
    /// Note that all the setters affecting `agent` are
    /// mutually exclusive.
    pub fn set_agent_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.agent = std::option::Option::Some(
            crate::model::export_agent_response::Agent::AgentUri(v.into()),
        );
        self
    }

    /// The value of [agent][crate::model::ExportAgentResponse::agent]
    /// if it holds a `AgentContent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn agent_content(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.agent.as_ref().and_then(|v| match v {
            crate::model::export_agent_response::Agent::AgentContent(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [agent][crate::model::ExportAgentResponse::agent]
    /// to hold a `AgentContent`.
    ///
    /// Note that all the setters affecting `agent` are
    /// mutually exclusive.
    pub fn set_agent_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.agent = std::option::Option::Some(
            crate::model::export_agent_response::Agent::AgentContent(v.into()),
        );
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for ExportAgentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ExportAgentResponse"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportAgentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agent_uri,
            __agent_content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportAgentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agentUri" => Ok(__FieldTag::__agent_uri),
                            "agent_uri" => Ok(__FieldTag::__agent_uri),
                            "agentContent" => Ok(__FieldTag::__agent_content),
                            "agent_content" => Ok(__FieldTag::__agent_content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportAgentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportAgentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agent_uri => {
                            if !fields.insert(__FieldTag::__agent_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_uri",
                                ));
                            }
                            if result.agent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent`, a oneof with full ID .google.cloud.dialogflow.v2.ExportAgentResponse.agent_uri, latest field was agentUri",
                                ));
                            }
                            result.agent = std::option::Option::Some(
                                crate::model::export_agent_response::Agent::AgentUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__agent_content => {
                            if !fields.insert(__FieldTag::__agent_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.agent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent`, a oneof with full ID .google.cloud.dialogflow.v2.ExportAgentResponse.agent_content, latest field was agentContent",
                                ));
                            }
                            result.agent = std::option::Option::Some(
                                crate::model::export_agent_response::Agent::AgentContent(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for ExportAgentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.agent_uri() {
            state.serialize_entry("agentUri", value)?;
        }
        if let Some(value) = self.agent_content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("agentContent", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExportAgentResponse].
#[cfg(feature = "agents")]
pub mod export_agent_response {
    #[allow(unused_imports)]
    use super::*;

    /// The exported agent.
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Agent {
        /// The URI to a file containing the exported agent. This field is populated
        /// only if `agent_uri` is specified in `ExportAgentRequest`.
        AgentUri(std::string::String),
        /// Zip compressed raw byte content for agent.
        AgentContent(::bytes::Bytes),
    }
}

/// The request message for
/// [Agents.ImportAgent][google.cloud.dialogflow.v2.Agents.ImportAgent].
///
/// [google.cloud.dialogflow.v2.Agents.ImportAgent]: crate::client::Agents::import_agent
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportAgentRequest {
    /// Required. The project that the agent to import is associated with.
    /// Format: `projects/<Project ID>`.
    pub parent: std::string::String,

    /// Required. The agent to import.
    pub agent: std::option::Option<crate::model::import_agent_request::Agent>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl ImportAgentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportAgentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [agent][crate::model::ImportAgentRequest::agent].
    ///
    /// Note that all the setters affecting `agent` are mutually
    /// exclusive.
    pub fn set_agent<
        T: std::convert::Into<std::option::Option<crate::model::import_agent_request::Agent>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.agent = v.into();
        self
    }

    /// The value of [agent][crate::model::ImportAgentRequest::agent]
    /// if it holds a `AgentUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn agent_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.agent.as_ref().and_then(|v| match v {
            crate::model::import_agent_request::Agent::AgentUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [agent][crate::model::ImportAgentRequest::agent]
    /// to hold a `AgentUri`.
    ///
    /// Note that all the setters affecting `agent` are
    /// mutually exclusive.
    pub fn set_agent_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.agent = std::option::Option::Some(
            crate::model::import_agent_request::Agent::AgentUri(v.into()),
        );
        self
    }

    /// The value of [agent][crate::model::ImportAgentRequest::agent]
    /// if it holds a `AgentContent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn agent_content(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.agent.as_ref().and_then(|v| match v {
            crate::model::import_agent_request::Agent::AgentContent(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [agent][crate::model::ImportAgentRequest::agent]
    /// to hold a `AgentContent`.
    ///
    /// Note that all the setters affecting `agent` are
    /// mutually exclusive.
    pub fn set_agent_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.agent = std::option::Option::Some(
            crate::model::import_agent_request::Agent::AgentContent(v.into()),
        );
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for ImportAgentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ImportAgentRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __agent_uri,
            __agent_content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "agentUri" => Ok(__FieldTag::__agent_uri),
                            "agent_uri" => Ok(__FieldTag::__agent_uri),
                            "agentContent" => Ok(__FieldTag::__agent_content),
                            "agent_content" => Ok(__FieldTag::__agent_content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__agent_uri => {
                            if !fields.insert(__FieldTag::__agent_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_uri",
                                ));
                            }
                            if result.agent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent`, a oneof with full ID .google.cloud.dialogflow.v2.ImportAgentRequest.agent_uri, latest field was agentUri",
                                ));
                            }
                            result.agent = std::option::Option::Some(
                                crate::model::import_agent_request::Agent::AgentUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__agent_content => {
                            if !fields.insert(__FieldTag::__agent_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.agent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent`, a oneof with full ID .google.cloud.dialogflow.v2.ImportAgentRequest.agent_content, latest field was agentContent",
                                ));
                            }
                            result.agent = std::option::Option::Some(
                                crate::model::import_agent_request::Agent::AgentContent(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for ImportAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.agent_uri() {
            state.serialize_entry("agentUri", value)?;
        }
        if let Some(value) = self.agent_content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("agentContent", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ImportAgentRequest].
#[cfg(feature = "agents")]
pub mod import_agent_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The agent to import.
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Agent {
        /// The URI to a Google Cloud Storage file containing the agent to import.
        /// Note: The URI must start with "gs://".
        ///
        /// Dialogflow performs a read operation for the Cloud Storage object
        /// on the caller's behalf, so your request authentication must
        /// have read permissions for the object. For more information, see
        /// [Dialogflow access
        /// control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
        AgentUri(std::string::String),
        /// Zip compressed raw byte content for agent.
        AgentContent(::bytes::Bytes),
    }
}

/// The request message for
/// [Agents.RestoreAgent][google.cloud.dialogflow.v2.Agents.RestoreAgent].
///
/// [google.cloud.dialogflow.v2.Agents.RestoreAgent]: crate::client::Agents::restore_agent
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreAgentRequest {
    /// Required. The project that the agent to restore is associated with.
    /// Format: `projects/<Project ID>`.
    pub parent: std::string::String,

    /// Required. The agent to restore.
    pub agent: std::option::Option<crate::model::restore_agent_request::Agent>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl RestoreAgentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RestoreAgentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [agent][crate::model::RestoreAgentRequest::agent].
    ///
    /// Note that all the setters affecting `agent` are mutually
    /// exclusive.
    pub fn set_agent<
        T: std::convert::Into<std::option::Option<crate::model::restore_agent_request::Agent>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.agent = v.into();
        self
    }

    /// The value of [agent][crate::model::RestoreAgentRequest::agent]
    /// if it holds a `AgentUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn agent_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.agent.as_ref().and_then(|v| match v {
            crate::model::restore_agent_request::Agent::AgentUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [agent][crate::model::RestoreAgentRequest::agent]
    /// to hold a `AgentUri`.
    ///
    /// Note that all the setters affecting `agent` are
    /// mutually exclusive.
    pub fn set_agent_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.agent = std::option::Option::Some(
            crate::model::restore_agent_request::Agent::AgentUri(v.into()),
        );
        self
    }

    /// The value of [agent][crate::model::RestoreAgentRequest::agent]
    /// if it holds a `AgentContent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn agent_content(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.agent.as_ref().and_then(|v| match v {
            crate::model::restore_agent_request::Agent::AgentContent(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [agent][crate::model::RestoreAgentRequest::agent]
    /// to hold a `AgentContent`.
    ///
    /// Note that all the setters affecting `agent` are
    /// mutually exclusive.
    pub fn set_agent_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.agent = std::option::Option::Some(
            crate::model::restore_agent_request::Agent::AgentContent(v.into()),
        );
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for RestoreAgentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.RestoreAgentRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestoreAgentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __agent_uri,
            __agent_content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreAgentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "agentUri" => Ok(__FieldTag::__agent_uri),
                            "agent_uri" => Ok(__FieldTag::__agent_uri),
                            "agentContent" => Ok(__FieldTag::__agent_content),
                            "agent_content" => Ok(__FieldTag::__agent_content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestoreAgentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreAgentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__agent_uri => {
                            if !fields.insert(__FieldTag::__agent_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_uri",
                                ));
                            }
                            if result.agent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent`, a oneof with full ID .google.cloud.dialogflow.v2.RestoreAgentRequest.agent_uri, latest field was agentUri",
                                ));
                            }
                            result.agent = std::option::Option::Some(
                                crate::model::restore_agent_request::Agent::AgentUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__agent_content => {
                            if !fields.insert(__FieldTag::__agent_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.agent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent`, a oneof with full ID .google.cloud.dialogflow.v2.RestoreAgentRequest.agent_content, latest field was agentContent",
                                ));
                            }
                            result.agent = std::option::Option::Some(
                                crate::model::restore_agent_request::Agent::AgentContent(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for RestoreAgentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.agent_uri() {
            state.serialize_entry("agentUri", value)?;
        }
        if let Some(value) = self.agent_content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("agentContent", &__With(value))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RestoreAgentRequest].
#[cfg(feature = "agents")]
pub mod restore_agent_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The agent to restore.
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Agent {
        /// The URI to a Google Cloud Storage file containing the agent to restore.
        /// Note: The URI must start with "gs://".
        ///
        /// Dialogflow performs a read operation for the Cloud Storage object
        /// on the caller's behalf, so your request authentication must
        /// have read permissions for the object. For more information, see
        /// [Dialogflow access
        /// control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
        AgentUri(std::string::String),
        /// Zip compressed raw byte content for agent.
        AgentContent(::bytes::Bytes),
    }
}

/// The request message for
/// [Agents.GetValidationResult][google.cloud.dialogflow.v2.Agents.GetValidationResult].
///
/// [google.cloud.dialogflow.v2.Agents.GetValidationResult]: crate::client::Agents::get_validation_result
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetValidationResultRequest {
    /// Required. The project that the agent is associated with.
    /// Format: `projects/<Project ID>`.
    pub parent: std::string::String,

    /// Optional. The language for which you want a validation result. If not
    /// specified, the agent's default language is used. [Many
    /// languages](https://cloud.google.com/dialogflow/docs/reference/language)
    /// are supported. Note: languages must be enabled in the agent before they can
    /// be used.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl GetValidationResultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GetValidationResultRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::GetValidationResultRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for GetValidationResultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetValidationResultRequest"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetValidationResultRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetValidationResultRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetValidationResultRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetValidationResultRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for GetValidationResultRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Answer records are records to manage answer history and feedbacks for
/// Dialogflow.
///
/// Currently, answer record includes:
///
/// - human agent assistant article suggestion
/// - human agent assistant faq article
///
/// It doesn't include:
///
/// - `DetectIntent` intent matching
/// - `DetectIntent` knowledge
///
/// Answer records are not related to the conversation history in the
/// Dialogflow Console. A Record is generated even when the end-user disables
/// conversation history in the console. Records are created when there's a human
/// agent assistant suggestion generated.
///
/// A typical workflow for customers provide feedback to an answer is:
///
/// 1. For human agent assistant, customers get suggestion via ListSuggestions
///    API. Together with the answers,
///    [AnswerRecord.name][google.cloud.dialogflow.v2.AnswerRecord.name] are
///    returned to the customers.
/// 1. The customer uses the
///    [AnswerRecord.name][google.cloud.dialogflow.v2.AnswerRecord.name] to call the
///    [AnswerRecords.UpdateAnswerRecord][google.cloud.dialogflow.v2.AnswerRecords.UpdateAnswerRecord]
///    method to send feedback about a specific answer that they believe is
///    wrong.
///
/// [google.cloud.dialogflow.v2.AnswerRecord.name]: crate::model::AnswerRecord::name
/// [google.cloud.dialogflow.v2.AnswerRecords.UpdateAnswerRecord]: crate::client::AnswerRecords::update_answer_record
#[cfg(feature = "answer-records")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AnswerRecord {
    /// The unique identifier of this answer record.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/answerRecords/<Answer Record ID>`.
    pub name: std::string::String,

    /// Required. The AnswerFeedback for this record. You can set this with
    /// [AnswerRecords.UpdateAnswerRecord][google.cloud.dialogflow.v2.AnswerRecords.UpdateAnswerRecord]
    /// in order to give us feedback about this answer.
    ///
    /// [google.cloud.dialogflow.v2.AnswerRecords.UpdateAnswerRecord]: crate::client::AnswerRecords::update_answer_record
    pub answer_feedback: std::option::Option<crate::model::AnswerFeedback>,

    /// The record for this answer.
    pub record: std::option::Option<crate::model::answer_record::Record>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "answer-records")]
impl AnswerRecord {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AnswerRecord::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [answer_feedback][crate::model::AnswerRecord::answer_feedback].
    pub fn set_answer_feedback<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnswerFeedback>,
    {
        self.answer_feedback = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [answer_feedback][crate::model::AnswerRecord::answer_feedback].
    pub fn set_or_clear_answer_feedback<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AnswerFeedback>,
    {
        self.answer_feedback = v.map(|x| x.into());
        self
    }

    /// Sets the value of [record][crate::model::AnswerRecord::record].
    ///
    /// Note that all the setters affecting `record` are mutually
    /// exclusive.
    pub fn set_record<
        T: std::convert::Into<std::option::Option<crate::model::answer_record::Record>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.record = v.into();
        self
    }

    /// The value of [record][crate::model::AnswerRecord::record]
    /// if it holds a `AgentAssistantRecord`, `None` if the field is not set or
    /// holds a different branch.
    pub fn agent_assistant_record(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AgentAssistantRecord>> {
        #[allow(unreachable_patterns)]
        self.record.as_ref().and_then(|v| match v {
            crate::model::answer_record::Record::AgentAssistantRecord(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [record][crate::model::AnswerRecord::record]
    /// to hold a `AgentAssistantRecord`.
    ///
    /// Note that all the setters affecting `record` are
    /// mutually exclusive.
    pub fn set_agent_assistant_record<
        T: std::convert::Into<std::boxed::Box<crate::model::AgentAssistantRecord>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.record = std::option::Option::Some(
            crate::model::answer_record::Record::AgentAssistantRecord(v.into()),
        );
        self
    }
}

#[cfg(feature = "answer-records")]
impl wkt::message::Message for AnswerRecord {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.AnswerRecord"
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnswerRecord {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __answer_feedback,
            __agent_assistant_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnswerRecord")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "answerFeedback" => Ok(__FieldTag::__answer_feedback),
                            "answer_feedback" => Ok(__FieldTag::__answer_feedback),
                            "agentAssistantRecord" => Ok(__FieldTag::__agent_assistant_record),
                            "agent_assistant_record" => Ok(__FieldTag::__agent_assistant_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnswerRecord;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnswerRecord")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__answer_feedback => {
                            if !fields.insert(__FieldTag::__answer_feedback) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_feedback",
                                ));
                            }
                            result.answer_feedback = map
                                .next_value::<std::option::Option<crate::model::AnswerFeedback>>(
                                )?;
                        }
                        __FieldTag::__agent_assistant_record => {
                            if !fields.insert(__FieldTag::__agent_assistant_record) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_assistant_record",
                                ));
                            }
                            if result.record.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `record`, a oneof with full ID .google.cloud.dialogflow.v2.AnswerRecord.agent_assistant_record, latest field was agentAssistantRecord",
                                ));
                            }
                            result.record = std::option::Option::Some(
                                crate::model::answer_record::Record::AgentAssistantRecord(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AgentAssistantRecord>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for AnswerRecord {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.answer_feedback.is_some() {
            state.serialize_entry("answerFeedback", &self.answer_feedback)?;
        }
        if let Some(value) = self.agent_assistant_record() {
            state.serialize_entry("agentAssistantRecord", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AnswerRecord].
#[cfg(feature = "answer-records")]
pub mod answer_record {
    #[allow(unused_imports)]
    use super::*;

    /// The record for this answer.
    #[cfg(feature = "answer-records")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Record {
        /// Output only. The record for human agent assistant.
        AgentAssistantRecord(std::boxed::Box<crate::model::AgentAssistantRecord>),
    }
}

/// Request message for
/// [AnswerRecords.ListAnswerRecords][google.cloud.dialogflow.v2.AnswerRecords.ListAnswerRecords].
///
/// [google.cloud.dialogflow.v2.AnswerRecords.ListAnswerRecords]: crate::client::AnswerRecords::list_answer_records
#[cfg(feature = "answer-records")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAnswerRecordsRequest {
    /// Required. The project to list all answer records for in reverse
    /// chronological order. Format: `projects/<Project ID>/locations/<Location
    /// ID>`.
    pub parent: std::string::String,

    /// Optional. Filters to restrict results to specific answer records. The
    /// expression has the following syntax:
    ///
    /// ```norust
    /// <field> <operator> <value> [AND <field> <operator> <value>] ...
    /// ```
    ///
    /// The following fields and operators are supported:
    ///
    /// * conversation_id with equals(=) operator
    ///
    /// Examples:
    ///
    /// * `conversation_id=bar` matches answer records in the
    ///   `projects/foo/locations/global/conversations/bar` conversation
    ///   (assuming the parent is `projects/foo/locations/global`).
    ///
    /// For more information about filtering, see
    /// [API Filtering](https://aip.dev/160).
    pub filter: std::string::String,

    /// Optional. The maximum number of records to return in a single page.
    /// The server may return fewer records than this. If unspecified, we use 10.
    /// The maximum is 100.
    pub page_size: i32,

    /// Optional. The
    /// [ListAnswerRecordsResponse.next_page_token][google.cloud.dialogflow.v2.ListAnswerRecordsResponse.next_page_token]
    /// value returned from a previous list request used to continue listing on
    /// the next page.
    ///
    /// [google.cloud.dialogflow.v2.ListAnswerRecordsResponse.next_page_token]: crate::model::ListAnswerRecordsResponse::next_page_token
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "answer-records")]
impl ListAnswerRecordsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAnswerRecordsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListAnswerRecordsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAnswerRecordsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAnswerRecordsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "answer-records")]
impl wkt::message::Message for ListAnswerRecordsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListAnswerRecordsRequest"
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAnswerRecordsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAnswerRecordsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAnswerRecordsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAnswerRecordsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for ListAnswerRecordsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [AnswerRecords.ListAnswerRecords][google.cloud.dialogflow.v2.AnswerRecords.ListAnswerRecords].
///
/// [google.cloud.dialogflow.v2.AnswerRecords.ListAnswerRecords]: crate::client::AnswerRecords::list_answer_records
#[cfg(feature = "answer-records")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAnswerRecordsResponse {
    /// The list of answer records.
    pub answer_records: std::vec::Vec<crate::model::AnswerRecord>,

    /// A token to retrieve next page of results. Or empty if there are no more
    /// results.
    /// Pass this value in the
    /// [ListAnswerRecordsRequest.page_token][google.cloud.dialogflow.v2.ListAnswerRecordsRequest.page_token]
    /// field in the subsequent call to `ListAnswerRecords` method to retrieve the
    /// next page of results.
    ///
    /// [google.cloud.dialogflow.v2.ListAnswerRecordsRequest.page_token]: crate::model::ListAnswerRecordsRequest::page_token
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "answer-records")]
impl ListAnswerRecordsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [answer_records][crate::model::ListAnswerRecordsResponse::answer_records].
    pub fn set_answer_records<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AnswerRecord>,
    {
        use std::iter::Iterator;
        self.answer_records = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAnswerRecordsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "answer-records")]
impl wkt::message::Message for ListAnswerRecordsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListAnswerRecordsResponse"
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAnswerRecordsResponse {
    type PageItem = crate::model::AnswerRecord;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.answer_records
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAnswerRecordsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answer_records,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAnswerRecordsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answerRecords" => Ok(__FieldTag::__answer_records),
                            "answer_records" => Ok(__FieldTag::__answer_records),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAnswerRecordsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAnswerRecordsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answer_records => {
                            if !fields.insert(__FieldTag::__answer_records) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_records",
                                ));
                            }
                            result.answer_records = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AnswerRecord>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for ListAnswerRecordsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.answer_records.is_empty() {
            state.serialize_entry("answerRecords", &self.answer_records)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [AnswerRecords.UpdateAnswerRecord][google.cloud.dialogflow.v2.AnswerRecords.UpdateAnswerRecord].
///
/// [google.cloud.dialogflow.v2.AnswerRecords.UpdateAnswerRecord]: crate::client::AnswerRecords::update_answer_record
#[cfg(feature = "answer-records")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAnswerRecordRequest {
    /// Required. Answer record to update.
    pub answer_record: std::option::Option<crate::model::AnswerRecord>,

    /// Required. The mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "answer-records")]
impl UpdateAnswerRecordRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [answer_record][crate::model::UpdateAnswerRecordRequest::answer_record].
    pub fn set_answer_record<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnswerRecord>,
    {
        self.answer_record = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [answer_record][crate::model::UpdateAnswerRecordRequest::answer_record].
    pub fn set_or_clear_answer_record<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AnswerRecord>,
    {
        self.answer_record = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAnswerRecordRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAnswerRecordRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "answer-records")]
impl wkt::message::Message for UpdateAnswerRecordRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.UpdateAnswerRecordRequest"
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAnswerRecordRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answer_record,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAnswerRecordRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAnswerRecordRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAnswerRecordRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_record",
                                ));
                            }
                            result.answer_record = map
                                .next_value::<std::option::Option<crate::model::AnswerRecord>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateAnswerRecordRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.answer_record.is_some() {
            state.serialize_entry("answerRecord", &self.answer_record)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents feedback the customer has about the quality & correctness of a
/// certain answer in a conversation.
#[cfg(feature = "answer-records")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AnswerFeedback {
    /// The correctness level of the specific answer.
    pub correctness_level: crate::model::answer_feedback::CorrectnessLevel,

    /// Indicates whether the answer/item was clicked by the human agent
    /// or not. Default to false.
    /// For knowledge search and knowledge assist, the answer record is considered
    /// to be clicked if the answer was copied or any URI was clicked.
    pub clicked: bool,

    /// Time when the answer/item was clicked.
    pub click_time: std::option::Option<wkt::Timestamp>,

    /// Indicates whether the answer/item was displayed to the human
    /// agent in the agent desktop UI. Default to false.
    pub displayed: bool,

    /// Time when the answer/item was displayed.
    pub display_time: std::option::Option<wkt::Timestamp>,

    /// Normally, detail feedback is provided when answer is not fully correct.
    pub detail_feedback: std::option::Option<crate::model::answer_feedback::DetailFeedback>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "answer-records")]
impl AnswerFeedback {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [correctness_level][crate::model::AnswerFeedback::correctness_level].
    pub fn set_correctness_level<
        T: std::convert::Into<crate::model::answer_feedback::CorrectnessLevel>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.correctness_level = v.into();
        self
    }

    /// Sets the value of [clicked][crate::model::AnswerFeedback::clicked].
    pub fn set_clicked<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.clicked = v.into();
        self
    }

    /// Sets the value of [click_time][crate::model::AnswerFeedback::click_time].
    pub fn set_click_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.click_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [click_time][crate::model::AnswerFeedback::click_time].
    pub fn set_or_clear_click_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.click_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [displayed][crate::model::AnswerFeedback::displayed].
    pub fn set_displayed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.displayed = v.into();
        self
    }

    /// Sets the value of [display_time][crate::model::AnswerFeedback::display_time].
    pub fn set_display_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.display_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [display_time][crate::model::AnswerFeedback::display_time].
    pub fn set_or_clear_display_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.display_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [detail_feedback][crate::model::AnswerFeedback::detail_feedback].
    ///
    /// Note that all the setters affecting `detail_feedback` are mutually
    /// exclusive.
    pub fn set_detail_feedback<
        T: std::convert::Into<std::option::Option<crate::model::answer_feedback::DetailFeedback>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.detail_feedback = v.into();
        self
    }

    /// The value of [detail_feedback][crate::model::AnswerFeedback::detail_feedback]
    /// if it holds a `AgentAssistantDetailFeedback`, `None` if the field is not set or
    /// holds a different branch.
    pub fn agent_assistant_detail_feedback(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AgentAssistantFeedback>> {
        #[allow(unreachable_patterns)]
        self.detail_feedback.as_ref().and_then(|v| match v {
            crate::model::answer_feedback::DetailFeedback::AgentAssistantDetailFeedback(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [detail_feedback][crate::model::AnswerFeedback::detail_feedback]
    /// to hold a `AgentAssistantDetailFeedback`.
    ///
    /// Note that all the setters affecting `detail_feedback` are
    /// mutually exclusive.
    pub fn set_agent_assistant_detail_feedback<
        T: std::convert::Into<std::boxed::Box<crate::model::AgentAssistantFeedback>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.detail_feedback = std::option::Option::Some(
            crate::model::answer_feedback::DetailFeedback::AgentAssistantDetailFeedback(v.into()),
        );
        self
    }
}

#[cfg(feature = "answer-records")]
impl wkt::message::Message for AnswerFeedback {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.AnswerFeedback"
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnswerFeedback {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __correctness_level,
            __agent_assistant_detail_feedback,
            __clicked,
            __click_time,
            __displayed,
            __display_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnswerFeedback")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "correctnessLevel" => Ok(__FieldTag::__correctness_level),
                            "correctness_level" => Ok(__FieldTag::__correctness_level),
                            "agentAssistantDetailFeedback" => {
                                Ok(__FieldTag::__agent_assistant_detail_feedback)
                            }
                            "agent_assistant_detail_feedback" => {
                                Ok(__FieldTag::__agent_assistant_detail_feedback)
                            }
                            "clicked" => Ok(__FieldTag::__clicked),
                            "clickTime" => Ok(__FieldTag::__click_time),
                            "click_time" => Ok(__FieldTag::__click_time),
                            "displayed" => Ok(__FieldTag::__displayed),
                            "displayTime" => Ok(__FieldTag::__display_time),
                            "display_time" => Ok(__FieldTag::__display_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnswerFeedback;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnswerFeedback")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__correctness_level => {
                            if !fields.insert(__FieldTag::__correctness_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for correctness_level",
                                ));
                            }
                            result.correctness_level = map
                                .next_value::<std::option::Option<
                                    crate::model::answer_feedback::CorrectnessLevel,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__agent_assistant_detail_feedback => {
                            if !fields.insert(__FieldTag::__agent_assistant_detail_feedback) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_assistant_detail_feedback",
                                ));
                            }
                            if result.detail_feedback.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `detail_feedback`, a oneof with full ID .google.cloud.dialogflow.v2.AnswerFeedback.agent_assistant_detail_feedback, latest field was agentAssistantDetailFeedback",
                                ));
                            }
                            result.detail_feedback = std::option::Option::Some(
                                crate::model::answer_feedback::DetailFeedback::AgentAssistantDetailFeedback(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AgentAssistantFeedback>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__clicked => {
                            if !fields.insert(__FieldTag::__clicked) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clicked",
                                ));
                            }
                            result.clicked = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__click_time => {
                            if !fields.insert(__FieldTag::__click_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for click_time",
                                ));
                            }
                            result.click_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__displayed => {
                            if !fields.insert(__FieldTag::__displayed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for displayed",
                                ));
                            }
                            result.displayed = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_time => {
                            if !fields.insert(__FieldTag::__display_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_time",
                                ));
                            }
                            result.display_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for AnswerFeedback {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.correctness_level) {
            state.serialize_entry("correctnessLevel", &self.correctness_level)?;
        }
        if let Some(value) = self.agent_assistant_detail_feedback() {
            state.serialize_entry("agentAssistantDetailFeedback", value)?;
        }
        if !wkt::internal::is_default(&self.clicked) {
            state.serialize_entry("clicked", &self.clicked)?;
        }
        if self.click_time.is_some() {
            state.serialize_entry("clickTime", &self.click_time)?;
        }
        if !wkt::internal::is_default(&self.displayed) {
            state.serialize_entry("displayed", &self.displayed)?;
        }
        if self.display_time.is_some() {
            state.serialize_entry("displayTime", &self.display_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AnswerFeedback].
#[cfg(feature = "answer-records")]
pub mod answer_feedback {
    #[allow(unused_imports)]
    use super::*;

    /// The correctness level of an answer.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "answer-records")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CorrectnessLevel {
        /// Correctness level unspecified.
        Unspecified,
        /// Answer is totally wrong.
        NotCorrect,
        /// Answer is partially correct.
        PartiallyCorrect,
        /// Answer is fully correct.
        FullyCorrect,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CorrectnessLevel::value] or
        /// [CorrectnessLevel::name].
        UnknownValue(correctness_level::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "answer-records")]
    pub mod correctness_level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "answer-records")]
    impl CorrectnessLevel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NotCorrect => std::option::Option::Some(1),
                Self::PartiallyCorrect => std::option::Option::Some(2),
                Self::FullyCorrect => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CORRECTNESS_LEVEL_UNSPECIFIED"),
                Self::NotCorrect => std::option::Option::Some("NOT_CORRECT"),
                Self::PartiallyCorrect => std::option::Option::Some("PARTIALLY_CORRECT"),
                Self::FullyCorrect => std::option::Option::Some("FULLY_CORRECT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "answer-records")]
    impl std::default::Default for CorrectnessLevel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "answer-records")]
    impl std::fmt::Display for CorrectnessLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "answer-records")]
    impl std::convert::From<i32> for CorrectnessLevel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NotCorrect,
                2 => Self::PartiallyCorrect,
                3 => Self::FullyCorrect,
                _ => Self::UnknownValue(correctness_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "answer-records")]
    impl std::convert::From<&str> for CorrectnessLevel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CORRECTNESS_LEVEL_UNSPECIFIED" => Self::Unspecified,
                "NOT_CORRECT" => Self::NotCorrect,
                "PARTIALLY_CORRECT" => Self::PartiallyCorrect,
                "FULLY_CORRECT" => Self::FullyCorrect,
                _ => Self::UnknownValue(correctness_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "answer-records")]
    impl serde::ser::Serialize for CorrectnessLevel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NotCorrect => serializer.serialize_i32(1),
                Self::PartiallyCorrect => serializer.serialize_i32(2),
                Self::FullyCorrect => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "answer-records")]
    impl<'de> serde::de::Deserialize<'de> for CorrectnessLevel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CorrectnessLevel>::new(
                ".google.cloud.dialogflow.v2.AnswerFeedback.CorrectnessLevel",
            ))
        }
    }

    /// Normally, detail feedback is provided when answer is not fully correct.
    #[cfg(feature = "answer-records")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DetailFeedback {
        /// Detail feedback of agent assist suggestions.
        AgentAssistantDetailFeedback(std::boxed::Box<crate::model::AgentAssistantFeedback>),
    }
}

/// Detail feedback of Agent Assist result.
#[cfg(feature = "answer-records")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AgentAssistantFeedback {
    /// Optional. Whether or not the suggested answer is relevant.
    ///
    /// For example:
    ///
    /// * Query: "Can I change my mailing address?"
    /// * Suggested document says: "Items must be returned/exchanged within 60
    ///   days of the purchase date."
    /// * [answer_relevance][google.cloud.dialogflow.v2.AgentAssistantFeedback.answer_relevance]: [AnswerRelevance.IRRELEVANT][google.cloud.dialogflow.v2.AgentAssistantFeedback.AnswerRelevance.IRRELEVANT]
    ///
    /// [google.cloud.dialogflow.v2.AgentAssistantFeedback.AnswerRelevance.IRRELEVANT]: crate::model::agent_assistant_feedback::AnswerRelevance::Irrelevant
    /// [google.cloud.dialogflow.v2.AgentAssistantFeedback.answer_relevance]: crate::model::AgentAssistantFeedback::answer_relevance
    pub answer_relevance: crate::model::agent_assistant_feedback::AnswerRelevance,

    /// Optional. Whether or not the information in the document is correct.
    ///
    /// For example:
    ///
    /// * Query: "Can I return the package in 2 days once received?"
    /// * Suggested document says: "Items must be returned/exchanged within 60
    ///   days of the purchase date."
    /// * Ground truth: "No return or exchange is allowed."
    /// * [document_correctness][google.cloud.dialogflow.v2.AgentAssistantFeedback.document_correctness]: [INCORRECT][google.cloud.dialogflow.v2.AgentAssistantFeedback.DocumentCorrectness.INCORRECT]
    ///
    /// [google.cloud.dialogflow.v2.AgentAssistantFeedback.DocumentCorrectness.INCORRECT]: crate::model::agent_assistant_feedback::DocumentCorrectness::Incorrect
    /// [google.cloud.dialogflow.v2.AgentAssistantFeedback.document_correctness]: crate::model::AgentAssistantFeedback::document_correctness
    pub document_correctness: crate::model::agent_assistant_feedback::DocumentCorrectness,

    /// Optional. Whether or not the suggested document is efficient. For example,
    /// if the document is poorly written, hard to understand, hard to use or
    /// too long to find useful information,
    /// [document_efficiency][google.cloud.dialogflow.v2.AgentAssistantFeedback.document_efficiency]
    /// is
    /// [DocumentEfficiency.INEFFICIENT][google.cloud.dialogflow.v2.AgentAssistantFeedback.DocumentEfficiency.INEFFICIENT].
    ///
    /// [google.cloud.dialogflow.v2.AgentAssistantFeedback.DocumentEfficiency.INEFFICIENT]: crate::model::agent_assistant_feedback::DocumentEfficiency::Inefficient
    /// [google.cloud.dialogflow.v2.AgentAssistantFeedback.document_efficiency]: crate::model::AgentAssistantFeedback::document_efficiency
    pub document_efficiency: crate::model::agent_assistant_feedback::DocumentEfficiency,

    /// Optional. Feedback for conversation summarization.
    pub summarization_feedback:
        std::option::Option<crate::model::agent_assistant_feedback::SummarizationFeedback>,

    /// Optional. Feedback for knowledge search.
    pub knowledge_search_feedback:
        std::option::Option<crate::model::agent_assistant_feedback::KnowledgeSearchFeedback>,

    /// Optional. Feedback for knowledge assist.
    pub knowledge_assist_feedback:
        std::option::Option<crate::model::agent_assistant_feedback::KnowledgeAssistFeedback>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "answer-records")]
impl AgentAssistantFeedback {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [answer_relevance][crate::model::AgentAssistantFeedback::answer_relevance].
    pub fn set_answer_relevance<
        T: std::convert::Into<crate::model::agent_assistant_feedback::AnswerRelevance>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.answer_relevance = v.into();
        self
    }

    /// Sets the value of [document_correctness][crate::model::AgentAssistantFeedback::document_correctness].
    pub fn set_document_correctness<
        T: std::convert::Into<crate::model::agent_assistant_feedback::DocumentCorrectness>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.document_correctness = v.into();
        self
    }

    /// Sets the value of [document_efficiency][crate::model::AgentAssistantFeedback::document_efficiency].
    pub fn set_document_efficiency<
        T: std::convert::Into<crate::model::agent_assistant_feedback::DocumentEfficiency>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.document_efficiency = v.into();
        self
    }

    /// Sets the value of [summarization_feedback][crate::model::AgentAssistantFeedback::summarization_feedback].
    pub fn set_summarization_feedback<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::agent_assistant_feedback::SummarizationFeedback>,
    {
        self.summarization_feedback = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [summarization_feedback][crate::model::AgentAssistantFeedback::summarization_feedback].
    pub fn set_or_clear_summarization_feedback<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::agent_assistant_feedback::SummarizationFeedback>,
    {
        self.summarization_feedback = v.map(|x| x.into());
        self
    }

    /// Sets the value of [knowledge_search_feedback][crate::model::AgentAssistantFeedback::knowledge_search_feedback].
    pub fn set_knowledge_search_feedback<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::agent_assistant_feedback::KnowledgeSearchFeedback>,
    {
        self.knowledge_search_feedback = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [knowledge_search_feedback][crate::model::AgentAssistantFeedback::knowledge_search_feedback].
    pub fn set_or_clear_knowledge_search_feedback<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::agent_assistant_feedback::KnowledgeSearchFeedback>,
    {
        self.knowledge_search_feedback = v.map(|x| x.into());
        self
    }

    /// Sets the value of [knowledge_assist_feedback][crate::model::AgentAssistantFeedback::knowledge_assist_feedback].
    pub fn set_knowledge_assist_feedback<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::agent_assistant_feedback::KnowledgeAssistFeedback>,
    {
        self.knowledge_assist_feedback = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [knowledge_assist_feedback][crate::model::AgentAssistantFeedback::knowledge_assist_feedback].
    pub fn set_or_clear_knowledge_assist_feedback<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::agent_assistant_feedback::KnowledgeAssistFeedback>,
    {
        self.knowledge_assist_feedback = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "answer-records")]
impl wkt::message::Message for AgentAssistantFeedback {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.AgentAssistantFeedback"
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AgentAssistantFeedback {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answer_relevance,
            __document_correctness,
            __document_efficiency,
            __summarization_feedback,
            __knowledge_search_feedback,
            __knowledge_assist_feedback,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AgentAssistantFeedback")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answerRelevance" => Ok(__FieldTag::__answer_relevance),
                            "answer_relevance" => Ok(__FieldTag::__answer_relevance),
                            "documentCorrectness" => Ok(__FieldTag::__document_correctness),
                            "document_correctness" => Ok(__FieldTag::__document_correctness),
                            "documentEfficiency" => Ok(__FieldTag::__document_efficiency),
                            "document_efficiency" => Ok(__FieldTag::__document_efficiency),
                            "summarizationFeedback" => Ok(__FieldTag::__summarization_feedback),
                            "summarization_feedback" => Ok(__FieldTag::__summarization_feedback),
                            "knowledgeSearchFeedback" => {
                                Ok(__FieldTag::__knowledge_search_feedback)
                            }
                            "knowledge_search_feedback" => {
                                Ok(__FieldTag::__knowledge_search_feedback)
                            }
                            "knowledgeAssistFeedback" => {
                                Ok(__FieldTag::__knowledge_assist_feedback)
                            }
                            "knowledge_assist_feedback" => {
                                Ok(__FieldTag::__knowledge_assist_feedback)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AgentAssistantFeedback;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AgentAssistantFeedback")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answer_relevance => {
                            if !fields.insert(__FieldTag::__answer_relevance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_relevance",
                                ));
                            }
                            result.answer_relevance = map
                                .next_value::<std::option::Option<
                                    crate::model::agent_assistant_feedback::AnswerRelevance,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__document_correctness => {
                            if !fields.insert(__FieldTag::__document_correctness) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_correctness",
                                ));
                            }
                            result.document_correctness = map
                                .next_value::<std::option::Option<
                                    crate::model::agent_assistant_feedback::DocumentCorrectness,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__document_efficiency => {
                            if !fields.insert(__FieldTag::__document_efficiency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_efficiency",
                                ));
                            }
                            result.document_efficiency = map
                                .next_value::<std::option::Option<
                                    crate::model::agent_assistant_feedback::DocumentEfficiency,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__summarization_feedback => {
                            if !fields.insert(__FieldTag::__summarization_feedback) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for summarization_feedback",
                                ));
                            }
                            result.summarization_feedback = map.next_value::<std::option::Option<
                                crate::model::agent_assistant_feedback::SummarizationFeedback,
                            >>()?;
                        }
                        __FieldTag::__knowledge_search_feedback => {
                            if !fields.insert(__FieldTag::__knowledge_search_feedback) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for knowledge_search_feedback",
                                ));
                            }
                            result.knowledge_search_feedback = map
                                .next_value::<std::option::Option<
                                    crate::model::agent_assistant_feedback::KnowledgeSearchFeedback,
                                >>()?;
                        }
                        __FieldTag::__knowledge_assist_feedback => {
                            if !fields.insert(__FieldTag::__knowledge_assist_feedback) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for knowledge_assist_feedback",
                                ));
                            }
                            result.knowledge_assist_feedback = map
                                .next_value::<std::option::Option<
                                    crate::model::agent_assistant_feedback::KnowledgeAssistFeedback,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for AgentAssistantFeedback {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.answer_relevance) {
            state.serialize_entry("answerRelevance", &self.answer_relevance)?;
        }
        if !wkt::internal::is_default(&self.document_correctness) {
            state.serialize_entry("documentCorrectness", &self.document_correctness)?;
        }
        if !wkt::internal::is_default(&self.document_efficiency) {
            state.serialize_entry("documentEfficiency", &self.document_efficiency)?;
        }
        if self.summarization_feedback.is_some() {
            state.serialize_entry("summarizationFeedback", &self.summarization_feedback)?;
        }
        if self.knowledge_search_feedback.is_some() {
            state.serialize_entry("knowledgeSearchFeedback", &self.knowledge_search_feedback)?;
        }
        if self.knowledge_assist_feedback.is_some() {
            state.serialize_entry("knowledgeAssistFeedback", &self.knowledge_assist_feedback)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AgentAssistantFeedback].
#[cfg(feature = "answer-records")]
pub mod agent_assistant_feedback {
    #[allow(unused_imports)]
    use super::*;

    /// Feedback for conversation summarization.
    #[cfg(feature = "answer-records")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SummarizationFeedback {
        /// Timestamp when composing of the summary starts.
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// Timestamp when the summary was submitted.
        pub submit_time: std::option::Option<wkt::Timestamp>,

        /// Text of actual submitted summary.
        pub summary_text: std::string::String,

        /// Optional. Actual text sections of submitted summary.
        pub text_sections: std::collections::HashMap<std::string::String, std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "answer-records")]
    impl SummarizationFeedback {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_time][crate::model::agent_assistant_feedback::SummarizationFeedback::start_time].
        pub fn set_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_time][crate::model::agent_assistant_feedback::SummarizationFeedback::start_time].
        pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [submit_time][crate::model::agent_assistant_feedback::SummarizationFeedback::submit_time].
        pub fn set_submit_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.submit_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [submit_time][crate::model::agent_assistant_feedback::SummarizationFeedback::submit_time].
        pub fn set_or_clear_submit_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.submit_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [summary_text][crate::model::agent_assistant_feedback::SummarizationFeedback::summary_text].
        pub fn set_summary_text<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.summary_text = v.into();
            self
        }

        /// Sets the value of [text_sections][crate::model::agent_assistant_feedback::SummarizationFeedback::text_sections].
        pub fn set_text_sections<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.text_sections = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    #[cfg(feature = "answer-records")]
    impl wkt::message::Message for SummarizationFeedback {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.AgentAssistantFeedback.SummarizationFeedback"
        }
    }

    #[cfg(feature = "answer-records")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SummarizationFeedback {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __start_time,
                __submit_time,
                __summary_text,
                __text_sections,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SummarizationFeedback")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "startTime" => Ok(__FieldTag::__start_time),
                                "start_time" => Ok(__FieldTag::__start_time),
                                "submitTime" => Ok(__FieldTag::__submit_time),
                                "submit_time" => Ok(__FieldTag::__submit_time),
                                "summaryText" => Ok(__FieldTag::__summary_text),
                                "summary_text" => Ok(__FieldTag::__summary_text),
                                "textSections" => Ok(__FieldTag::__text_sections),
                                "text_sections" => Ok(__FieldTag::__text_sections),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SummarizationFeedback;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SummarizationFeedback")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__start_time => {
                                if !fields.insert(__FieldTag::__start_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for start_time",
                                    ));
                                }
                                result.start_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__submit_time => {
                                if !fields.insert(__FieldTag::__submit_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for submit_time",
                                    ));
                                }
                                result.submit_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__summary_text => {
                                if !fields.insert(__FieldTag::__summary_text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for summary_text",
                                    ));
                                }
                                result.summary_text = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__text_sections => {
                                if !fields.insert(__FieldTag::__text_sections) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text_sections",
                                    ));
                                }
                                result.text_sections = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "answer-records")]
    #[doc(hidden)]
    impl serde::ser::Serialize for SummarizationFeedback {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.start_time.is_some() {
                state.serialize_entry("startTime", &self.start_time)?;
            }
            if self.submit_time.is_some() {
                state.serialize_entry("submitTime", &self.submit_time)?;
            }
            if !self.summary_text.is_empty() {
                state.serialize_entry("summaryText", &self.summary_text)?;
            }
            if !self.text_sections.is_empty() {
                state.serialize_entry("textSections", &self.text_sections)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Feedback for knowledge search.
    #[cfg(feature = "answer-records")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct KnowledgeSearchFeedback {
        /// Whether the answer was copied by the human agent or not.
        /// If the value is set to be true,
        /// [AnswerFeedback.clicked][google.cloud.dialogflow.v2.AnswerFeedback.clicked]
        /// will be updated to be true.
        ///
        /// [google.cloud.dialogflow.v2.AnswerFeedback.clicked]: crate::model::AnswerFeedback::clicked
        pub answer_copied: bool,

        /// The URIs clicked by the human agent. The value is appended for each
        /// [UpdateAnswerRecordRequest][google.cloud.dialogflow.v2.UpdateAnswerRecordRequest].
        /// If the value is not empty,
        /// [AnswerFeedback.clicked][google.cloud.dialogflow.v2.AnswerFeedback.clicked]
        /// will be updated to be true.
        ///
        /// [google.cloud.dialogflow.v2.AnswerFeedback.clicked]: crate::model::AnswerFeedback::clicked
        /// [google.cloud.dialogflow.v2.UpdateAnswerRecordRequest]: crate::model::UpdateAnswerRecordRequest
        pub clicked_uris: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "answer-records")]
    impl KnowledgeSearchFeedback {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [answer_copied][crate::model::agent_assistant_feedback::KnowledgeSearchFeedback::answer_copied].
        pub fn set_answer_copied<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.answer_copied = v.into();
            self
        }

        /// Sets the value of [clicked_uris][crate::model::agent_assistant_feedback::KnowledgeSearchFeedback::clicked_uris].
        pub fn set_clicked_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.clicked_uris = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "answer-records")]
    impl wkt::message::Message for KnowledgeSearchFeedback {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.AgentAssistantFeedback.KnowledgeSearchFeedback"
        }
    }

    #[cfg(feature = "answer-records")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for KnowledgeSearchFeedback {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __answer_copied,
                __clicked_uris,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for KnowledgeSearchFeedback")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "answerCopied" => Ok(__FieldTag::__answer_copied),
                                "answer_copied" => Ok(__FieldTag::__answer_copied),
                                "clickedUris" => Ok(__FieldTag::__clicked_uris),
                                "clicked_uris" => Ok(__FieldTag::__clicked_uris),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = KnowledgeSearchFeedback;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct KnowledgeSearchFeedback")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__answer_copied => {
                                if !fields.insert(__FieldTag::__answer_copied) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for answer_copied",
                                    ));
                                }
                                result.answer_copied = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__clicked_uris => {
                                if !fields.insert(__FieldTag::__clicked_uris) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for clicked_uris",
                                    ));
                                }
                                result.clicked_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "answer-records")]
    #[doc(hidden)]
    impl serde::ser::Serialize for KnowledgeSearchFeedback {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.answer_copied) {
                state.serialize_entry("answerCopied", &self.answer_copied)?;
            }
            if !self.clicked_uris.is_empty() {
                state.serialize_entry("clickedUris", &self.clicked_uris)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Feedback for knowledge assist.
    #[cfg(feature = "answer-records")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct KnowledgeAssistFeedback {
        /// Whether the suggested answer was copied by the human agent.
        /// If the value is set to be true,
        /// [AnswerFeedback.clicked][google.cloud.dialogflow.v2.AnswerFeedback.clicked]
        /// will be updated to be true.
        ///
        /// [google.cloud.dialogflow.v2.AnswerFeedback.clicked]: crate::model::AnswerFeedback::clicked
        pub answer_copied: bool,

        /// The URIs clicked by the human agent. The value is appended for each
        /// UpdateAnswerRecordRequest.
        /// If the value is not empty,
        /// [AnswerFeedback.clicked][google.cloud.dialogflow.v2.AnswerFeedback.clicked]
        /// will be updated to be true.
        ///
        /// [google.cloud.dialogflow.v2.AnswerFeedback.clicked]: crate::model::AnswerFeedback::clicked
        pub clicked_uris: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "answer-records")]
    impl KnowledgeAssistFeedback {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [answer_copied][crate::model::agent_assistant_feedback::KnowledgeAssistFeedback::answer_copied].
        pub fn set_answer_copied<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.answer_copied = v.into();
            self
        }

        /// Sets the value of [clicked_uris][crate::model::agent_assistant_feedback::KnowledgeAssistFeedback::clicked_uris].
        pub fn set_clicked_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.clicked_uris = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "answer-records")]
    impl wkt::message::Message for KnowledgeAssistFeedback {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.AgentAssistantFeedback.KnowledgeAssistFeedback"
        }
    }

    #[cfg(feature = "answer-records")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for KnowledgeAssistFeedback {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __answer_copied,
                __clicked_uris,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for KnowledgeAssistFeedback")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "answerCopied" => Ok(__FieldTag::__answer_copied),
                                "answer_copied" => Ok(__FieldTag::__answer_copied),
                                "clickedUris" => Ok(__FieldTag::__clicked_uris),
                                "clicked_uris" => Ok(__FieldTag::__clicked_uris),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = KnowledgeAssistFeedback;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct KnowledgeAssistFeedback")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__answer_copied => {
                                if !fields.insert(__FieldTag::__answer_copied) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for answer_copied",
                                    ));
                                }
                                result.answer_copied = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__clicked_uris => {
                                if !fields.insert(__FieldTag::__clicked_uris) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for clicked_uris",
                                    ));
                                }
                                result.clicked_uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "answer-records")]
    #[doc(hidden)]
    impl serde::ser::Serialize for KnowledgeAssistFeedback {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.answer_copied) {
                state.serialize_entry("answerCopied", &self.answer_copied)?;
            }
            if !self.clicked_uris.is_empty() {
                state.serialize_entry("clickedUris", &self.clicked_uris)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Relevance of an answer.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "answer-records")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AnswerRelevance {
        /// Answer relevance unspecified.
        Unspecified,
        /// Answer is irrelevant to query.
        Irrelevant,
        /// Answer is relevant to query.
        Relevant,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AnswerRelevance::value] or
        /// [AnswerRelevance::name].
        UnknownValue(answer_relevance::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "answer-records")]
    pub mod answer_relevance {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "answer-records")]
    impl AnswerRelevance {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Irrelevant => std::option::Option::Some(1),
                Self::Relevant => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ANSWER_RELEVANCE_UNSPECIFIED"),
                Self::Irrelevant => std::option::Option::Some("IRRELEVANT"),
                Self::Relevant => std::option::Option::Some("RELEVANT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "answer-records")]
    impl std::default::Default for AnswerRelevance {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "answer-records")]
    impl std::fmt::Display for AnswerRelevance {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "answer-records")]
    impl std::convert::From<i32> for AnswerRelevance {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Irrelevant,
                2 => Self::Relevant,
                _ => Self::UnknownValue(answer_relevance::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "answer-records")]
    impl std::convert::From<&str> for AnswerRelevance {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ANSWER_RELEVANCE_UNSPECIFIED" => Self::Unspecified,
                "IRRELEVANT" => Self::Irrelevant,
                "RELEVANT" => Self::Relevant,
                _ => Self::UnknownValue(answer_relevance::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "answer-records")]
    impl serde::ser::Serialize for AnswerRelevance {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Irrelevant => serializer.serialize_i32(1),
                Self::Relevant => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "answer-records")]
    impl<'de> serde::de::Deserialize<'de> for AnswerRelevance {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AnswerRelevance>::new(
                ".google.cloud.dialogflow.v2.AgentAssistantFeedback.AnswerRelevance",
            ))
        }
    }

    /// Correctness of document.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "answer-records")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DocumentCorrectness {
        /// Document correctness unspecified.
        Unspecified,
        /// Information in document is incorrect.
        Incorrect,
        /// Information in document is correct.
        Correct,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DocumentCorrectness::value] or
        /// [DocumentCorrectness::name].
        UnknownValue(document_correctness::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "answer-records")]
    pub mod document_correctness {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "answer-records")]
    impl DocumentCorrectness {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Incorrect => std::option::Option::Some(1),
                Self::Correct => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DOCUMENT_CORRECTNESS_UNSPECIFIED"),
                Self::Incorrect => std::option::Option::Some("INCORRECT"),
                Self::Correct => std::option::Option::Some("CORRECT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "answer-records")]
    impl std::default::Default for DocumentCorrectness {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "answer-records")]
    impl std::fmt::Display for DocumentCorrectness {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "answer-records")]
    impl std::convert::From<i32> for DocumentCorrectness {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Incorrect,
                2 => Self::Correct,
                _ => Self::UnknownValue(document_correctness::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "answer-records")]
    impl std::convert::From<&str> for DocumentCorrectness {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DOCUMENT_CORRECTNESS_UNSPECIFIED" => Self::Unspecified,
                "INCORRECT" => Self::Incorrect,
                "CORRECT" => Self::Correct,
                _ => Self::UnknownValue(document_correctness::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "answer-records")]
    impl serde::ser::Serialize for DocumentCorrectness {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Incorrect => serializer.serialize_i32(1),
                Self::Correct => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "answer-records")]
    impl<'de> serde::de::Deserialize<'de> for DocumentCorrectness {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DocumentCorrectness>::new(
                ".google.cloud.dialogflow.v2.AgentAssistantFeedback.DocumentCorrectness",
            ))
        }
    }

    /// Efficiency of document.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "answer-records")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DocumentEfficiency {
        /// Document efficiency unspecified.
        Unspecified,
        /// Document is inefficient.
        Inefficient,
        /// Document is efficient.
        Efficient,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DocumentEfficiency::value] or
        /// [DocumentEfficiency::name].
        UnknownValue(document_efficiency::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "answer-records")]
    pub mod document_efficiency {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "answer-records")]
    impl DocumentEfficiency {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Inefficient => std::option::Option::Some(1),
                Self::Efficient => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DOCUMENT_EFFICIENCY_UNSPECIFIED"),
                Self::Inefficient => std::option::Option::Some("INEFFICIENT"),
                Self::Efficient => std::option::Option::Some("EFFICIENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "answer-records")]
    impl std::default::Default for DocumentEfficiency {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "answer-records")]
    impl std::fmt::Display for DocumentEfficiency {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "answer-records")]
    impl std::convert::From<i32> for DocumentEfficiency {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Inefficient,
                2 => Self::Efficient,
                _ => Self::UnknownValue(document_efficiency::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "answer-records")]
    impl std::convert::From<&str> for DocumentEfficiency {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DOCUMENT_EFFICIENCY_UNSPECIFIED" => Self::Unspecified,
                "INEFFICIENT" => Self::Inefficient,
                "EFFICIENT" => Self::Efficient,
                _ => Self::UnknownValue(document_efficiency::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "answer-records")]
    impl serde::ser::Serialize for DocumentEfficiency {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Inefficient => serializer.serialize_i32(1),
                Self::Efficient => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "answer-records")]
    impl<'de> serde::de::Deserialize<'de> for DocumentEfficiency {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DocumentEfficiency>::new(
                ".google.cloud.dialogflow.v2.AgentAssistantFeedback.DocumentEfficiency",
            ))
        }
    }
}

/// Represents a record of a human agent assist answer.
#[cfg(feature = "answer-records")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AgentAssistantRecord {
    /// Output only. The agent assist answer.
    pub answer: std::option::Option<crate::model::agent_assistant_record::Answer>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "answer-records")]
impl AgentAssistantRecord {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [answer][crate::model::AgentAssistantRecord::answer].
    ///
    /// Note that all the setters affecting `answer` are mutually
    /// exclusive.
    pub fn set_answer<
        T: std::convert::Into<std::option::Option<crate::model::agent_assistant_record::Answer>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.answer = v.into();
        self
    }

    /// The value of [answer][crate::model::AgentAssistantRecord::answer]
    /// if it holds a `ArticleSuggestionAnswer`, `None` if the field is not set or
    /// holds a different branch.
    pub fn article_suggestion_answer(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ArticleAnswer>> {
        #[allow(unreachable_patterns)]
        self.answer.as_ref().and_then(|v| match v {
            crate::model::agent_assistant_record::Answer::ArticleSuggestionAnswer(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [answer][crate::model::AgentAssistantRecord::answer]
    /// to hold a `ArticleSuggestionAnswer`.
    ///
    /// Note that all the setters affecting `answer` are
    /// mutually exclusive.
    pub fn set_article_suggestion_answer<
        T: std::convert::Into<std::boxed::Box<crate::model::ArticleAnswer>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.answer = std::option::Option::Some(
            crate::model::agent_assistant_record::Answer::ArticleSuggestionAnswer(v.into()),
        );
        self
    }

    /// The value of [answer][crate::model::AgentAssistantRecord::answer]
    /// if it holds a `FaqAnswer`, `None` if the field is not set or
    /// holds a different branch.
    pub fn faq_answer(&self) -> std::option::Option<&std::boxed::Box<crate::model::FaqAnswer>> {
        #[allow(unreachable_patterns)]
        self.answer.as_ref().and_then(|v| match v {
            crate::model::agent_assistant_record::Answer::FaqAnswer(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [answer][crate::model::AgentAssistantRecord::answer]
    /// to hold a `FaqAnswer`.
    ///
    /// Note that all the setters affecting `answer` are
    /// mutually exclusive.
    pub fn set_faq_answer<T: std::convert::Into<std::boxed::Box<crate::model::FaqAnswer>>>(
        mut self,
        v: T,
    ) -> Self {
        self.answer = std::option::Option::Some(
            crate::model::agent_assistant_record::Answer::FaqAnswer(v.into()),
        );
        self
    }

    /// The value of [answer][crate::model::AgentAssistantRecord::answer]
    /// if it holds a `DialogflowAssistAnswer`, `None` if the field is not set or
    /// holds a different branch.
    pub fn dialogflow_assist_answer(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DialogflowAssistAnswer>> {
        #[allow(unreachable_patterns)]
        self.answer.as_ref().and_then(|v| match v {
            crate::model::agent_assistant_record::Answer::DialogflowAssistAnswer(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [answer][crate::model::AgentAssistantRecord::answer]
    /// to hold a `DialogflowAssistAnswer`.
    ///
    /// Note that all the setters affecting `answer` are
    /// mutually exclusive.
    pub fn set_dialogflow_assist_answer<
        T: std::convert::Into<std::boxed::Box<crate::model::DialogflowAssistAnswer>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.answer = std::option::Option::Some(
            crate::model::agent_assistant_record::Answer::DialogflowAssistAnswer(v.into()),
        );
        self
    }
}

#[cfg(feature = "answer-records")]
impl wkt::message::Message for AgentAssistantRecord {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.AgentAssistantRecord"
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AgentAssistantRecord {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __article_suggestion_answer,
            __faq_answer,
            __dialogflow_assist_answer,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AgentAssistantRecord")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "articleSuggestionAnswer" => {
                                Ok(__FieldTag::__article_suggestion_answer)
                            }
                            "article_suggestion_answer" => {
                                Ok(__FieldTag::__article_suggestion_answer)
                            }
                            "faqAnswer" => Ok(__FieldTag::__faq_answer),
                            "faq_answer" => Ok(__FieldTag::__faq_answer),
                            "dialogflowAssistAnswer" => Ok(__FieldTag::__dialogflow_assist_answer),
                            "dialogflow_assist_answer" => {
                                Ok(__FieldTag::__dialogflow_assist_answer)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AgentAssistantRecord;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AgentAssistantRecord")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__article_suggestion_answer => {
                            if !fields.insert(__FieldTag::__article_suggestion_answer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for article_suggestion_answer",
                                ));
                            }
                            if result.answer.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `answer`, a oneof with full ID .google.cloud.dialogflow.v2.AgentAssistantRecord.article_suggestion_answer, latest field was articleSuggestionAnswer",
                                ));
                            }
                            result.answer = std::option::Option::Some(
                                crate::model::agent_assistant_record::Answer::ArticleSuggestionAnswer(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ArticleAnswer>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__faq_answer => {
                            if !fields.insert(__FieldTag::__faq_answer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for faq_answer",
                                ));
                            }
                            if result.answer.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `answer`, a oneof with full ID .google.cloud.dialogflow.v2.AgentAssistantRecord.faq_answer, latest field was faqAnswer",
                                ));
                            }
                            result.answer = std::option::Option::Some(
                                crate::model::agent_assistant_record::Answer::FaqAnswer(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::FaqAnswer>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__dialogflow_assist_answer => {
                            if !fields.insert(__FieldTag::__dialogflow_assist_answer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dialogflow_assist_answer",
                                ));
                            }
                            if result.answer.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `answer`, a oneof with full ID .google.cloud.dialogflow.v2.AgentAssistantRecord.dialogflow_assist_answer, latest field was dialogflowAssistAnswer",
                                ));
                            }
                            result.answer = std::option::Option::Some(
                                crate::model::agent_assistant_record::Answer::DialogflowAssistAnswer(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DialogflowAssistAnswer>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for AgentAssistantRecord {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.article_suggestion_answer() {
            state.serialize_entry("articleSuggestionAnswer", value)?;
        }
        if let Some(value) = self.faq_answer() {
            state.serialize_entry("faqAnswer", value)?;
        }
        if let Some(value) = self.dialogflow_assist_answer() {
            state.serialize_entry("dialogflowAssistAnswer", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AgentAssistantRecord].
#[cfg(feature = "answer-records")]
pub mod agent_assistant_record {
    #[allow(unused_imports)]
    use super::*;

    /// Output only. The agent assist answer.
    #[cfg(feature = "answer-records")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Answer {
        /// Output only. The article suggestion answer.
        ArticleSuggestionAnswer(std::boxed::Box<crate::model::ArticleAnswer>),
        /// Output only. The FAQ answer.
        FaqAnswer(std::boxed::Box<crate::model::FaqAnswer>),
        /// Output only. Dialogflow assist answer.
        DialogflowAssistAnswer(std::boxed::Box<crate::model::DialogflowAssistAnswer>),
    }
}

/// Hints for the speech recognizer to help with recognition in a specific
/// conversation state.
#[cfg(any(feature = "participants", feature = "sessions",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SpeechContext {
    /// Optional. A list of strings containing words and phrases that the speech
    /// recognizer should recognize with higher likelihood.
    ///
    /// This list can be used to:
    ///
    /// * improve accuracy for words and phrases you expect the user to say,
    ///   e.g. typical commands for your Dialogflow agent
    /// * add additional words to the speech recognizer vocabulary
    /// * ...
    ///
    /// See the [Cloud Speech
    /// documentation](https://cloud.google.com/speech-to-text/quotas) for usage
    /// limits.
    pub phrases: std::vec::Vec<std::string::String>,

    /// Optional. Boost for this context compared to other contexts:
    ///
    /// * If the boost is positive, Dialogflow will increase the probability that
    ///   the phrases in this context are recognized over similar sounding phrases.
    /// * If the boost is unspecified or non-positive, Dialogflow will not apply
    ///   any boost.
    ///
    /// Dialogflow recommends that you use boosts in the range (0, 20] and that you
    /// find a value that fits your use case with binary search.
    pub boost: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl SpeechContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [phrases][crate::model::SpeechContext::phrases].
    pub fn set_phrases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.phrases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [boost][crate::model::SpeechContext::boost].
    pub fn set_boost<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.boost = v.into();
        self
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl wkt::message::Message for SpeechContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SpeechContext"
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SpeechContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __phrases,
            __boost,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpeechContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "phrases" => Ok(__FieldTag::__phrases),
                            "boost" => Ok(__FieldTag::__boost),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SpeechContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpeechContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__phrases => {
                            if !fields.insert(__FieldTag::__phrases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrases",
                                ));
                            }
                            result.phrases = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__boost => {
                            if !fields.insert(__FieldTag::__boost) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boost",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.boost = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for SpeechContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.phrases.is_empty() {
            state.serialize_entry("phrases", &self.phrases)?;
        }
        if !wkt::internal::is_default(&self.boost) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("boost", &__With(&self.boost))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information for a word recognized by the speech recognizer.
#[cfg(any(feature = "participants", feature = "sessions",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SpeechWordInfo {
    /// The word this info is for.
    pub word: std::string::String,

    /// Time offset relative to the beginning of the audio that corresponds to the
    /// start of the spoken word. This is an experimental feature and the accuracy
    /// of the time offset can vary.
    pub start_offset: std::option::Option<wkt::Duration>,

    /// Time offset relative to the beginning of the audio that corresponds to the
    /// end of the spoken word. This is an experimental feature and the accuracy of
    /// the time offset can vary.
    pub end_offset: std::option::Option<wkt::Duration>,

    /// The Speech confidence between 0.0 and 1.0 for this word. A higher number
    /// indicates an estimated greater likelihood that the recognized word is
    /// correct. The default of 0.0 is a sentinel value indicating that confidence
    /// was not set.
    ///
    /// This field is not guaranteed to be fully stable over time for the same
    /// audio input. Users should also not rely on it to always be provided.
    pub confidence: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl SpeechWordInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [word][crate::model::SpeechWordInfo::word].
    pub fn set_word<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.word = v.into();
        self
    }

    /// Sets the value of [start_offset][crate::model::SpeechWordInfo::start_offset].
    pub fn set_start_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.start_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_offset][crate::model::SpeechWordInfo::start_offset].
    pub fn set_or_clear_start_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.start_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_offset][crate::model::SpeechWordInfo::end_offset].
    pub fn set_end_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.end_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_offset][crate::model::SpeechWordInfo::end_offset].
    pub fn set_or_clear_end_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.end_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [confidence][crate::model::SpeechWordInfo::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl wkt::message::Message for SpeechWordInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SpeechWordInfo"
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SpeechWordInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __word,
            __start_offset,
            __end_offset,
            __confidence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpeechWordInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "word" => Ok(__FieldTag::__word),
                            "startOffset" => Ok(__FieldTag::__start_offset),
                            "start_offset" => Ok(__FieldTag::__start_offset),
                            "endOffset" => Ok(__FieldTag::__end_offset),
                            "end_offset" => Ok(__FieldTag::__end_offset),
                            "confidence" => Ok(__FieldTag::__confidence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SpeechWordInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpeechWordInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__word => {
                            if !fields.insert(__FieldTag::__word) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for word",
                                ));
                            }
                            result.word = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_offset => {
                            if !fields.insert(__FieldTag::__start_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_offset",
                                ));
                            }
                            result.start_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__end_offset => {
                            if !fields.insert(__FieldTag::__end_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_offset",
                                ));
                            }
                            result.end_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for SpeechWordInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.word.is_empty() {
            state.serialize_entry("word", &self.word)?;
        }
        if self.start_offset.is_some() {
            state.serialize_entry("startOffset", &self.start_offset)?;
        }
        if self.end_offset.is_some() {
            state.serialize_entry("endOffset", &self.end_offset)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instructs the speech recognizer how to process the audio content.
#[cfg(any(feature = "participants", feature = "sessions",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InputAudioConfig {
    /// Required. Audio encoding of the audio content to process.
    pub audio_encoding: crate::model::AudioEncoding,

    /// Required. Sample rate (in Hertz) of the audio content sent in the query.
    /// Refer to [Cloud Speech API
    /// documentation](https://cloud.google.com/speech-to-text/docs/basics) for
    /// more details.
    pub sample_rate_hertz: i32,

    /// Required. The language of the supplied audio. Dialogflow does not do
    /// translations. See [Language
    /// Support](https://cloud.google.com/dialogflow/docs/reference/language)
    /// for a list of the currently supported language codes. Note that queries in
    /// the same session do not necessarily need to specify the same language.
    pub language_code: std::string::String,

    /// If `true`, Dialogflow returns
    /// [SpeechWordInfo][google.cloud.dialogflow.v2.SpeechWordInfo] in
    /// [StreamingRecognitionResult][google.cloud.dialogflow.v2.StreamingRecognitionResult]
    /// with information about the recognized speech words, e.g. start and end time
    /// offsets. If false or unspecified, Speech doesn't return any word-level
    /// information.
    ///
    /// [google.cloud.dialogflow.v2.SpeechWordInfo]: crate::model::SpeechWordInfo
    /// [google.cloud.dialogflow.v2.StreamingRecognitionResult]: crate::model::StreamingRecognitionResult
    pub enable_word_info: bool,

    /// A list of strings containing words and phrases that the speech
    /// recognizer should recognize with higher likelihood.
    ///
    /// See [the Cloud Speech
    /// documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints)
    /// for more details.
    ///
    /// This field is deprecated. Please use [`speech_contexts`]() instead. If you
    /// specify both [`phrase_hints`]() and [`speech_contexts`](), Dialogflow will
    /// treat the [`phrase_hints`]() as a single additional [`SpeechContext`]().
    #[deprecated]
    pub phrase_hints: std::vec::Vec<std::string::String>,

    /// Context information to assist speech recognition.
    ///
    /// See [the Cloud Speech
    /// documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints)
    /// for more details.
    pub speech_contexts: std::vec::Vec<crate::model::SpeechContext>,

    /// Optional. Which Speech model to select for the given request.
    /// For more information, see
    /// [Speech models](https://cloud.google.com/dialogflow/es/docs/speech-models).
    pub model: std::string::String,

    /// Which variant of the [Speech
    /// model][google.cloud.dialogflow.v2.InputAudioConfig.model] to use.
    ///
    /// [google.cloud.dialogflow.v2.InputAudioConfig.model]: crate::model::InputAudioConfig::model
    pub model_variant: crate::model::SpeechModelVariant,

    /// If `false` (default), recognition does not cease until the
    /// client closes the stream.
    /// If `true`, the recognizer will detect a single spoken utterance in input
    /// audio. Recognition ceases when it detects the audio's voice has
    /// stopped or paused. In this case, once a detected intent is received, the
    /// client should close the stream and start a new request with a new stream as
    /// needed.
    /// Note: This setting is relevant only for streaming methods.
    /// Note: When specified, InputAudioConfig.single_utterance takes precedence
    /// over StreamingDetectIntentRequest.single_utterance.
    pub single_utterance: bool,

    /// Only used in
    /// [Participants.AnalyzeContent][google.cloud.dialogflow.v2.Participants.AnalyzeContent]
    /// and
    /// [Participants.StreamingAnalyzeContent][google.cloud.dialogflow.v2.Participants.StreamingAnalyzeContent].
    /// If `false` and recognition doesn't return any result, trigger
    /// `NO_SPEECH_RECOGNIZED` event to Dialogflow agent.
    ///
    /// [google.cloud.dialogflow.v2.Participants.AnalyzeContent]: crate::client::Participants::analyze_content
    pub disable_no_speech_recognized_event: bool,

    /// Enable automatic punctuation option at the speech backend.
    pub enable_automatic_punctuation: bool,

    /// A collection of phrase set resources to use for speech adaptation.
    pub phrase_sets: std::vec::Vec<std::string::String>,

    /// If `true`, the request will opt out for STT conformer model migration.
    /// This field will be deprecated once force migration takes place in June
    /// 2024. Please refer to [Dialogflow ES Speech model
    /// migration](https://cloud.google.com/dialogflow/es/docs/speech-model-migration).
    pub opt_out_conformer_model_migration: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl InputAudioConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audio_encoding][crate::model::InputAudioConfig::audio_encoding].
    pub fn set_audio_encoding<T: std::convert::Into<crate::model::AudioEncoding>>(
        mut self,
        v: T,
    ) -> Self {
        self.audio_encoding = v.into();
        self
    }

    /// Sets the value of [sample_rate_hertz][crate::model::InputAudioConfig::sample_rate_hertz].
    pub fn set_sample_rate_hertz<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.sample_rate_hertz = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::InputAudioConfig::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [enable_word_info][crate::model::InputAudioConfig::enable_word_info].
    pub fn set_enable_word_info<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_word_info = v.into();
        self
    }

    /// Sets the value of [phrase_hints][crate::model::InputAudioConfig::phrase_hints].
    #[deprecated]
    pub fn set_phrase_hints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.phrase_hints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [speech_contexts][crate::model::InputAudioConfig::speech_contexts].
    pub fn set_speech_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SpeechContext>,
    {
        use std::iter::Iterator;
        self.speech_contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [model][crate::model::InputAudioConfig::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [model_variant][crate::model::InputAudioConfig::model_variant].
    pub fn set_model_variant<T: std::convert::Into<crate::model::SpeechModelVariant>>(
        mut self,
        v: T,
    ) -> Self {
        self.model_variant = v.into();
        self
    }

    /// Sets the value of [single_utterance][crate::model::InputAudioConfig::single_utterance].
    pub fn set_single_utterance<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.single_utterance = v.into();
        self
    }

    /// Sets the value of [disable_no_speech_recognized_event][crate::model::InputAudioConfig::disable_no_speech_recognized_event].
    pub fn set_disable_no_speech_recognized_event<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.disable_no_speech_recognized_event = v.into();
        self
    }

    /// Sets the value of [enable_automatic_punctuation][crate::model::InputAudioConfig::enable_automatic_punctuation].
    pub fn set_enable_automatic_punctuation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_automatic_punctuation = v.into();
        self
    }

    /// Sets the value of [phrase_sets][crate::model::InputAudioConfig::phrase_sets].
    pub fn set_phrase_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.phrase_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [opt_out_conformer_model_migration][crate::model::InputAudioConfig::opt_out_conformer_model_migration].
    pub fn set_opt_out_conformer_model_migration<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.opt_out_conformer_model_migration = v.into();
        self
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl wkt::message::Message for InputAudioConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.InputAudioConfig"
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InputAudioConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_encoding,
            __sample_rate_hertz,
            __language_code,
            __enable_word_info,
            __phrase_hints,
            __speech_contexts,
            __model,
            __model_variant,
            __single_utterance,
            __disable_no_speech_recognized_event,
            __enable_automatic_punctuation,
            __phrase_sets,
            __opt_out_conformer_model_migration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InputAudioConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioEncoding" => Ok(__FieldTag::__audio_encoding),
                            "audio_encoding" => Ok(__FieldTag::__audio_encoding),
                            "sampleRateHertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "sample_rate_hertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "enableWordInfo" => Ok(__FieldTag::__enable_word_info),
                            "enable_word_info" => Ok(__FieldTag::__enable_word_info),
                            "phraseHints" => Ok(__FieldTag::__phrase_hints),
                            "phrase_hints" => Ok(__FieldTag::__phrase_hints),
                            "speechContexts" => Ok(__FieldTag::__speech_contexts),
                            "speech_contexts" => Ok(__FieldTag::__speech_contexts),
                            "model" => Ok(__FieldTag::__model),
                            "modelVariant" => Ok(__FieldTag::__model_variant),
                            "model_variant" => Ok(__FieldTag::__model_variant),
                            "singleUtterance" => Ok(__FieldTag::__single_utterance),
                            "single_utterance" => Ok(__FieldTag::__single_utterance),
                            "disableNoSpeechRecognizedEvent" => {
                                Ok(__FieldTag::__disable_no_speech_recognized_event)
                            }
                            "disable_no_speech_recognized_event" => {
                                Ok(__FieldTag::__disable_no_speech_recognized_event)
                            }
                            "enableAutomaticPunctuation" => {
                                Ok(__FieldTag::__enable_automatic_punctuation)
                            }
                            "enable_automatic_punctuation" => {
                                Ok(__FieldTag::__enable_automatic_punctuation)
                            }
                            "phraseSets" => Ok(__FieldTag::__phrase_sets),
                            "phrase_sets" => Ok(__FieldTag::__phrase_sets),
                            "optOutConformerModelMigration" => {
                                Ok(__FieldTag::__opt_out_conformer_model_migration)
                            }
                            "opt_out_conformer_model_migration" => {
                                Ok(__FieldTag::__opt_out_conformer_model_migration)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InputAudioConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InputAudioConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_encoding => {
                            if !fields.insert(__FieldTag::__audio_encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_encoding",
                                ));
                            }
                            result.audio_encoding = map
                                .next_value::<std::option::Option<crate::model::AudioEncoding>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sample_rate_hertz => {
                            if !fields.insert(__FieldTag::__sample_rate_hertz) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_rate_hertz",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sample_rate_hertz =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_word_info => {
                            if !fields.insert(__FieldTag::__enable_word_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_word_info",
                                ));
                            }
                            result.enable_word_info = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__phrase_hints => {
                            if !fields.insert(__FieldTag::__phrase_hints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrase_hints",
                                ));
                            }
                            result.phrase_hints = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__speech_contexts => {
                            if !fields.insert(__FieldTag::__speech_contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_contexts",
                                ));
                            }
                            result.speech_contexts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SpeechContext>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__model_variant => {
                            if !fields.insert(__FieldTag::__model_variant) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model_variant",
                                ));
                            }
                            result.model_variant = map.next_value::<std::option::Option<crate::model::SpeechModelVariant>>()?.unwrap_or_default();
                        }
                        __FieldTag::__single_utterance => {
                            if !fields.insert(__FieldTag::__single_utterance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_utterance",
                                ));
                            }
                            result.single_utterance = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disable_no_speech_recognized_event => {
                            if !fields.insert(__FieldTag::__disable_no_speech_recognized_event) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disable_no_speech_recognized_event",
                                ));
                            }
                            result.disable_no_speech_recognized_event = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_automatic_punctuation => {
                            if !fields.insert(__FieldTag::__enable_automatic_punctuation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_automatic_punctuation",
                                ));
                            }
                            result.enable_automatic_punctuation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__phrase_sets => {
                            if !fields.insert(__FieldTag::__phrase_sets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrase_sets",
                                ));
                            }
                            result.phrase_sets = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__opt_out_conformer_model_migration => {
                            if !fields.insert(__FieldTag::__opt_out_conformer_model_migration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for opt_out_conformer_model_migration",
                                ));
                            }
                            result.opt_out_conformer_model_migration = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for InputAudioConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.audio_encoding) {
            state.serialize_entry("audioEncoding", &self.audio_encoding)?;
        }
        if !wkt::internal::is_default(&self.sample_rate_hertz) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sampleRateHertz", &__With(&self.sample_rate_hertz))?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.enable_word_info) {
            state.serialize_entry("enableWordInfo", &self.enable_word_info)?;
        }
        if !self.phrase_hints.is_empty() {
            state.serialize_entry("phraseHints", &self.phrase_hints)?;
        }
        if !self.speech_contexts.is_empty() {
            state.serialize_entry("speechContexts", &self.speech_contexts)?;
        }
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !wkt::internal::is_default(&self.model_variant) {
            state.serialize_entry("modelVariant", &self.model_variant)?;
        }
        if !wkt::internal::is_default(&self.single_utterance) {
            state.serialize_entry("singleUtterance", &self.single_utterance)?;
        }
        if !wkt::internal::is_default(&self.disable_no_speech_recognized_event) {
            state.serialize_entry(
                "disableNoSpeechRecognizedEvent",
                &self.disable_no_speech_recognized_event,
            )?;
        }
        if !wkt::internal::is_default(&self.enable_automatic_punctuation) {
            state.serialize_entry(
                "enableAutomaticPunctuation",
                &self.enable_automatic_punctuation,
            )?;
        }
        if !self.phrase_sets.is_empty() {
            state.serialize_entry("phraseSets", &self.phrase_sets)?;
        }
        if !wkt::internal::is_default(&self.opt_out_conformer_model_migration) {
            state.serialize_entry(
                "optOutConformerModelMigration",
                &self.opt_out_conformer_model_migration,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Description of which voice to use for speech synthesis.
#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VoiceSelectionParams {
    /// Optional. The name of the voice. If not set, the service will choose a
    /// voice based on the other parameters such as language_code and
    /// [ssml_gender][google.cloud.dialogflow.v2.VoiceSelectionParams.ssml_gender].
    ///
    /// [google.cloud.dialogflow.v2.VoiceSelectionParams.ssml_gender]: crate::model::VoiceSelectionParams::ssml_gender
    pub name: std::string::String,

    /// Optional. The preferred gender of the voice. If not set, the service will
    /// choose a voice based on the other parameters such as language_code and
    /// [name][google.cloud.dialogflow.v2.VoiceSelectionParams.name]. Note that
    /// this is only a preference, not requirement. If a voice of the appropriate
    /// gender is not available, the synthesizer should substitute a voice with a
    /// different gender rather than failing the request.
    ///
    /// [google.cloud.dialogflow.v2.VoiceSelectionParams.name]: crate::model::VoiceSelectionParams::name
    pub ssml_gender: crate::model::SsmlVoiceGender,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
impl VoiceSelectionParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VoiceSelectionParams::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ssml_gender][crate::model::VoiceSelectionParams::ssml_gender].
    pub fn set_ssml_gender<T: std::convert::Into<crate::model::SsmlVoiceGender>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssml_gender = v.into();
        self
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
impl wkt::message::Message for VoiceSelectionParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.VoiceSelectionParams"
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VoiceSelectionParams {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __ssml_gender,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VoiceSelectionParams")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "ssmlGender" => Ok(__FieldTag::__ssml_gender),
                            "ssml_gender" => Ok(__FieldTag::__ssml_gender),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VoiceSelectionParams;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VoiceSelectionParams")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ssml_gender => {
                            if !fields.insert(__FieldTag::__ssml_gender) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ssml_gender",
                                ));
                            }
                            result.ssml_gender = map
                                .next_value::<std::option::Option<crate::model::SsmlVoiceGender>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for VoiceSelectionParams {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.ssml_gender) {
            state.serialize_entry("ssmlGender", &self.ssml_gender)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configuration of how speech should be synthesized.
#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SynthesizeSpeechConfig {
    /// Optional. Speaking rate/speed, in the range [0.25, 4.0]. 1.0 is the normal
    /// native speed supported by the specific voice. 2.0 is twice as fast, and 0.5
    /// is half as fast. If unset(0.0), defaults to the native 1.0 speed. Any other
    /// values < 0.25 or > 4.0 will return an error.
    pub speaking_rate: f64,

    /// Optional. Speaking pitch, in the range [-20.0, 20.0]. 20 means increase 20
    /// semitones from the original pitch. -20 means decrease 20 semitones from the
    /// original pitch.
    pub pitch: f64,

    /// Optional. Volume gain (in dB) of the normal native volume supported by the
    /// specific voice, in the range [-96.0, 16.0]. If unset, or set to a value of
    /// 0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
    /// will play at approximately half the amplitude of the normal native signal
    /// amplitude. A value of +6.0 (dB) will play at approximately twice the
    /// amplitude of the normal native signal amplitude. We strongly recommend not
    /// to exceed +10 (dB) as there's usually no effective increase in loudness for
    /// any value greater than that.
    pub volume_gain_db: f64,

    /// Optional. An identifier which selects 'audio effects' profiles that are
    /// applied on (post synthesized) text to speech. Effects are applied on top of
    /// each other in the order they are given.
    pub effects_profile_id: std::vec::Vec<std::string::String>,

    /// Optional. The desired voice of the synthesized audio.
    pub voice: std::option::Option<crate::model::VoiceSelectionParams>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
impl SynthesizeSpeechConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [speaking_rate][crate::model::SynthesizeSpeechConfig::speaking_rate].
    pub fn set_speaking_rate<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.speaking_rate = v.into();
        self
    }

    /// Sets the value of [pitch][crate::model::SynthesizeSpeechConfig::pitch].
    pub fn set_pitch<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.pitch = v.into();
        self
    }

    /// Sets the value of [volume_gain_db][crate::model::SynthesizeSpeechConfig::volume_gain_db].
    pub fn set_volume_gain_db<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.volume_gain_db = v.into();
        self
    }

    /// Sets the value of [effects_profile_id][crate::model::SynthesizeSpeechConfig::effects_profile_id].
    pub fn set_effects_profile_id<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.effects_profile_id = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [voice][crate::model::SynthesizeSpeechConfig::voice].
    pub fn set_voice<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VoiceSelectionParams>,
    {
        self.voice = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [voice][crate::model::SynthesizeSpeechConfig::voice].
    pub fn set_or_clear_voice<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VoiceSelectionParams>,
    {
        self.voice = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
impl wkt::message::Message for SynthesizeSpeechConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SynthesizeSpeechConfig"
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SynthesizeSpeechConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __speaking_rate,
            __pitch,
            __volume_gain_db,
            __effects_profile_id,
            __voice,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SynthesizeSpeechConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "speakingRate" => Ok(__FieldTag::__speaking_rate),
                            "speaking_rate" => Ok(__FieldTag::__speaking_rate),
                            "pitch" => Ok(__FieldTag::__pitch),
                            "volumeGainDb" => Ok(__FieldTag::__volume_gain_db),
                            "volume_gain_db" => Ok(__FieldTag::__volume_gain_db),
                            "effectsProfileId" => Ok(__FieldTag::__effects_profile_id),
                            "effects_profile_id" => Ok(__FieldTag::__effects_profile_id),
                            "voice" => Ok(__FieldTag::__voice),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SynthesizeSpeechConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SynthesizeSpeechConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__speaking_rate => {
                            if !fields.insert(__FieldTag::__speaking_rate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speaking_rate",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.speaking_rate =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__pitch => {
                            if !fields.insert(__FieldTag::__pitch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pitch",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pitch = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__volume_gain_db => {
                            if !fields.insert(__FieldTag::__volume_gain_db) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_gain_db",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.volume_gain_db =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__effects_profile_id => {
                            if !fields.insert(__FieldTag::__effects_profile_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for effects_profile_id",
                                ));
                            }
                            result.effects_profile_id = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__voice => {
                            if !fields.insert(__FieldTag::__voice) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for voice",
                                ));
                            }
                            result.voice = map.next_value::<std::option::Option<crate::model::VoiceSelectionParams>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for SynthesizeSpeechConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.speaking_rate) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("speakingRate", &__With(&self.speaking_rate))?;
        }
        if !wkt::internal::is_default(&self.pitch) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pitch", &__With(&self.pitch))?;
        }
        if !wkt::internal::is_default(&self.volume_gain_db) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("volumeGainDb", &__With(&self.volume_gain_db))?;
        }
        if !self.effects_profile_id.is_empty() {
            state.serialize_entry("effectsProfileId", &self.effects_profile_id)?;
        }
        if self.voice.is_some() {
            state.serialize_entry("voice", &self.voice)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Instructs the speech synthesizer on how to generate the output audio content.
/// If this audio config is supplied in a request, it overrides all existing
/// text-to-speech settings applied to the agent.
#[cfg(any(feature = "participants", feature = "sessions",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OutputAudioConfig {
    /// Required. Audio encoding of the synthesized audio content.
    pub audio_encoding: crate::model::OutputAudioEncoding,

    /// The synthesis sample rate (in hertz) for this audio. If not
    /// provided, then the synthesizer will use the default sample rate based on
    /// the audio encoding. If this is different from the voice's natural sample
    /// rate, then the synthesizer will honor this request by converting to the
    /// desired sample rate (which might result in worse audio quality).
    pub sample_rate_hertz: i32,

    /// Configuration of how speech should be synthesized.
    pub synthesize_speech_config: std::option::Option<crate::model::SynthesizeSpeechConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl OutputAudioConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audio_encoding][crate::model::OutputAudioConfig::audio_encoding].
    pub fn set_audio_encoding<T: std::convert::Into<crate::model::OutputAudioEncoding>>(
        mut self,
        v: T,
    ) -> Self {
        self.audio_encoding = v.into();
        self
    }

    /// Sets the value of [sample_rate_hertz][crate::model::OutputAudioConfig::sample_rate_hertz].
    pub fn set_sample_rate_hertz<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.sample_rate_hertz = v.into();
        self
    }

    /// Sets the value of [synthesize_speech_config][crate::model::OutputAudioConfig::synthesize_speech_config].
    pub fn set_synthesize_speech_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SynthesizeSpeechConfig>,
    {
        self.synthesize_speech_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [synthesize_speech_config][crate::model::OutputAudioConfig::synthesize_speech_config].
    pub fn set_or_clear_synthesize_speech_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SynthesizeSpeechConfig>,
    {
        self.synthesize_speech_config = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl wkt::message::Message for OutputAudioConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.OutputAudioConfig"
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OutputAudioConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_encoding,
            __sample_rate_hertz,
            __synthesize_speech_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OutputAudioConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioEncoding" => Ok(__FieldTag::__audio_encoding),
                            "audio_encoding" => Ok(__FieldTag::__audio_encoding),
                            "sampleRateHertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "sample_rate_hertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "synthesizeSpeechConfig" => Ok(__FieldTag::__synthesize_speech_config),
                            "synthesize_speech_config" => {
                                Ok(__FieldTag::__synthesize_speech_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OutputAudioConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OutputAudioConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_encoding => {
                            if !fields.insert(__FieldTag::__audio_encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_encoding",
                                ));
                            }
                            result.audio_encoding = map.next_value::<std::option::Option<crate::model::OutputAudioEncoding>>()?.unwrap_or_default();
                        }
                        __FieldTag::__sample_rate_hertz => {
                            if !fields.insert(__FieldTag::__sample_rate_hertz) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_rate_hertz",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sample_rate_hertz =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__synthesize_speech_config => {
                            if !fields.insert(__FieldTag::__synthesize_speech_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for synthesize_speech_config",
                                ));
                            }
                            result.synthesize_speech_config = map.next_value::<std::option::Option<crate::model::SynthesizeSpeechConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for OutputAudioConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.audio_encoding) {
            state.serialize_entry("audioEncoding", &self.audio_encoding)?;
        }
        if !wkt::internal::is_default(&self.sample_rate_hertz) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sampleRateHertz", &__With(&self.sample_rate_hertz))?;
        }
        if self.synthesize_speech_config.is_some() {
            state.serialize_entry("synthesizeSpeechConfig", &self.synthesize_speech_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A wrapper of repeated TelephonyDtmf digits.
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TelephonyDtmfEvents {
    /// A sequence of TelephonyDtmf digits.
    pub dtmf_events: std::vec::Vec<crate::model::TelephonyDtmf>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl TelephonyDtmfEvents {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dtmf_events][crate::model::TelephonyDtmfEvents::dtmf_events].
    pub fn set_dtmf_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TelephonyDtmf>,
    {
        use std::iter::Iterator;
        self.dtmf_events = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for TelephonyDtmfEvents {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.TelephonyDtmfEvents"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TelephonyDtmfEvents {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dtmf_events,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TelephonyDtmfEvents")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dtmfEvents" => Ok(__FieldTag::__dtmf_events),
                            "dtmf_events" => Ok(__FieldTag::__dtmf_events),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TelephonyDtmfEvents;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TelephonyDtmfEvents")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dtmf_events => {
                            if !fields.insert(__FieldTag::__dtmf_events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dtmf_events",
                                ));
                            }
                            result.dtmf_events = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TelephonyDtmf>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for TelephonyDtmfEvents {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dtmf_events.is_empty() {
            state.serialize_entry("dtmfEvents", &self.dtmf_events)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configures speech transcription for
/// [ConversationProfile][google.cloud.dialogflow.v2.ConversationProfile].
///
/// [google.cloud.dialogflow.v2.ConversationProfile]: crate::model::ConversationProfile
#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SpeechToTextConfig {
    /// The speech model used in speech to text.
    /// `SPEECH_MODEL_VARIANT_UNSPECIFIED`, `USE_BEST_AVAILABLE` will be treated as
    /// `USE_ENHANCED`. It can be overridden in
    /// [AnalyzeContentRequest][google.cloud.dialogflow.v2.AnalyzeContentRequest]
    /// and
    /// [StreamingAnalyzeContentRequest][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest]
    /// request. If enhanced model variant is specified and an enhanced version of
    /// the specified model for the language does not exist, then it would emit an
    /// error.
    ///
    /// [google.cloud.dialogflow.v2.AnalyzeContentRequest]: crate::model::AnalyzeContentRequest
    /// [google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest]: crate::model::StreamingAnalyzeContentRequest
    pub speech_model_variant: crate::model::SpeechModelVariant,

    /// Which Speech model to select. Select the
    /// model best suited to your domain to get best results. If a model is not
    /// explicitly specified, then Dialogflow auto-selects a model based on other
    /// parameters in the SpeechToTextConfig and Agent settings.
    /// If enhanced speech model is enabled for the agent and an enhanced
    /// version of the specified model for the language does not exist, then the
    /// speech is recognized using the standard version of the specified model.
    /// Refer to
    /// [Cloud Speech API
    /// documentation](https://cloud.google.com/speech-to-text/docs/basics#select-model)
    /// for more details.
    /// If you specify a model, the following models typically have the best
    /// performance:
    ///
    /// - phone_call (best for Agent Assist and telephony)
    /// - latest_short (best for Dialogflow non-telephony)
    /// - command_and_search
    ///
    /// Leave this field unspecified to use
    /// [Agent Speech
    /// settings](https://cloud.google.com/dialogflow/cx/docs/concept/agent#settings-speech)
    /// for model selection.
    pub model: std::string::String,

    /// List of names of Cloud Speech phrase sets that are used for transcription.
    /// For phrase set limitations, please refer to [Cloud Speech API quotas and
    /// limits](https://cloud.google.com/speech-to-text/quotas#content).
    pub phrase_sets: std::vec::Vec<std::string::String>,

    /// Audio encoding of the audio content to process.
    pub audio_encoding: crate::model::AudioEncoding,

    /// Sample rate (in Hertz) of the audio content sent in the query.
    /// Refer to [Cloud Speech API
    /// documentation](https://cloud.google.com/speech-to-text/docs/basics) for
    /// more details.
    pub sample_rate_hertz: i32,

    /// The language of the supplied audio. Dialogflow does not do
    /// translations. See [Language
    /// Support](https://cloud.google.com/dialogflow/docs/reference/language)
    /// for a list of the currently supported language codes. Note that queries in
    /// the same session do not necessarily need to specify the same language.
    pub language_code: std::string::String,

    /// If `true`, Dialogflow returns
    /// [SpeechWordInfo][google.cloud.dialogflow.v2.SpeechWordInfo] in
    /// [StreamingRecognitionResult][google.cloud.dialogflow.v2.StreamingRecognitionResult]
    /// with information about the recognized speech words, e.g. start and end time
    /// offsets. If false or unspecified, Speech doesn't return any word-level
    /// information.
    ///
    /// [google.cloud.dialogflow.v2.SpeechWordInfo]: crate::model::SpeechWordInfo
    /// [google.cloud.dialogflow.v2.StreamingRecognitionResult]: crate::model::StreamingRecognitionResult
    pub enable_word_info: bool,

    /// Use timeout based endpointing, interpreting endpointer sensitivity as
    /// seconds of timeout value.
    pub use_timeout_based_endpointing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
impl SpeechToTextConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [speech_model_variant][crate::model::SpeechToTextConfig::speech_model_variant].
    pub fn set_speech_model_variant<T: std::convert::Into<crate::model::SpeechModelVariant>>(
        mut self,
        v: T,
    ) -> Self {
        self.speech_model_variant = v.into();
        self
    }

    /// Sets the value of [model][crate::model::SpeechToTextConfig::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [phrase_sets][crate::model::SpeechToTextConfig::phrase_sets].
    pub fn set_phrase_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.phrase_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [audio_encoding][crate::model::SpeechToTextConfig::audio_encoding].
    pub fn set_audio_encoding<T: std::convert::Into<crate::model::AudioEncoding>>(
        mut self,
        v: T,
    ) -> Self {
        self.audio_encoding = v.into();
        self
    }

    /// Sets the value of [sample_rate_hertz][crate::model::SpeechToTextConfig::sample_rate_hertz].
    pub fn set_sample_rate_hertz<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.sample_rate_hertz = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::SpeechToTextConfig::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [enable_word_info][crate::model::SpeechToTextConfig::enable_word_info].
    pub fn set_enable_word_info<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_word_info = v.into();
        self
    }

    /// Sets the value of [use_timeout_based_endpointing][crate::model::SpeechToTextConfig::use_timeout_based_endpointing].
    pub fn set_use_timeout_based_endpointing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_timeout_based_endpointing = v.into();
        self
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
impl wkt::message::Message for SpeechToTextConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SpeechToTextConfig"
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SpeechToTextConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __speech_model_variant,
            __model,
            __phrase_sets,
            __audio_encoding,
            __sample_rate_hertz,
            __language_code,
            __enable_word_info,
            __use_timeout_based_endpointing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SpeechToTextConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "speechModelVariant" => Ok(__FieldTag::__speech_model_variant),
                            "speech_model_variant" => Ok(__FieldTag::__speech_model_variant),
                            "model" => Ok(__FieldTag::__model),
                            "phraseSets" => Ok(__FieldTag::__phrase_sets),
                            "phrase_sets" => Ok(__FieldTag::__phrase_sets),
                            "audioEncoding" => Ok(__FieldTag::__audio_encoding),
                            "audio_encoding" => Ok(__FieldTag::__audio_encoding),
                            "sampleRateHertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "sample_rate_hertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "enableWordInfo" => Ok(__FieldTag::__enable_word_info),
                            "enable_word_info" => Ok(__FieldTag::__enable_word_info),
                            "useTimeoutBasedEndpointing" => {
                                Ok(__FieldTag::__use_timeout_based_endpointing)
                            }
                            "use_timeout_based_endpointing" => {
                                Ok(__FieldTag::__use_timeout_based_endpointing)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SpeechToTextConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SpeechToTextConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__speech_model_variant => {
                            if !fields.insert(__FieldTag::__speech_model_variant) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_model_variant",
                                ));
                            }
                            result.speech_model_variant = map.next_value::<std::option::Option<crate::model::SpeechModelVariant>>()?.unwrap_or_default();
                        }
                        __FieldTag::__model => {
                            if !fields.insert(__FieldTag::__model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for model",
                                ));
                            }
                            result.model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__phrase_sets => {
                            if !fields.insert(__FieldTag::__phrase_sets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phrase_sets",
                                ));
                            }
                            result.phrase_sets = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__audio_encoding => {
                            if !fields.insert(__FieldTag::__audio_encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_encoding",
                                ));
                            }
                            result.audio_encoding = map
                                .next_value::<std::option::Option<crate::model::AudioEncoding>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sample_rate_hertz => {
                            if !fields.insert(__FieldTag::__sample_rate_hertz) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_rate_hertz",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sample_rate_hertz =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_word_info => {
                            if !fields.insert(__FieldTag::__enable_word_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_word_info",
                                ));
                            }
                            result.enable_word_info = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__use_timeout_based_endpointing => {
                            if !fields.insert(__FieldTag::__use_timeout_based_endpointing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_timeout_based_endpointing",
                                ));
                            }
                            result.use_timeout_based_endpointing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for SpeechToTextConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.speech_model_variant) {
            state.serialize_entry("speechModelVariant", &self.speech_model_variant)?;
        }
        if !self.model.is_empty() {
            state.serialize_entry("model", &self.model)?;
        }
        if !self.phrase_sets.is_empty() {
            state.serialize_entry("phraseSets", &self.phrase_sets)?;
        }
        if !wkt::internal::is_default(&self.audio_encoding) {
            state.serialize_entry("audioEncoding", &self.audio_encoding)?;
        }
        if !wkt::internal::is_default(&self.sample_rate_hertz) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sampleRateHertz", &__With(&self.sample_rate_hertz))?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.enable_word_info) {
            state.serialize_entry("enableWordInfo", &self.enable_word_info)?;
        }
        if !wkt::internal::is_default(&self.use_timeout_based_endpointing) {
            state.serialize_entry(
                "useTimeoutBasedEndpointing",
                &self.use_timeout_based_endpointing,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Dialogflow contexts are similar to natural language context. If a person says
/// to you "they are orange", you need context in order to understand what "they"
/// is referring to. Similarly, for Dialogflow to handle an end-user expression
/// like that, it needs to be provided with context in order to correctly match
/// an intent.
///
/// Using contexts, you can control the flow of a conversation. You can configure
/// contexts for an intent by setting input and output contexts, which are
/// identified by string names. When an intent is matched, any configured output
/// contexts for that intent become active. While any contexts are active,
/// Dialogflow is more likely to match intents that are configured with input
/// contexts that correspond to the currently active contexts.
///
/// For more information about context, see the
/// [Contexts guide](https://cloud.google.com/dialogflow/docs/contexts-overview).
#[cfg(any(
    feature = "answer-records",
    feature = "contexts",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Context {
    /// Required. The unique identifier of the context. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`,
    /// or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>/contexts/<Context ID>`.
    ///
    /// The `Context ID` is always converted to lowercase, may only contain
    /// characters in `a-zA-Z0-9_-%` and may be at most 250 bytes long.
    ///
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    ///
    /// The following context names are reserved for internal use by Dialogflow.
    /// You should not use these contexts or create contexts with these names:
    ///
    /// * `__system_counters__`
    /// * `*_id_dialog_context`
    /// * `*_dialog_params_size`
    pub name: std::string::String,

    /// Optional. The number of conversational query requests after which the
    /// context expires. The default is `0`. If set to `0`, the context expires
    /// immediately. Contexts expire automatically after 20 minutes if there
    /// are no matching queries.
    pub lifespan_count: i32,

    /// Optional. The collection of parameters associated with this context.
    ///
    /// Depending on your protocol or client library language, this is a
    /// map, associative array, symbol table, dictionary, or JSON object
    /// composed of a collection of (MapKey, MapValue) pairs:
    ///
    /// * MapKey type: string
    /// * MapKey value: parameter name
    /// * MapValue type: If parameter's entity type is a composite entity then use
    ///   map, otherwise, depending on the parameter value type, it could be one of
    ///   string, number, boolean, null, list or map.
    /// * MapValue value: If parameter's entity type is a composite entity then use
    ///   map from composite entity property names to property values, otherwise,
    ///   use parameter value.
    pub parameters: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "answer-records",
    feature = "contexts",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
impl Context {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Context::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [lifespan_count][crate::model::Context::lifespan_count].
    pub fn set_lifespan_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.lifespan_count = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::Context::parameters].
    pub fn set_parameters<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.parameters = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [parameters][crate::model::Context::parameters].
    pub fn set_or_clear_parameters<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.parameters = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "contexts",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
impl wkt::message::Message for Context {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.Context"
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "contexts",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Context {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __lifespan_count,
            __parameters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Context")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "lifespanCount" => Ok(__FieldTag::__lifespan_count),
                            "lifespan_count" => Ok(__FieldTag::__lifespan_count),
                            "parameters" => Ok(__FieldTag::__parameters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Context;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Context")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__lifespan_count => {
                            if !fields.insert(__FieldTag::__lifespan_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifespan_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.lifespan_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "contexts",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for Context {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.lifespan_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("lifespanCount", &__With(&self.lifespan_count))?;
        }
        if self.parameters.is_some() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Contexts.ListContexts][google.cloud.dialogflow.v2.Contexts.ListContexts].
///
/// [google.cloud.dialogflow.v2.Contexts.ListContexts]: crate::client::Contexts::list_contexts
#[cfg(feature = "contexts")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListContextsRequest {
    /// Required. The session to list all contexts from.
    /// Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "contexts")]
impl ListContextsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListContextsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListContextsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListContextsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "contexts")]
impl wkt::message::Message for ListContextsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListContextsRequest"
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListContextsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListContextsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListContextsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListContextsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl serde::ser::Serialize for ListContextsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Contexts.ListContexts][google.cloud.dialogflow.v2.Contexts.ListContexts].
///
/// [google.cloud.dialogflow.v2.Contexts.ListContexts]: crate::client::Contexts::list_contexts
#[cfg(feature = "contexts")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListContextsResponse {
    /// The list of contexts. There will be a maximum number of items
    /// returned based on the page_size field in the request.
    pub contexts: std::vec::Vec<crate::model::Context>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "contexts")]
impl ListContextsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [contexts][crate::model::ListContextsResponse::contexts].
    pub fn set_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Context>,
    {
        use std::iter::Iterator;
        self.contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListContextsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "contexts")]
impl wkt::message::Message for ListContextsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListContextsResponse"
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListContextsResponse {
    type PageItem = crate::model::Context;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.contexts
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListContextsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __contexts,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListContextsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "contexts" => Ok(__FieldTag::__contexts),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListContextsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListContextsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__contexts => {
                            if !fields.insert(__FieldTag::__contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contexts",
                                ));
                            }
                            result.contexts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Context>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl serde::ser::Serialize for ListContextsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.contexts.is_empty() {
            state.serialize_entry("contexts", &self.contexts)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Contexts.GetContext][google.cloud.dialogflow.v2.Contexts.GetContext].
///
/// [google.cloud.dialogflow.v2.Contexts.GetContext]: crate::client::Contexts::get_context
#[cfg(feature = "contexts")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetContextRequest {
    /// Required. The name of the context. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`
    /// or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>/contexts/<Context ID>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "contexts")]
impl GetContextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetContextRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "contexts")]
impl wkt::message::Message for GetContextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetContextRequest"
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetContextRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetContextRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetContextRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetContextRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl serde::ser::Serialize for GetContextRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Contexts.CreateContext][google.cloud.dialogflow.v2.Contexts.CreateContext].
///
/// [google.cloud.dialogflow.v2.Contexts.CreateContext]: crate::client::Contexts::create_context
#[cfg(feature = "contexts")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateContextRequest {
    /// Required. The session to create a context for.
    /// Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    pub parent: std::string::String,

    /// Required. The context to create.
    pub context: std::option::Option<crate::model::Context>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "contexts")]
impl CreateContextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateContextRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [context][crate::model::CreateContextRequest::context].
    pub fn set_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Context>,
    {
        self.context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [context][crate::model::CreateContextRequest::context].
    pub fn set_or_clear_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Context>,
    {
        self.context = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "contexts")]
impl wkt::message::Message for CreateContextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CreateContextRequest"
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateContextRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __context,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateContextRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "context" => Ok(__FieldTag::__context),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateContextRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateContextRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__context => {
                            if !fields.insert(__FieldTag::__context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context",
                                ));
                            }
                            result.context =
                                map.next_value::<std::option::Option<crate::model::Context>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateContextRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.context.is_some() {
            state.serialize_entry("context", &self.context)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Contexts.UpdateContext][google.cloud.dialogflow.v2.Contexts.UpdateContext].
///
/// [google.cloud.dialogflow.v2.Contexts.UpdateContext]: crate::client::Contexts::update_context
#[cfg(feature = "contexts")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateContextRequest {
    /// Required. The context to update.
    pub context: std::option::Option<crate::model::Context>,

    /// Optional. The mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "contexts")]
impl UpdateContextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [context][crate::model::UpdateContextRequest::context].
    pub fn set_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Context>,
    {
        self.context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [context][crate::model::UpdateContextRequest::context].
    pub fn set_or_clear_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Context>,
    {
        self.context = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateContextRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateContextRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "contexts")]
impl wkt::message::Message for UpdateContextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.UpdateContextRequest"
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateContextRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __context,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateContextRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "context" => Ok(__FieldTag::__context),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateContextRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateContextRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__context => {
                            if !fields.insert(__FieldTag::__context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context",
                                ));
                            }
                            result.context =
                                map.next_value::<std::option::Option<crate::model::Context>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateContextRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.context.is_some() {
            state.serialize_entry("context", &self.context)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Contexts.DeleteContext][google.cloud.dialogflow.v2.Contexts.DeleteContext].
///
/// [google.cloud.dialogflow.v2.Contexts.DeleteContext]: crate::client::Contexts::delete_context
#[cfg(feature = "contexts")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteContextRequest {
    /// Required. The name of the context to delete. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/contexts/<Context ID>`
    /// or `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>/contexts/<Context ID>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "contexts")]
impl DeleteContextRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteContextRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "contexts")]
impl wkt::message::Message for DeleteContextRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DeleteContextRequest"
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteContextRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteContextRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteContextRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteContextRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteContextRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Contexts.DeleteAllContexts][google.cloud.dialogflow.v2.Contexts.DeleteAllContexts].
///
/// [google.cloud.dialogflow.v2.Contexts.DeleteAllContexts]: crate::client::Contexts::delete_all_contexts
#[cfg(feature = "contexts")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAllContextsRequest {
    /// Required. The name of the session to delete all contexts from. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>` or `projects/<Project
    /// ID>/agent/environments/<Environment ID>/users/<User ID>/sessions/<Session
    /// ID>`.
    /// If `Environment ID` is not specified we assume default 'draft' environment.
    /// If `User ID` is not specified, we assume default '-' user.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "contexts")]
impl DeleteAllContextsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::DeleteAllContextsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

#[cfg(feature = "contexts")]
impl wkt::message::Message for DeleteAllContextsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DeleteAllContextsRequest"
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAllContextsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAllContextsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAllContextsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAllContextsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "contexts")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteAllContextsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a conversation.
/// A conversation is an interaction between an agent, including live agents
/// and Dialogflow agents, and a support customer. Conversations can
/// include phone calls and text-based chat sessions.
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Conversation {
    /// Output only. Identifier. The unique identifier of this conversation.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>`.
    pub name: std::string::String,

    /// Output only. The current state of the Conversation.
    pub lifecycle_state: crate::model::conversation::LifecycleState,

    /// Required. The Conversation Profile to be used to configure this
    /// Conversation. This field cannot be updated.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversationProfiles/<Conversation Profile ID>`.
    pub conversation_profile: std::string::String,

    /// Output only. It will not be empty if the conversation is to be connected
    /// over telephony.
    pub phone_number: std::option::Option<crate::model::ConversationPhoneNumber>,

    /// Output only. The time the conversation was started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the conversation was finished.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The stage of a conversation. It indicates whether the virtual
    /// agent or a human agent is handling the conversation.
    ///
    /// If the conversation is created with the conversation profile that has
    /// Dialogflow config set, defaults to
    /// [ConversationStage.VIRTUAL_AGENT_STAGE][google.cloud.dialogflow.v2.Conversation.ConversationStage.VIRTUAL_AGENT_STAGE];
    /// Otherwise, defaults to
    /// [ConversationStage.HUMAN_ASSIST_STAGE][google.cloud.dialogflow.v2.Conversation.ConversationStage.HUMAN_ASSIST_STAGE].
    ///
    /// If the conversation is created with the conversation profile that has
    /// Dialogflow config set but explicitly sets conversation_stage to
    /// [ConversationStage.HUMAN_ASSIST_STAGE][google.cloud.dialogflow.v2.Conversation.ConversationStage.HUMAN_ASSIST_STAGE],
    /// it skips
    /// [ConversationStage.VIRTUAL_AGENT_STAGE][google.cloud.dialogflow.v2.Conversation.ConversationStage.VIRTUAL_AGENT_STAGE]
    /// stage and directly goes to
    /// [ConversationStage.HUMAN_ASSIST_STAGE][google.cloud.dialogflow.v2.Conversation.ConversationStage.HUMAN_ASSIST_STAGE].
    ///
    /// [google.cloud.dialogflow.v2.Conversation.ConversationStage.HUMAN_ASSIST_STAGE]: crate::model::conversation::ConversationStage::HumanAssistStage
    /// [google.cloud.dialogflow.v2.Conversation.ConversationStage.VIRTUAL_AGENT_STAGE]: crate::model::conversation::ConversationStage::VirtualAgentStage
    pub conversation_stage: crate::model::conversation::ConversationStage,

    /// Output only. The telephony connection information.
    pub telephony_connection_info:
        std::option::Option<crate::model::conversation::TelephonyConnectionInfo>,

    /// Output only. The context reference updates provided by external systems.
    pub ingested_context_references: std::collections::HashMap<
        std::string::String,
        crate::model::conversation::ContextReference,
    >,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl Conversation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Conversation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [lifecycle_state][crate::model::Conversation::lifecycle_state].
    pub fn set_lifecycle_state<
        T: std::convert::Into<crate::model::conversation::LifecycleState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.lifecycle_state = v.into();
        self
    }

    /// Sets the value of [conversation_profile][crate::model::Conversation::conversation_profile].
    pub fn set_conversation_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_profile = v.into();
        self
    }

    /// Sets the value of [phone_number][crate::model::Conversation::phone_number].
    pub fn set_phone_number<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConversationPhoneNumber>,
    {
        self.phone_number = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [phone_number][crate::model::Conversation::phone_number].
    pub fn set_or_clear_phone_number<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConversationPhoneNumber>,
    {
        self.phone_number = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::Conversation::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Conversation::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::Conversation::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::Conversation::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conversation_stage][crate::model::Conversation::conversation_stage].
    pub fn set_conversation_stage<
        T: std::convert::Into<crate::model::conversation::ConversationStage>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_stage = v.into();
        self
    }

    /// Sets the value of [telephony_connection_info][crate::model::Conversation::telephony_connection_info].
    pub fn set_telephony_connection_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::conversation::TelephonyConnectionInfo>,
    {
        self.telephony_connection_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [telephony_connection_info][crate::model::Conversation::telephony_connection_info].
    pub fn set_or_clear_telephony_connection_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::conversation::TelephonyConnectionInfo>,
    {
        self.telephony_connection_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ingested_context_references][crate::model::Conversation::ingested_context_references].
    pub fn set_ingested_context_references<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::conversation::ContextReference>,
    {
        use std::iter::Iterator;
        self.ingested_context_references =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for Conversation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.Conversation"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Conversation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __lifecycle_state,
            __conversation_profile,
            __phone_number,
            __start_time,
            __end_time,
            __conversation_stage,
            __telephony_connection_info,
            __ingested_context_references,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Conversation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "lifecycleState" => Ok(__FieldTag::__lifecycle_state),
                            "lifecycle_state" => Ok(__FieldTag::__lifecycle_state),
                            "conversationProfile" => Ok(__FieldTag::__conversation_profile),
                            "conversation_profile" => Ok(__FieldTag::__conversation_profile),
                            "phoneNumber" => Ok(__FieldTag::__phone_number),
                            "phone_number" => Ok(__FieldTag::__phone_number),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "conversationStage" => Ok(__FieldTag::__conversation_stage),
                            "conversation_stage" => Ok(__FieldTag::__conversation_stage),
                            "telephonyConnectionInfo" => {
                                Ok(__FieldTag::__telephony_connection_info)
                            }
                            "telephony_connection_info" => {
                                Ok(__FieldTag::__telephony_connection_info)
                            }
                            "ingestedContextReferences" => {
                                Ok(__FieldTag::__ingested_context_references)
                            }
                            "ingested_context_references" => {
                                Ok(__FieldTag::__ingested_context_references)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Conversation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Conversation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__lifecycle_state => {
                            if !fields.insert(__FieldTag::__lifecycle_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lifecycle_state",
                                ));
                            }
                            result.lifecycle_state = map.next_value::<std::option::Option<crate::model::conversation::LifecycleState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__conversation_profile => {
                            if !fields.insert(__FieldTag::__conversation_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_profile",
                                ));
                            }
                            result.conversation_profile = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__phone_number => {
                            if !fields.insert(__FieldTag::__phone_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phone_number",
                                ));
                            }
                            result.phone_number = map.next_value::<std::option::Option<crate::model::ConversationPhoneNumber>>()?
                                ;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__conversation_stage => {
                            if !fields.insert(__FieldTag::__conversation_stage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_stage",
                                ));
                            }
                            result.conversation_stage =
                                map.next_value::<std::option::Option<
                                    crate::model::conversation::ConversationStage,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__telephony_connection_info => {
                            if !fields.insert(__FieldTag::__telephony_connection_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for telephony_connection_info",
                                ));
                            }
                            result.telephony_connection_info = map
                                .next_value::<std::option::Option<
                                    crate::model::conversation::TelephonyConnectionInfo,
                                >>()?;
                        }
                        __FieldTag::__ingested_context_references => {
                            if !fields.insert(__FieldTag::__ingested_context_references) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ingested_context_references",
                                ));
                            }
                            result.ingested_context_references = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::conversation::ContextReference,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for Conversation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.lifecycle_state) {
            state.serialize_entry("lifecycleState", &self.lifecycle_state)?;
        }
        if !self.conversation_profile.is_empty() {
            state.serialize_entry("conversationProfile", &self.conversation_profile)?;
        }
        if self.phone_number.is_some() {
            state.serialize_entry("phoneNumber", &self.phone_number)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.conversation_stage) {
            state.serialize_entry("conversationStage", &self.conversation_stage)?;
        }
        if self.telephony_connection_info.is_some() {
            state.serialize_entry("telephonyConnectionInfo", &self.telephony_connection_info)?;
        }
        if !self.ingested_context_references.is_empty() {
            state.serialize_entry(
                "ingestedContextReferences",
                &self.ingested_context_references,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Conversation].
#[cfg(feature = "conversations")]
pub mod conversation {
    #[allow(unused_imports)]
    use super::*;

    /// The information about phone calls connected via phone gateway to the
    /// conversation.
    #[cfg(feature = "conversations")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TelephonyConnectionInfo {
        /// Output only. The number dialed to connect this call in E.164 format.
        pub dialed_number: std::string::String,

        /// Optional. SDP of the call. It's initially the SDP answer to the endpoint,
        /// but maybe later updated for the purpose of making the link active, etc.
        pub sdp: std::string::String,

        /// Output only. The SIP headers from the initial SIP INVITE.
        pub sip_headers:
            std::vec::Vec<crate::model::conversation::telephony_connection_info::SipHeader>,

        /// Output only. The mime content from the initial SIP INVITE.
        pub extra_mime_contents:
            std::vec::Vec<crate::model::conversation::telephony_connection_info::MimeContent>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "conversations")]
    impl TelephonyConnectionInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dialed_number][crate::model::conversation::TelephonyConnectionInfo::dialed_number].
        pub fn set_dialed_number<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.dialed_number = v.into();
            self
        }

        /// Sets the value of [sdp][crate::model::conversation::TelephonyConnectionInfo::sdp].
        pub fn set_sdp<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.sdp = v.into();
            self
        }

        /// Sets the value of [sip_headers][crate::model::conversation::TelephonyConnectionInfo::sip_headers].
        pub fn set_sip_headers<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::conversation::telephony_connection_info::SipHeader>,
        {
            use std::iter::Iterator;
            self.sip_headers = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [extra_mime_contents][crate::model::conversation::TelephonyConnectionInfo::extra_mime_contents].
        pub fn set_extra_mime_contents<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::conversation::telephony_connection_info::MimeContent,
                >,
        {
            use std::iter::Iterator;
            self.extra_mime_contents = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "conversations")]
    impl wkt::message::Message for TelephonyConnectionInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.Conversation.TelephonyConnectionInfo"
        }
    }

    #[cfg(feature = "conversations")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TelephonyConnectionInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __dialed_number,
                __sdp,
                __sip_headers,
                __extra_mime_contents,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TelephonyConnectionInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "dialedNumber" => Ok(__FieldTag::__dialed_number),
                                "dialed_number" => Ok(__FieldTag::__dialed_number),
                                "sdp" => Ok(__FieldTag::__sdp),
                                "sipHeaders" => Ok(__FieldTag::__sip_headers),
                                "sip_headers" => Ok(__FieldTag::__sip_headers),
                                "extraMimeContents" => Ok(__FieldTag::__extra_mime_contents),
                                "extra_mime_contents" => Ok(__FieldTag::__extra_mime_contents),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TelephonyConnectionInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TelephonyConnectionInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__dialed_number => {
                                if !fields.insert(__FieldTag::__dialed_number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dialed_number",
                                    ));
                                }
                                result.dialed_number = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__sdp => {
                                if !fields.insert(__FieldTag::__sdp) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sdp",
                                    ));
                                }
                                result.sdp = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__sip_headers => {
                                if !fields.insert(__FieldTag::__sip_headers) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sip_headers",
                                    ));
                                }
                                result.sip_headers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::conversation::telephony_connection_info::SipHeader>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__extra_mime_contents => {
                                if !fields.insert(__FieldTag::__extra_mime_contents) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for extra_mime_contents",
                                    ));
                                }
                                result.extra_mime_contents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::conversation::telephony_connection_info::MimeContent>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "conversations")]
    #[doc(hidden)]
    impl serde::ser::Serialize for TelephonyConnectionInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.dialed_number.is_empty() {
                state.serialize_entry("dialedNumber", &self.dialed_number)?;
            }
            if !self.sdp.is_empty() {
                state.serialize_entry("sdp", &self.sdp)?;
            }
            if !self.sip_headers.is_empty() {
                state.serialize_entry("sipHeaders", &self.sip_headers)?;
            }
            if !self.extra_mime_contents.is_empty() {
                state.serialize_entry("extraMimeContents", &self.extra_mime_contents)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [TelephonyConnectionInfo].
    #[cfg(feature = "conversations")]
    pub mod telephony_connection_info {
        #[allow(unused_imports)]
        use super::*;

        /// The SIP headers from the initial SIP INVITE.
        #[cfg(feature = "conversations")]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct SipHeader {
            /// Optional. The name of the header.
            pub name: std::string::String,

            /// Optional. The value of the header.
            pub value: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "conversations")]
        impl SipHeader {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [name][crate::model::conversation::telephony_connection_info::SipHeader::name].
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }

            /// Sets the value of [value][crate::model::conversation::telephony_connection_info::SipHeader::value].
            pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.value = v.into();
                self
            }
        }

        #[cfg(feature = "conversations")]
        impl wkt::message::Message for SipHeader {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Conversation.TelephonyConnectionInfo.SipHeader"
            }
        }

        #[cfg(feature = "conversations")]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for SipHeader {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __name,
                    __value,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for SipHeader")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "name" => Ok(__FieldTag::__name),
                                    "value" => Ok(__FieldTag::__value),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = SipHeader;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct SipHeader")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__name => {
                                    if !fields.insert(__FieldTag::__name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for name"),
                                        );
                                    }
                                    result.name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__value => {
                                    if !fields.insert(__FieldTag::__value) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for value"),
                                        );
                                    }
                                    result.value = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(feature = "conversations")]
        #[doc(hidden)]
        impl serde::ser::Serialize for SipHeader {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.name.is_empty() {
                    state.serialize_entry("name", &self.name)?;
                }
                if !self.value.is_empty() {
                    state.serialize_entry("value", &self.value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The mime content from the initial SIP INVITE.
        #[cfg(feature = "conversations")]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct MimeContent {
            /// Optional. The mime type of the content.
            pub mime_type: std::string::String,

            /// Optional. The content payload.
            pub content: ::bytes::Bytes,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "conversations")]
        impl MimeContent {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [mime_type][crate::model::conversation::telephony_connection_info::MimeContent::mime_type].
            pub fn set_mime_type<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.mime_type = v.into();
                self
            }

            /// Sets the value of [content][crate::model::conversation::telephony_connection_info::MimeContent::content].
            pub fn set_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
                self.content = v.into();
                self
            }
        }

        #[cfg(feature = "conversations")]
        impl wkt::message::Message for MimeContent {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Conversation.TelephonyConnectionInfo.MimeContent"
            }
        }

        #[cfg(feature = "conversations")]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for MimeContent {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __mime_type,
                    __content,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for MimeContent")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "mimeType" => Ok(__FieldTag::__mime_type),
                                    "mime_type" => Ok(__FieldTag::__mime_type),
                                    "content" => Ok(__FieldTag::__content),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = MimeContent;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct MimeContent")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__mime_type => {
                                    if !fields.insert(__FieldTag::__mime_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for mime_type",
                                            ),
                                        );
                                    }
                                    result.mime_type = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__content => {
                                    if !fields.insert(__FieldTag::__content) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for content",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<::bytes::Bytes>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::<
                                                std::option::Option<serde_with::base64::Base64>,
                                            >::deserialize(
                                                deserializer
                                            )
                                            .map(__With)
                                        }
                                    }
                                    result.content =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(feature = "conversations")]
        #[doc(hidden)]
        impl serde::ser::Serialize for MimeContent {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.mime_type.is_empty() {
                    state.serialize_entry("mimeType", &self.mime_type)?;
                }
                if !self.content.is_empty() {
                    struct __With<'a>(&'a ::bytes::Bytes);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<serde_with::base64::Base64>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("content", &__With(&self.content))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Represents a section of ingested context information.
    #[cfg(feature = "conversations")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ContextReference {
        /// Required. The list of content updates for a context reference.
        pub context_contents:
            std::vec::Vec<crate::model::conversation::context_reference::ContextContent>,

        /// Required. The mode in which context reference contents are updated.
        pub update_mode: crate::model::conversation::context_reference::UpdateMode,

        /// Optional. The language of the information ingested, defaults to "en-US"
        /// if not set.
        pub language_code: std::string::String,

        /// Output only. The time the context reference was first created.
        pub create_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "conversations")]
    impl ContextReference {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [context_contents][crate::model::conversation::ContextReference::context_contents].
        pub fn set_context_contents<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::conversation::context_reference::ContextContent>,
        {
            use std::iter::Iterator;
            self.context_contents = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [update_mode][crate::model::conversation::ContextReference::update_mode].
        pub fn set_update_mode<
            T: std::convert::Into<crate::model::conversation::context_reference::UpdateMode>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.update_mode = v.into();
            self
        }

        /// Sets the value of [language_code][crate::model::conversation::ContextReference::language_code].
        pub fn set_language_code<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.language_code = v.into();
            self
        }

        /// Sets the value of [create_time][crate::model::conversation::ContextReference::create_time].
        pub fn set_create_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.create_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [create_time][crate::model::conversation::ContextReference::create_time].
        pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.create_time = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "conversations")]
    impl wkt::message::Message for ContextReference {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.Conversation.ContextReference"
        }
    }

    #[cfg(feature = "conversations")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ContextReference {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __context_contents,
                __update_mode,
                __language_code,
                __create_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ContextReference")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "contextContents" => Ok(__FieldTag::__context_contents),
                                "context_contents" => Ok(__FieldTag::__context_contents),
                                "updateMode" => Ok(__FieldTag::__update_mode),
                                "update_mode" => Ok(__FieldTag::__update_mode),
                                "languageCode" => Ok(__FieldTag::__language_code),
                                "language_code" => Ok(__FieldTag::__language_code),
                                "createTime" => Ok(__FieldTag::__create_time),
                                "create_time" => Ok(__FieldTag::__create_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ContextReference;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ContextReference")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__context_contents => {
                                if !fields.insert(__FieldTag::__context_contents) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for context_contents",
                                    ));
                                }
                                result.context_contents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::conversation::context_reference::ContextContent>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__update_mode => {
                                if !fields.insert(__FieldTag::__update_mode) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for update_mode",
                                    ));
                                }
                                result.update_mode = map
                                    .next_value::<std::option::Option<
                                        crate::model::conversation::context_reference::UpdateMode,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__language_code => {
                                if !fields.insert(__FieldTag::__language_code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for language_code",
                                    ));
                                }
                                result.language_code = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__create_time => {
                                if !fields.insert(__FieldTag::__create_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for create_time",
                                    ));
                                }
                                result.create_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "conversations")]
    #[doc(hidden)]
    impl serde::ser::Serialize for ContextReference {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.context_contents.is_empty() {
                state.serialize_entry("contextContents", &self.context_contents)?;
            }
            if !wkt::internal::is_default(&self.update_mode) {
                state.serialize_entry("updateMode", &self.update_mode)?;
            }
            if !self.language_code.is_empty() {
                state.serialize_entry("languageCode", &self.language_code)?;
            }
            if self.create_time.is_some() {
                state.serialize_entry("createTime", &self.create_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ContextReference].
    #[cfg(feature = "conversations")]
    pub mod context_reference {
        #[allow(unused_imports)]
        use super::*;

        /// Contents ingested.
        #[cfg(feature = "conversations")]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ContextContent {
            /// Required. The information ingested in a single request.
            pub content: std::string::String,

            /// Required. The format of the ingested string.
            pub content_format:
                crate::model::conversation::context_reference::context_content::ContentFormat,

            /// Output only. The time when this information was incorporated into the
            /// relevant context reference.
            pub ingestion_time: std::option::Option<wkt::Timestamp>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "conversations")]
        impl ContextContent {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [content][crate::model::conversation::context_reference::ContextContent::content].
            pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.content = v.into();
                self
            }

            /// Sets the value of [content_format][crate::model::conversation::context_reference::ContextContent::content_format].
            pub fn set_content_format<T: std::convert::Into<crate::model::conversation::context_reference::context_content::ContentFormat>>(mut self, v: T) -> Self{
                self.content_format = v.into();
                self
            }

            /// Sets the value of [ingestion_time][crate::model::conversation::context_reference::ContextContent::ingestion_time].
            pub fn set_ingestion_time<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.ingestion_time = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [ingestion_time][crate::model::conversation::context_reference::ContextContent::ingestion_time].
            pub fn set_or_clear_ingestion_time<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.ingestion_time = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "conversations")]
        impl wkt::message::Message for ContextContent {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Conversation.ContextReference.ContextContent"
            }
        }

        #[cfg(feature = "conversations")]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ContextContent {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __content,
                    __content_format,
                    __ingestion_time,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ContextContent")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "content" => Ok(__FieldTag::__content),
                                    "contentFormat" => Ok(__FieldTag::__content_format),
                                    "content_format" => Ok(__FieldTag::__content_format),
                                    "ingestionTime" => Ok(__FieldTag::__ingestion_time),
                                    "ingestion_time" => Ok(__FieldTag::__ingestion_time),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ContextContent;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ContextContent")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__content => {
                                    if !fields.insert(__FieldTag::__content) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for content",
                                            ),
                                        );
                                    }
                                    result.content = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__content_format => {
                                    if !fields.insert(__FieldTag::__content_format) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for content_format",
                                            ),
                                        );
                                    }
                                    result.content_format = map.next_value::<std::option::Option<crate::model::conversation::context_reference::context_content::ContentFormat>>()?.unwrap_or_default();
                                }
                                __FieldTag::__ingestion_time => {
                                    if !fields.insert(__FieldTag::__ingestion_time) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for ingestion_time",
                                            ),
                                        );
                                    }
                                    result.ingestion_time =
                                        map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(feature = "conversations")]
        #[doc(hidden)]
        impl serde::ser::Serialize for ContextContent {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.content.is_empty() {
                    state.serialize_entry("content", &self.content)?;
                }
                if !wkt::internal::is_default(&self.content_format) {
                    state.serialize_entry("contentFormat", &self.content_format)?;
                }
                if self.ingestion_time.is_some() {
                    state.serialize_entry("ingestionTime", &self.ingestion_time)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [ContextContent].
        #[cfg(feature = "conversations")]
        pub mod context_content {
            #[allow(unused_imports)]
            use super::*;

            /// Represents the format of the ingested string.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[cfg(feature = "conversations")]
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum ContentFormat {
                /// Unspecified content format.
                Unspecified,
                /// Content was provided in JSON format.
                Json,
                /// Content was provided as plain text.
                PlainText,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [ContentFormat::value] or
                /// [ContentFormat::name].
                UnknownValue(content_format::UnknownValue),
            }

            #[doc(hidden)]
            #[cfg(feature = "conversations")]
            pub mod content_format {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            #[cfg(feature = "conversations")]
            impl ContentFormat {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Json => std::option::Option::Some(1),
                        Self::PlainText => std::option::Option::Some(2),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("CONTENT_FORMAT_UNSPECIFIED")
                        }
                        Self::Json => std::option::Option::Some("JSON"),
                        Self::PlainText => std::option::Option::Some("PLAIN_TEXT"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            #[cfg(feature = "conversations")]
            impl std::default::Default for ContentFormat {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            #[cfg(feature = "conversations")]
            impl std::fmt::Display for ContentFormat {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            #[cfg(feature = "conversations")]
            impl std::convert::From<i32> for ContentFormat {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Json,
                        2 => Self::PlainText,
                        _ => Self::UnknownValue(content_format::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            #[cfg(feature = "conversations")]
            impl std::convert::From<&str> for ContentFormat {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "CONTENT_FORMAT_UNSPECIFIED" => Self::Unspecified,
                        "JSON" => Self::Json,
                        "PLAIN_TEXT" => Self::PlainText,
                        _ => Self::UnknownValue(content_format::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            #[cfg(feature = "conversations")]
            impl serde::ser::Serialize for ContentFormat {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Json => serializer.serialize_i32(1),
                        Self::PlainText => serializer.serialize_i32(2),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            #[cfg(feature = "conversations")]
            impl<'de> serde::de::Deserialize<'de> for ContentFormat {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<ContentFormat>::new(
                        ".google.cloud.dialogflow.v2.Conversation.ContextReference.ContextContent.ContentFormat"))
                }
            }
        }

        /// Represents the mode in which context reference contents are updated.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "conversations")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum UpdateMode {
            /// Unspecified update mode.
            Unspecified,
            /// Context content updates are applied in append mode.
            Append,
            /// Context content updates are applied in overwrite mode.
            Overwrite,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [UpdateMode::value] or
            /// [UpdateMode::name].
            UnknownValue(update_mode::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "conversations")]
        pub mod update_mode {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "conversations")]
        impl UpdateMode {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Append => std::option::Option::Some(1),
                    Self::Overwrite => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("UPDATE_MODE_UNSPECIFIED"),
                    Self::Append => std::option::Option::Some("APPEND"),
                    Self::Overwrite => std::option::Option::Some("OVERWRITE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "conversations")]
        impl std::default::Default for UpdateMode {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "conversations")]
        impl std::fmt::Display for UpdateMode {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "conversations")]
        impl std::convert::From<i32> for UpdateMode {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Append,
                    2 => Self::Overwrite,
                    _ => Self::UnknownValue(update_mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "conversations")]
        impl std::convert::From<&str> for UpdateMode {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "UPDATE_MODE_UNSPECIFIED" => Self::Unspecified,
                    "APPEND" => Self::Append,
                    "OVERWRITE" => Self::Overwrite,
                    _ => Self::UnknownValue(update_mode::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "conversations")]
        impl serde::ser::Serialize for UpdateMode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Append => serializer.serialize_i32(1),
                    Self::Overwrite => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "conversations")]
        impl<'de> serde::de::Deserialize<'de> for UpdateMode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<UpdateMode>::new(
                    ".google.cloud.dialogflow.v2.Conversation.ContextReference.UpdateMode",
                ))
            }
        }
    }

    /// Enumeration of the completion status of the conversation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "conversations")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LifecycleState {
        /// Unknown.
        Unspecified,
        /// Conversation is currently open for media analysis.
        InProgress,
        /// Conversation has been completed.
        Completed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LifecycleState::value] or
        /// [LifecycleState::name].
        UnknownValue(lifecycle_state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "conversations")]
    pub mod lifecycle_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "conversations")]
    impl LifecycleState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InProgress => std::option::Option::Some(1),
                Self::Completed => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LIFECYCLE_STATE_UNSPECIFIED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Completed => std::option::Option::Some("COMPLETED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "conversations")]
    impl std::default::Default for LifecycleState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "conversations")]
    impl std::fmt::Display for LifecycleState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "conversations")]
    impl std::convert::From<i32> for LifecycleState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InProgress,
                2 => Self::Completed,
                _ => Self::UnknownValue(lifecycle_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "conversations")]
    impl std::convert::From<&str> for LifecycleState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LIFECYCLE_STATE_UNSPECIFIED" => Self::Unspecified,
                "IN_PROGRESS" => Self::InProgress,
                "COMPLETED" => Self::Completed,
                _ => Self::UnknownValue(lifecycle_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "conversations")]
    impl serde::ser::Serialize for LifecycleState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InProgress => serializer.serialize_i32(1),
                Self::Completed => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "conversations")]
    impl<'de> serde::de::Deserialize<'de> for LifecycleState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LifecycleState>::new(
                ".google.cloud.dialogflow.v2.Conversation.LifecycleState",
            ))
        }
    }

    /// Enumeration of the different conversation stages a conversation can be in.
    /// Reference:
    /// <https://cloud.google.com/agent-assist/docs/basics#conversation_stages>
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "conversations")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConversationStage {
        /// Unknown. Should never be used after a conversation is successfully
        /// created.
        Unspecified,
        /// The conversation should return virtual agent responses into the
        /// conversation.
        VirtualAgentStage,
        /// The conversation should not provide responses, just listen and provide
        /// suggestions.
        HumanAssistStage,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConversationStage::value] or
        /// [ConversationStage::name].
        UnknownValue(conversation_stage::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "conversations")]
    pub mod conversation_stage {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "conversations")]
    impl ConversationStage {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::VirtualAgentStage => std::option::Option::Some(1),
                Self::HumanAssistStage => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONVERSATION_STAGE_UNSPECIFIED"),
                Self::VirtualAgentStage => std::option::Option::Some("VIRTUAL_AGENT_STAGE"),
                Self::HumanAssistStage => std::option::Option::Some("HUMAN_ASSIST_STAGE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "conversations")]
    impl std::default::Default for ConversationStage {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "conversations")]
    impl std::fmt::Display for ConversationStage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "conversations")]
    impl std::convert::From<i32> for ConversationStage {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::VirtualAgentStage,
                2 => Self::HumanAssistStage,
                _ => Self::UnknownValue(conversation_stage::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "conversations")]
    impl std::convert::From<&str> for ConversationStage {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONVERSATION_STAGE_UNSPECIFIED" => Self::Unspecified,
                "VIRTUAL_AGENT_STAGE" => Self::VirtualAgentStage,
                "HUMAN_ASSIST_STAGE" => Self::HumanAssistStage,
                _ => Self::UnknownValue(conversation_stage::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "conversations")]
    impl serde::ser::Serialize for ConversationStage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::VirtualAgentStage => serializer.serialize_i32(1),
                Self::HumanAssistStage => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "conversations")]
    impl<'de> serde::de::Deserialize<'de> for ConversationStage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConversationStage>::new(
                ".google.cloud.dialogflow.v2.Conversation.ConversationStage",
            ))
        }
    }
}

/// The request message for
/// [Conversations.CreateConversation][google.cloud.dialogflow.v2.Conversations.CreateConversation].
///
/// [google.cloud.dialogflow.v2.Conversations.CreateConversation]: crate::client::Conversations::create_conversation
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateConversationRequest {
    /// Required. Resource identifier of the project creating the conversation.
    /// Format: `projects/<Project ID>/locations/<Location ID>`.
    pub parent: std::string::String,

    /// Required. The conversation to create.
    pub conversation: std::option::Option<crate::model::Conversation>,

    /// Optional. Identifier of the conversation. Generally it's auto generated by
    /// Google. Only set it if you cannot wait for the response to return a
    /// auto-generated one to you.
    ///
    /// The conversation ID must be compliant with the regression formula
    /// `[a-zA-Z][a-zA-Z0-9_-]*` with the characters length in range of [3,64].
    /// If the field is provided, the caller is responsible for
    ///
    /// 1. the uniqueness of the ID, otherwise the request will be rejected.
    /// 1. the consistency for whether to use custom ID or not under a project to
    ///    better ensure uniqueness.
    pub conversation_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl CreateConversationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConversationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [conversation][crate::model::CreateConversationRequest::conversation].
    pub fn set_conversation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Conversation>,
    {
        self.conversation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation][crate::model::CreateConversationRequest::conversation].
    pub fn set_or_clear_conversation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Conversation>,
    {
        self.conversation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conversation_id][crate::model::CreateConversationRequest::conversation_id].
    pub fn set_conversation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.conversation_id = v.into();
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for CreateConversationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CreateConversationRequest"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateConversationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __conversation,
            __conversation_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConversationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "conversation" => Ok(__FieldTag::__conversation),
                            "conversationId" => Ok(__FieldTag::__conversation_id),
                            "conversation_id" => Ok(__FieldTag::__conversation_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateConversationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConversationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation",
                                ));
                            }
                            result.conversation = map
                                .next_value::<std::option::Option<crate::model::Conversation>>()?;
                        }
                        __FieldTag::__conversation_id => {
                            if !fields.insert(__FieldTag::__conversation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_id",
                                ));
                            }
                            result.conversation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateConversationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.conversation.is_some() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !self.conversation_id.is_empty() {
            state.serialize_entry("conversationId", &self.conversation_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Conversations.ListConversations][google.cloud.dialogflow.v2.Conversations.ListConversations].
///
/// [google.cloud.dialogflow.v2.Conversations.ListConversations]: crate::client::Conversations::list_conversations
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConversationsRequest {
    /// Required. The project from which to list all conversation.
    /// Format: `projects/<Project ID>/locations/<Location ID>`.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    /// Optional. A filter expression that filters conversations listed in the
    /// response. Only `lifecycle_state` can be filtered on in this way. For
    /// example, the following expression only returns `COMPLETED` conversations:
    ///
    /// `lifecycle_state = "COMPLETED"`
    ///
    /// For more information about filtering, see
    /// [API Filtering](https://aip.dev/160).
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl ListConversationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConversationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConversationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConversationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConversationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for ListConversationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListConversationsRequest"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConversationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConversationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for ListConversationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Conversations.ListConversations][google.cloud.dialogflow.v2.Conversations.ListConversations].
///
/// [google.cloud.dialogflow.v2.Conversations.ListConversations]: crate::client::Conversations::list_conversations
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConversationsResponse {
    /// The list of conversations. There will be a maximum number of items
    /// returned based on the page_size field in the request.
    pub conversations: std::vec::Vec<crate::model::Conversation>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl ListConversationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversations][crate::model::ListConversationsResponse::conversations].
    pub fn set_conversations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Conversation>,
    {
        use std::iter::Iterator;
        self.conversations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConversationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for ListConversationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListConversationsResponse"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConversationsResponse {
    type PageItem = crate::model::Conversation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.conversations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConversationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversations" => Ok(__FieldTag::__conversations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConversationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversations => {
                            if !fields.insert(__FieldTag::__conversations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversations",
                                ));
                            }
                            result.conversations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Conversation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for ListConversationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversations.is_empty() {
            state.serialize_entry("conversations", &self.conversations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Conversations.GetConversation][google.cloud.dialogflow.v2.Conversations.GetConversation].
///
/// [google.cloud.dialogflow.v2.Conversations.GetConversation]: crate::client::Conversations::get_conversation
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConversationRequest {
    /// Required. The name of the conversation. Format:
    /// `projects/<Project ID>/locations/<Location ID>/conversations/<Conversation
    /// ID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl GetConversationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConversationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for GetConversationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetConversationRequest"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConversationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConversationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConversationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConversationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for GetConversationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Conversations.CompleteConversation][google.cloud.dialogflow.v2.Conversations.CompleteConversation].
///
/// [google.cloud.dialogflow.v2.Conversations.CompleteConversation]: crate::client::Conversations::complete_conversation
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CompleteConversationRequest {
    /// Required. Resource identifier of the conversation to close.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl CompleteConversationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CompleteConversationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for CompleteConversationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CompleteConversationRequest"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CompleteConversationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompleteConversationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CompleteConversationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompleteConversationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for CompleteConversationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Conversations.ListMessages][google.cloud.dialogflow.v2.Conversations.ListMessages].
///
/// [google.cloud.dialogflow.v2.Conversations.ListMessages]: crate::client::Conversations::list_messages
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMessagesRequest {
    /// Required. The name of the conversation to list messages for.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>`
    pub parent: std::string::String,

    /// Optional. Filter on message fields. Currently predicates on `create_time`
    /// and `create_time_epoch_microseconds` are supported. `create_time` only
    /// support milliseconds accuracy. E.g.,
    /// `create_time_epoch_microseconds > 1551790877964485` or
    /// `create_time > 2017-01-15T01:30:15.01Z`.
    ///
    /// For more information about filtering, see
    /// [API Filtering](https://aip.dev/160).
    pub filter: std::string::String,

    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl ListMessagesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMessagesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMessagesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMessagesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMessagesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for ListMessagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListMessagesRequest"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMessagesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMessagesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMessagesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMessagesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for ListMessagesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Conversations.ListMessages][google.cloud.dialogflow.v2.Conversations.ListMessages].
///
/// [google.cloud.dialogflow.v2.Conversations.ListMessages]: crate::client::Conversations::list_messages
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMessagesResponse {
    /// The list of messages. There will be a maximum number of items
    /// returned based on the page_size field in the request.
    /// `messages` is sorted by `create_time` in descending order.
    pub messages: std::vec::Vec<crate::model::Message>,

    /// Token to retrieve the next page of results, or empty if there are
    /// no more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl ListMessagesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [messages][crate::model::ListMessagesResponse::messages].
    pub fn set_messages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Message>,
    {
        use std::iter::Iterator;
        self.messages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMessagesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for ListMessagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListMessagesResponse"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMessagesResponse {
    type PageItem = crate::model::Message;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.messages
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMessagesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __messages,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMessagesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "messages" => Ok(__FieldTag::__messages),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMessagesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMessagesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__messages => {
                            if !fields.insert(__FieldTag::__messages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for messages",
                                ));
                            }
                            result.messages = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Message>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for ListMessagesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.messages.is_empty() {
            state.serialize_entry("messages", &self.messages)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a phone number for telephony integration. It allows for connecting
/// a particular conversation over telephony.
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ConversationPhoneNumber {
    /// Output only. Desired country code for the phone number.
    pub country_code: i32,

    /// Output only. The phone number to connect to this conversation.
    pub phone_number: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl ConversationPhoneNumber {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [country_code][crate::model::ConversationPhoneNumber::country_code].
    pub fn set_country_code<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.country_code = v.into();
        self
    }

    /// Sets the value of [phone_number][crate::model::ConversationPhoneNumber::phone_number].
    pub fn set_phone_number<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.phone_number = v.into();
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for ConversationPhoneNumber {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ConversationPhoneNumber"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConversationPhoneNumber {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __country_code,
            __phone_number,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationPhoneNumber")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "countryCode" => Ok(__FieldTag::__country_code),
                            "country_code" => Ok(__FieldTag::__country_code),
                            "phoneNumber" => Ok(__FieldTag::__phone_number),
                            "phone_number" => Ok(__FieldTag::__phone_number),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConversationPhoneNumber;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationPhoneNumber")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__country_code => {
                            if !fields.insert(__FieldTag::__country_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for country_code",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.country_code = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__phone_number => {
                            if !fields.insert(__FieldTag::__phone_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phone_number",
                                ));
                            }
                            result.phone_number = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for ConversationPhoneNumber {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.country_code) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("countryCode", &__With(&self.country_code))?;
        }
        if !self.phone_number.is_empty() {
            state.serialize_entry("phoneNumber", &self.phone_number)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for [ConversationsService.IngestContextReferences][].
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct IngestContextReferencesRequest {
    /// Required. Resource identifier of the conversation to ingest context
    /// information for. Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>`.
    pub conversation: std::string::String,

    /// Required. The context references to ingest. The key is the name of the
    /// context reference and the value contains the contents of the context
    /// reference. The key is used to incorporate ingested context references to
    /// enhance the generator.
    pub context_references: std::collections::HashMap<
        std::string::String,
        crate::model::conversation::ContextReference,
    >,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl IngestContextReferencesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation][crate::model::IngestContextReferencesRequest::conversation].
    pub fn set_conversation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.conversation = v.into();
        self
    }

    /// Sets the value of [context_references][crate::model::IngestContextReferencesRequest::context_references].
    pub fn set_context_references<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::conversation::ContextReference>,
    {
        use std::iter::Iterator;
        self.context_references = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for IngestContextReferencesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.IngestContextReferencesRequest"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IngestContextReferencesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation,
            __context_references,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IngestContextReferencesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversation" => Ok(__FieldTag::__conversation),
                            "contextReferences" => Ok(__FieldTag::__context_references),
                            "context_references" => Ok(__FieldTag::__context_references),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IngestContextReferencesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IngestContextReferencesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation",
                                ));
                            }
                            result.conversation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__context_references => {
                            if !fields.insert(__FieldTag::__context_references) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context_references",
                                ));
                            }
                            result.context_references = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::conversation::ContextReference,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for IngestContextReferencesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation.is_empty() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !self.context_references.is_empty() {
            state.serialize_entry("contextReferences", &self.context_references)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for [ConversationsService.IngestContextReferences][].
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct IngestContextReferencesResponse {
    /// All context references ingested.
    pub ingested_context_references: std::collections::HashMap<
        std::string::String,
        crate::model::conversation::ContextReference,
    >,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl IngestContextReferencesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ingested_context_references][crate::model::IngestContextReferencesResponse::ingested_context_references].
    pub fn set_ingested_context_references<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::conversation::ContextReference>,
    {
        use std::iter::Iterator;
        self.ingested_context_references =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for IngestContextReferencesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.IngestContextReferencesResponse"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IngestContextReferencesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ingested_context_references,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IngestContextReferencesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ingestedContextReferences" => {
                                Ok(__FieldTag::__ingested_context_references)
                            }
                            "ingested_context_references" => {
                                Ok(__FieldTag::__ingested_context_references)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IngestContextReferencesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IngestContextReferencesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ingested_context_references => {
                            if !fields.insert(__FieldTag::__ingested_context_references) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ingested_context_references",
                                ));
                            }
                            result.ingested_context_references = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::conversation::ContextReference,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for IngestContextReferencesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.ingested_context_references.is_empty() {
            state.serialize_entry(
                "ingestedContextReferences",
                &self.ingested_context_references,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Conversations.SuggestConversationSummary][google.cloud.dialogflow.v2.Conversations.SuggestConversationSummary].
///
/// [google.cloud.dialogflow.v2.Conversations.SuggestConversationSummary]: crate::client::Conversations::suggest_conversation_summary
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SuggestConversationSummaryRequest {
    /// Required. The conversation to fetch suggestion for.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>`.
    pub conversation: std::string::String,

    /// Optional. The name of the latest conversation message used as context for
    /// compiling suggestion. If empty, the latest message of the conversation will
    /// be used.
    ///
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/messages/<Message ID>`.
    pub latest_message: std::string::String,

    /// Optional. Max number of messages prior to and including
    /// [latest_message] to use as context when compiling the
    /// suggestion. By default 500 and at most 1000.
    pub context_size: i32,

    /// Optional. Parameters for a human assist query. Only used for POC/demo
    /// purpose.
    pub assist_query_params: std::option::Option<crate::model::AssistQueryParameters>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl SuggestConversationSummaryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation][crate::model::SuggestConversationSummaryRequest::conversation].
    pub fn set_conversation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.conversation = v.into();
        self
    }

    /// Sets the value of [latest_message][crate::model::SuggestConversationSummaryRequest::latest_message].
    pub fn set_latest_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.latest_message = v.into();
        self
    }

    /// Sets the value of [context_size][crate::model::SuggestConversationSummaryRequest::context_size].
    pub fn set_context_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.context_size = v.into();
        self
    }

    /// Sets the value of [assist_query_params][crate::model::SuggestConversationSummaryRequest::assist_query_params].
    pub fn set_assist_query_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AssistQueryParameters>,
    {
        self.assist_query_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [assist_query_params][crate::model::SuggestConversationSummaryRequest::assist_query_params].
    pub fn set_or_clear_assist_query_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AssistQueryParameters>,
    {
        self.assist_query_params = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for SuggestConversationSummaryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SuggestConversationSummaryRequest"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SuggestConversationSummaryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation,
            __latest_message,
            __context_size,
            __assist_query_params,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestConversationSummaryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversation" => Ok(__FieldTag::__conversation),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            "assistQueryParams" => Ok(__FieldTag::__assist_query_params),
                            "assist_query_params" => Ok(__FieldTag::__assist_query_params),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SuggestConversationSummaryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestConversationSummaryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation",
                                ));
                            }
                            result.conversation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_message",
                                ));
                            }
                            result.latest_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__assist_query_params => {
                            if !fields.insert(__FieldTag::__assist_query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assist_query_params",
                                ));
                            }
                            result.assist_query_params = map.next_value::<std::option::Option<crate::model::AssistQueryParameters>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for SuggestConversationSummaryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation.is_empty() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if self.assist_query_params.is_some() {
            state.serialize_entry("assistQueryParams", &self.assist_query_params)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Conversations.SuggestConversationSummary][google.cloud.dialogflow.v2.Conversations.SuggestConversationSummary].
///
/// [google.cloud.dialogflow.v2.Conversations.SuggestConversationSummary]: crate::client::Conversations::suggest_conversation_summary
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SuggestConversationSummaryResponse {
    /// Generated summary.
    pub summary: std::option::Option<crate::model::suggest_conversation_summary_response::Summary>,

    /// The name of the latest conversation message used as context for
    /// compiling suggestion.
    ///
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/messages/<Message ID>`.
    pub latest_message: std::string::String,

    /// Number of messages prior to and including
    /// [latest_message][google.cloud.dialogflow.v2.SuggestConversationSummaryResponse.latest_message]
    /// used to compile the suggestion. It may be smaller than the
    /// [SuggestConversationSummaryRequest.context_size][google.cloud.dialogflow.v2.SuggestConversationSummaryRequest.context_size]
    /// field in the request if there weren't that many messages in the
    /// conversation.
    ///
    /// [google.cloud.dialogflow.v2.SuggestConversationSummaryRequest.context_size]: crate::model::SuggestConversationSummaryRequest::context_size
    /// [google.cloud.dialogflow.v2.SuggestConversationSummaryResponse.latest_message]: crate::model::SuggestConversationSummaryResponse::latest_message
    pub context_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl SuggestConversationSummaryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [summary][crate::model::SuggestConversationSummaryResponse::summary].
    pub fn set_summary<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::suggest_conversation_summary_response::Summary>,
    {
        self.summary = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [summary][crate::model::SuggestConversationSummaryResponse::summary].
    pub fn set_or_clear_summary<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::suggest_conversation_summary_response::Summary>,
    {
        self.summary = v.map(|x| x.into());
        self
    }

    /// Sets the value of [latest_message][crate::model::SuggestConversationSummaryResponse::latest_message].
    pub fn set_latest_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.latest_message = v.into();
        self
    }

    /// Sets the value of [context_size][crate::model::SuggestConversationSummaryResponse::context_size].
    pub fn set_context_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.context_size = v.into();
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for SuggestConversationSummaryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SuggestConversationSummaryResponse"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SuggestConversationSummaryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __summary,
            __latest_message,
            __context_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestConversationSummaryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "summary" => Ok(__FieldTag::__summary),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SuggestConversationSummaryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestConversationSummaryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__summary => {
                            if !fields.insert(__FieldTag::__summary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for summary",
                                ));
                            }
                            result.summary = map.next_value::<std::option::Option<
                                crate::model::suggest_conversation_summary_response::Summary,
                            >>()?;
                        }
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_message",
                                ));
                            }
                            result.latest_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for SuggestConversationSummaryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.summary.is_some() {
            state.serialize_entry("summary", &self.summary)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SuggestConversationSummaryResponse].
#[cfg(feature = "conversations")]
pub mod suggest_conversation_summary_response {
    #[allow(unused_imports)]
    use super::*;

    /// Generated summary for a conversation.
    #[cfg(feature = "conversations")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Summary {
        /// The summary content that is concatenated into one string.
        pub text: std::string::String,

        /// The summary content that is divided into sections. The key is the
        /// section's name and the value is the section's content. There is no
        /// specific format for the key or value.
        pub text_sections: std::collections::HashMap<std::string::String, std::string::String>,

        /// The name of the answer record. Format:
        /// "projects/\<Project ID\>/answerRecords/\<Answer Record ID\>"
        pub answer_record: std::string::String,

        /// The baseline model version used to generate this summary. It is empty if
        /// a baseline model was not used to generate this summary.
        pub baseline_model_version: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "conversations")]
    impl Summary {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text][crate::model::suggest_conversation_summary_response::Summary::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }

        /// Sets the value of [text_sections][crate::model::suggest_conversation_summary_response::Summary::text_sections].
        pub fn set_text_sections<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.text_sections = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [answer_record][crate::model::suggest_conversation_summary_response::Summary::answer_record].
        pub fn set_answer_record<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.answer_record = v.into();
            self
        }

        /// Sets the value of [baseline_model_version][crate::model::suggest_conversation_summary_response::Summary::baseline_model_version].
        pub fn set_baseline_model_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.baseline_model_version = v.into();
            self
        }
    }

    #[cfg(feature = "conversations")]
    impl wkt::message::Message for Summary {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.SuggestConversationSummaryResponse.Summary"
        }
    }

    #[cfg(feature = "conversations")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Summary {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __text,
                __text_sections,
                __answer_record,
                __baseline_model_version,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Summary")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "text" => Ok(__FieldTag::__text),
                                "textSections" => Ok(__FieldTag::__text_sections),
                                "text_sections" => Ok(__FieldTag::__text_sections),
                                "answerRecord" => Ok(__FieldTag::__answer_record),
                                "answer_record" => Ok(__FieldTag::__answer_record),
                                "baselineModelVersion" => Ok(__FieldTag::__baseline_model_version),
                                "baseline_model_version" => {
                                    Ok(__FieldTag::__baseline_model_version)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Summary;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Summary")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__text => {
                                if !fields.insert(__FieldTag::__text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text",
                                    ));
                                }
                                result.text = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__text_sections => {
                                if !fields.insert(__FieldTag::__text_sections) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text_sections",
                                    ));
                                }
                                result.text_sections = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__answer_record => {
                                if !fields.insert(__FieldTag::__answer_record) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for answer_record",
                                    ));
                                }
                                result.answer_record = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__baseline_model_version => {
                                if !fields.insert(__FieldTag::__baseline_model_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for baseline_model_version",
                                    ));
                                }
                                result.baseline_model_version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "conversations")]
    #[doc(hidden)]
    impl serde::ser::Serialize for Summary {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.text.is_empty() {
                state.serialize_entry("text", &self.text)?;
            }
            if !self.text_sections.is_empty() {
                state.serialize_entry("textSections", &self.text_sections)?;
            }
            if !self.answer_record.is_empty() {
                state.serialize_entry("answerRecord", &self.answer_record)?;
            }
            if !self.baseline_model_version.is_empty() {
                state.serialize_entry("baselineModelVersion", &self.baseline_model_version)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// The request message for
/// [Conversations.GenerateStatelessSummary][google.cloud.dialogflow.v2.Conversations.GenerateStatelessSummary].
///
/// [google.cloud.dialogflow.v2.Conversations.GenerateStatelessSummary]: crate::client::Conversations::generate_stateless_summary
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateStatelessSummaryRequest {
    /// Required. The conversation to suggest a summary for.
    pub stateless_conversation:
        std::option::Option<crate::model::generate_stateless_summary_request::MinimalConversation>,

    /// Required. A ConversationProfile containing information required for Summary
    /// generation.
    /// Required fields: {language_code, security_settings}
    /// Optional fields: {agent_assistant_config}
    pub conversation_profile: std::option::Option<crate::model::ConversationProfile>,

    /// Optional. The name of the latest conversation message used as context for
    /// generating a Summary. If empty, the latest message of the conversation will
    /// be used. The format is specific to the user and the names of the messages
    /// provided.
    pub latest_message: std::string::String,

    /// Optional. Max number of messages prior to and including
    /// [latest_message] to use as context when compiling the
    /// suggestion. By default 500 and at most 1000.
    pub max_context_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl GenerateStatelessSummaryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [stateless_conversation][crate::model::GenerateStatelessSummaryRequest::stateless_conversation].
    pub fn set_stateless_conversation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::generate_stateless_summary_request::MinimalConversation,
            >,
    {
        self.stateless_conversation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stateless_conversation][crate::model::GenerateStatelessSummaryRequest::stateless_conversation].
    pub fn set_or_clear_stateless_conversation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::generate_stateless_summary_request::MinimalConversation,
            >,
    {
        self.stateless_conversation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conversation_profile][crate::model::GenerateStatelessSummaryRequest::conversation_profile].
    pub fn set_conversation_profile<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConversationProfile>,
    {
        self.conversation_profile = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation_profile][crate::model::GenerateStatelessSummaryRequest::conversation_profile].
    pub fn set_or_clear_conversation_profile<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConversationProfile>,
    {
        self.conversation_profile = v.map(|x| x.into());
        self
    }

    /// Sets the value of [latest_message][crate::model::GenerateStatelessSummaryRequest::latest_message].
    pub fn set_latest_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.latest_message = v.into();
        self
    }

    /// Sets the value of [max_context_size][crate::model::GenerateStatelessSummaryRequest::max_context_size].
    pub fn set_max_context_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_context_size = v.into();
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for GenerateStatelessSummaryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GenerateStatelessSummaryRequest"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateStatelessSummaryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __stateless_conversation,
            __conversation_profile,
            __latest_message,
            __max_context_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateStatelessSummaryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "statelessConversation" => Ok(__FieldTag::__stateless_conversation),
                            "stateless_conversation" => Ok(__FieldTag::__stateless_conversation),
                            "conversationProfile" => Ok(__FieldTag::__conversation_profile),
                            "conversation_profile" => Ok(__FieldTag::__conversation_profile),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "maxContextSize" => Ok(__FieldTag::__max_context_size),
                            "max_context_size" => Ok(__FieldTag::__max_context_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateStatelessSummaryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateStatelessSummaryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__stateless_conversation => {
                            if !fields.insert(__FieldTag::__stateless_conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stateless_conversation",
                                ));
                            }
                            result.stateless_conversation = map.next_value::<std::option::Option<crate::model::generate_stateless_summary_request::MinimalConversation>>()?
                                ;
                        }
                        __FieldTag::__conversation_profile => {
                            if !fields.insert(__FieldTag::__conversation_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_profile",
                                ));
                            }
                            result.conversation_profile = map.next_value::<std::option::Option<crate::model::ConversationProfile>>()?
                                ;
                        }
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_message",
                                ));
                            }
                            result.latest_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_context_size => {
                            if !fields.insert(__FieldTag::__max_context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_context_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_context_size =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for GenerateStatelessSummaryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.stateless_conversation.is_some() {
            state.serialize_entry("statelessConversation", &self.stateless_conversation)?;
        }
        if self.conversation_profile.is_some() {
            state.serialize_entry("conversationProfile", &self.conversation_profile)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.max_context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxContextSize", &__With(&self.max_context_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GenerateStatelessSummaryRequest].
#[cfg(feature = "conversations")]
pub mod generate_stateless_summary_request {
    #[allow(unused_imports)]
    use super::*;

    /// The minimum amount of information required to generate a Summary without
    /// having a Conversation resource created.
    #[cfg(feature = "conversations")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MinimalConversation {
        /// Required. The messages that the Summary will be generated from. It is
        /// expected that this message content is already redacted and does not
        /// contain any PII. Required fields: {content, language_code, participant,
        /// participant_role} Optional fields: {send_time} If send_time is not
        /// provided, then the messages must be provided in chronological order.
        pub messages: std::vec::Vec<crate::model::Message>,

        /// Required. The parent resource to charge for the Summary's generation.
        /// Format: `projects/<Project ID>/locations/<Location ID>`.
        pub parent: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "conversations")]
    impl MinimalConversation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [messages][crate::model::generate_stateless_summary_request::MinimalConversation::messages].
        pub fn set_messages<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Message>,
        {
            use std::iter::Iterator;
            self.messages = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [parent][crate::model::generate_stateless_summary_request::MinimalConversation::parent].
        pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.parent = v.into();
            self
        }
    }

    #[cfg(feature = "conversations")]
    impl wkt::message::Message for MinimalConversation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.GenerateStatelessSummaryRequest.MinimalConversation"
        }
    }

    #[cfg(feature = "conversations")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MinimalConversation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __messages,
                __parent,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MinimalConversation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "messages" => Ok(__FieldTag::__messages),
                                "parent" => Ok(__FieldTag::__parent),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MinimalConversation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MinimalConversation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__messages => {
                                if !fields.insert(__FieldTag::__messages) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for messages",
                                    ));
                                }
                                result.messages = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Message>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__parent => {
                                if !fields.insert(__FieldTag::__parent) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parent",
                                    ));
                                }
                                result.parent = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "conversations")]
    #[doc(hidden)]
    impl serde::ser::Serialize for MinimalConversation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.messages.is_empty() {
                state.serialize_entry("messages", &self.messages)?;
            }
            if !self.parent.is_empty() {
                state.serialize_entry("parent", &self.parent)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// The response message for
/// [Conversations.GenerateStatelessSummary][google.cloud.dialogflow.v2.Conversations.GenerateStatelessSummary].
///
/// [google.cloud.dialogflow.v2.Conversations.GenerateStatelessSummary]: crate::client::Conversations::generate_stateless_summary
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateStatelessSummaryResponse {
    /// Generated summary.
    pub summary: std::option::Option<crate::model::generate_stateless_summary_response::Summary>,

    /// The name of the latest conversation message used as context for
    /// compiling suggestion. The format is specific to the user and the names of
    /// the messages provided.
    pub latest_message: std::string::String,

    /// Number of messages prior to and including
    /// [latest_message][google.cloud.dialogflow.v2.GenerateStatelessSummaryResponse.latest_message]
    /// used to compile the suggestion. It may be smaller than the
    /// [GenerateStatelessSummaryRequest.max_context_size][google.cloud.dialogflow.v2.GenerateStatelessSummaryRequest.max_context_size]
    /// field in the request if there weren't that many messages in the
    /// conversation.
    ///
    /// [google.cloud.dialogflow.v2.GenerateStatelessSummaryRequest.max_context_size]: crate::model::GenerateStatelessSummaryRequest::max_context_size
    /// [google.cloud.dialogflow.v2.GenerateStatelessSummaryResponse.latest_message]: crate::model::GenerateStatelessSummaryResponse::latest_message
    pub context_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl GenerateStatelessSummaryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [summary][crate::model::GenerateStatelessSummaryResponse::summary].
    pub fn set_summary<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::generate_stateless_summary_response::Summary>,
    {
        self.summary = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [summary][crate::model::GenerateStatelessSummaryResponse::summary].
    pub fn set_or_clear_summary<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::generate_stateless_summary_response::Summary>,
    {
        self.summary = v.map(|x| x.into());
        self
    }

    /// Sets the value of [latest_message][crate::model::GenerateStatelessSummaryResponse::latest_message].
    pub fn set_latest_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.latest_message = v.into();
        self
    }

    /// Sets the value of [context_size][crate::model::GenerateStatelessSummaryResponse::context_size].
    pub fn set_context_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.context_size = v.into();
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for GenerateStatelessSummaryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GenerateStatelessSummaryResponse"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateStatelessSummaryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __summary,
            __latest_message,
            __context_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateStatelessSummaryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "summary" => Ok(__FieldTag::__summary),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateStatelessSummaryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateStatelessSummaryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__summary => {
                            if !fields.insert(__FieldTag::__summary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for summary",
                                ));
                            }
                            result.summary = map.next_value::<std::option::Option<
                                crate::model::generate_stateless_summary_response::Summary,
                            >>()?;
                        }
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_message",
                                ));
                            }
                            result.latest_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for GenerateStatelessSummaryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.summary.is_some() {
            state.serialize_entry("summary", &self.summary)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GenerateStatelessSummaryResponse].
#[cfg(feature = "conversations")]
pub mod generate_stateless_summary_response {
    #[allow(unused_imports)]
    use super::*;

    /// Generated summary for a conversation.
    #[cfg(feature = "conversations")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Summary {
        /// The summary content that is concatenated into one string.
        pub text: std::string::String,

        /// The summary content that is divided into sections. The key is the
        /// section's name and the value is the section's content. There is no
        /// specific format for the key or value.
        pub text_sections: std::collections::HashMap<std::string::String, std::string::String>,

        /// The baseline model version used to generate this summary. It is empty if
        /// a baseline model was not used to generate this summary.
        pub baseline_model_version: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "conversations")]
    impl Summary {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [text][crate::model::generate_stateless_summary_response::Summary::text].
        pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.text = v.into();
            self
        }

        /// Sets the value of [text_sections][crate::model::generate_stateless_summary_response::Summary::text_sections].
        pub fn set_text_sections<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.text_sections = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [baseline_model_version][crate::model::generate_stateless_summary_response::Summary::baseline_model_version].
        pub fn set_baseline_model_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.baseline_model_version = v.into();
            self
        }
    }

    #[cfg(feature = "conversations")]
    impl wkt::message::Message for Summary {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.GenerateStatelessSummaryResponse.Summary"
        }
    }

    #[cfg(feature = "conversations")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Summary {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __text,
                __text_sections,
                __baseline_model_version,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Summary")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "text" => Ok(__FieldTag::__text),
                                "textSections" => Ok(__FieldTag::__text_sections),
                                "text_sections" => Ok(__FieldTag::__text_sections),
                                "baselineModelVersion" => Ok(__FieldTag::__baseline_model_version),
                                "baseline_model_version" => {
                                    Ok(__FieldTag::__baseline_model_version)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Summary;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Summary")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__text => {
                                if !fields.insert(__FieldTag::__text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text",
                                    ));
                                }
                                result.text = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__text_sections => {
                                if !fields.insert(__FieldTag::__text_sections) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text_sections",
                                    ));
                                }
                                result.text_sections = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__baseline_model_version => {
                                if !fields.insert(__FieldTag::__baseline_model_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for baseline_model_version",
                                    ));
                                }
                                result.baseline_model_version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "conversations")]
    #[doc(hidden)]
    impl serde::ser::Serialize for Summary {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.text.is_empty() {
                state.serialize_entry("text", &self.text)?;
            }
            if !self.text_sections.is_empty() {
                state.serialize_entry("textSections", &self.text_sections)?;
            }
            if !self.baseline_model_version.is_empty() {
                state.serialize_entry("baselineModelVersion", &self.baseline_model_version)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// The request message for
/// [Conversations.GenerateStatelessSuggestion][google.cloud.dialogflow.v2.Conversations.GenerateStatelessSuggestion].
///
/// [google.cloud.dialogflow.v2.Conversations.GenerateStatelessSuggestion]: crate::client::Conversations::generate_stateless_suggestion
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateStatelessSuggestionRequest {
    /// Required. The parent resource to charge for the Suggestion's generation.
    /// Format: `projects/<Project ID>/locations/<Location ID>`.
    pub parent: std::string::String,

    /// Optional. A section of ingested context information. The key is the name of
    /// the context reference and the value contains the contents of the context
    /// reference. The key is used to incorporate ingested context references to
    /// enhance the generator.
    pub context_references: std::collections::HashMap<
        std::string::String,
        crate::model::conversation::ContextReference,
    >,

    /// Optional. Context of the conversation, including transcripts.
    pub conversation_context: std::option::Option<crate::model::ConversationContext>,

    /// Optional. A list of trigger events. Generator will be triggered only if
    /// it's trigger event is included here.
    pub trigger_events: std::vec::Vec<crate::model::TriggerEvent>,

    /// Generator.
    pub generator_resource:
        std::option::Option<crate::model::generate_stateless_suggestion_request::GeneratorResource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl GenerateStatelessSuggestionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GenerateStatelessSuggestionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [context_references][crate::model::GenerateStatelessSuggestionRequest::context_references].
    pub fn set_context_references<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::conversation::ContextReference>,
    {
        use std::iter::Iterator;
        self.context_references = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [conversation_context][crate::model::GenerateStatelessSuggestionRequest::conversation_context].
    pub fn set_conversation_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConversationContext>,
    {
        self.conversation_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation_context][crate::model::GenerateStatelessSuggestionRequest::conversation_context].
    pub fn set_or_clear_conversation_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConversationContext>,
    {
        self.conversation_context = v.map(|x| x.into());
        self
    }

    /// Sets the value of [trigger_events][crate::model::GenerateStatelessSuggestionRequest::trigger_events].
    pub fn set_trigger_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TriggerEvent>,
    {
        use std::iter::Iterator;
        self.trigger_events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [generator_resource][crate::model::GenerateStatelessSuggestionRequest::generator_resource].
    ///
    /// Note that all the setters affecting `generator_resource` are mutually
    /// exclusive.
    pub fn set_generator_resource<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::generate_stateless_suggestion_request::GeneratorResource,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.generator_resource = v.into();
        self
    }

    /// The value of [generator_resource][crate::model::GenerateStatelessSuggestionRequest::generator_resource]
    /// if it holds a `Generator`, `None` if the field is not set or
    /// holds a different branch.
    pub fn generator(&self) -> std::option::Option<&std::boxed::Box<crate::model::Generator>> {
        #[allow(unreachable_patterns)]
        self.generator_resource.as_ref().and_then(|v| match v {
            crate::model::generate_stateless_suggestion_request::GeneratorResource::Generator(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [generator_resource][crate::model::GenerateStatelessSuggestionRequest::generator_resource]
    /// to hold a `Generator`.
    ///
    /// Note that all the setters affecting `generator_resource` are
    /// mutually exclusive.
    pub fn set_generator<T: std::convert::Into<std::boxed::Box<crate::model::Generator>>>(
        mut self,
        v: T,
    ) -> Self {
        self.generator_resource = std::option::Option::Some(
            crate::model::generate_stateless_suggestion_request::GeneratorResource::Generator(
                v.into(),
            ),
        );
        self
    }

    /// The value of [generator_resource][crate::model::GenerateStatelessSuggestionRequest::generator_resource]
    /// if it holds a `GeneratorName`, `None` if the field is not set or
    /// holds a different branch.
    pub fn generator_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.generator_resource.as_ref().and_then(|v| match v {
            crate::model::generate_stateless_suggestion_request::GeneratorResource::GeneratorName(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [generator_resource][crate::model::GenerateStatelessSuggestionRequest::generator_resource]
    /// to hold a `GeneratorName`.
    ///
    /// Note that all the setters affecting `generator_resource` are
    /// mutually exclusive.
    pub fn set_generator_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.generator_resource = std::option::Option::Some(
            crate::model::generate_stateless_suggestion_request::GeneratorResource::GeneratorName(
                v.into(),
            ),
        );
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for GenerateStatelessSuggestionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GenerateStatelessSuggestionRequest"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateStatelessSuggestionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __generator,
            __generator_name,
            __context_references,
            __conversation_context,
            __trigger_events,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateStatelessSuggestionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "generator" => Ok(__FieldTag::__generator),
                            "generatorName" => Ok(__FieldTag::__generator_name),
                            "generator_name" => Ok(__FieldTag::__generator_name),
                            "contextReferences" => Ok(__FieldTag::__context_references),
                            "context_references" => Ok(__FieldTag::__context_references),
                            "conversationContext" => Ok(__FieldTag::__conversation_context),
                            "conversation_context" => Ok(__FieldTag::__conversation_context),
                            "triggerEvents" => Ok(__FieldTag::__trigger_events),
                            "trigger_events" => Ok(__FieldTag::__trigger_events),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateStatelessSuggestionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateStatelessSuggestionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generator => {
                            if !fields.insert(__FieldTag::__generator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generator",
                                ));
                            }
                            if result.generator_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `generator_resource`, a oneof with full ID .google.cloud.dialogflow.v2.GenerateStatelessSuggestionRequest.generator, latest field was generator",
                                ));
                            }
                            result.generator_resource = std::option::Option::Some(
                                crate::model::generate_stateless_suggestion_request::GeneratorResource::Generator(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::Generator>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__generator_name => {
                            if !fields.insert(__FieldTag::__generator_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generator_name",
                                ));
                            }
                            if result.generator_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `generator_resource`, a oneof with full ID .google.cloud.dialogflow.v2.GenerateStatelessSuggestionRequest.generator_name, latest field was generatorName",
                                ));
                            }
                            result.generator_resource = std::option::Option::Some(
                                crate::model::generate_stateless_suggestion_request::GeneratorResource::GeneratorName(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__context_references => {
                            if !fields.insert(__FieldTag::__context_references) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context_references",
                                ));
                            }
                            result.context_references = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::conversation::ContextReference,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversation_context => {
                            if !fields.insert(__FieldTag::__conversation_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_context",
                                ));
                            }
                            result.conversation_context = map.next_value::<std::option::Option<crate::model::ConversationContext>>()?
                                ;
                        }
                        __FieldTag::__trigger_events => {
                            if !fields.insert(__FieldTag::__trigger_events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_events",
                                ));
                            }
                            result.trigger_events = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TriggerEvent>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for GenerateStatelessSuggestionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.generator() {
            state.serialize_entry("generator", value)?;
        }
        if let Some(value) = self.generator_name() {
            state.serialize_entry("generatorName", value)?;
        }
        if !self.context_references.is_empty() {
            state.serialize_entry("contextReferences", &self.context_references)?;
        }
        if self.conversation_context.is_some() {
            state.serialize_entry("conversationContext", &self.conversation_context)?;
        }
        if !self.trigger_events.is_empty() {
            state.serialize_entry("triggerEvents", &self.trigger_events)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GenerateStatelessSuggestionRequest].
#[cfg(feature = "conversations")]
pub mod generate_stateless_suggestion_request {
    #[allow(unused_imports)]
    use super::*;

    /// Generator.
    #[cfg(feature = "conversations")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum GeneratorResource {
        /// Uncreated generator. It should be a complete generator that includes all
        /// information about the generator.
        Generator(std::boxed::Box<crate::model::Generator>),
        /// The resource name of the existing created generator. Format:
        /// `projects/<Project ID>/locations/<Location ID>/generators/<Generator ID>`
        GeneratorName(std::string::String),
    }
}

/// The response message for
/// [Conversations.GenerateStatelessSuggestion][google.cloud.dialogflow.v2.Conversations.GenerateStatelessSuggestion].
///
/// [google.cloud.dialogflow.v2.Conversations.GenerateStatelessSuggestion]: crate::client::Conversations::generate_stateless_suggestion
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateStatelessSuggestionResponse {
    /// Required. Generated suggestion for a conversation.
    pub generator_suggestion: std::option::Option<crate::model::GeneratorSuggestion>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl GenerateStatelessSuggestionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generator_suggestion][crate::model::GenerateStatelessSuggestionResponse::generator_suggestion].
    pub fn set_generator_suggestion<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GeneratorSuggestion>,
    {
        self.generator_suggestion = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [generator_suggestion][crate::model::GenerateStatelessSuggestionResponse::generator_suggestion].
    pub fn set_or_clear_generator_suggestion<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GeneratorSuggestion>,
    {
        self.generator_suggestion = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for GenerateStatelessSuggestionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GenerateStatelessSuggestionResponse"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateStatelessSuggestionResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generator_suggestion,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateStatelessSuggestionResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generatorSuggestion" => Ok(__FieldTag::__generator_suggestion),
                            "generator_suggestion" => Ok(__FieldTag::__generator_suggestion),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateStatelessSuggestionResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateStatelessSuggestionResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generator_suggestion => {
                            if !fields.insert(__FieldTag::__generator_suggestion) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generator_suggestion",
                                ));
                            }
                            result.generator_suggestion = map.next_value::<std::option::Option<crate::model::GeneratorSuggestion>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for GenerateStatelessSuggestionResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.generator_suggestion.is_some() {
            state.serialize_entry("generatorSuggestion", &self.generator_suggestion)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Conversations.SearchKnowledge][google.cloud.dialogflow.v2.Conversations.SearchKnowledge].
///
/// [google.cloud.dialogflow.v2.Conversations.SearchKnowledge]: crate::client::Conversations::search_knowledge
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchKnowledgeRequest {
    /// Required. The parent resource contains the conversation profile
    /// Format: 'projects/\<Project ID\>' or `projects/<Project
    /// ID>/locations/<Location ID>`.
    pub parent: std::string::String,

    /// Required. The natural language text query for knowledge search.
    pub query: std::option::Option<crate::model::TextInput>,

    /// Required. The conversation profile used to configure the search.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversationProfiles/<Conversation Profile ID>`.
    pub conversation_profile: std::string::String,

    /// Required. The ID of the search session.
    /// The session_id can be combined with Dialogflow V3 Agent ID retrieved from
    /// conversation profile or on its own to identify a search session. The search
    /// history of the same session will impact the search result. It's up to the
    /// API caller to choose an appropriate `Session ID`. It can be a random number
    /// or some type of session identifiers (preferably hashed). The length must
    /// not exceed 36 characters.
    pub session_id: std::string::String,

    /// Optional. The conversation (between human agent and end user) where the
    /// search request is triggered. Format: `projects/<Project
    /// ID>/locations/<Location ID>/conversations/<Conversation ID>`.
    pub conversation: std::string::String,

    /// Optional. The name of the latest conversation message when the request is
    /// triggered.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/messages/<Message ID>`.
    pub latest_message: std::string::String,

    /// Optional. The source of the query in the request.
    pub query_source: crate::model::search_knowledge_request::QuerySource,

    /// Optional. Information about the end-user to improve the relevance and
    /// accuracy of generative answers.
    ///
    /// This will be interpreted and used by a language model, so, for good
    /// results, the data should be self-descriptive, and in a simple structure.
    ///
    /// Example:
    ///
    /// ```norust
    /// {
    ///   "subscription plan": "Business Premium Plus",
    ///   "devices owned": [
    ///     {"model": "Google Pixel 7"},
    ///     {"model": "Google Pixel Tablet"}
    ///   ]
    /// }
    /// ```
    pub end_user_metadata: std::option::Option<wkt::Struct>,

    /// Optional. Configuration specific to search queries with data stores.
    pub search_config: std::option::Option<crate::model::search_knowledge_request::SearchConfig>,

    /// Optional. Whether to search the query exactly without query rewrite.
    pub exact_search: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl SearchKnowledgeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchKnowledgeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [query][crate::model::SearchKnowledgeRequest::query].
    pub fn set_query<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TextInput>,
    {
        self.query = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query][crate::model::SearchKnowledgeRequest::query].
    pub fn set_or_clear_query<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TextInput>,
    {
        self.query = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conversation_profile][crate::model::SearchKnowledgeRequest::conversation_profile].
    pub fn set_conversation_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_profile = v.into();
        self
    }

    /// Sets the value of [session_id][crate::model::SearchKnowledgeRequest::session_id].
    pub fn set_session_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session_id = v.into();
        self
    }

    /// Sets the value of [conversation][crate::model::SearchKnowledgeRequest::conversation].
    pub fn set_conversation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.conversation = v.into();
        self
    }

    /// Sets the value of [latest_message][crate::model::SearchKnowledgeRequest::latest_message].
    pub fn set_latest_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.latest_message = v.into();
        self
    }

    /// Sets the value of [query_source][crate::model::SearchKnowledgeRequest::query_source].
    pub fn set_query_source<
        T: std::convert::Into<crate::model::search_knowledge_request::QuerySource>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.query_source = v.into();
        self
    }

    /// Sets the value of [end_user_metadata][crate::model::SearchKnowledgeRequest::end_user_metadata].
    pub fn set_end_user_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.end_user_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_user_metadata][crate::model::SearchKnowledgeRequest::end_user_metadata].
    pub fn set_or_clear_end_user_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.end_user_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [search_config][crate::model::SearchKnowledgeRequest::search_config].
    pub fn set_search_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::search_knowledge_request::SearchConfig>,
    {
        self.search_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [search_config][crate::model::SearchKnowledgeRequest::search_config].
    pub fn set_or_clear_search_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::search_knowledge_request::SearchConfig>,
    {
        self.search_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [exact_search][crate::model::SearchKnowledgeRequest::exact_search].
    pub fn set_exact_search<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.exact_search = v.into();
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for SearchKnowledgeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SearchKnowledgeRequest"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchKnowledgeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __query,
            __conversation_profile,
            __session_id,
            __conversation,
            __latest_message,
            __query_source,
            __end_user_metadata,
            __search_config,
            __exact_search,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchKnowledgeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "query" => Ok(__FieldTag::__query),
                            "conversationProfile" => Ok(__FieldTag::__conversation_profile),
                            "conversation_profile" => Ok(__FieldTag::__conversation_profile),
                            "sessionId" => Ok(__FieldTag::__session_id),
                            "session_id" => Ok(__FieldTag::__session_id),
                            "conversation" => Ok(__FieldTag::__conversation),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "querySource" => Ok(__FieldTag::__query_source),
                            "query_source" => Ok(__FieldTag::__query_source),
                            "endUserMetadata" => Ok(__FieldTag::__end_user_metadata),
                            "end_user_metadata" => Ok(__FieldTag::__end_user_metadata),
                            "searchConfig" => Ok(__FieldTag::__search_config),
                            "search_config" => Ok(__FieldTag::__search_config),
                            "exactSearch" => Ok(__FieldTag::__exact_search),
                            "exact_search" => Ok(__FieldTag::__exact_search),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchKnowledgeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchKnowledgeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query =
                                map.next_value::<std::option::Option<crate::model::TextInput>>()?;
                        }
                        __FieldTag::__conversation_profile => {
                            if !fields.insert(__FieldTag::__conversation_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_profile",
                                ));
                            }
                            result.conversation_profile = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__session_id => {
                            if !fields.insert(__FieldTag::__session_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_id",
                                ));
                            }
                            result.session_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation",
                                ));
                            }
                            result.conversation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_message",
                                ));
                            }
                            result.latest_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_source => {
                            if !fields.insert(__FieldTag::__query_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_source",
                                ));
                            }
                            result.query_source = map
                                .next_value::<std::option::Option<
                                    crate::model::search_knowledge_request::QuerySource,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__end_user_metadata => {
                            if !fields.insert(__FieldTag::__end_user_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_user_metadata",
                                ));
                            }
                            result.end_user_metadata =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__search_config => {
                            if !fields.insert(__FieldTag::__search_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for search_config",
                                ));
                            }
                            result.search_config = map.next_value::<std::option::Option<
                                crate::model::search_knowledge_request::SearchConfig,
                            >>()?;
                        }
                        __FieldTag::__exact_search => {
                            if !fields.insert(__FieldTag::__exact_search) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exact_search",
                                ));
                            }
                            result.exact_search = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for SearchKnowledgeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.query.is_some() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.conversation_profile.is_empty() {
            state.serialize_entry("conversationProfile", &self.conversation_profile)?;
        }
        if !self.session_id.is_empty() {
            state.serialize_entry("sessionId", &self.session_id)?;
        }
        if !self.conversation.is_empty() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.query_source) {
            state.serialize_entry("querySource", &self.query_source)?;
        }
        if self.end_user_metadata.is_some() {
            state.serialize_entry("endUserMetadata", &self.end_user_metadata)?;
        }
        if self.search_config.is_some() {
            state.serialize_entry("searchConfig", &self.search_config)?;
        }
        if !wkt::internal::is_default(&self.exact_search) {
            state.serialize_entry("exactSearch", &self.exact_search)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SearchKnowledgeRequest].
#[cfg(feature = "conversations")]
pub mod search_knowledge_request {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration specific to search queries with data stores.
    #[cfg(feature = "conversations")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SearchConfig {
        /// Optional. Boost specifications for data stores.
        ///
        /// Maps from datastore name to their boost configuration. Do not specify
        /// more than one BoostSpecs for each datastore name. If multiple BoostSpecs
        /// are provided for the same datastore name, the behavior is undefined.
        pub boost_specs:
            std::vec::Vec<crate::model::search_knowledge_request::search_config::BoostSpecs>,

        /// Optional. Filter specification for data store queries.
        ///
        /// TMaps from datastore name to the filter expression for that datastore. Do
        /// not specify more than one FilterSpecs for each datastore name. If
        /// multiple FilterSpecs are provided for the same datastore name, the
        /// behavior is undefined.
        pub filter_specs:
            std::vec::Vec<crate::model::search_knowledge_request::search_config::FilterSpecs>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "conversations")]
    impl SearchConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [boost_specs][crate::model::search_knowledge_request::SearchConfig::boost_specs].
        pub fn set_boost_specs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::search_knowledge_request::search_config::BoostSpecs,
                >,
        {
            use std::iter::Iterator;
            self.boost_specs = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [filter_specs][crate::model::search_knowledge_request::SearchConfig::filter_specs].
        pub fn set_filter_specs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::search_knowledge_request::search_config::FilterSpecs,
                >,
        {
            use std::iter::Iterator;
            self.filter_specs = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "conversations")]
    impl wkt::message::Message for SearchConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.SearchKnowledgeRequest.SearchConfig"
        }
    }

    #[cfg(feature = "conversations")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SearchConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __boost_specs,
                __filter_specs,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SearchConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "boostSpecs" => Ok(__FieldTag::__boost_specs),
                                "boost_specs" => Ok(__FieldTag::__boost_specs),
                                "filterSpecs" => Ok(__FieldTag::__filter_specs),
                                "filter_specs" => Ok(__FieldTag::__filter_specs),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SearchConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SearchConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__boost_specs => {
                                if !fields.insert(__FieldTag::__boost_specs) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for boost_specs",
                                    ));
                                }
                                result.boost_specs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::search_knowledge_request::search_config::BoostSpecs>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__filter_specs => {
                                if !fields.insert(__FieldTag::__filter_specs) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for filter_specs",
                                    ));
                                }
                                result.filter_specs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::search_knowledge_request::search_config::FilterSpecs>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "conversations")]
    #[doc(hidden)]
    impl serde::ser::Serialize for SearchConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.boost_specs.is_empty() {
                state.serialize_entry("boostSpecs", &self.boost_specs)?;
            }
            if !self.filter_specs.is_empty() {
                state.serialize_entry("filterSpecs", &self.filter_specs)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [SearchConfig].
    #[cfg(feature = "conversations")]
    pub mod search_config {
        #[allow(unused_imports)]
        use super::*;

        /// Boost specifications for data stores.
        #[cfg(feature = "conversations")]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct BoostSpecs {
            /// Optional. Data Stores where the boosting configuration is applied. The
            /// full names of the referenced data stores. Formats:
            /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`
            /// `projects/{project}/locations/{location}/dataStores/{data_store}`
            pub data_stores: std::vec::Vec<std::string::String>,

            /// Optional. A list of boosting specifications.
            pub spec: std::vec::Vec<
                crate::model::search_knowledge_request::search_config::boost_specs::BoostSpec,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "conversations")]
        impl BoostSpecs {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [data_stores][crate::model::search_knowledge_request::search_config::BoostSpecs::data_stores].
            pub fn set_data_stores<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.data_stores = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [spec][crate::model::search_knowledge_request::search_config::BoostSpecs::spec].
            pub fn set_spec<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::search_knowledge_request::search_config::boost_specs::BoostSpec>
            {
                use std::iter::Iterator;
                self.spec = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(feature = "conversations")]
        impl wkt::message::Message for BoostSpecs {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.SearchKnowledgeRequest.SearchConfig.BoostSpecs"
            }
        }

        #[cfg(feature = "conversations")]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for BoostSpecs {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __data_stores,
                    __spec,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for BoostSpecs")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "dataStores" => Ok(__FieldTag::__data_stores),
                                    "data_stores" => Ok(__FieldTag::__data_stores),
                                    "spec" => Ok(__FieldTag::__spec),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = BoostSpecs;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct BoostSpecs")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__data_stores => {
                                    if !fields.insert(__FieldTag::__data_stores) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for data_stores",
                                            ),
                                        );
                                    }
                                    result.data_stores = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__spec => {
                                    if !fields.insert(__FieldTag::__spec) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for spec"),
                                        );
                                    }
                                    result.spec = map.next_value::<std::option::Option<std::vec::Vec<crate::model::search_knowledge_request::search_config::boost_specs::BoostSpec>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(feature = "conversations")]
        #[doc(hidden)]
        impl serde::ser::Serialize for BoostSpecs {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.data_stores.is_empty() {
                    state.serialize_entry("dataStores", &self.data_stores)?;
                }
                if !self.spec.is_empty() {
                    state.serialize_entry("spec", &self.spec)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [BoostSpecs].
        #[cfg(feature = "conversations")]
        pub mod boost_specs {
            #[allow(unused_imports)]
            use super::*;

            /// Boost specification to boost certain documents.
            /// A copy of google.cloud.discoveryengine.v1main.BoostSpec, field
            /// documentation is available at
            /// <https://cloud.google.com/generative-ai-app-builder/docs/reference/rest/v1alpha/BoostSpec>
            #[cfg(feature = "conversations")]
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct BoostSpec {

                /// Optional. Condition boost specifications. If a document matches
                /// multiple conditions in the specifications, boost scores from these
                /// specifications are all applied and combined in a non-linear way.
                /// Maximum number of specifications is 20.
                pub condition_boost_specs: std::vec::Vec<crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::ConditionBoostSpec>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(feature = "conversations")]
            impl BoostSpec {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [condition_boost_specs][crate::model::search_knowledge_request::search_config::boost_specs::BoostSpec::condition_boost_specs].
                pub fn set_condition_boost_specs<T, V>(mut self, v: T) -> Self
                where
                    T: std::iter::IntoIterator<Item = V>,
                    V: std::convert::Into<crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::ConditionBoostSpec>
                {
                    use std::iter::Iterator;
                    self.condition_boost_specs = v.into_iter().map(|i| i.into()).collect();
                    self
                }
            }

            #[cfg(feature = "conversations")]
            impl wkt::message::Message for BoostSpec {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.dialogflow.v2.SearchKnowledgeRequest.SearchConfig.BoostSpecs.BoostSpec"
                }
            }

            #[cfg(feature = "conversations")]
            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for BoostSpec {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __condition_boost_specs,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for BoostSpec")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "conditionBoostSpecs" => {
                                            Ok(__FieldTag::__condition_boost_specs)
                                        }
                                        "condition_boost_specs" => {
                                            Ok(__FieldTag::__condition_boost_specs)
                                        }
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = BoostSpec;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct BoostSpec")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__condition_boost_specs => {
                                        if !fields.insert(__FieldTag::__condition_boost_specs) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for condition_boost_specs",
                                                ),
                                            );
                                        }
                                        result.condition_boost_specs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::ConditionBoostSpec>>>()?.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[cfg(feature = "conversations")]
            #[doc(hidden)]
            impl serde::ser::Serialize for BoostSpec {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.condition_boost_specs.is_empty() {
                        state
                            .serialize_entry("conditionBoostSpecs", &self.condition_boost_specs)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Defines additional types related to [BoostSpec].
            #[cfg(feature = "conversations")]
            pub mod boost_spec {
                #[allow(unused_imports)]
                use super::*;

                /// Boost applies to documents which match a condition.
                #[cfg(feature = "conversations")]
                #[derive(Clone, Debug, Default, PartialEq)]
                #[non_exhaustive]
                pub struct ConditionBoostSpec {

                    /// Optional. An expression which specifies a boost condition. The
                    /// syntax and supported fields are the same as a filter expression.
                    /// Examples:
                    ///
                    /// * To boost documents with document ID "doc_1" or "doc_2", and
                    ///   color
                    ///   "Red" or "Blue":
                    ///   * (id: ANY("doc_1", "doc_2")) AND (color: ANY("Red","Blue"))
                    pub condition: std::string::String,

                    /// Optional. Strength of the condition boost, which should be in [-1,
                    /// 1]. Negative boost means demotion. Default is 0.0.
                    ///
                    /// Setting to 1.0 gives the document a big promotion. However, it does
                    /// not necessarily mean that the boosted document will be the top
                    /// result at all times, nor that other documents will be excluded.
                    /// Results could still be shown even when none of them matches the
                    /// condition. And results that are significantly more relevant to the
                    /// search query can still trump your heavily favored but irrelevant
                    /// documents.
                    ///
                    /// Setting to -1.0 gives the document a big demotion. However, results
                    /// that are deeply relevant might still be shown. The document will
                    /// have an upstream battle to get a fairly high ranking, but it is not
                    /// blocked out completely.
                    ///
                    /// Setting to 0.0 means no boost applied. The boosting condition is
                    /// ignored.
                    pub boost: f32,

                    /// Optional. Complex specification for custom ranking based on
                    /// customer defined attribute value.
                    pub boost_control_spec: std::option::Option<crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::BoostControlSpec>,

                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                #[cfg(feature = "conversations")]
                impl ConditionBoostSpec {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [condition][crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::ConditionBoostSpec::condition].
                    pub fn set_condition<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.condition = v.into();
                        self
                    }

                    /// Sets the value of [boost][crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::ConditionBoostSpec::boost].
                    pub fn set_boost<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
                        self.boost = v.into();
                        self
                    }

                    /// Sets the value of [boost_control_spec][crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::ConditionBoostSpec::boost_control_spec].
                    pub fn set_boost_control_spec<T>(mut self, v: T) -> Self
                    where T: std::convert::Into<crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::BoostControlSpec>
                    {
                        self.boost_control_spec = std::option::Option::Some(v.into());
                        self
                    }

                    /// Sets or clears the value of [boost_control_spec][crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::ConditionBoostSpec::boost_control_spec].
                    pub fn set_or_clear_boost_control_spec<T>(mut self, v: std::option::Option<T>) -> Self
                    where T: std::convert::Into<crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::BoostControlSpec>
                    {
                        self.boost_control_spec = v.map(|x| x.into());
                        self
                    }
                }

                #[cfg(feature = "conversations")]
                impl wkt::message::Message for ConditionBoostSpec {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.dialogflow.v2.SearchKnowledgeRequest.SearchConfig.BoostSpecs.BoostSpec.ConditionBoostSpec"
                    }
                }

                #[cfg(feature = "conversations")]
                #[doc(hidden)]
                impl<'de> serde::de::Deserialize<'de> for ConditionBoostSpec {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        #[derive(PartialEq, Eq, Hash)]
                        enum __FieldTag {
                            __condition,
                            __boost,
                            __boost_control_spec,
                            Unknown(std::string::String),
                        }
                        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                            fn deserialize<D>(
                                deserializer: D,
                            ) -> std::result::Result<Self, D::Error>
                            where
                                D: serde::Deserializer<'de>,
                            {
                                struct Visitor;
                                impl<'de> serde::de::Visitor<'de> for Visitor {
                                    type Value = __FieldTag;
                                    fn expecting(
                                        &self,
                                        formatter: &mut std::fmt::Formatter,
                                    ) -> std::fmt::Result {
                                        formatter.write_str("a field name for ConditionBoostSpec")
                                    }
                                    fn visit_str<E>(
                                        self,
                                        value: &str,
                                    ) -> std::result::Result<Self::Value, E>
                                    where
                                        E: serde::de::Error,
                                    {
                                        use std::result::Result::Ok;
                                        use std::string::ToString;
                                        match value {
                                            "condition" => Ok(__FieldTag::__condition),
                                            "boost" => Ok(__FieldTag::__boost),
                                            "boostControlSpec" => {
                                                Ok(__FieldTag::__boost_control_spec)
                                            }
                                            "boost_control_spec" => {
                                                Ok(__FieldTag::__boost_control_spec)
                                            }
                                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                                        }
                                    }
                                }
                                deserializer.deserialize_identifier(Visitor)
                            }
                        }
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = ConditionBoostSpec;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("struct ConditionBoostSpec")
                            }
                            fn visit_map<A>(
                                self,
                                mut map: A,
                            ) -> std::result::Result<Self::Value, A::Error>
                            where
                                A: serde::de::MapAccess<'de>,
                            {
                                #[allow(unused_imports)]
                                use serde::de::Error;
                                use std::option::Option::Some;
                                let mut fields = std::collections::HashSet::new();
                                let mut result = Self::Value::new();
                                while let Some(tag) = map.next_key::<__FieldTag>()? {
                                    #[allow(clippy::match_single_binding)]
                                    match tag {
                                        __FieldTag::__condition => {
                                            if !fields.insert(__FieldTag::__condition) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for condition",
                                                    ),
                                                );
                                            }
                                            result.condition = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                                        }
                                        __FieldTag::__boost => {
                                            if !fields.insert(__FieldTag::__boost) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for boost",
                                                    ),
                                                );
                                            }
                                            struct __With(std::option::Option<f32>);
                                            impl<'de> serde::de::Deserialize<'de> for __With {
                                                fn deserialize<D>(
                                                    deserializer: D,
                                                ) -> std::result::Result<Self, D::Error>
                                                where
                                                    D: serde::de::Deserializer<'de>,
                                                {
                                                    serde_with::As::<
                                                        std::option::Option<wkt::internal::F32>,
                                                    >::deserialize(
                                                        deserializer
                                                    )
                                                    .map(__With)
                                                }
                                            }
                                            result.boost =
                                                map.next_value::<__With>()?.0.unwrap_or_default();
                                        }
                                        __FieldTag::__boost_control_spec => {
                                            if !fields.insert(__FieldTag::__boost_control_spec) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for boost_control_spec",
                                                    ),
                                                );
                                            }
                                            result.boost_control_spec = map.next_value::<std::option::Option<crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::BoostControlSpec>>()?
                                                ;
                                        }
                                        __FieldTag::Unknown(key) => {
                                            let value = map.next_value::<serde_json::Value>()?;
                                            result._unknown_fields.insert(key, value);
                                        }
                                    }
                                }
                                std::result::Result::Ok(result)
                            }
                        }
                        deserializer.deserialize_any(Visitor)
                    }
                }

                #[cfg(feature = "conversations")]
                #[doc(hidden)]
                impl serde::ser::Serialize for ConditionBoostSpec {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        use serde::ser::SerializeMap;
                        #[allow(unused_imports)]
                        use std::option::Option::Some;
                        let mut state = serializer.serialize_map(std::option::Option::None)?;
                        if !self.condition.is_empty() {
                            state.serialize_entry("condition", &self.condition)?;
                        }
                        if !wkt::internal::is_default(&self.boost) {
                            struct __With<'a>(&'a f32);
                            impl<'a> serde::ser::Serialize for __With<'a> {
                                fn serialize<S>(
                                    &self,
                                    serializer: S,
                                ) -> std::result::Result<S::Ok, S::Error>
                                where
                                    S: serde::ser::Serializer,
                                {
                                    serde_with::As::<wkt::internal::F32>::serialize(
                                        self.0, serializer,
                                    )
                                }
                            }
                            state.serialize_entry("boost", &__With(&self.boost))?;
                        }
                        if self.boost_control_spec.is_some() {
                            state.serialize_entry("boostControlSpec", &self.boost_control_spec)?;
                        }
                        if !self._unknown_fields.is_empty() {
                            for (key, value) in self._unknown_fields.iter() {
                                state.serialize_entry(key, &value)?;
                            }
                        }
                        state.end()
                    }
                }

                /// Defines additional types related to [ConditionBoostSpec].
                #[cfg(feature = "conversations")]
                pub mod condition_boost_spec {
                    #[allow(unused_imports)]
                    use super::*;

                    /// Specification for custom ranking based on customer specified
                    /// attribute
                    /// value. It provides more controls for customized ranking than the
                    /// simple (condition, boost) combination above.
                    #[cfg(feature = "conversations")]
                    #[derive(Clone, Debug, Default, PartialEq)]
                    #[non_exhaustive]
                    pub struct BoostControlSpec {

                        /// Optional. The name of the field whose value will be used to
                        /// determine the boost amount.
                        pub field_name: std::string::String,

                        /// Optional. The attribute type to be used to determine the boost
                        /// amount. The attribute value can be derived from the field value
                        /// of the specified field_name. In the case of numerical it is
                        /// straightforward i.e. attribute_value = numerical_field_value. In
                        /// the case of freshness however, attribute_value = (time.now() -
                        /// datetime_field_value).
                        pub attribute_type: crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::boost_control_spec::AttributeType,

                        /// Optional. The interpolation type to be applied to connect the
                        /// control points listed below.
                        pub interpolation_type: crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::boost_control_spec::InterpolationType,

                        /// Optional. The control points used to define the curve. The
                        /// monotonic function (defined through the interpolation_type above)
                        /// passes through the control points listed here.
                        pub control_points: std::vec::Vec<crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint>,

                        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                    }

                    #[cfg(feature = "conversations")]
                    impl BoostControlSpec {
                        pub fn new() -> Self {
                            std::default::Default::default()
                        }

                        /// Sets the value of [field_name][crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::BoostControlSpec::field_name].
                        pub fn set_field_name<T: std::convert::Into<std::string::String>>(
                            mut self,
                            v: T,
                        ) -> Self {
                            self.field_name = v.into();
                            self
                        }

                        /// Sets the value of [attribute_type][crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::BoostControlSpec::attribute_type].
                        pub fn set_attribute_type<T: std::convert::Into<crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::boost_control_spec::AttributeType>>(mut self, v: T) -> Self{
                            self.attribute_type = v.into();
                            self
                        }

                        /// Sets the value of [interpolation_type][crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::BoostControlSpec::interpolation_type].
                        pub fn set_interpolation_type<T: std::convert::Into<crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::boost_control_spec::InterpolationType>>(mut self, v: T) -> Self{
                            self.interpolation_type = v.into();
                            self
                        }

                        /// Sets the value of [control_points][crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::BoostControlSpec::control_points].
                        pub fn set_control_points<T, V>(mut self, v: T) -> Self
                        where
                            T: std::iter::IntoIterator<Item = V>,
                            V: std::convert::Into<crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint>
                        {
                            use std::iter::Iterator;
                            self.control_points = v.into_iter().map(|i| i.into()).collect();
                            self
                        }
                    }

                    #[cfg(feature = "conversations")]
                    impl wkt::message::Message for BoostControlSpec {
                        fn typename() -> &'static str {
                            "type.googleapis.com/google.cloud.dialogflow.v2.SearchKnowledgeRequest.SearchConfig.BoostSpecs.BoostSpec.ConditionBoostSpec.BoostControlSpec"
                        }
                    }

                    #[cfg(feature = "conversations")]
                    #[doc(hidden)]
                    impl<'de> serde::de::Deserialize<'de> for BoostControlSpec {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            #[allow(non_camel_case_types)]
                            #[doc(hidden)]
                            #[derive(PartialEq, Eq, Hash)]
                            enum __FieldTag {
                                __field_name,
                                __attribute_type,
                                __interpolation_type,
                                __control_points,
                                Unknown(std::string::String),
                            }
                            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::Deserializer<'de>,
                                {
                                    struct Visitor;
                                    impl<'de> serde::de::Visitor<'de> for Visitor {
                                        type Value = __FieldTag;
                                        fn expecting(
                                            &self,
                                            formatter: &mut std::fmt::Formatter,
                                        ) -> std::fmt::Result
                                        {
                                            formatter.write_str("a field name for BoostControlSpec")
                                        }
                                        fn visit_str<E>(
                                            self,
                                            value: &str,
                                        ) -> std::result::Result<Self::Value, E>
                                        where
                                            E: serde::de::Error,
                                        {
                                            use std::result::Result::Ok;
                                            use std::string::ToString;
                                            match value {
                                                "fieldName" => Ok(__FieldTag::__field_name),
                                                "field_name" => Ok(__FieldTag::__field_name),
                                                "attributeType" => Ok(__FieldTag::__attribute_type),
                                                "attribute_type" => {
                                                    Ok(__FieldTag::__attribute_type)
                                                }
                                                "interpolationType" => {
                                                    Ok(__FieldTag::__interpolation_type)
                                                }
                                                "interpolation_type" => {
                                                    Ok(__FieldTag::__interpolation_type)
                                                }
                                                "controlPoints" => Ok(__FieldTag::__control_points),
                                                "control_points" => {
                                                    Ok(__FieldTag::__control_points)
                                                }
                                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                                            }
                                        }
                                    }
                                    deserializer.deserialize_identifier(Visitor)
                                }
                            }
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = BoostControlSpec;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("struct BoostControlSpec")
                                }
                                fn visit_map<A>(
                                    self,
                                    mut map: A,
                                ) -> std::result::Result<Self::Value, A::Error>
                                where
                                    A: serde::de::MapAccess<'de>,
                                {
                                    #[allow(unused_imports)]
                                    use serde::de::Error;
                                    use std::option::Option::Some;
                                    let mut fields = std::collections::HashSet::new();
                                    let mut result = Self::Value::new();
                                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                                        #[allow(clippy::match_single_binding)]
                                        match tag {
                                            __FieldTag::__field_name => {
                                                if !fields.insert(__FieldTag::__field_name) {
                                                    return std::result::Result::Err(
                                                        A::Error::duplicate_field(
                                                            "multiple values for field_name",
                                                        ),
                                                    );
                                                }
                                                result.field_name = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                                            }
                                            __FieldTag::__attribute_type => {
                                                if !fields.insert(__FieldTag::__attribute_type) {
                                                    return std::result::Result::Err(
                                                        A::Error::duplicate_field(
                                                            "multiple values for attribute_type",
                                                        ),
                                                    );
                                                }
                                                result.attribute_type = map.next_value::<std::option::Option<crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::boost_control_spec::AttributeType>>()?.unwrap_or_default();
                                            }
                                            __FieldTag::__interpolation_type => {
                                                if !fields.insert(__FieldTag::__interpolation_type)
                                                {
                                                    return std::result::Result::Err(
                                                        A::Error::duplicate_field(
                                                            "multiple values for interpolation_type",
                                                        ),
                                                    );
                                                }
                                                result.interpolation_type = map.next_value::<std::option::Option<crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::boost_control_spec::InterpolationType>>()?.unwrap_or_default();
                                            }
                                            __FieldTag::__control_points => {
                                                if !fields.insert(__FieldTag::__control_points) {
                                                    return std::result::Result::Err(
                                                        A::Error::duplicate_field(
                                                            "multiple values for control_points",
                                                        ),
                                                    );
                                                }
                                                result.control_points = map.next_value::<std::option::Option<std::vec::Vec<crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint>>>()?.unwrap_or_default();
                                            }
                                            __FieldTag::Unknown(key) => {
                                                let value =
                                                    map.next_value::<serde_json::Value>()?;
                                                result._unknown_fields.insert(key, value);
                                            }
                                        }
                                    }
                                    std::result::Result::Ok(result)
                                }
                            }
                            deserializer.deserialize_any(Visitor)
                        }
                    }

                    #[cfg(feature = "conversations")]
                    #[doc(hidden)]
                    impl serde::ser::Serialize for BoostControlSpec {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            use serde::ser::SerializeMap;
                            #[allow(unused_imports)]
                            use std::option::Option::Some;
                            let mut state = serializer.serialize_map(std::option::Option::None)?;
                            if !self.field_name.is_empty() {
                                state.serialize_entry("fieldName", &self.field_name)?;
                            }
                            if !wkt::internal::is_default(&self.attribute_type) {
                                state.serialize_entry("attributeType", &self.attribute_type)?;
                            }
                            if !wkt::internal::is_default(&self.interpolation_type) {
                                state.serialize_entry(
                                    "interpolationType",
                                    &self.interpolation_type,
                                )?;
                            }
                            if !self.control_points.is_empty() {
                                state.serialize_entry("controlPoints", &self.control_points)?;
                            }
                            if !self._unknown_fields.is_empty() {
                                for (key, value) in self._unknown_fields.iter() {
                                    state.serialize_entry(key, &value)?;
                                }
                            }
                            state.end()
                        }
                    }

                    /// Defines additional types related to [BoostControlSpec].
                    #[cfg(feature = "conversations")]
                    pub mod boost_control_spec {
                        #[allow(unused_imports)]
                        use super::*;

                        /// The control points used to define the curve. The curve defined
                        /// through these control points can only be monotonically increasing
                        /// or decreasing(constant values are acceptable).
                        #[cfg(feature = "conversations")]
                        #[derive(Clone, Debug, Default, PartialEq)]
                        #[non_exhaustive]
                        pub struct ControlPoint {
                            /// Optional. Can be one of:
                            ///
                            /// 1. The numerical field value.
                            /// 1. The duration spec for freshness:
                            ///    The value must be formatted as an XSD `dayTimeDuration` value
                            ///    (a restricted subset of an ISO 8601 duration value). The
                            ///    pattern for this is: `[nD][T[nH][nM][nS]]`.
                            pub attribute_value: std::string::String,

                            /// Optional. The value between -1 to 1 by which to boost the score
                            /// if the attribute_value evaluates to the value specified above.
                            pub boost_amount: f32,

                            _unknown_fields:
                                serde_json::Map<std::string::String, serde_json::Value>,
                        }

                        #[cfg(feature = "conversations")]
                        impl ControlPoint {
                            pub fn new() -> Self {
                                std::default::Default::default()
                            }

                            /// Sets the value of [attribute_value][crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint::attribute_value].
                            pub fn set_attribute_value<
                                T: std::convert::Into<std::string::String>,
                            >(
                                mut self,
                                v: T,
                            ) -> Self {
                                self.attribute_value = v.into();
                                self
                            }

                            /// Sets the value of [boost_amount][crate::model::search_knowledge_request::search_config::boost_specs::boost_spec::condition_boost_spec::boost_control_spec::ControlPoint::boost_amount].
                            pub fn set_boost_amount<T: std::convert::Into<f32>>(
                                mut self,
                                v: T,
                            ) -> Self {
                                self.boost_amount = v.into();
                                self
                            }
                        }

                        #[cfg(feature = "conversations")]
                        impl wkt::message::Message for ControlPoint {
                            fn typename() -> &'static str {
                                "type.googleapis.com/google.cloud.dialogflow.v2.SearchKnowledgeRequest.SearchConfig.BoostSpecs.BoostSpec.ConditionBoostSpec.BoostControlSpec.ControlPoint"
                            }
                        }

                        #[cfg(feature = "conversations")]
                        #[doc(hidden)]
                        impl<'de> serde::de::Deserialize<'de> for ControlPoint {
                            fn deserialize<D>(
                                deserializer: D,
                            ) -> std::result::Result<Self, D::Error>
                            where
                                D: serde::Deserializer<'de>,
                            {
                                #[allow(non_camel_case_types)]
                                #[doc(hidden)]
                                #[derive(PartialEq, Eq, Hash)]
                                enum __FieldTag {
                                    __attribute_value,
                                    __boost_amount,
                                    Unknown(std::string::String),
                                }
                                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::Deserializer<'de>,
                                    {
                                        struct Visitor;
                                        impl<'de> serde::de::Visitor<'de> for Visitor {
                                            type Value = __FieldTag;
                                            fn expecting(
                                                &self,
                                                formatter: &mut std::fmt::Formatter,
                                            ) -> std::fmt::Result
                                            {
                                                formatter.write_str("a field name for ControlPoint")
                                            }
                                            fn visit_str<E>(
                                                self,
                                                value: &str,
                                            ) -> std::result::Result<Self::Value, E>
                                            where
                                                E: serde::de::Error,
                                            {
                                                use std::result::Result::Ok;
                                                use std::string::ToString;
                                                match value {
                                                    "attributeValue" => {
                                                        Ok(__FieldTag::__attribute_value)
                                                    }
                                                    "attribute_value" => {
                                                        Ok(__FieldTag::__attribute_value)
                                                    }
                                                    "boostAmount" => Ok(__FieldTag::__boost_amount),
                                                    "boost_amount" => {
                                                        Ok(__FieldTag::__boost_amount)
                                                    }
                                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                                }
                                            }
                                        }
                                        deserializer.deserialize_identifier(Visitor)
                                    }
                                }
                                struct Visitor;
                                impl<'de> serde::de::Visitor<'de> for Visitor {
                                    type Value = ControlPoint;
                                    fn expecting(
                                        &self,
                                        formatter: &mut std::fmt::Formatter,
                                    ) -> std::fmt::Result {
                                        formatter.write_str("struct ControlPoint")
                                    }
                                    fn visit_map<A>(
                                        self,
                                        mut map: A,
                                    ) -> std::result::Result<Self::Value, A::Error>
                                    where
                                        A: serde::de::MapAccess<'de>,
                                    {
                                        #[allow(unused_imports)]
                                        use serde::de::Error;
                                        use std::option::Option::Some;
                                        let mut fields = std::collections::HashSet::new();
                                        let mut result = Self::Value::new();
                                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                                            #[allow(clippy::match_single_binding)]
                                            match tag {
                                                __FieldTag::__attribute_value => {
                                                    if !fields.insert(__FieldTag::__attribute_value)
                                                    {
                                                        return std::result::Result::Err(
                                                            A::Error::duplicate_field(
                                                                "multiple values for attribute_value",
                                                            ),
                                                        );
                                                    }
                                                    result.attribute_value =
                                                        map.next_value::<std::option::Option<
                                                            std::string::String,
                                                        >>(
                                                        )?
                                                        .unwrap_or_default();
                                                }
                                                __FieldTag::__boost_amount => {
                                                    if !fields.insert(__FieldTag::__boost_amount) {
                                                        return std::result::Result::Err(
                                                            A::Error::duplicate_field(
                                                                "multiple values for boost_amount",
                                                            ),
                                                        );
                                                    }
                                                    struct __With(std::option::Option<f32>);
                                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                                        fn deserialize<D>(
                                                            deserializer: D,
                                                        ) -> std::result::Result<Self, D::Error>
                                                        where
                                                            D: serde::de::Deserializer<'de>,
                                                        {
                                                            serde_with::As::<
                                                                std::option::Option<
                                                                    wkt::internal::F32,
                                                                >,
                                                            >::deserialize(
                                                                deserializer
                                                            )
                                                            .map(__With)
                                                        }
                                                    }
                                                    result.boost_amount = map
                                                        .next_value::<__With>()?
                                                        .0
                                                        .unwrap_or_default();
                                                }
                                                __FieldTag::Unknown(key) => {
                                                    let value =
                                                        map.next_value::<serde_json::Value>()?;
                                                    result._unknown_fields.insert(key, value);
                                                }
                                            }
                                        }
                                        std::result::Result::Ok(result)
                                    }
                                }
                                deserializer.deserialize_any(Visitor)
                            }
                        }

                        #[cfg(feature = "conversations")]
                        #[doc(hidden)]
                        impl serde::ser::Serialize for ControlPoint {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                use serde::ser::SerializeMap;
                                #[allow(unused_imports)]
                                use std::option::Option::Some;
                                let mut state =
                                    serializer.serialize_map(std::option::Option::None)?;
                                if !self.attribute_value.is_empty() {
                                    state
                                        .serialize_entry("attributeValue", &self.attribute_value)?;
                                }
                                if !wkt::internal::is_default(&self.boost_amount) {
                                    struct __With<'a>(&'a f32);
                                    impl<'a> serde::ser::Serialize for __With<'a> {
                                        fn serialize<S>(
                                            &self,
                                            serializer: S,
                                        ) -> std::result::Result<S::Ok, S::Error>
                                        where
                                            S: serde::ser::Serializer,
                                        {
                                            serde_with::As::<wkt::internal::F32>::serialize(
                                                self.0, serializer,
                                            )
                                        }
                                    }
                                    state.serialize_entry(
                                        "boostAmount",
                                        &__With(&self.boost_amount),
                                    )?;
                                }
                                if !self._unknown_fields.is_empty() {
                                    for (key, value) in self._unknown_fields.iter() {
                                        state.serialize_entry(key, &value)?;
                                    }
                                }
                                state.end()
                            }
                        }

                        /// The attribute(or function) for which the custom ranking is to be
                        /// applied.
                        ///
                        /// # Working with unknown values
                        ///
                        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
                        /// additional enum variants at any time. Adding new variants is not considered
                        /// a breaking change. Applications should write their code in anticipation of:
                        ///
                        /// - New values appearing in future releases of the client library, **and**
                        /// - New values received dynamically, without application changes.
                        ///
                        /// Please consult the [Working with enums] section in the user guide for some
                        /// guidelines.
                        ///
                        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
                        #[cfg(feature = "conversations")]
                        #[derive(Clone, Debug, PartialEq)]
                        #[non_exhaustive]
                        pub enum AttributeType {
                            /// Unspecified AttributeType.
                            Unspecified,
                            /// The value of the numerical field will be used to dynamically
                            /// update the boost amount. In this case, the attribute_value (the
                            /// x value) of the control point will be the actual value of the
                            /// numerical field for which the boost_amount is specified.
                            Numerical,
                            /// For the freshness use case the attribute value will be the
                            /// duration between the current time and the date in the datetime
                            /// field specified. The value must be formatted as an XSD
                            /// `dayTimeDuration` value (a restricted subset of an ISO 8601
                            /// duration value). The pattern for this is:
                            /// `[nD][T[nH][nM][nS]]`. E.g. `5D`, `3DT12H30M`, `T24H`.
                            Freshness,
                            /// If set, the enum was initialized with an unknown value.
                            ///
                            /// Applications can examine the value using [AttributeType::value] or
                            /// [AttributeType::name].
                            UnknownValue(attribute_type::UnknownValue),
                        }

                        #[doc(hidden)]
                        #[cfg(feature = "conversations")]
                        pub mod attribute_type {
                            #[allow(unused_imports)]
                            use super::*;
                            #[derive(Clone, Debug, PartialEq)]
                            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
                        }

                        #[cfg(feature = "conversations")]
                        impl AttributeType {
                            /// Gets the enum value.
                            ///
                            /// Returns `None` if the enum contains an unknown value deserialized from
                            /// the string representation of enums.
                            pub fn value(&self) -> std::option::Option<i32> {
                                match self {
                                    Self::Unspecified => std::option::Option::Some(0),
                                    Self::Numerical => std::option::Option::Some(1),
                                    Self::Freshness => std::option::Option::Some(2),
                                    Self::UnknownValue(u) => u.0.value(),
                                }
                            }

                            /// Gets the enum value as a string.
                            ///
                            /// Returns `None` if the enum contains an unknown value deserialized from
                            /// the integer representation of enums.
                            pub fn name(&self) -> std::option::Option<&str> {
                                match self {
                                    Self::Unspecified => {
                                        std::option::Option::Some("ATTRIBUTE_TYPE_UNSPECIFIED")
                                    }
                                    Self::Numerical => std::option::Option::Some("NUMERICAL"),
                                    Self::Freshness => std::option::Option::Some("FRESHNESS"),
                                    Self::UnknownValue(u) => u.0.name(),
                                }
                            }
                        }

                        #[cfg(feature = "conversations")]
                        impl std::default::Default for AttributeType {
                            fn default() -> Self {
                                use std::convert::From;
                                Self::from(0)
                            }
                        }

                        #[cfg(feature = "conversations")]
                        impl std::fmt::Display for AttributeType {
                            fn fmt(
                                &self,
                                f: &mut std::fmt::Formatter<'_>,
                            ) -> std::result::Result<(), std::fmt::Error>
                            {
                                wkt::internal::display_enum(f, self.name(), self.value())
                            }
                        }

                        #[cfg(feature = "conversations")]
                        impl std::convert::From<i32> for AttributeType {
                            fn from(value: i32) -> Self {
                                match value {
                                    0 => Self::Unspecified,
                                    1 => Self::Numerical,
                                    2 => Self::Freshness,
                                    _ => Self::UnknownValue(attribute_type::UnknownValue(
                                        wkt::internal::UnknownEnumValue::Integer(value),
                                    )),
                                }
                            }
                        }

                        #[cfg(feature = "conversations")]
                        impl std::convert::From<&str> for AttributeType {
                            fn from(value: &str) -> Self {
                                use std::string::ToString;
                                match value {
                                    "ATTRIBUTE_TYPE_UNSPECIFIED" => Self::Unspecified,
                                    "NUMERICAL" => Self::Numerical,
                                    "FRESHNESS" => Self::Freshness,
                                    _ => Self::UnknownValue(attribute_type::UnknownValue(
                                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                                    )),
                                }
                            }
                        }

                        #[cfg(feature = "conversations")]
                        impl serde::ser::Serialize for AttributeType {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::Serializer,
                            {
                                match self {
                                    Self::Unspecified => serializer.serialize_i32(0),
                                    Self::Numerical => serializer.serialize_i32(1),
                                    Self::Freshness => serializer.serialize_i32(2),
                                    Self::UnknownValue(u) => u.0.serialize(serializer),
                                }
                            }
                        }

                        #[cfg(feature = "conversations")]
                        impl<'de> serde::de::Deserialize<'de> for AttributeType {
                            fn deserialize<D>(
                                deserializer: D,
                            ) -> std::result::Result<Self, D::Error>
                            where
                                D: serde::Deserializer<'de>,
                            {
                                deserializer.deserialize_any(wkt::internal::EnumVisitor::<AttributeType>::new(
                                    ".google.cloud.dialogflow.v2.SearchKnowledgeRequest.SearchConfig.BoostSpecs.BoostSpec.ConditionBoostSpec.BoostControlSpec.AttributeType"))
                            }
                        }

                        /// The interpolation type to be applied. Default will be linear
                        /// (Piecewise Linear).
                        ///
                        /// # Working with unknown values
                        ///
                        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
                        /// additional enum variants at any time. Adding new variants is not considered
                        /// a breaking change. Applications should write their code in anticipation of:
                        ///
                        /// - New values appearing in future releases of the client library, **and**
                        /// - New values received dynamically, without application changes.
                        ///
                        /// Please consult the [Working with enums] section in the user guide for some
                        /// guidelines.
                        ///
                        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
                        #[cfg(feature = "conversations")]
                        #[derive(Clone, Debug, PartialEq)]
                        #[non_exhaustive]
                        pub enum InterpolationType {
                            /// Interpolation type is unspecified. In this case, it defaults to
                            /// Linear.
                            Unspecified,
                            /// Piecewise linear interpolation will be applied.
                            Linear,
                            /// If set, the enum was initialized with an unknown value.
                            ///
                            /// Applications can examine the value using [InterpolationType::value] or
                            /// [InterpolationType::name].
                            UnknownValue(interpolation_type::UnknownValue),
                        }

                        #[doc(hidden)]
                        #[cfg(feature = "conversations")]
                        pub mod interpolation_type {
                            #[allow(unused_imports)]
                            use super::*;
                            #[derive(Clone, Debug, PartialEq)]
                            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
                        }

                        #[cfg(feature = "conversations")]
                        impl InterpolationType {
                            /// Gets the enum value.
                            ///
                            /// Returns `None` if the enum contains an unknown value deserialized from
                            /// the string representation of enums.
                            pub fn value(&self) -> std::option::Option<i32> {
                                match self {
                                    Self::Unspecified => std::option::Option::Some(0),
                                    Self::Linear => std::option::Option::Some(1),
                                    Self::UnknownValue(u) => u.0.value(),
                                }
                            }

                            /// Gets the enum value as a string.
                            ///
                            /// Returns `None` if the enum contains an unknown value deserialized from
                            /// the integer representation of enums.
                            pub fn name(&self) -> std::option::Option<&str> {
                                match self {
                                    Self::Unspecified => {
                                        std::option::Option::Some("INTERPOLATION_TYPE_UNSPECIFIED")
                                    }
                                    Self::Linear => std::option::Option::Some("LINEAR"),
                                    Self::UnknownValue(u) => u.0.name(),
                                }
                            }
                        }

                        #[cfg(feature = "conversations")]
                        impl std::default::Default for InterpolationType {
                            fn default() -> Self {
                                use std::convert::From;
                                Self::from(0)
                            }
                        }

                        #[cfg(feature = "conversations")]
                        impl std::fmt::Display for InterpolationType {
                            fn fmt(
                                &self,
                                f: &mut std::fmt::Formatter<'_>,
                            ) -> std::result::Result<(), std::fmt::Error>
                            {
                                wkt::internal::display_enum(f, self.name(), self.value())
                            }
                        }

                        #[cfg(feature = "conversations")]
                        impl std::convert::From<i32> for InterpolationType {
                            fn from(value: i32) -> Self {
                                match value {
                                    0 => Self::Unspecified,
                                    1 => Self::Linear,
                                    _ => Self::UnknownValue(interpolation_type::UnknownValue(
                                        wkt::internal::UnknownEnumValue::Integer(value),
                                    )),
                                }
                            }
                        }

                        #[cfg(feature = "conversations")]
                        impl std::convert::From<&str> for InterpolationType {
                            fn from(value: &str) -> Self {
                                use std::string::ToString;
                                match value {
                                    "INTERPOLATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                                    "LINEAR" => Self::Linear,
                                    _ => Self::UnknownValue(interpolation_type::UnknownValue(
                                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                                    )),
                                }
                            }
                        }

                        #[cfg(feature = "conversations")]
                        impl serde::ser::Serialize for InterpolationType {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::Serializer,
                            {
                                match self {
                                    Self::Unspecified => serializer.serialize_i32(0),
                                    Self::Linear => serializer.serialize_i32(1),
                                    Self::UnknownValue(u) => u.0.serialize(serializer),
                                }
                            }
                        }

                        #[cfg(feature = "conversations")]
                        impl<'de> serde::de::Deserialize<'de> for InterpolationType {
                            fn deserialize<D>(
                                deserializer: D,
                            ) -> std::result::Result<Self, D::Error>
                            where
                                D: serde::Deserializer<'de>,
                            {
                                deserializer.deserialize_any(wkt::internal::EnumVisitor::<InterpolationType>::new(
                                    ".google.cloud.dialogflow.v2.SearchKnowledgeRequest.SearchConfig.BoostSpecs.BoostSpec.ConditionBoostSpec.BoostControlSpec.InterpolationType"))
                            }
                        }
                    }
                }
            }
        }

        /// Filter specification for data store queries.
        #[cfg(feature = "conversations")]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct FilterSpecs {
            /// Optional. The data store where the filter configuration is applied.
            /// Full resource name of data store, such as
            /// projects/{project}/locations/{location}/collections/{collectionId}/
            /// dataStores/{dataStoreId}.
            pub data_stores: std::vec::Vec<std::string::String>,

            /// Optional. The filter expression to be applied.
            /// Expression syntax is documented at
            /// <https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata#filter-expression-syntax>
            pub filter: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "conversations")]
        impl FilterSpecs {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [data_stores][crate::model::search_knowledge_request::search_config::FilterSpecs::data_stores].
            pub fn set_data_stores<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.data_stores = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [filter][crate::model::search_knowledge_request::search_config::FilterSpecs::filter].
            pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.filter = v.into();
                self
            }
        }

        #[cfg(feature = "conversations")]
        impl wkt::message::Message for FilterSpecs {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.SearchKnowledgeRequest.SearchConfig.FilterSpecs"
            }
        }

        #[cfg(feature = "conversations")]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for FilterSpecs {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __data_stores,
                    __filter,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for FilterSpecs")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "dataStores" => Ok(__FieldTag::__data_stores),
                                    "data_stores" => Ok(__FieldTag::__data_stores),
                                    "filter" => Ok(__FieldTag::__filter),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = FilterSpecs;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct FilterSpecs")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__data_stores => {
                                    if !fields.insert(__FieldTag::__data_stores) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for data_stores",
                                            ),
                                        );
                                    }
                                    result.data_stores = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__filter => {
                                    if !fields.insert(__FieldTag::__filter) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for filter"),
                                        );
                                    }
                                    result.filter = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(feature = "conversations")]
        #[doc(hidden)]
        impl serde::ser::Serialize for FilterSpecs {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.data_stores.is_empty() {
                    state.serialize_entry("dataStores", &self.data_stores)?;
                }
                if !self.filter.is_empty() {
                    state.serialize_entry("filter", &self.filter)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// The source of the query. We use QuerySource to distinguish queries directly
    /// entered by agents and suggested queries from
    /// [Participants.SuggestKnowledgeAssist][google.cloud.dialogflow.v2.Participants.SuggestKnowledgeAssist].
    /// If SUGGESTED_QUERY source is specified, we will treat it as a continuation
    /// of a SuggestKnowledgeAssist call.
    ///
    /// [google.cloud.dialogflow.v2.Participants.SuggestKnowledgeAssist]: crate::client::Participants::suggest_knowledge_assist
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "conversations")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum QuerySource {
        /// Unknown query source.
        Unspecified,
        /// The query is from agents.
        AgentQuery,
        /// The query is a suggested query from
        /// [Participants.SuggestKnowledgeAssist][google.cloud.dialogflow.v2.Participants.SuggestKnowledgeAssist].
        ///
        /// [google.cloud.dialogflow.v2.Participants.SuggestKnowledgeAssist]: crate::client::Participants::suggest_knowledge_assist
        SuggestedQuery,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [QuerySource::value] or
        /// [QuerySource::name].
        UnknownValue(query_source::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "conversations")]
    pub mod query_source {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "conversations")]
    impl QuerySource {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AgentQuery => std::option::Option::Some(1),
                Self::SuggestedQuery => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("QUERY_SOURCE_UNSPECIFIED"),
                Self::AgentQuery => std::option::Option::Some("AGENT_QUERY"),
                Self::SuggestedQuery => std::option::Option::Some("SUGGESTED_QUERY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "conversations")]
    impl std::default::Default for QuerySource {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "conversations")]
    impl std::fmt::Display for QuerySource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "conversations")]
    impl std::convert::From<i32> for QuerySource {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AgentQuery,
                2 => Self::SuggestedQuery,
                _ => Self::UnknownValue(query_source::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "conversations")]
    impl std::convert::From<&str> for QuerySource {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "QUERY_SOURCE_UNSPECIFIED" => Self::Unspecified,
                "AGENT_QUERY" => Self::AgentQuery,
                "SUGGESTED_QUERY" => Self::SuggestedQuery,
                _ => Self::UnknownValue(query_source::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "conversations")]
    impl serde::ser::Serialize for QuerySource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AgentQuery => serializer.serialize_i32(1),
                Self::SuggestedQuery => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "conversations")]
    impl<'de> serde::de::Deserialize<'de> for QuerySource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<QuerySource>::new(
                ".google.cloud.dialogflow.v2.SearchKnowledgeRequest.QuerySource",
            ))
        }
    }
}

/// The response message for
/// [Conversations.SearchKnowledge][google.cloud.dialogflow.v2.Conversations.SearchKnowledge].
///
/// [google.cloud.dialogflow.v2.Conversations.SearchKnowledge]: crate::client::Conversations::search_knowledge
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchKnowledgeResponse {
    /// Most relevant snippets extracted from articles in the given knowledge base,
    /// ordered by confidence.
    pub answers: std::vec::Vec<crate::model::SearchKnowledgeAnswer>,

    /// The rewritten query used to search knowledge.
    pub rewritten_query: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl SearchKnowledgeResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [answers][crate::model::SearchKnowledgeResponse::answers].
    pub fn set_answers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SearchKnowledgeAnswer>,
    {
        use std::iter::Iterator;
        self.answers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rewritten_query][crate::model::SearchKnowledgeResponse::rewritten_query].
    pub fn set_rewritten_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rewritten_query = v.into();
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for SearchKnowledgeResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SearchKnowledgeResponse"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchKnowledgeResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answers,
            __rewritten_query,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchKnowledgeResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answers" => Ok(__FieldTag::__answers),
                            "rewrittenQuery" => Ok(__FieldTag::__rewritten_query),
                            "rewritten_query" => Ok(__FieldTag::__rewritten_query),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchKnowledgeResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchKnowledgeResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answers => {
                            if !fields.insert(__FieldTag::__answers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answers",
                                ));
                            }
                            result.answers = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SearchKnowledgeAnswer>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rewritten_query => {
                            if !fields.insert(__FieldTag::__rewritten_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rewritten_query",
                                ));
                            }
                            result.rewritten_query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for SearchKnowledgeResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.answers.is_empty() {
            state.serialize_entry("answers", &self.answers)?;
        }
        if !self.rewritten_query.is_empty() {
            state.serialize_entry("rewrittenQuery", &self.rewritten_query)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a SearchKnowledge answer.
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchKnowledgeAnswer {
    /// The piece of text from the knowledge base documents that answers
    /// the search query
    pub answer: std::string::String,

    /// The type of the answer.
    pub answer_type: crate::model::search_knowledge_answer::AnswerType,

    /// All sources used to generate the answer.
    pub answer_sources: std::vec::Vec<crate::model::search_knowledge_answer::AnswerSource>,

    /// The name of the answer record.
    /// Format: `projects/<Project ID>/locations/<location ID>/answer
    /// Records/<Answer Record ID>`
    pub answer_record: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl SearchKnowledgeAnswer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [answer][crate::model::SearchKnowledgeAnswer::answer].
    pub fn set_answer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.answer = v.into();
        self
    }

    /// Sets the value of [answer_type][crate::model::SearchKnowledgeAnswer::answer_type].
    pub fn set_answer_type<
        T: std::convert::Into<crate::model::search_knowledge_answer::AnswerType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.answer_type = v.into();
        self
    }

    /// Sets the value of [answer_sources][crate::model::SearchKnowledgeAnswer::answer_sources].
    pub fn set_answer_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::search_knowledge_answer::AnswerSource>,
    {
        use std::iter::Iterator;
        self.answer_sources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [answer_record][crate::model::SearchKnowledgeAnswer::answer_record].
    pub fn set_answer_record<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.answer_record = v.into();
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for SearchKnowledgeAnswer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SearchKnowledgeAnswer"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchKnowledgeAnswer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answer,
            __answer_type,
            __answer_sources,
            __answer_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchKnowledgeAnswer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answer" => Ok(__FieldTag::__answer),
                            "answerType" => Ok(__FieldTag::__answer_type),
                            "answer_type" => Ok(__FieldTag::__answer_type),
                            "answerSources" => Ok(__FieldTag::__answer_sources),
                            "answer_sources" => Ok(__FieldTag::__answer_sources),
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchKnowledgeAnswer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchKnowledgeAnswer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answer => {
                            if !fields.insert(__FieldTag::__answer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer",
                                ));
                            }
                            result.answer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__answer_type => {
                            if !fields.insert(__FieldTag::__answer_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_type",
                                ));
                            }
                            result.answer_type = map
                                .next_value::<std::option::Option<
                                    crate::model::search_knowledge_answer::AnswerType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__answer_sources => {
                            if !fields.insert(__FieldTag::__answer_sources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_sources",
                                ));
                            }
                            result.answer_sources = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::search_knowledge_answer::AnswerSource,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_record",
                                ));
                            }
                            result.answer_record = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for SearchKnowledgeAnswer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.answer.is_empty() {
            state.serialize_entry("answer", &self.answer)?;
        }
        if !wkt::internal::is_default(&self.answer_type) {
            state.serialize_entry("answerType", &self.answer_type)?;
        }
        if !self.answer_sources.is_empty() {
            state.serialize_entry("answerSources", &self.answer_sources)?;
        }
        if !self.answer_record.is_empty() {
            state.serialize_entry("answerRecord", &self.answer_record)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SearchKnowledgeAnswer].
#[cfg(feature = "conversations")]
pub mod search_knowledge_answer {
    #[allow(unused_imports)]
    use super::*;

    /// The sources of the answers.
    #[cfg(feature = "conversations")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AnswerSource {
        /// The title of the article.
        pub title: std::string::String,

        /// The URI of the article.
        pub uri: std::string::String,

        /// The relevant snippet of the article.
        pub snippet: std::string::String,

        /// Metadata associated with the article.
        pub metadata: std::option::Option<wkt::Struct>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "conversations")]
    impl AnswerSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [title][crate::model::search_knowledge_answer::AnswerSource::title].
        pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.title = v.into();
            self
        }

        /// Sets the value of [uri][crate::model::search_knowledge_answer::AnswerSource::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [snippet][crate::model::search_knowledge_answer::AnswerSource::snippet].
        pub fn set_snippet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.snippet = v.into();
            self
        }

        /// Sets the value of [metadata][crate::model::search_knowledge_answer::AnswerSource::metadata].
        pub fn set_metadata<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.metadata = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [metadata][crate::model::search_knowledge_answer::AnswerSource::metadata].
        pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Struct>,
        {
            self.metadata = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "conversations")]
    impl wkt::message::Message for AnswerSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.SearchKnowledgeAnswer.AnswerSource"
        }
    }

    #[cfg(feature = "conversations")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AnswerSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __title,
                __uri,
                __snippet,
                __metadata,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AnswerSource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "title" => Ok(__FieldTag::__title),
                                "uri" => Ok(__FieldTag::__uri),
                                "snippet" => Ok(__FieldTag::__snippet),
                                "metadata" => Ok(__FieldTag::__metadata),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AnswerSource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AnswerSource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__title => {
                                if !fields.insert(__FieldTag::__title) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for title",
                                    ));
                                }
                                result.title = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__uri => {
                                if !fields.insert(__FieldTag::__uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uri",
                                    ));
                                }
                                result.uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__snippet => {
                                if !fields.insert(__FieldTag::__snippet) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for snippet",
                                    ));
                                }
                                result.snippet = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__metadata => {
                                if !fields.insert(__FieldTag::__metadata) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for metadata",
                                    ));
                                }
                                result.metadata =
                                    map.next_value::<std::option::Option<wkt::Struct>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "conversations")]
    #[doc(hidden)]
    impl serde::ser::Serialize for AnswerSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.title.is_empty() {
                state.serialize_entry("title", &self.title)?;
            }
            if !self.uri.is_empty() {
                state.serialize_entry("uri", &self.uri)?;
            }
            if !self.snippet.is_empty() {
                state.serialize_entry("snippet", &self.snippet)?;
            }
            if self.metadata.is_some() {
                state.serialize_entry("metadata", &self.metadata)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The type of the answer.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "conversations")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AnswerType {
        /// The answer has a unspecified type.
        Unspecified,
        /// The answer is from FAQ documents.
        Faq,
        /// The answer is from generative model.
        Generative,
        /// The answer is from intent matching.
        Intent,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AnswerType::value] or
        /// [AnswerType::name].
        UnknownValue(answer_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "conversations")]
    pub mod answer_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "conversations")]
    impl AnswerType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Faq => std::option::Option::Some(1),
                Self::Generative => std::option::Option::Some(2),
                Self::Intent => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ANSWER_TYPE_UNSPECIFIED"),
                Self::Faq => std::option::Option::Some("FAQ"),
                Self::Generative => std::option::Option::Some("GENERATIVE"),
                Self::Intent => std::option::Option::Some("INTENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "conversations")]
    impl std::default::Default for AnswerType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "conversations")]
    impl std::fmt::Display for AnswerType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "conversations")]
    impl std::convert::From<i32> for AnswerType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Faq,
                2 => Self::Generative,
                3 => Self::Intent,
                _ => Self::UnknownValue(answer_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "conversations")]
    impl std::convert::From<&str> for AnswerType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ANSWER_TYPE_UNSPECIFIED" => Self::Unspecified,
                "FAQ" => Self::Faq,
                "GENERATIVE" => Self::Generative,
                "INTENT" => Self::Intent,
                _ => Self::UnknownValue(answer_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "conversations")]
    impl serde::ser::Serialize for AnswerType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Faq => serializer.serialize_i32(1),
                Self::Generative => serializer.serialize_i32(2),
                Self::Intent => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "conversations")]
    impl<'de> serde::de::Deserialize<'de> for AnswerType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AnswerType>::new(
                ".google.cloud.dialogflow.v2.SearchKnowledgeAnswer.AnswerType",
            ))
        }
    }
}

/// The request message for
/// [Conversations.GenerateSuggestions][google.cloud.dialogflow.v2.Conversations.GenerateSuggestions].
///
/// [google.cloud.dialogflow.v2.Conversations.GenerateSuggestions]: crate::client::Conversations::generate_suggestions
#[cfg(feature = "conversations")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateSuggestionsRequest {
    /// Required. The conversation for which the suggestions are generated. Format:
    /// `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>`.
    ///
    /// The conversation must be created with a conversation profile which has
    /// generators configured in it to be able to get suggestions.
    pub conversation: std::string::String,

    /// Optional. The name of the latest conversation message for which the request
    /// is triggered. Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/messages/<Message ID>`.
    pub latest_message: std::string::String,

    /// Optional. A list of trigger events. Only generators configured in the
    /// conversation_profile whose trigger_event is listed here will be triggered.
    pub trigger_events: std::vec::Vec<crate::model::TriggerEvent>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversations")]
impl GenerateSuggestionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation][crate::model::GenerateSuggestionsRequest::conversation].
    pub fn set_conversation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.conversation = v.into();
        self
    }

    /// Sets the value of [latest_message][crate::model::GenerateSuggestionsRequest::latest_message].
    pub fn set_latest_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.latest_message = v.into();
        self
    }

    /// Sets the value of [trigger_events][crate::model::GenerateSuggestionsRequest::trigger_events].
    pub fn set_trigger_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TriggerEvent>,
    {
        use std::iter::Iterator;
        self.trigger_events = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "conversations")]
impl wkt::message::Message for GenerateSuggestionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GenerateSuggestionsRequest"
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateSuggestionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation,
            __latest_message,
            __trigger_events,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateSuggestionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversation" => Ok(__FieldTag::__conversation),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "triggerEvents" => Ok(__FieldTag::__trigger_events),
                            "trigger_events" => Ok(__FieldTag::__trigger_events),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateSuggestionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateSuggestionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation",
                                ));
                            }
                            result.conversation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_message",
                                ));
                            }
                            result.latest_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trigger_events => {
                            if !fields.insert(__FieldTag::__trigger_events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_events",
                                ));
                            }
                            result.trigger_events = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TriggerEvent>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversations")]
#[doc(hidden)]
impl serde::ser::Serialize for GenerateSuggestionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation.is_empty() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !self.trigger_events.is_empty() {
            state.serialize_entry("triggerEvents", &self.trigger_events)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents metadata of a conversation.
#[cfg(feature = "conversation-datasets")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ConversationInfo {
    /// Optional. The language code of the conversation data within this dataset.
    /// See <https://cloud.google.com/apis/design/standard_fields> for more
    /// information. Supports all UTF-8 languages.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-datasets")]
impl ConversationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language_code][crate::model::ConversationInfo::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "conversation-datasets")]
impl wkt::message::Message for ConversationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ConversationInfo"
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConversationInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConversationInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for ConversationInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the configuration of importing a set of conversation files in
/// Google Cloud Storage.
#[cfg(feature = "conversation-datasets")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InputConfig {
    /// Required. Where the data is from.
    pub source: std::option::Option<crate::model::input_config::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-datasets")]
impl InputConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::InputConfig::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::input_config::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::InputConfig::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSources>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::input_config::Source::GcsSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::InputConfig::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSources>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::input_config::Source::GcsSource(v.into()));
        self
    }
}

#[cfg(feature = "conversation-datasets")]
impl wkt::message::Message for InputConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.InputConfig"
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InputConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_source,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InputConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsSource" => Ok(__FieldTag::__gcs_source),
                            "gcs_source" => Ok(__FieldTag::__gcs_source),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InputConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InputConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_source => {
                            if !fields.insert(__FieldTag::__gcs_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.v2.InputConfig.gcs_source, latest field was gcsSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::input_config::Source::GcsSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsSources>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for InputConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [InputConfig].
#[cfg(feature = "conversation-datasets")]
pub mod input_config {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Where the data is from.
    #[cfg(feature = "conversation-datasets")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// The Cloud Storage URI has the form gs://\<Google Cloud Storage bucket
        /// name\>//agent*.json. Wildcards are allowed and will be expanded into all
        /// matched JSON files, which will be read as one conversation per file.
        GcsSource(std::boxed::Box<crate::model::GcsSources>),
    }
}

/// Represents a conversation dataset that a user imports raw data into.
/// The data inside ConversationDataset can not be changed after
/// ImportConversationData finishes (and calling ImportConversationData on a
/// dataset that already has data is not allowed).
#[cfg(feature = "conversation-datasets")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ConversationDataset {
    /// Output only. ConversationDataset resource name. Format:
    /// `projects/<Project ID>/locations/<Location
    /// ID>/conversationDatasets/<Conversation Dataset ID>`
    pub name: std::string::String,

    /// Required. The display name of the dataset. Maximum of 64 bytes.
    pub display_name: std::string::String,

    /// Optional. The description of the dataset. Maximum of 10000 bytes.
    pub description: std::string::String,

    /// Output only. Creation time of this dataset.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Input configurations set during conversation data import.
    pub input_config: std::option::Option<crate::model::InputConfig>,

    /// Output only. Metadata set during conversation data import.
    pub conversation_info: std::option::Option<crate::model::ConversationInfo>,

    /// Output only. The number of conversations this conversation dataset
    /// contains.
    pub conversation_count: i64,

    /// Output only. A read only boolean field reflecting Zone Isolation status of
    /// the dataset.
    pub satisfies_pzi: std::option::Option<bool>,

    /// Output only. A read only boolean field reflecting Zone Separation status of
    /// the dataset.
    pub satisfies_pzs: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-datasets")]
impl ConversationDataset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConversationDataset::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ConversationDataset::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::ConversationDataset::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ConversationDataset::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ConversationDataset::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [input_config][crate::model::ConversationDataset::input_config].
    pub fn set_input_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InputConfig>,
    {
        self.input_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input_config][crate::model::ConversationDataset::input_config].
    pub fn set_or_clear_input_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InputConfig>,
    {
        self.input_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conversation_info][crate::model::ConversationDataset::conversation_info].
    pub fn set_conversation_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConversationInfo>,
    {
        self.conversation_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation_info][crate::model::ConversationDataset::conversation_info].
    pub fn set_or_clear_conversation_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConversationInfo>,
    {
        self.conversation_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conversation_count][crate::model::ConversationDataset::conversation_count].
    pub fn set_conversation_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.conversation_count = v.into();
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::ConversationDataset::satisfies_pzi].
    pub fn set_satisfies_pzi<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzi][crate::model::ConversationDataset::satisfies_pzi].
    pub fn set_or_clear_satisfies_pzi<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::ConversationDataset::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::ConversationDataset::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "conversation-datasets")]
impl wkt::message::Message for ConversationDataset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ConversationDataset"
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConversationDataset {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __create_time,
            __input_config,
            __conversation_info,
            __conversation_count,
            __satisfies_pzi,
            __satisfies_pzs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationDataset")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "inputConfig" => Ok(__FieldTag::__input_config),
                            "input_config" => Ok(__FieldTag::__input_config),
                            "conversationInfo" => Ok(__FieldTag::__conversation_info),
                            "conversation_info" => Ok(__FieldTag::__conversation_info),
                            "conversationCount" => Ok(__FieldTag::__conversation_count),
                            "conversation_count" => Ok(__FieldTag::__conversation_count),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConversationDataset;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationDataset")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__input_config => {
                            if !fields.insert(__FieldTag::__input_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_config",
                                ));
                            }
                            result.input_config =
                                map.next_value::<std::option::Option<crate::model::InputConfig>>()?;
                        }
                        __FieldTag::__conversation_info => {
                            if !fields.insert(__FieldTag::__conversation_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_info",
                                ));
                            }
                            result.conversation_info = map
                                .next_value::<std::option::Option<crate::model::ConversationInfo>>(
                                )?;
                        }
                        __FieldTag::__conversation_count => {
                            if !fields.insert(__FieldTag::__conversation_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.conversation_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for ConversationDataset {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.input_config.is_some() {
            state.serialize_entry("inputConfig", &self.input_config)?;
        }
        if self.conversation_info.is_some() {
            state.serialize_entry("conversationInfo", &self.conversation_info)?;
        }
        if !wkt::internal::is_default(&self.conversation_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("conversationCount", &__With(&self.conversation_count))?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [ConversationDatasets.CreateConversationDataset][google.cloud.dialogflow.v2.ConversationDatasets.CreateConversationDataset].
///
/// [google.cloud.dialogflow.v2.ConversationDatasets.CreateConversationDataset]: crate::client::ConversationDatasets::create_conversation_dataset
#[cfg(feature = "conversation-datasets")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateConversationDatasetRequest {
    /// Required. The project to create conversation dataset for. Format:
    /// `projects/<Project ID>/locations/<Location ID>`
    pub parent: std::string::String,

    /// Required. The conversation dataset to create.
    pub conversation_dataset: std::option::Option<crate::model::ConversationDataset>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-datasets")]
impl CreateConversationDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConversationDatasetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [conversation_dataset][crate::model::CreateConversationDatasetRequest::conversation_dataset].
    pub fn set_conversation_dataset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConversationDataset>,
    {
        self.conversation_dataset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation_dataset][crate::model::CreateConversationDatasetRequest::conversation_dataset].
    pub fn set_or_clear_conversation_dataset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConversationDataset>,
    {
        self.conversation_dataset = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "conversation-datasets")]
impl wkt::message::Message for CreateConversationDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CreateConversationDatasetRequest"
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateConversationDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __conversation_dataset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConversationDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "conversationDataset" => Ok(__FieldTag::__conversation_dataset),
                            "conversation_dataset" => Ok(__FieldTag::__conversation_dataset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateConversationDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConversationDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversation_dataset => {
                            if !fields.insert(__FieldTag::__conversation_dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_dataset",
                                ));
                            }
                            result.conversation_dataset = map.next_value::<std::option::Option<crate::model::ConversationDataset>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateConversationDatasetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.conversation_dataset.is_some() {
            state.serialize_entry("conversationDataset", &self.conversation_dataset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [ConversationDatasets.GetConversationDataset][google.cloud.dialogflow.v2.ConversationDatasets.GetConversationDataset].
///
/// [google.cloud.dialogflow.v2.ConversationDatasets.GetConversationDataset]: crate::client::ConversationDatasets::get_conversation_dataset
#[cfg(feature = "conversation-datasets")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConversationDatasetRequest {
    /// Required. The conversation dataset to retrieve. Format:
    /// `projects/<Project ID>/locations/<Location
    /// ID>/conversationDatasets/<Conversation Dataset ID>`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-datasets")]
impl GetConversationDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConversationDatasetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "conversation-datasets")]
impl wkt::message::Message for GetConversationDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetConversationDatasetRequest"
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConversationDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConversationDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConversationDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConversationDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for GetConversationDatasetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [ConversationDatasets.ListConversationDatasets][google.cloud.dialogflow.v2.ConversationDatasets.ListConversationDatasets].
///
/// [google.cloud.dialogflow.v2.ConversationDatasets.ListConversationDatasets]: crate::client::ConversationDatasets::list_conversation_datasets
#[cfg(feature = "conversation-datasets")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConversationDatasetsRequest {
    /// Required. The project and location name to list all conversation datasets
    /// for. Format: `projects/<Project ID>/locations/<Location ID>`
    pub parent: std::string::String,

    /// Optional. Maximum number of conversation datasets to return in a single
    /// page. By default 100 and at most 1000.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-datasets")]
impl ListConversationDatasetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConversationDatasetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConversationDatasetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConversationDatasetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "conversation-datasets")]
impl wkt::message::Message for ListConversationDatasetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListConversationDatasetsRequest"
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConversationDatasetsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationDatasetsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConversationDatasetsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationDatasetsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for ListConversationDatasetsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [ConversationDatasets.ListConversationDatasets][google.cloud.dialogflow.v2.ConversationDatasets.ListConversationDatasets].
///
/// [google.cloud.dialogflow.v2.ConversationDatasets.ListConversationDatasets]: crate::client::ConversationDatasets::list_conversation_datasets
#[cfg(feature = "conversation-datasets")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConversationDatasetsResponse {
    /// The list of datasets to return.
    pub conversation_datasets: std::vec::Vec<crate::model::ConversationDataset>,

    /// The token to use to retrieve the next page of results, or empty if there
    /// are no more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-datasets")]
impl ListConversationDatasetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation_datasets][crate::model::ListConversationDatasetsResponse::conversation_datasets].
    pub fn set_conversation_datasets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConversationDataset>,
    {
        use std::iter::Iterator;
        self.conversation_datasets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConversationDatasetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "conversation-datasets")]
impl wkt::message::Message for ListConversationDatasetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListConversationDatasetsResponse"
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConversationDatasetsResponse {
    type PageItem = crate::model::ConversationDataset;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.conversation_datasets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConversationDatasetsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_datasets,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationDatasetsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationDatasets" => Ok(__FieldTag::__conversation_datasets),
                            "conversation_datasets" => Ok(__FieldTag::__conversation_datasets),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConversationDatasetsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationDatasetsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_datasets => {
                            if !fields.insert(__FieldTag::__conversation_datasets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_datasets",
                                ));
                            }
                            result.conversation_datasets = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConversationDataset>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for ListConversationDatasetsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_datasets.is_empty() {
            state.serialize_entry("conversationDatasets", &self.conversation_datasets)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [ConversationDatasets.DeleteConversationDataset][google.cloud.dialogflow.v2.ConversationDatasets.DeleteConversationDataset].
///
/// [google.cloud.dialogflow.v2.ConversationDatasets.DeleteConversationDataset]: crate::client::ConversationDatasets::delete_conversation_dataset
#[cfg(feature = "conversation-datasets")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteConversationDatasetRequest {
    /// Required. The conversation dataset to delete. Format:
    /// `projects/<Project ID>/locations/<Location
    /// ID>/conversationDatasets/<Conversation Dataset ID>`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-datasets")]
impl DeleteConversationDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConversationDatasetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "conversation-datasets")]
impl wkt::message::Message for DeleteConversationDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DeleteConversationDatasetRequest"
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteConversationDatasetRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteConversationDatasetRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteConversationDatasetRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConversationDatasetRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteConversationDatasetRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [ConversationDatasets.ImportConversationData][google.cloud.dialogflow.v2.ConversationDatasets.ImportConversationData].
///
/// [google.cloud.dialogflow.v2.ConversationDatasets.ImportConversationData]: crate::client::ConversationDatasets::import_conversation_data
#[cfg(feature = "conversation-datasets")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportConversationDataRequest {
    /// Required. Dataset resource name. Format:
    /// `projects/<Project ID>/locations/<Location
    /// ID>/conversationDatasets/<Conversation Dataset ID>`
    pub name: std::string::String,

    /// Required. Configuration describing where to import data from.
    pub input_config: std::option::Option<crate::model::InputConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-datasets")]
impl ImportConversationDataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ImportConversationDataRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [input_config][crate::model::ImportConversationDataRequest::input_config].
    pub fn set_input_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InputConfig>,
    {
        self.input_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [input_config][crate::model::ImportConversationDataRequest::input_config].
    pub fn set_or_clear_input_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InputConfig>,
    {
        self.input_config = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "conversation-datasets")]
impl wkt::message::Message for ImportConversationDataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ImportConversationDataRequest"
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportConversationDataRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __input_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportConversationDataRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "inputConfig" => Ok(__FieldTag::__input_config),
                            "input_config" => Ok(__FieldTag::__input_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportConversationDataRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportConversationDataRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input_config => {
                            if !fields.insert(__FieldTag::__input_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_config",
                                ));
                            }
                            result.input_config =
                                map.next_value::<std::option::Option<crate::model::InputConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for ImportConversationDataRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.input_config.is_some() {
            state.serialize_entry("inputConfig", &self.input_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for a
/// [ConversationDatasets.ImportConversationData][google.cloud.dialogflow.v2.ConversationDatasets.ImportConversationData]
/// operation.
///
/// [google.cloud.dialogflow.v2.ConversationDatasets.ImportConversationData]: crate::client::ConversationDatasets::import_conversation_data
#[cfg(feature = "conversation-datasets")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportConversationDataOperationMetadata {
    /// The resource name of the imported conversation dataset. Format:
    /// `projects/<Project ID>/locations/<Location
    /// ID>/conversationDatasets/<Conversation Dataset Id>`
    pub conversation_dataset: std::string::String,

    /// Partial failures are failures that don't fail the whole long running
    /// operation, e.g. single files that couldn't be read.
    pub partial_failures: std::vec::Vec<rpc::model::Status>,

    /// Timestamp when import conversation data request was created. The time is
    /// measured on server side.
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-datasets")]
impl ImportConversationDataOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation_dataset][crate::model::ImportConversationDataOperationMetadata::conversation_dataset].
    pub fn set_conversation_dataset<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_dataset = v.into();
        self
    }

    /// Sets the value of [partial_failures][crate::model::ImportConversationDataOperationMetadata::partial_failures].
    pub fn set_partial_failures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.partial_failures = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::ImportConversationDataOperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ImportConversationDataOperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "conversation-datasets")]
impl wkt::message::Message for ImportConversationDataOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ImportConversationDataOperationMetadata"
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportConversationDataOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_dataset,
            __partial_failures,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ImportConversationDataOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationDataset" => Ok(__FieldTag::__conversation_dataset),
                            "conversation_dataset" => Ok(__FieldTag::__conversation_dataset),
                            "partialFailures" => Ok(__FieldTag::__partial_failures),
                            "partial_failures" => Ok(__FieldTag::__partial_failures),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportConversationDataOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportConversationDataOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_dataset => {
                            if !fields.insert(__FieldTag::__conversation_dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_dataset",
                                ));
                            }
                            result.conversation_dataset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__partial_failures => {
                            if !fields.insert(__FieldTag::__partial_failures) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partial_failures",
                                ));
                            }
                            result.partial_failures = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for ImportConversationDataOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_dataset.is_empty() {
            state.serialize_entry("conversationDataset", &self.conversation_dataset)?;
        }
        if !self.partial_failures.is_empty() {
            state.serialize_entry("partialFailures", &self.partial_failures)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response used for
/// [ConversationDatasets.ImportConversationData][google.cloud.dialogflow.v2.ConversationDatasets.ImportConversationData]
/// long running operation.
///
/// [google.cloud.dialogflow.v2.ConversationDatasets.ImportConversationData]: crate::client::ConversationDatasets::import_conversation_data
#[cfg(feature = "conversation-datasets")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportConversationDataOperationResponse {
    /// The resource name of the imported conversation dataset. Format:
    /// `projects/<Project ID>/locations/<Location
    /// ID>/conversationDatasets/<Conversation Dataset Id>`
    pub conversation_dataset: std::string::String,

    /// Number of conversations imported successfully.
    pub import_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-datasets")]
impl ImportConversationDataOperationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation_dataset][crate::model::ImportConversationDataOperationResponse::conversation_dataset].
    pub fn set_conversation_dataset<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_dataset = v.into();
        self
    }

    /// Sets the value of [import_count][crate::model::ImportConversationDataOperationResponse::import_count].
    pub fn set_import_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.import_count = v.into();
        self
    }
}

#[cfg(feature = "conversation-datasets")]
impl wkt::message::Message for ImportConversationDataOperationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ImportConversationDataOperationResponse"
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportConversationDataOperationResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_dataset,
            __import_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ImportConversationDataOperationResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationDataset" => Ok(__FieldTag::__conversation_dataset),
                            "conversation_dataset" => Ok(__FieldTag::__conversation_dataset),
                            "importCount" => Ok(__FieldTag::__import_count),
                            "import_count" => Ok(__FieldTag::__import_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportConversationDataOperationResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportConversationDataOperationResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_dataset => {
                            if !fields.insert(__FieldTag::__conversation_dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_dataset",
                                ));
                            }
                            result.conversation_dataset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__import_count => {
                            if !fields.insert(__FieldTag::__import_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.import_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for ImportConversationDataOperationResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_dataset.is_empty() {
            state.serialize_entry("conversationDataset", &self.conversation_dataset)?;
        }
        if !wkt::internal::is_default(&self.import_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("importCount", &__With(&self.import_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for [CreateConversationDataset][].
#[cfg(feature = "conversation-datasets")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateConversationDatasetOperationMetadata {
    /// The resource name of the conversation dataset that will be created. Format:
    /// `projects/<Project ID>/locations/<Location
    /// ID>/conversationDatasets/<Conversation Dataset Id>`
    pub conversation_dataset: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-datasets")]
impl CreateConversationDatasetOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation_dataset][crate::model::CreateConversationDatasetOperationMetadata::conversation_dataset].
    pub fn set_conversation_dataset<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_dataset = v.into();
        self
    }
}

#[cfg(feature = "conversation-datasets")]
impl wkt::message::Message for CreateConversationDatasetOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CreateConversationDatasetOperationMetadata"
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateConversationDatasetOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_dataset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for CreateConversationDatasetOperationMetadata",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationDataset" => Ok(__FieldTag::__conversation_dataset),
                            "conversation_dataset" => Ok(__FieldTag::__conversation_dataset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateConversationDatasetOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConversationDatasetOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_dataset => {
                            if !fields.insert(__FieldTag::__conversation_dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_dataset",
                                ));
                            }
                            result.conversation_dataset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateConversationDatasetOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_dataset.is_empty() {
            state.serialize_entry("conversationDataset", &self.conversation_dataset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for [DeleteConversationDataset][].
#[cfg(feature = "conversation-datasets")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteConversationDatasetOperationMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-datasets")]
impl DeleteConversationDatasetOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "conversation-datasets")]
impl wkt::message::Message for DeleteConversationDatasetOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DeleteConversationDatasetOperationMetadata"
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteConversationDatasetOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for DeleteConversationDatasetOperationMetadata",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteConversationDatasetOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConversationDatasetOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-datasets")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteConversationDatasetOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a notification sent to Pub/Sub subscribers for conversation
/// lifecycle events.
#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ConversationEvent {
    /// The unique identifier of the conversation this notification
    /// refers to.
    /// Format: `projects/<Project ID>/conversations/<Conversation ID>`.
    pub conversation: std::string::String,

    /// The type of the event that this notification refers to.
    pub r#type: crate::model::conversation_event::Type,

    /// More detailed information about an error. Only set for type
    /// UNRECOVERABLE_ERROR_IN_PHONE_CALL.
    pub error_status: std::option::Option<rpc::model::Status>,

    /// Payload of conversation event.
    pub payload: std::option::Option<crate::model::conversation_event::Payload>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
impl ConversationEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation][crate::model::ConversationEvent::conversation].
    pub fn set_conversation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.conversation = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::ConversationEvent::type].
    pub fn set_type<T: std::convert::Into<crate::model::conversation_event::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [error_status][crate::model::ConversationEvent::error_status].
    pub fn set_error_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_status][crate::model::ConversationEvent::error_status].
    pub fn set_or_clear_error_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [payload][crate::model::ConversationEvent::payload].
    ///
    /// Note that all the setters affecting `payload` are mutually
    /// exclusive.
    pub fn set_payload<
        T: std::convert::Into<std::option::Option<crate::model::conversation_event::Payload>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.payload = v.into();
        self
    }

    /// The value of [payload][crate::model::ConversationEvent::payload]
    /// if it holds a `NewMessagePayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn new_message_payload(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::Message>> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::model::conversation_event::Payload::NewMessagePayload(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::model::ConversationEvent::payload]
    /// to hold a `NewMessagePayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_new_message_payload<
        T: std::convert::Into<std::boxed::Box<crate::model::Message>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.payload = std::option::Option::Some(
            crate::model::conversation_event::Payload::NewMessagePayload(v.into()),
        );
        self
    }

    /// The value of [payload][crate::model::ConversationEvent::payload]
    /// if it holds a `NewRecognitionResultPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn new_recognition_result_payload(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StreamingRecognitionResult>> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::model::conversation_event::Payload::NewRecognitionResultPayload(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::model::ConversationEvent::payload]
    /// to hold a `NewRecognitionResultPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_new_recognition_result_payload<
        T: std::convert::Into<std::boxed::Box<crate::model::StreamingRecognitionResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.payload = std::option::Option::Some(
            crate::model::conversation_event::Payload::NewRecognitionResultPayload(v.into()),
        );
        self
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
impl wkt::message::Message for ConversationEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ConversationEvent"
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConversationEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation,
            __type,
            __error_status,
            __new_message_payload,
            __new_recognition_result_payload,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversation" => Ok(__FieldTag::__conversation),
                            "type" => Ok(__FieldTag::__type),
                            "errorStatus" => Ok(__FieldTag::__error_status),
                            "error_status" => Ok(__FieldTag::__error_status),
                            "newMessagePayload" => Ok(__FieldTag::__new_message_payload),
                            "new_message_payload" => Ok(__FieldTag::__new_message_payload),
                            "newRecognitionResultPayload" => {
                                Ok(__FieldTag::__new_recognition_result_payload)
                            }
                            "new_recognition_result_payload" => {
                                Ok(__FieldTag::__new_recognition_result_payload)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConversationEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation",
                                ));
                            }
                            result.conversation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::conversation_event::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error_status => {
                            if !fields.insert(__FieldTag::__error_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_status",
                                ));
                            }
                            result.error_status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__new_message_payload => {
                            if !fields.insert(__FieldTag::__new_message_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_message_payload",
                                ));
                            }
                            if result.payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `payload`, a oneof with full ID .google.cloud.dialogflow.v2.ConversationEvent.new_message_payload, latest field was newMessagePayload",
                                ));
                            }
                            result.payload =
                                std::option::Option::Some(
                                    crate::model::conversation_event::Payload::NewMessagePayload(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Message>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__new_recognition_result_payload => {
                            if !fields.insert(__FieldTag::__new_recognition_result_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_recognition_result_payload",
                                ));
                            }
                            if result.payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `payload`, a oneof with full ID .google.cloud.dialogflow.v2.ConversationEvent.new_recognition_result_payload, latest field was newRecognitionResultPayload",
                                ));
                            }
                            result.payload = std::option::Option::Some(
                                crate::model::conversation_event::Payload::NewRecognitionResultPayload(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StreamingRecognitionResult>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for ConversationEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation.is_empty() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if self.error_status.is_some() {
            state.serialize_entry("errorStatus", &self.error_status)?;
        }
        if let Some(value) = self.new_message_payload() {
            state.serialize_entry("newMessagePayload", value)?;
        }
        if let Some(value) = self.new_recognition_result_payload() {
            state.serialize_entry("newRecognitionResultPayload", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ConversationEvent].
#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
pub mod conversation_event {
    #[allow(unused_imports)]
    use super::*;

    /// Enumeration of the types of events available.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(all(
        feature = "agents",
        feature = "answer-records",
        feature = "contexts",
        feature = "conversation-datasets",
        feature = "conversation-models",
        feature = "conversation-profiles",
        feature = "conversations",
        feature = "documents",
        feature = "encryption-spec-service",
        feature = "entity-types",
        feature = "environments",
        feature = "fulfillments",
        feature = "generators",
        feature = "intents",
        feature = "knowledge-bases",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "versions",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Type not set.
        Unspecified,
        /// A new conversation has been opened. This is fired when a telephone call
        /// is answered, or a conversation is created via the API.
        ConversationStarted,
        /// An existing conversation has closed. This is fired when a telephone call
        /// is terminated, or a conversation is closed via the API.
        ConversationFinished,
        /// An existing conversation has received notification from Dialogflow that
        /// human intervention is required.
        HumanInterventionNeeded,
        /// An existing conversation has received a new message, either from API or
        /// telephony. It is configured in
        /// [ConversationProfile.new_message_event_notification_config][google.cloud.dialogflow.v2.ConversationProfile.new_message_event_notification_config]
        ///
        /// [google.cloud.dialogflow.v2.ConversationProfile.new_message_event_notification_config]: crate::model::ConversationProfile::new_message_event_notification_config
        NewMessage,
        /// An existing conversation has received a new speech recognition result.
        /// This is mainly for delivering intermediate transcripts. The notification
        /// is configured in
        /// [ConversationProfile.new_recognition_event_notification_config][].
        NewRecognitionResult,
        /// Unrecoverable error during a telephone call.
        ///
        /// In general non-recoverable errors only occur if something was
        /// misconfigured in the ConversationProfile corresponding to the call. After
        /// a non-recoverable error, Dialogflow may stop responding.
        ///
        /// We don't fire this event:
        ///
        /// * in an API call because we can directly return the error, or,
        /// * when we can recover from an error.
        UnrecoverableError,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(all(
        feature = "agents",
        feature = "answer-records",
        feature = "contexts",
        feature = "conversation-datasets",
        feature = "conversation-models",
        feature = "conversation-profiles",
        feature = "conversations",
        feature = "documents",
        feature = "encryption-spec-service",
        feature = "entity-types",
        feature = "environments",
        feature = "fulfillments",
        feature = "generators",
        feature = "intents",
        feature = "knowledge-bases",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "versions",
    ))]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(all(
        feature = "agents",
        feature = "answer-records",
        feature = "contexts",
        feature = "conversation-datasets",
        feature = "conversation-models",
        feature = "conversation-profiles",
        feature = "conversations",
        feature = "documents",
        feature = "encryption-spec-service",
        feature = "entity-types",
        feature = "environments",
        feature = "fulfillments",
        feature = "generators",
        feature = "intents",
        feature = "knowledge-bases",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "versions",
    ))]
    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ConversationStarted => std::option::Option::Some(1),
                Self::ConversationFinished => std::option::Option::Some(2),
                Self::HumanInterventionNeeded => std::option::Option::Some(3),
                Self::NewMessage => std::option::Option::Some(5),
                Self::NewRecognitionResult => std::option::Option::Some(7),
                Self::UnrecoverableError => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::ConversationStarted => std::option::Option::Some("CONVERSATION_STARTED"),
                Self::ConversationFinished => std::option::Option::Some("CONVERSATION_FINISHED"),
                Self::HumanInterventionNeeded => {
                    std::option::Option::Some("HUMAN_INTERVENTION_NEEDED")
                }
                Self::NewMessage => std::option::Option::Some("NEW_MESSAGE"),
                Self::NewRecognitionResult => std::option::Option::Some("NEW_RECOGNITION_RESULT"),
                Self::UnrecoverableError => std::option::Option::Some("UNRECOVERABLE_ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "answer-records",
        feature = "contexts",
        feature = "conversation-datasets",
        feature = "conversation-models",
        feature = "conversation-profiles",
        feature = "conversations",
        feature = "documents",
        feature = "encryption-spec-service",
        feature = "entity-types",
        feature = "environments",
        feature = "fulfillments",
        feature = "generators",
        feature = "intents",
        feature = "knowledge-bases",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "versions",
    ))]
    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "answer-records",
        feature = "contexts",
        feature = "conversation-datasets",
        feature = "conversation-models",
        feature = "conversation-profiles",
        feature = "conversations",
        feature = "documents",
        feature = "encryption-spec-service",
        feature = "entity-types",
        feature = "environments",
        feature = "fulfillments",
        feature = "generators",
        feature = "intents",
        feature = "knowledge-bases",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "versions",
    ))]
    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "answer-records",
        feature = "contexts",
        feature = "conversation-datasets",
        feature = "conversation-models",
        feature = "conversation-profiles",
        feature = "conversations",
        feature = "documents",
        feature = "encryption-spec-service",
        feature = "entity-types",
        feature = "environments",
        feature = "fulfillments",
        feature = "generators",
        feature = "intents",
        feature = "knowledge-bases",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "versions",
    ))]
    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ConversationStarted,
                2 => Self::ConversationFinished,
                3 => Self::HumanInterventionNeeded,
                4 => Self::UnrecoverableError,
                5 => Self::NewMessage,
                7 => Self::NewRecognitionResult,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "answer-records",
        feature = "contexts",
        feature = "conversation-datasets",
        feature = "conversation-models",
        feature = "conversation-profiles",
        feature = "conversations",
        feature = "documents",
        feature = "encryption-spec-service",
        feature = "entity-types",
        feature = "environments",
        feature = "fulfillments",
        feature = "generators",
        feature = "intents",
        feature = "knowledge-bases",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "versions",
    ))]
    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "CONVERSATION_STARTED" => Self::ConversationStarted,
                "CONVERSATION_FINISHED" => Self::ConversationFinished,
                "HUMAN_INTERVENTION_NEEDED" => Self::HumanInterventionNeeded,
                "NEW_MESSAGE" => Self::NewMessage,
                "NEW_RECOGNITION_RESULT" => Self::NewRecognitionResult,
                "UNRECOVERABLE_ERROR" => Self::UnrecoverableError,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "answer-records",
        feature = "contexts",
        feature = "conversation-datasets",
        feature = "conversation-models",
        feature = "conversation-profiles",
        feature = "conversations",
        feature = "documents",
        feature = "encryption-spec-service",
        feature = "entity-types",
        feature = "environments",
        feature = "fulfillments",
        feature = "generators",
        feature = "intents",
        feature = "knowledge-bases",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "versions",
    ))]
    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ConversationStarted => serializer.serialize_i32(1),
                Self::ConversationFinished => serializer.serialize_i32(2),
                Self::HumanInterventionNeeded => serializer.serialize_i32(3),
                Self::NewMessage => serializer.serialize_i32(5),
                Self::NewRecognitionResult => serializer.serialize_i32(7),
                Self::UnrecoverableError => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(all(
        feature = "agents",
        feature = "answer-records",
        feature = "contexts",
        feature = "conversation-datasets",
        feature = "conversation-models",
        feature = "conversation-profiles",
        feature = "conversations",
        feature = "documents",
        feature = "encryption-spec-service",
        feature = "entity-types",
        feature = "environments",
        feature = "fulfillments",
        feature = "generators",
        feature = "intents",
        feature = "knowledge-bases",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
        feature = "versions",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.dialogflow.v2.ConversationEvent.Type",
            ))
        }
    }

    /// Payload of conversation event.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Payload {
        /// Payload of NEW_MESSAGE event.
        NewMessagePayload(std::boxed::Box<crate::model::Message>),
        /// Payload of NEW_RECOGNITION_RESULT event.
        NewRecognitionResultPayload(std::boxed::Box<crate::model::StreamingRecognitionResult>),
    }
}

/// Represents a conversation model.
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ConversationModel {
    /// ConversationModel resource name. Format:
    /// `projects/<Project ID>/conversationModels/<Conversation Model ID>`
    pub name: std::string::String,

    /// Required. The display name of the model. At most 64 bytes long.
    pub display_name: std::string::String,

    /// Output only. Creation time of this model.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Required. Datasets used to create model.
    pub datasets: std::vec::Vec<crate::model::InputDataset>,

    /// Output only. State of the model. A model can only serve prediction requests
    /// after it gets deployed.
    pub state: crate::model::conversation_model::State,

    /// Language code for the conversation model. If not specified, the language
    /// is en-US. Language at ConversationModel should be set for all non en-us
    /// languages.
    /// This should be a [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt)
    /// language tag. Example: "en-US".
    pub language_code: std::string::String,

    /// Output only. A read only boolean field reflecting Zone Separation
    /// status of the model.
    pub satisfies_pzs: std::option::Option<bool>,

    /// Output only. A read only boolean field reflecting Zone Isolation status
    /// of the model.
    pub satisfies_pzi: std::option::Option<bool>,

    /// Required.
    /// The model metadata that is specific to the problem type.
    /// Must match the metadata type of the dataset used to train the model.
    pub model_metadata: std::option::Option<crate::model::conversation_model::ModelMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl ConversationModel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConversationModel::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ConversationModel::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ConversationModel::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ConversationModel::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [datasets][crate::model::ConversationModel::datasets].
    pub fn set_datasets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InputDataset>,
    {
        use std::iter::Iterator;
        self.datasets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::ConversationModel::state].
    pub fn set_state<T: std::convert::Into<crate::model::conversation_model::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::ConversationModel::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::ConversationModel::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::ConversationModel::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::ConversationModel::satisfies_pzi].
    pub fn set_satisfies_pzi<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzi][crate::model::ConversationModel::satisfies_pzi].
    pub fn set_or_clear_satisfies_pzi<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = v.map(|x| x.into());
        self
    }

    /// Sets the value of [model_metadata][crate::model::ConversationModel::model_metadata].
    ///
    /// Note that all the setters affecting `model_metadata` are mutually
    /// exclusive.
    pub fn set_model_metadata<
        T: std::convert::Into<std::option::Option<crate::model::conversation_model::ModelMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_metadata = v.into();
        self
    }

    /// The value of [model_metadata][crate::model::ConversationModel::model_metadata]
    /// if it holds a `ArticleSuggestionModelMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn article_suggestion_model_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ArticleSuggestionModelMetadata>> {
        #[allow(unreachable_patterns)]
        self.model_metadata.as_ref().and_then(|v| match v {
            crate::model::conversation_model::ModelMetadata::ArticleSuggestionModelMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [model_metadata][crate::model::ConversationModel::model_metadata]
    /// to hold a `ArticleSuggestionModelMetadata`.
    ///
    /// Note that all the setters affecting `model_metadata` are
    /// mutually exclusive.
    pub fn set_article_suggestion_model_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::ArticleSuggestionModelMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_metadata = std::option::Option::Some(
            crate::model::conversation_model::ModelMetadata::ArticleSuggestionModelMetadata(
                v.into(),
            ),
        );
        self
    }

    /// The value of [model_metadata][crate::model::ConversationModel::model_metadata]
    /// if it holds a `SmartReplyModelMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn smart_reply_model_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SmartReplyModelMetadata>> {
        #[allow(unreachable_patterns)]
        self.model_metadata.as_ref().and_then(|v| match v {
            crate::model::conversation_model::ModelMetadata::SmartReplyModelMetadata(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [model_metadata][crate::model::ConversationModel::model_metadata]
    /// to hold a `SmartReplyModelMetadata`.
    ///
    /// Note that all the setters affecting `model_metadata` are
    /// mutually exclusive.
    pub fn set_smart_reply_model_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::SmartReplyModelMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_metadata = std::option::Option::Some(
            crate::model::conversation_model::ModelMetadata::SmartReplyModelMetadata(v.into()),
        );
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for ConversationModel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ConversationModel"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConversationModel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __create_time,
            __datasets,
            __state,
            __language_code,
            __article_suggestion_model_metadata,
            __smart_reply_model_metadata,
            __satisfies_pzs,
            __satisfies_pzi,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationModel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "datasets" => Ok(__FieldTag::__datasets),
                            "state" => Ok(__FieldTag::__state),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "articleSuggestionModelMetadata" => {
                                Ok(__FieldTag::__article_suggestion_model_metadata)
                            }
                            "article_suggestion_model_metadata" => {
                                Ok(__FieldTag::__article_suggestion_model_metadata)
                            }
                            "smartReplyModelMetadata" => {
                                Ok(__FieldTag::__smart_reply_model_metadata)
                            }
                            "smart_reply_model_metadata" => {
                                Ok(__FieldTag::__smart_reply_model_metadata)
                            }
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConversationModel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationModel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__datasets => {
                            if !fields.insert(__FieldTag::__datasets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datasets",
                                ));
                            }
                            result.datasets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::InputDataset>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::conversation_model::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__article_suggestion_model_metadata => {
                            if !fields.insert(__FieldTag::__article_suggestion_model_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for article_suggestion_model_metadata",
                                ));
                            }
                            if result.model_metadata.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `model_metadata`, a oneof with full ID .google.cloud.dialogflow.v2.ConversationModel.article_suggestion_model_metadata, latest field was articleSuggestionModelMetadata",
                                ));
                            }
                            result.model_metadata = std::option::Option::Some(
                                crate::model::conversation_model::ModelMetadata::ArticleSuggestionModelMetadata(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ArticleSuggestionModelMetadata>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__smart_reply_model_metadata => {
                            if !fields.insert(__FieldTag::__smart_reply_model_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for smart_reply_model_metadata",
                                ));
                            }
                            if result.model_metadata.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `model_metadata`, a oneof with full ID .google.cloud.dialogflow.v2.ConversationModel.smart_reply_model_metadata, latest field was smartReplyModelMetadata",
                                ));
                            }
                            result.model_metadata = std::option::Option::Some(
                                crate::model::conversation_model::ModelMetadata::SmartReplyModelMetadata(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SmartReplyModelMetadata>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for ConversationModel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.datasets.is_empty() {
            state.serialize_entry("datasets", &self.datasets)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if let Some(value) = self.article_suggestion_model_metadata() {
            state.serialize_entry("articleSuggestionModelMetadata", value)?;
        }
        if let Some(value) = self.smart_reply_model_metadata() {
            state.serialize_entry("smartReplyModelMetadata", value)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ConversationModel].
#[cfg(feature = "conversation-models")]
pub mod conversation_model {
    #[allow(unused_imports)]
    use super::*;

    /// State of the model.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "conversation-models")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Should not be used, an un-set enum has this value by default.
        Unspecified,
        /// Model being created.
        Creating,
        /// Model is not deployed but ready to deploy.
        Undeployed,
        /// Model is deploying.
        Deploying,
        /// Model is deployed and ready to use.
        Deployed,
        /// Model is undeploying.
        Undeploying,
        /// Model is deleting.
        Deleting,
        /// Model is in error state. Not ready to deploy and use.
        Failed,
        /// Model is being created but the training has not started,
        /// The model may remain in this state until there is enough capacity to
        /// start training.
        Pending,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "conversation-models")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "conversation-models")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Undeployed => std::option::Option::Some(2),
                Self::Deploying => std::option::Option::Some(3),
                Self::Deployed => std::option::Option::Some(4),
                Self::Undeploying => std::option::Option::Some(5),
                Self::Deleting => std::option::Option::Some(6),
                Self::Failed => std::option::Option::Some(7),
                Self::Pending => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Undeployed => std::option::Option::Some("UNDEPLOYED"),
                Self::Deploying => std::option::Option::Some("DEPLOYING"),
                Self::Deployed => std::option::Option::Some("DEPLOYED"),
                Self::Undeploying => std::option::Option::Some("UNDEPLOYING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "conversation-models")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "conversation-models")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "conversation-models")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Undeployed,
                3 => Self::Deploying,
                4 => Self::Deployed,
                5 => Self::Undeploying,
                6 => Self::Deleting,
                7 => Self::Failed,
                8 => Self::Pending,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "conversation-models")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "UNDEPLOYED" => Self::Undeployed,
                "DEPLOYING" => Self::Deploying,
                "DEPLOYED" => Self::Deployed,
                "UNDEPLOYING" => Self::Undeploying,
                "DELETING" => Self::Deleting,
                "FAILED" => Self::Failed,
                "PENDING" => Self::Pending,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "conversation-models")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Undeployed => serializer.serialize_i32(2),
                Self::Deploying => serializer.serialize_i32(3),
                Self::Deployed => serializer.serialize_i32(4),
                Self::Undeploying => serializer.serialize_i32(5),
                Self::Deleting => serializer.serialize_i32(6),
                Self::Failed => serializer.serialize_i32(7),
                Self::Pending => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "conversation-models")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dialogflow.v2.ConversationModel.State",
            ))
        }
    }

    /// Model type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "conversation-models")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelType {
        /// ModelType unspecified.
        Unspecified,
        /// ModelType smart reply dual encoder model.
        SmartReplyDualEncoderModel,
        /// ModelType smart reply bert model.
        SmartReplyBertModel,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ModelType::value] or
        /// [ModelType::name].
        UnknownValue(model_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "conversation-models")]
    pub mod model_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "conversation-models")]
    impl ModelType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SmartReplyDualEncoderModel => std::option::Option::Some(2),
                Self::SmartReplyBertModel => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODEL_TYPE_UNSPECIFIED"),
                Self::SmartReplyDualEncoderModel => {
                    std::option::Option::Some("SMART_REPLY_DUAL_ENCODER_MODEL")
                }
                Self::SmartReplyBertModel => std::option::Option::Some("SMART_REPLY_BERT_MODEL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "conversation-models")]
    impl std::default::Default for ModelType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "conversation-models")]
    impl std::fmt::Display for ModelType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "conversation-models")]
    impl std::convert::From<i32> for ModelType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::SmartReplyDualEncoderModel,
                6 => Self::SmartReplyBertModel,
                _ => Self::UnknownValue(model_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "conversation-models")]
    impl std::convert::From<&str> for ModelType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODEL_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SMART_REPLY_DUAL_ENCODER_MODEL" => Self::SmartReplyDualEncoderModel,
                "SMART_REPLY_BERT_MODEL" => Self::SmartReplyBertModel,
                _ => Self::UnknownValue(model_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "conversation-models")]
    impl serde::ser::Serialize for ModelType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SmartReplyDualEncoderModel => serializer.serialize_i32(2),
                Self::SmartReplyBertModel => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "conversation-models")]
    impl<'de> serde::de::Deserialize<'de> for ModelType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ModelType>::new(
                ".google.cloud.dialogflow.v2.ConversationModel.ModelType",
            ))
        }
    }

    /// Required.
    /// The model metadata that is specific to the problem type.
    /// Must match the metadata type of the dataset used to train the model.
    #[cfg(feature = "conversation-models")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelMetadata {
        /// Metadata for article suggestion models.
        ArticleSuggestionModelMetadata(
            std::boxed::Box<crate::model::ArticleSuggestionModelMetadata>,
        ),
        /// Metadata for smart reply models.
        SmartReplyModelMetadata(std::boxed::Box<crate::model::SmartReplyModelMetadata>),
    }
}

/// Represents evaluation result of a conversation model.
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ConversationModelEvaluation {
    /// The resource name of the evaluation. Format:
    /// `projects/<Project ID>/conversationModels/<Conversation Model
    /// ID>/evaluations/<Evaluation ID>`
    pub name: std::string::String,

    /// Optional. The display name of the model evaluation. At most 64 bytes long.
    pub display_name: std::string::String,

    /// Optional. The configuration of the evaluation task.
    pub evaluation_config: std::option::Option<crate::model::EvaluationConfig>,

    /// Output only. Creation time of this model.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Human eval template in csv format.
    /// It takes real-world conversations provided through input dataset, generates
    /// example suggestions for customer to verify quality of the model.
    /// For Smart Reply, the generated csv file contains columns of
    /// Context, (Suggestions,Q1,Q2)*3, Actual reply.
    /// Context contains at most 10 latest messages in the conversation prior to
    /// the current suggestion.
    /// Q1: "Would you send it as the next message of agent?"
    /// Evaluated based on whether the suggest is appropriate to be sent by
    /// agent in current context.
    /// Q2: "Does the suggestion move the conversation closer to resolution?"
    /// Evaluated based on whether the suggestion provide solutions, or answers
    /// customer's question or collect information from customer to resolve the
    /// customer's issue.
    /// Actual reply column contains the actual agent reply sent in the context.
    pub raw_human_eval_template_csv: std::string::String,

    /// Metrics details.
    pub metrics: std::option::Option<crate::model::conversation_model_evaluation::Metrics>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl ConversationModelEvaluation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConversationModelEvaluation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ConversationModelEvaluation::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [evaluation_config][crate::model::ConversationModelEvaluation::evaluation_config].
    pub fn set_evaluation_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EvaluationConfig>,
    {
        self.evaluation_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [evaluation_config][crate::model::ConversationModelEvaluation::evaluation_config].
    pub fn set_or_clear_evaluation_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EvaluationConfig>,
    {
        self.evaluation_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::ConversationModelEvaluation::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ConversationModelEvaluation::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [raw_human_eval_template_csv][crate::model::ConversationModelEvaluation::raw_human_eval_template_csv].
    pub fn set_raw_human_eval_template_csv<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.raw_human_eval_template_csv = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::ConversationModelEvaluation::metrics].
    ///
    /// Note that all the setters affecting `metrics` are mutually
    /// exclusive.
    pub fn set_metrics<
        T: std::convert::Into<
                std::option::Option<crate::model::conversation_model_evaluation::Metrics>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metrics = v.into();
        self
    }

    /// The value of [metrics][crate::model::ConversationModelEvaluation::metrics]
    /// if it holds a `SmartReplyMetrics`, `None` if the field is not set or
    /// holds a different branch.
    pub fn smart_reply_metrics(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SmartReplyMetrics>> {
        #[allow(unreachable_patterns)]
        self.metrics.as_ref().and_then(|v| match v {
            crate::model::conversation_model_evaluation::Metrics::SmartReplyMetrics(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [metrics][crate::model::ConversationModelEvaluation::metrics]
    /// to hold a `SmartReplyMetrics`.
    ///
    /// Note that all the setters affecting `metrics` are
    /// mutually exclusive.
    pub fn set_smart_reply_metrics<
        T: std::convert::Into<std::boxed::Box<crate::model::SmartReplyMetrics>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.metrics = std::option::Option::Some(
            crate::model::conversation_model_evaluation::Metrics::SmartReplyMetrics(v.into()),
        );
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for ConversationModelEvaluation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ConversationModelEvaluation"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConversationModelEvaluation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __evaluation_config,
            __create_time,
            __smart_reply_metrics,
            __raw_human_eval_template_csv,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationModelEvaluation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "evaluationConfig" => Ok(__FieldTag::__evaluation_config),
                            "evaluation_config" => Ok(__FieldTag::__evaluation_config),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "smartReplyMetrics" => Ok(__FieldTag::__smart_reply_metrics),
                            "smart_reply_metrics" => Ok(__FieldTag::__smart_reply_metrics),
                            "rawHumanEvalTemplateCsv" => {
                                Ok(__FieldTag::__raw_human_eval_template_csv)
                            }
                            "raw_human_eval_template_csv" => {
                                Ok(__FieldTag::__raw_human_eval_template_csv)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConversationModelEvaluation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationModelEvaluation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__evaluation_config => {
                            if !fields.insert(__FieldTag::__evaluation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for evaluation_config",
                                ));
                            }
                            result.evaluation_config = map
                                .next_value::<std::option::Option<crate::model::EvaluationConfig>>(
                                )?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__smart_reply_metrics => {
                            if !fields.insert(__FieldTag::__smart_reply_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for smart_reply_metrics",
                                ));
                            }
                            if result.metrics.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `metrics`, a oneof with full ID .google.cloud.dialogflow.v2.ConversationModelEvaluation.smart_reply_metrics, latest field was smartReplyMetrics",
                                ));
                            }
                            result.metrics = std::option::Option::Some(
                                crate::model::conversation_model_evaluation::Metrics::SmartReplyMetrics(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SmartReplyMetrics>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__raw_human_eval_template_csv => {
                            if !fields.insert(__FieldTag::__raw_human_eval_template_csv) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for raw_human_eval_template_csv",
                                ));
                            }
                            result.raw_human_eval_template_csv = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for ConversationModelEvaluation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.evaluation_config.is_some() {
            state.serialize_entry("evaluationConfig", &self.evaluation_config)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if let Some(value) = self.smart_reply_metrics() {
            state.serialize_entry("smartReplyMetrics", value)?;
        }
        if !self.raw_human_eval_template_csv.is_empty() {
            state.serialize_entry("rawHumanEvalTemplateCsv", &self.raw_human_eval_template_csv)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ConversationModelEvaluation].
#[cfg(feature = "conversation-models")]
pub mod conversation_model_evaluation {
    #[allow(unused_imports)]
    use super::*;

    /// Metrics details.
    #[cfg(feature = "conversation-models")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Metrics {
        /// Output only. Only available when model is for smart reply.
        SmartReplyMetrics(std::boxed::Box<crate::model::SmartReplyMetrics>),
    }
}

/// The configuration for model evaluation.
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EvaluationConfig {
    /// Required. Datasets used for evaluation.
    pub datasets: std::vec::Vec<crate::model::InputDataset>,

    /// Specific configurations for different models in order to do evaluation.
    pub model_specific_config:
        std::option::Option<crate::model::evaluation_config::ModelSpecificConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl EvaluationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [datasets][crate::model::EvaluationConfig::datasets].
    pub fn set_datasets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InputDataset>,
    {
        use std::iter::Iterator;
        self.datasets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [model_specific_config][crate::model::EvaluationConfig::model_specific_config].
    ///
    /// Note that all the setters affecting `model_specific_config` are mutually
    /// exclusive.
    pub fn set_model_specific_config<
        T: std::convert::Into<
                std::option::Option<crate::model::evaluation_config::ModelSpecificConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_specific_config = v.into();
        self
    }

    /// The value of [model_specific_config][crate::model::EvaluationConfig::model_specific_config]
    /// if it holds a `SmartReplyConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn smart_reply_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::evaluation_config::SmartReplyConfig>>
    {
        #[allow(unreachable_patterns)]
        self.model_specific_config.as_ref().and_then(|v| match v {
            crate::model::evaluation_config::ModelSpecificConfig::SmartReplyConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [model_specific_config][crate::model::EvaluationConfig::model_specific_config]
    /// to hold a `SmartReplyConfig`.
    ///
    /// Note that all the setters affecting `model_specific_config` are
    /// mutually exclusive.
    pub fn set_smart_reply_config<
        T: std::convert::Into<std::boxed::Box<crate::model::evaluation_config::SmartReplyConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_specific_config = std::option::Option::Some(
            crate::model::evaluation_config::ModelSpecificConfig::SmartReplyConfig(v.into()),
        );
        self
    }

    /// The value of [model_specific_config][crate::model::EvaluationConfig::model_specific_config]
    /// if it holds a `SmartComposeConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn smart_compose_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::evaluation_config::SmartComposeConfig>>
    {
        #[allow(unreachable_patterns)]
        self.model_specific_config.as_ref().and_then(|v| match v {
            crate::model::evaluation_config::ModelSpecificConfig::SmartComposeConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [model_specific_config][crate::model::EvaluationConfig::model_specific_config]
    /// to hold a `SmartComposeConfig`.
    ///
    /// Note that all the setters affecting `model_specific_config` are
    /// mutually exclusive.
    pub fn set_smart_compose_config<
        T: std::convert::Into<std::boxed::Box<crate::model::evaluation_config::SmartComposeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.model_specific_config = std::option::Option::Some(
            crate::model::evaluation_config::ModelSpecificConfig::SmartComposeConfig(v.into()),
        );
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for EvaluationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.EvaluationConfig"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EvaluationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __datasets,
            __smart_reply_config,
            __smart_compose_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvaluationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "datasets" => Ok(__FieldTag::__datasets),
                            "smartReplyConfig" => Ok(__FieldTag::__smart_reply_config),
                            "smart_reply_config" => Ok(__FieldTag::__smart_reply_config),
                            "smartComposeConfig" => Ok(__FieldTag::__smart_compose_config),
                            "smart_compose_config" => Ok(__FieldTag::__smart_compose_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EvaluationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvaluationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__datasets => {
                            if !fields.insert(__FieldTag::__datasets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datasets",
                                ));
                            }
                            result.datasets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::InputDataset>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__smart_reply_config => {
                            if !fields.insert(__FieldTag::__smart_reply_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for smart_reply_config",
                                ));
                            }
                            if result.model_specific_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `model_specific_config`, a oneof with full ID .google.cloud.dialogflow.v2.EvaluationConfig.smart_reply_config, latest field was smartReplyConfig",
                                ));
                            }
                            result.model_specific_config = std::option::Option::Some(
                                crate::model::evaluation_config::ModelSpecificConfig::SmartReplyConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::evaluation_config::SmartReplyConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__smart_compose_config => {
                            if !fields.insert(__FieldTag::__smart_compose_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for smart_compose_config",
                                ));
                            }
                            if result.model_specific_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `model_specific_config`, a oneof with full ID .google.cloud.dialogflow.v2.EvaluationConfig.smart_compose_config, latest field was smartComposeConfig",
                                ));
                            }
                            result.model_specific_config = std::option::Option::Some(
                                crate::model::evaluation_config::ModelSpecificConfig::SmartComposeConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::evaluation_config::SmartComposeConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for EvaluationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.datasets.is_empty() {
            state.serialize_entry("datasets", &self.datasets)?;
        }
        if let Some(value) = self.smart_reply_config() {
            state.serialize_entry("smartReplyConfig", value)?;
        }
        if let Some(value) = self.smart_compose_config() {
            state.serialize_entry("smartComposeConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EvaluationConfig].
#[cfg(feature = "conversation-models")]
pub mod evaluation_config {
    #[allow(unused_imports)]
    use super::*;

    /// Smart reply specific configuration for evaluation job.
    #[cfg(feature = "conversation-models")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SmartReplyConfig {
        /// The allowlist document resource name.
        /// Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base
        /// ID>/documents/<Document ID>`. Only used for smart reply model.
        pub allowlist_document: std::string::String,

        /// Required. The model to be evaluated can return multiple results with
        /// confidence score on each query. These results will be sorted by the
        /// descending order of the scores and we only keep the first
        /// max_result_count results as the final results to evaluate.
        pub max_result_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "conversation-models")]
    impl SmartReplyConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [allowlist_document][crate::model::evaluation_config::SmartReplyConfig::allowlist_document].
        pub fn set_allowlist_document<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.allowlist_document = v.into();
            self
        }

        /// Sets the value of [max_result_count][crate::model::evaluation_config::SmartReplyConfig::max_result_count].
        pub fn set_max_result_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_result_count = v.into();
            self
        }
    }

    #[cfg(feature = "conversation-models")]
    impl wkt::message::Message for SmartReplyConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.EvaluationConfig.SmartReplyConfig"
        }
    }

    #[cfg(feature = "conversation-models")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SmartReplyConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __allowlist_document,
                __max_result_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SmartReplyConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "allowlistDocument" => Ok(__FieldTag::__allowlist_document),
                                "allowlist_document" => Ok(__FieldTag::__allowlist_document),
                                "maxResultCount" => Ok(__FieldTag::__max_result_count),
                                "max_result_count" => Ok(__FieldTag::__max_result_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SmartReplyConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SmartReplyConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__allowlist_document => {
                                if !fields.insert(__FieldTag::__allowlist_document) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allowlist_document",
                                    ));
                                }
                                result.allowlist_document = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__max_result_count => {
                                if !fields.insert(__FieldTag::__max_result_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_result_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_result_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "conversation-models")]
    #[doc(hidden)]
    impl serde::ser::Serialize for SmartReplyConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.allowlist_document.is_empty() {
                state.serialize_entry("allowlistDocument", &self.allowlist_document)?;
            }
            if !wkt::internal::is_default(&self.max_result_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("maxResultCount", &__With(&self.max_result_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Smart compose specific configuration for evaluation job.
    #[cfg(feature = "conversation-models")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SmartComposeConfig {
        /// The allowlist document resource name.
        /// Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base
        /// ID>/documents/<Document ID>`. Only used for smart compose model.
        pub allowlist_document: std::string::String,

        /// Required. The model to be evaluated can return multiple results with
        /// confidence score on each query. These results will be sorted by the
        /// descending order of the scores and we only keep the first
        /// max_result_count results as the final results to evaluate.
        pub max_result_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "conversation-models")]
    impl SmartComposeConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [allowlist_document][crate::model::evaluation_config::SmartComposeConfig::allowlist_document].
        pub fn set_allowlist_document<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.allowlist_document = v.into();
            self
        }

        /// Sets the value of [max_result_count][crate::model::evaluation_config::SmartComposeConfig::max_result_count].
        pub fn set_max_result_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_result_count = v.into();
            self
        }
    }

    #[cfg(feature = "conversation-models")]
    impl wkt::message::Message for SmartComposeConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.EvaluationConfig.SmartComposeConfig"
        }
    }

    #[cfg(feature = "conversation-models")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SmartComposeConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __allowlist_document,
                __max_result_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SmartComposeConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "allowlistDocument" => Ok(__FieldTag::__allowlist_document),
                                "allowlist_document" => Ok(__FieldTag::__allowlist_document),
                                "maxResultCount" => Ok(__FieldTag::__max_result_count),
                                "max_result_count" => Ok(__FieldTag::__max_result_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SmartComposeConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SmartComposeConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__allowlist_document => {
                                if !fields.insert(__FieldTag::__allowlist_document) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allowlist_document",
                                    ));
                                }
                                result.allowlist_document = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__max_result_count => {
                                if !fields.insert(__FieldTag::__max_result_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_result_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_result_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "conversation-models")]
    #[doc(hidden)]
    impl serde::ser::Serialize for SmartComposeConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.allowlist_document.is_empty() {
                state.serialize_entry("allowlistDocument", &self.allowlist_document)?;
            }
            if !wkt::internal::is_default(&self.max_result_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("maxResultCount", &__With(&self.max_result_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Specific configurations for different models in order to do evaluation.
    #[cfg(feature = "conversation-models")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ModelSpecificConfig {
        /// Configuration for smart reply model evaluation.
        SmartReplyConfig(std::boxed::Box<crate::model::evaluation_config::SmartReplyConfig>),
        /// Configuration for smart compose model evaluation.
        SmartComposeConfig(std::boxed::Box<crate::model::evaluation_config::SmartComposeConfig>),
    }
}

/// InputDataset used to create model or do evaluation.
/// NextID:5
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InputDataset {
    /// Required. ConversationDataset resource name. Format:
    /// `projects/<Project ID>/locations/<Location
    /// ID>/conversationDatasets/<Conversation Dataset ID>`
    pub dataset: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl InputDataset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dataset][crate::model::InputDataset::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for InputDataset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.InputDataset"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InputDataset {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InputDataset")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dataset" => Ok(__FieldTag::__dataset),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InputDataset;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InputDataset")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataset => {
                            if !fields.insert(__FieldTag::__dataset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset",
                                ));
                            }
                            result.dataset = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for InputDataset {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dataset.is_empty() {
            state.serialize_entry("dataset", &self.dataset)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for article suggestion models.
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ArticleSuggestionModelMetadata {
    /// Optional. Type of the article suggestion model. If not provided, model_type
    /// is used.
    pub training_model_type: crate::model::conversation_model::ModelType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl ArticleSuggestionModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [training_model_type][crate::model::ArticleSuggestionModelMetadata::training_model_type].
    pub fn set_training_model_type<
        T: std::convert::Into<crate::model::conversation_model::ModelType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.training_model_type = v.into();
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for ArticleSuggestionModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ArticleSuggestionModelMetadata"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ArticleSuggestionModelMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __training_model_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ArticleSuggestionModelMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "trainingModelType" => Ok(__FieldTag::__training_model_type),
                            "training_model_type" => Ok(__FieldTag::__training_model_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ArticleSuggestionModelMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ArticleSuggestionModelMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__training_model_type => {
                            if !fields.insert(__FieldTag::__training_model_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for training_model_type",
                                ));
                            }
                            result.training_model_type =
                                map.next_value::<std::option::Option<
                                    crate::model::conversation_model::ModelType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for ArticleSuggestionModelMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.training_model_type) {
            state.serialize_entry("trainingModelType", &self.training_model_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for smart reply models.
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SmartReplyModelMetadata {
    /// Optional. Type of the smart reply model. If not provided, model_type is
    /// used.
    pub training_model_type: crate::model::conversation_model::ModelType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl SmartReplyModelMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [training_model_type][crate::model::SmartReplyModelMetadata::training_model_type].
    pub fn set_training_model_type<
        T: std::convert::Into<crate::model::conversation_model::ModelType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.training_model_type = v.into();
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for SmartReplyModelMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SmartReplyModelMetadata"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SmartReplyModelMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __training_model_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SmartReplyModelMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "trainingModelType" => Ok(__FieldTag::__training_model_type),
                            "training_model_type" => Ok(__FieldTag::__training_model_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SmartReplyModelMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SmartReplyModelMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__training_model_type => {
                            if !fields.insert(__FieldTag::__training_model_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for training_model_type",
                                ));
                            }
                            result.training_model_type =
                                map.next_value::<std::option::Option<
                                    crate::model::conversation_model::ModelType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for SmartReplyModelMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.training_model_type) {
            state.serialize_entry("trainingModelType", &self.training_model_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The evaluation metrics for smart reply model.
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SmartReplyMetrics {
    /// Percentage of target participant messages in the evaluation dataset for
    /// which similar messages have appeared at least once in the allowlist. Should
    /// be [0, 1].
    pub allowlist_coverage: f32,

    /// Metrics of top n smart replies, sorted by [TopNMetric.n][].
    pub top_n_metrics: std::vec::Vec<crate::model::smart_reply_metrics::TopNMetrics>,

    /// Total number of conversations used to generate this metric.
    pub conversation_count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl SmartReplyMetrics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allowlist_coverage][crate::model::SmartReplyMetrics::allowlist_coverage].
    pub fn set_allowlist_coverage<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.allowlist_coverage = v.into();
        self
    }

    /// Sets the value of [top_n_metrics][crate::model::SmartReplyMetrics::top_n_metrics].
    pub fn set_top_n_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::smart_reply_metrics::TopNMetrics>,
    {
        use std::iter::Iterator;
        self.top_n_metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [conversation_count][crate::model::SmartReplyMetrics::conversation_count].
    pub fn set_conversation_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.conversation_count = v.into();
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for SmartReplyMetrics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SmartReplyMetrics"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SmartReplyMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allowlist_coverage,
            __top_n_metrics,
            __conversation_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SmartReplyMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowlistCoverage" => Ok(__FieldTag::__allowlist_coverage),
                            "allowlist_coverage" => Ok(__FieldTag::__allowlist_coverage),
                            "topNMetrics" => Ok(__FieldTag::__top_n_metrics),
                            "top_n_metrics" => Ok(__FieldTag::__top_n_metrics),
                            "conversationCount" => Ok(__FieldTag::__conversation_count),
                            "conversation_count" => Ok(__FieldTag::__conversation_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SmartReplyMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SmartReplyMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allowlist_coverage => {
                            if !fields.insert(__FieldTag::__allowlist_coverage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowlist_coverage",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.allowlist_coverage =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__top_n_metrics => {
                            if !fields.insert(__FieldTag::__top_n_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for top_n_metrics",
                                ));
                            }
                            result.top_n_metrics = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::smart_reply_metrics::TopNMetrics>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversation_count => {
                            if !fields.insert(__FieldTag::__conversation_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.conversation_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for SmartReplyMetrics {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.allowlist_coverage) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("allowlistCoverage", &__With(&self.allowlist_coverage))?;
        }
        if !self.top_n_metrics.is_empty() {
            state.serialize_entry("topNMetrics", &self.top_n_metrics)?;
        }
        if !wkt::internal::is_default(&self.conversation_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("conversationCount", &__With(&self.conversation_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SmartReplyMetrics].
#[cfg(feature = "conversation-models")]
pub mod smart_reply_metrics {
    #[allow(unused_imports)]
    use super::*;

    /// Evaluation metrics when retrieving `n` smart replies with the model.
    #[cfg(feature = "conversation-models")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TopNMetrics {
        /// Number of retrieved smart replies. For example, when `n` is 3, this
        /// evaluation contains metrics for when Dialogflow retrieves 3 smart replies
        /// with the model.
        pub n: i32,

        /// Defined as `number of queries whose top n smart replies have at least one
        /// similar (token match similarity above the defined threshold) reply as the
        /// real reply` divided by `number of queries with at least one smart reply`.
        /// Value ranges from 0.0 to 1.0 inclusive.
        pub recall: f32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "conversation-models")]
    impl TopNMetrics {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [n][crate::model::smart_reply_metrics::TopNMetrics::n].
        pub fn set_n<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.n = v.into();
            self
        }

        /// Sets the value of [recall][crate::model::smart_reply_metrics::TopNMetrics::recall].
        pub fn set_recall<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.recall = v.into();
            self
        }
    }

    #[cfg(feature = "conversation-models")]
    impl wkt::message::Message for TopNMetrics {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.SmartReplyMetrics.TopNMetrics"
        }
    }

    #[cfg(feature = "conversation-models")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TopNMetrics {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __n,
                __recall,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TopNMetrics")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "n" => Ok(__FieldTag::__n),
                                "recall" => Ok(__FieldTag::__recall),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TopNMetrics;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TopNMetrics")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__n => {
                                if !fields.insert(__FieldTag::__n) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for n",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.n = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__recall => {
                                if !fields.insert(__FieldTag::__recall) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for recall",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.recall = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "conversation-models")]
    #[doc(hidden)]
    impl serde::ser::Serialize for TopNMetrics {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.n) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("n", &__With(&self.n))?;
            }
            if !wkt::internal::is_default(&self.recall) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("recall", &__With(&self.recall))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// The request message for
/// [ConversationModels.CreateConversationModel][google.cloud.dialogflow.v2.ConversationModels.CreateConversationModel]
///
/// [google.cloud.dialogflow.v2.ConversationModels.CreateConversationModel]: crate::client::ConversationModels::create_conversation_model
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateConversationModelRequest {
    /// The project to create conversation model for. Format:
    /// `projects/<Project ID>`
    pub parent: std::string::String,

    /// Required. The conversation model to create.
    pub conversation_model: std::option::Option<crate::model::ConversationModel>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl CreateConversationModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConversationModelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [conversation_model][crate::model::CreateConversationModelRequest::conversation_model].
    pub fn set_conversation_model<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConversationModel>,
    {
        self.conversation_model = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation_model][crate::model::CreateConversationModelRequest::conversation_model].
    pub fn set_or_clear_conversation_model<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConversationModel>,
    {
        self.conversation_model = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for CreateConversationModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CreateConversationModelRequest"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateConversationModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __conversation_model,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConversationModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "conversationModel" => Ok(__FieldTag::__conversation_model),
                            "conversation_model" => Ok(__FieldTag::__conversation_model),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateConversationModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConversationModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversation_model => {
                            if !fields.insert(__FieldTag::__conversation_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_model",
                                ));
                            }
                            result.conversation_model = map
                                .next_value::<std::option::Option<crate::model::ConversationModel>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateConversationModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.conversation_model.is_some() {
            state.serialize_entry("conversationModel", &self.conversation_model)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [ConversationModels.GetConversationModel][google.cloud.dialogflow.v2.ConversationModels.GetConversationModel]
///
/// [google.cloud.dialogflow.v2.ConversationModels.GetConversationModel]: crate::client::ConversationModels::get_conversation_model
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConversationModelRequest {
    /// Required. The conversation model to retrieve. Format:
    /// `projects/<Project ID>/conversationModels/<Conversation Model ID>`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl GetConversationModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConversationModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for GetConversationModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetConversationModelRequest"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConversationModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConversationModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConversationModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConversationModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for GetConversationModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [ConversationModels.ListConversationModels][google.cloud.dialogflow.v2.ConversationModels.ListConversationModels]
///
/// [google.cloud.dialogflow.v2.ConversationModels.ListConversationModels]: crate::client::ConversationModels::list_conversation_models
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConversationModelsRequest {
    /// Required. The project to list all conversation models for.
    /// Format: `projects/<Project ID>`
    pub parent: std::string::String,

    /// Optional. Maximum number of conversation models to return in a single
    /// page. By default 100 and at most 1000.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl ListConversationModelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConversationModelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConversationModelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConversationModelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for ListConversationModelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListConversationModelsRequest"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConversationModelsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationModelsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConversationModelsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationModelsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for ListConversationModelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [ConversationModels.ListConversationModels][google.cloud.dialogflow.v2.ConversationModels.ListConversationModels]
///
/// [google.cloud.dialogflow.v2.ConversationModels.ListConversationModels]: crate::client::ConversationModels::list_conversation_models
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConversationModelsResponse {
    /// The list of models to return.
    pub conversation_models: std::vec::Vec<crate::model::ConversationModel>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl ListConversationModelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation_models][crate::model::ListConversationModelsResponse::conversation_models].
    pub fn set_conversation_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConversationModel>,
    {
        use std::iter::Iterator;
        self.conversation_models = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConversationModelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for ListConversationModelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListConversationModelsResponse"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConversationModelsResponse {
    type PageItem = crate::model::ConversationModel;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.conversation_models
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConversationModelsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_models,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationModelsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationModels" => Ok(__FieldTag::__conversation_models),
                            "conversation_models" => Ok(__FieldTag::__conversation_models),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConversationModelsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationModelsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_models => {
                            if !fields.insert(__FieldTag::__conversation_models) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_models",
                                ));
                            }
                            result.conversation_models =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConversationModel>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for ListConversationModelsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_models.is_empty() {
            state.serialize_entry("conversationModels", &self.conversation_models)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [ConversationModels.DeleteConversationModel][google.cloud.dialogflow.v2.ConversationModels.DeleteConversationModel]
///
/// [google.cloud.dialogflow.v2.ConversationModels.DeleteConversationModel]: crate::client::ConversationModels::delete_conversation_model
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteConversationModelRequest {
    /// Required. The conversation model to delete. Format:
    /// `projects/<Project ID>/conversationModels/<Conversation Model ID>`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl DeleteConversationModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConversationModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for DeleteConversationModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DeleteConversationModelRequest"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteConversationModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteConversationModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteConversationModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConversationModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteConversationModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [ConversationModels.DeployConversationModel][google.cloud.dialogflow.v2.ConversationModels.DeployConversationModel]
///
/// [google.cloud.dialogflow.v2.ConversationModels.DeployConversationModel]: crate::client::ConversationModels::deploy_conversation_model
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployConversationModelRequest {
    /// Required. The conversation model to deploy. Format:
    /// `projects/<Project ID>/conversationModels/<Conversation Model ID>`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl DeployConversationModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeployConversationModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for DeployConversationModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DeployConversationModelRequest"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployConversationModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeployConversationModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployConversationModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployConversationModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for DeployConversationModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [ConversationModels.UndeployConversationModel][google.cloud.dialogflow.v2.ConversationModels.UndeployConversationModel]
///
/// [google.cloud.dialogflow.v2.ConversationModels.UndeployConversationModel]: crate::client::ConversationModels::undeploy_conversation_model
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UndeployConversationModelRequest {
    /// Required. The conversation model to undeploy. Format:
    /// `projects/<Project ID>/conversationModels/<Conversation Model ID>`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl UndeployConversationModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UndeployConversationModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for UndeployConversationModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.UndeployConversationModelRequest"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UndeployConversationModelRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeployConversationModelRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UndeployConversationModelRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeployConversationModelRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for UndeployConversationModelRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [ConversationModels.GetConversationModelEvaluation][google.cloud.dialogflow.v2.ConversationModels.GetConversationModelEvaluation]
///
/// [google.cloud.dialogflow.v2.ConversationModels.GetConversationModelEvaluation]: crate::client::ConversationModels::get_conversation_model_evaluation
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConversationModelEvaluationRequest {
    /// Required. The conversation model evaluation resource name. Format:
    /// `projects/<Project ID>/conversationModels/<Conversation Model
    /// ID>/evaluations/<Evaluation ID>`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl GetConversationModelEvaluationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConversationModelEvaluationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for GetConversationModelEvaluationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetConversationModelEvaluationRequest"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConversationModelEvaluationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for GetConversationModelEvaluationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConversationModelEvaluationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConversationModelEvaluationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for GetConversationModelEvaluationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [ConversationModels.ListConversationModelEvaluations][google.cloud.dialogflow.v2.ConversationModels.ListConversationModelEvaluations]
///
/// [google.cloud.dialogflow.v2.ConversationModels.ListConversationModelEvaluations]: crate::client::ConversationModels::list_conversation_model_evaluations
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConversationModelEvaluationsRequest {
    /// Required. The conversation model resource name. Format:
    /// `projects/<Project ID>/conversationModels/<Conversation Model ID>`
    pub parent: std::string::String,

    /// Optional. Maximum number of evaluations to return in a
    /// single page. By default 100 and at most 1000.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl ListConversationModelEvaluationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConversationModelEvaluationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConversationModelEvaluationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConversationModelEvaluationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for ListConversationModelEvaluationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListConversationModelEvaluationsRequest"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConversationModelEvaluationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListConversationModelEvaluationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConversationModelEvaluationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationModelEvaluationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for ListConversationModelEvaluationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [ConversationModels.ListConversationModelEvaluations][google.cloud.dialogflow.v2.ConversationModels.ListConversationModelEvaluations]
///
/// [google.cloud.dialogflow.v2.ConversationModels.ListConversationModelEvaluations]: crate::client::ConversationModels::list_conversation_model_evaluations
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConversationModelEvaluationsResponse {
    /// The list of evaluations to return.
    pub conversation_model_evaluations: std::vec::Vec<crate::model::ConversationModelEvaluation>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl ListConversationModelEvaluationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation_model_evaluations][crate::model::ListConversationModelEvaluationsResponse::conversation_model_evaluations].
    pub fn set_conversation_model_evaluations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConversationModelEvaluation>,
    {
        use std::iter::Iterator;
        self.conversation_model_evaluations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConversationModelEvaluationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for ListConversationModelEvaluationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListConversationModelEvaluationsResponse"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConversationModelEvaluationsResponse {
    type PageItem = crate::model::ConversationModelEvaluation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.conversation_model_evaluations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConversationModelEvaluationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_model_evaluations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ListConversationModelEvaluationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationModelEvaluations" => {
                                Ok(__FieldTag::__conversation_model_evaluations)
                            }
                            "conversation_model_evaluations" => {
                                Ok(__FieldTag::__conversation_model_evaluations)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConversationModelEvaluationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationModelEvaluationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_model_evaluations => {
                            if !fields.insert(__FieldTag::__conversation_model_evaluations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_model_evaluations",
                                ));
                            }
                            result.conversation_model_evaluations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConversationModelEvaluation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for ListConversationModelEvaluationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_model_evaluations.is_empty() {
            state.serialize_entry(
                "conversationModelEvaluations",
                &self.conversation_model_evaluations,
            )?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [ConversationModels.CreateConversationModelEvaluation][google.cloud.dialogflow.v2.ConversationModels.CreateConversationModelEvaluation]
///
/// [google.cloud.dialogflow.v2.ConversationModels.CreateConversationModelEvaluation]: crate::client::ConversationModels::create_conversation_model_evaluation
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateConversationModelEvaluationRequest {
    /// Required. The conversation model resource name. Format:
    /// `projects/<Project ID>/locations/<Location
    /// ID>/conversationModels/<Conversation Model ID>`
    pub parent: std::string::String,

    /// Required. The conversation model evaluation to be created.
    pub conversation_model_evaluation:
        std::option::Option<crate::model::ConversationModelEvaluation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl CreateConversationModelEvaluationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConversationModelEvaluationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [conversation_model_evaluation][crate::model::CreateConversationModelEvaluationRequest::conversation_model_evaluation].
    pub fn set_conversation_model_evaluation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConversationModelEvaluation>,
    {
        self.conversation_model_evaluation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation_model_evaluation][crate::model::CreateConversationModelEvaluationRequest::conversation_model_evaluation].
    pub fn set_or_clear_conversation_model_evaluation<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::ConversationModelEvaluation>,
    {
        self.conversation_model_evaluation = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for CreateConversationModelEvaluationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CreateConversationModelEvaluationRequest"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateConversationModelEvaluationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __conversation_model_evaluation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for CreateConversationModelEvaluationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "conversationModelEvaluation" => {
                                Ok(__FieldTag::__conversation_model_evaluation)
                            }
                            "conversation_model_evaluation" => {
                                Ok(__FieldTag::__conversation_model_evaluation)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateConversationModelEvaluationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConversationModelEvaluationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversation_model_evaluation => {
                            if !fields.insert(__FieldTag::__conversation_model_evaluation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_model_evaluation",
                                ));
                            }
                            result.conversation_model_evaluation = map.next_value::<std::option::Option<crate::model::ConversationModelEvaluation>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateConversationModelEvaluationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.conversation_model_evaluation.is_some() {
            state.serialize_entry(
                "conversationModelEvaluation",
                &self.conversation_model_evaluation,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for a
/// [ConversationModels.CreateConversationModel][google.cloud.dialogflow.v2.ConversationModels.CreateConversationModel]
/// operation.
///
/// [google.cloud.dialogflow.v2.ConversationModels.CreateConversationModel]: crate::client::ConversationModels::create_conversation_model
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateConversationModelOperationMetadata {
    /// The resource name of the conversation model. Format:
    /// `projects/<Project ID>/conversationModels/<Conversation Model Id>`
    pub conversation_model: std::string::String,

    /// State of CreateConversationModel operation.
    pub state: crate::model::create_conversation_model_operation_metadata::State,

    /// Timestamp when the request to create conversation model is submitted. The
    /// time is measured on server side.
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl CreateConversationModelOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation_model][crate::model::CreateConversationModelOperationMetadata::conversation_model].
    pub fn set_conversation_model<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_model = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CreateConversationModelOperationMetadata::state].
    pub fn set_state<
        T: std::convert::Into<crate::model::create_conversation_model_operation_metadata::State>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CreateConversationModelOperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CreateConversationModelOperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for CreateConversationModelOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CreateConversationModelOperationMetadata"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateConversationModelOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_model,
            __state,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for CreateConversationModelOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationModel" => Ok(__FieldTag::__conversation_model),
                            "conversation_model" => Ok(__FieldTag::__conversation_model),
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateConversationModelOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConversationModelOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_model => {
                            if !fields.insert(__FieldTag::__conversation_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_model",
                                ));
                            }
                            result.conversation_model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::create_conversation_model_operation_metadata::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateConversationModelOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_model.is_empty() {
            state.serialize_entry("conversationModel", &self.conversation_model)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CreateConversationModelOperationMetadata].
#[cfg(feature = "conversation-models")]
pub mod create_conversation_model_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// State of CreateConversationModel operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "conversation-models")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Invalid.
        Unspecified,
        /// Request is submitted, but training has not started yet.
        /// The model may remain in this state until there is enough capacity to
        /// start training.
        Pending,
        /// The training has succeeded.
        Succeeded,
        /// The training has succeeded.
        Failed,
        /// The training has been cancelled.
        Cancelled,
        /// The training is in cancelling state.
        Cancelling,
        /// Custom model is training.
        Training,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "conversation-models")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "conversation-models")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Cancelled => std::option::Option::Some(4),
                Self::Cancelling => std::option::Option::Some(5),
                Self::Training => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Training => std::option::Option::Some("TRAINING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "conversation-models")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "conversation-models")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "conversation-models")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Succeeded,
                3 => Self::Failed,
                4 => Self::Cancelled,
                5 => Self::Cancelling,
                6 => Self::Training,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "conversation-models")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "CANCELLED" => Self::Cancelled,
                "CANCELLING" => Self::Cancelling,
                "TRAINING" => Self::Training,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "conversation-models")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Cancelled => serializer.serialize_i32(4),
                Self::Cancelling => serializer.serialize_i32(5),
                Self::Training => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "conversation-models")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dialogflow.v2.CreateConversationModelOperationMetadata.State",
            ))
        }
    }
}

/// Metadata for a
/// [ConversationModels.DeployConversationModel][google.cloud.dialogflow.v2.ConversationModels.DeployConversationModel]
/// operation.
///
/// [google.cloud.dialogflow.v2.ConversationModels.DeployConversationModel]: crate::client::ConversationModels::deploy_conversation_model
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeployConversationModelOperationMetadata {
    /// The resource name of the conversation model. Format:
    /// `projects/<Project ID>/conversationModels/<Conversation Model Id>`
    pub conversation_model: std::string::String,

    /// Timestamp when request to deploy conversation model was submitted. The time
    /// is measured on server side.
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl DeployConversationModelOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation_model][crate::model::DeployConversationModelOperationMetadata::conversation_model].
    pub fn set_conversation_model<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_model = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DeployConversationModelOperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DeployConversationModelOperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for DeployConversationModelOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DeployConversationModelOperationMetadata"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeployConversationModelOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_model,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for DeployConversationModelOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationModel" => Ok(__FieldTag::__conversation_model),
                            "conversation_model" => Ok(__FieldTag::__conversation_model),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeployConversationModelOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeployConversationModelOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_model => {
                            if !fields.insert(__FieldTag::__conversation_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_model",
                                ));
                            }
                            result.conversation_model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for DeployConversationModelOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_model.is_empty() {
            state.serialize_entry("conversationModel", &self.conversation_model)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for a
/// [ConversationModels.UndeployConversationModel][google.cloud.dialogflow.v2.ConversationModels.UndeployConversationModel]
/// operation.
///
/// [google.cloud.dialogflow.v2.ConversationModels.UndeployConversationModel]: crate::client::ConversationModels::undeploy_conversation_model
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UndeployConversationModelOperationMetadata {
    /// The resource name of the conversation model. Format:
    /// `projects/<Project ID>/conversationModels/<Conversation Model Id>`
    pub conversation_model: std::string::String,

    /// Timestamp when the request to undeploy conversation model was submitted.
    /// The time is measured on server side.
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl UndeployConversationModelOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation_model][crate::model::UndeployConversationModelOperationMetadata::conversation_model].
    pub fn set_conversation_model<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_model = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::UndeployConversationModelOperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::UndeployConversationModelOperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for UndeployConversationModelOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.UndeployConversationModelOperationMetadata"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UndeployConversationModelOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_model,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for UndeployConversationModelOperationMetadata",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationModel" => Ok(__FieldTag::__conversation_model),
                            "conversation_model" => Ok(__FieldTag::__conversation_model),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UndeployConversationModelOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeployConversationModelOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_model => {
                            if !fields.insert(__FieldTag::__conversation_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_model",
                                ));
                            }
                            result.conversation_model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for UndeployConversationModelOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_model.is_empty() {
            state.serialize_entry("conversationModel", &self.conversation_model)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for a
/// [ConversationModels.DeleteConversationModel][google.cloud.dialogflow.v2.ConversationModels.DeleteConversationModel]
/// operation.
///
/// [google.cloud.dialogflow.v2.ConversationModels.DeleteConversationModel]: crate::client::ConversationModels::delete_conversation_model
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteConversationModelOperationMetadata {
    /// The resource name of the conversation model. Format:
    /// `projects/<Project ID>/conversationModels/<Conversation Model Id>`
    pub conversation_model: std::string::String,

    /// Timestamp when delete conversation model request was created. The time is
    /// measured on server side.
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl DeleteConversationModelOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation_model][crate::model::DeleteConversationModelOperationMetadata::conversation_model].
    pub fn set_conversation_model<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_model = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::DeleteConversationModelOperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DeleteConversationModelOperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for DeleteConversationModelOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DeleteConversationModelOperationMetadata"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteConversationModelOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_model,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for DeleteConversationModelOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationModel" => Ok(__FieldTag::__conversation_model),
                            "conversation_model" => Ok(__FieldTag::__conversation_model),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteConversationModelOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConversationModelOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_model => {
                            if !fields.insert(__FieldTag::__conversation_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_model",
                                ));
                            }
                            result.conversation_model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteConversationModelOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_model.is_empty() {
            state.serialize_entry("conversationModel", &self.conversation_model)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for a
/// [ConversationModels.CreateConversationModelEvaluation][google.cloud.dialogflow.v2.ConversationModels.CreateConversationModelEvaluation]
/// operation.
///
/// [google.cloud.dialogflow.v2.ConversationModels.CreateConversationModelEvaluation]: crate::client::ConversationModels::create_conversation_model_evaluation
#[cfg(feature = "conversation-models")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateConversationModelEvaluationOperationMetadata {
    /// The resource name of the conversation model. Format:
    /// `projects/<Project ID>/locations/<Location
    /// ID>/conversationModels/<Conversation Model Id>/evaluations/<Evaluation Id>`
    pub conversation_model_evaluation: std::string::String,

    /// The resource name of the conversation model. Format:
    /// `projects/<Project ID>/locations/<Location
    /// ID>/conversationModels/<Conversation Model Id>`
    pub conversation_model: std::string::String,

    /// State of CreateConversationModel operation.
    pub state: crate::model::create_conversation_model_evaluation_operation_metadata::State,

    /// Timestamp when the request to create conversation model was submitted. The
    /// time is measured on server side.
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-models")]
impl CreateConversationModelEvaluationOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation_model_evaluation][crate::model::CreateConversationModelEvaluationOperationMetadata::conversation_model_evaluation].
    pub fn set_conversation_model_evaluation<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_model_evaluation = v.into();
        self
    }

    /// Sets the value of [conversation_model][crate::model::CreateConversationModelEvaluationOperationMetadata::conversation_model].
    pub fn set_conversation_model<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_model = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CreateConversationModelEvaluationOperationMetadata::state].
    pub fn set_state<
        T: std::convert::Into<
                crate::model::create_conversation_model_evaluation_operation_metadata::State,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::CreateConversationModelEvaluationOperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CreateConversationModelEvaluationOperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "conversation-models")]
impl wkt::message::Message for CreateConversationModelEvaluationOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CreateConversationModelEvaluationOperationMetadata"
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateConversationModelEvaluationOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_model_evaluation,
            __conversation_model,
            __state,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for CreateConversationModelEvaluationOperationMetadata",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationModelEvaluation" => {
                                Ok(__FieldTag::__conversation_model_evaluation)
                            }
                            "conversation_model_evaluation" => {
                                Ok(__FieldTag::__conversation_model_evaluation)
                            }
                            "conversationModel" => Ok(__FieldTag::__conversation_model),
                            "conversation_model" => Ok(__FieldTag::__conversation_model),
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateConversationModelEvaluationOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConversationModelEvaluationOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_model_evaluation => {
                            if !fields.insert(__FieldTag::__conversation_model_evaluation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_model_evaluation",
                                ));
                            }
                            result.conversation_model_evaluation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversation_model => {
                            if !fields.insert(__FieldTag::__conversation_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_model",
                                ));
                            }
                            result.conversation_model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::create_conversation_model_evaluation_operation_metadata::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-models")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateConversationModelEvaluationOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_model_evaluation.is_empty() {
            state.serialize_entry(
                "conversationModelEvaluation",
                &self.conversation_model_evaluation,
            )?;
        }
        if !self.conversation_model.is_empty() {
            state.serialize_entry("conversationModel", &self.conversation_model)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CreateConversationModelEvaluationOperationMetadata].
#[cfg(feature = "conversation-models")]
pub mod create_conversation_model_evaluation_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// State of CreateConversationModel operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "conversation-models")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Operation status not specified.
        Unspecified,
        /// The operation is being prepared.
        Initializing,
        /// The operation is running.
        Running,
        /// The operation is cancelled.
        Cancelled,
        /// The operation has succeeded.
        Succeeded,
        /// The operation has failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "conversation-models")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "conversation-models")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Initializing => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Initializing => std::option::Option::Some("INITIALIZING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "conversation-models")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "conversation-models")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "conversation-models")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Initializing,
                2 => Self::Running,
                3 => Self::Cancelled,
                4 => Self::Succeeded,
                5 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "conversation-models")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "INITIALIZING" => Self::Initializing,
                "RUNNING" => Self::Running,
                "CANCELLED" => Self::Cancelled,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "conversation-models")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Initializing => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "conversation-models")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dialogflow.v2.CreateConversationModelEvaluationOperationMetadata.State"))
        }
    }
}

/// Defines the services to connect to incoming Dialogflow conversations.
#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ConversationProfile {
    /// The unique identifier of this conversation profile.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversationProfiles/<Conversation Profile ID>`.
    pub name: std::string::String,

    /// Required. Human readable name for this profile. Max length 1024 bytes.
    pub display_name: std::string::String,

    /// Output only. Create time of the conversation profile.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time of the conversation profile.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Configuration for an automated agent to use with this profile.
    pub automated_agent_config: std::option::Option<crate::model::AutomatedAgentConfig>,

    /// Configuration for agent assistance to use with this profile.
    pub human_agent_assistant_config: std::option::Option<crate::model::HumanAgentAssistantConfig>,

    /// Configuration for connecting to a live agent.
    ///
    /// Currently, this feature is not general available, please contact Google
    /// to get access.
    pub human_agent_handoff_config: std::option::Option<crate::model::HumanAgentHandoffConfig>,

    /// Configuration for publishing conversation lifecycle events.
    pub notification_config: std::option::Option<crate::model::NotificationConfig>,

    /// Configuration for logging conversation lifecycle events.
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Configuration for publishing new message events. Event will be sent in
    /// format of [ConversationEvent][google.cloud.dialogflow.v2.ConversationEvent]
    ///
    /// [google.cloud.dialogflow.v2.ConversationEvent]: crate::model::ConversationEvent
    pub new_message_event_notification_config:
        std::option::Option<crate::model::NotificationConfig>,

    /// Optional. Configuration for publishing transcription intermediate results.
    /// Event will be sent in format of
    /// [ConversationEvent][google.cloud.dialogflow.v2.ConversationEvent]. If
    /// configured, the following information will be populated as
    /// [ConversationEvent][google.cloud.dialogflow.v2.ConversationEvent] Pub/Sub
    /// message attributes:
    ///
    /// - "participant_id"
    /// - "participant_role"
    /// - "message_id"
    ///
    /// [google.cloud.dialogflow.v2.ConversationEvent]: crate::model::ConversationEvent
    pub new_recognition_result_notification_config:
        std::option::Option<crate::model::NotificationConfig>,

    /// Settings for speech transcription.
    pub stt_config: std::option::Option<crate::model::SpeechToTextConfig>,

    /// Language code for the conversation profile. If not specified, the language
    /// is en-US. Language at ConversationProfile should be set for all non en-US
    /// languages.
    /// This should be a [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt)
    /// language tag. Example: "en-US".
    pub language_code: std::string::String,

    /// The time zone of this conversational profile from the
    /// [time zone database](https://www.iana.org/time-zones), e.g.,
    /// America/New_York, Europe/Paris. Defaults to America/New_York.
    pub time_zone: std::string::String,

    /// Name of the CX SecuritySettings reference for the agent.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/securitySettings/<Security Settings ID>`.
    pub security_settings: std::string::String,

    /// Configuration for Text-to-Speech synthesization.
    ///
    /// Used by Phone Gateway to specify synthesization options. If agent defines
    /// synthesization options as well, agent settings overrides the option here.
    pub tts_config: std::option::Option<crate::model::SynthesizeSpeechConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
impl ConversationProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConversationProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::ConversationProfile::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ConversationProfile::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ConversationProfile::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ConversationProfile::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ConversationProfile::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [automated_agent_config][crate::model::ConversationProfile::automated_agent_config].
    pub fn set_automated_agent_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutomatedAgentConfig>,
    {
        self.automated_agent_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automated_agent_config][crate::model::ConversationProfile::automated_agent_config].
    pub fn set_or_clear_automated_agent_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutomatedAgentConfig>,
    {
        self.automated_agent_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [human_agent_assistant_config][crate::model::ConversationProfile::human_agent_assistant_config].
    pub fn set_human_agent_assistant_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HumanAgentAssistantConfig>,
    {
        self.human_agent_assistant_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [human_agent_assistant_config][crate::model::ConversationProfile::human_agent_assistant_config].
    pub fn set_or_clear_human_agent_assistant_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::HumanAgentAssistantConfig>,
    {
        self.human_agent_assistant_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [human_agent_handoff_config][crate::model::ConversationProfile::human_agent_handoff_config].
    pub fn set_human_agent_handoff_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HumanAgentHandoffConfig>,
    {
        self.human_agent_handoff_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [human_agent_handoff_config][crate::model::ConversationProfile::human_agent_handoff_config].
    pub fn set_or_clear_human_agent_handoff_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::HumanAgentHandoffConfig>,
    {
        self.human_agent_handoff_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [notification_config][crate::model::ConversationProfile::notification_config].
    pub fn set_notification_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.notification_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [notification_config][crate::model::ConversationProfile::notification_config].
    pub fn set_or_clear_notification_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.notification_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logging_config][crate::model::ConversationProfile::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::ConversationProfile::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [new_message_event_notification_config][crate::model::ConversationProfile::new_message_event_notification_config].
    pub fn set_new_message_event_notification_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.new_message_event_notification_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [new_message_event_notification_config][crate::model::ConversationProfile::new_message_event_notification_config].
    pub fn set_or_clear_new_message_event_notification_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.new_message_event_notification_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [new_recognition_result_notification_config][crate::model::ConversationProfile::new_recognition_result_notification_config].
    pub fn set_new_recognition_result_notification_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.new_recognition_result_notification_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [new_recognition_result_notification_config][crate::model::ConversationProfile::new_recognition_result_notification_config].
    pub fn set_or_clear_new_recognition_result_notification_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.new_recognition_result_notification_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [stt_config][crate::model::ConversationProfile::stt_config].
    pub fn set_stt_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SpeechToTextConfig>,
    {
        self.stt_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stt_config][crate::model::ConversationProfile::stt_config].
    pub fn set_or_clear_stt_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SpeechToTextConfig>,
    {
        self.stt_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::ConversationProfile::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::ConversationProfile::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [security_settings][crate::model::ConversationProfile::security_settings].
    pub fn set_security_settings<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.security_settings = v.into();
        self
    }

    /// Sets the value of [tts_config][crate::model::ConversationProfile::tts_config].
    pub fn set_tts_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SynthesizeSpeechConfig>,
    {
        self.tts_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tts_config][crate::model::ConversationProfile::tts_config].
    pub fn set_or_clear_tts_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SynthesizeSpeechConfig>,
    {
        self.tts_config = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
impl wkt::message::Message for ConversationProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ConversationProfile"
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConversationProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __create_time,
            __update_time,
            __automated_agent_config,
            __human_agent_assistant_config,
            __human_agent_handoff_config,
            __notification_config,
            __logging_config,
            __new_message_event_notification_config,
            __new_recognition_result_notification_config,
            __stt_config,
            __language_code,
            __time_zone,
            __security_settings,
            __tts_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "automatedAgentConfig" => Ok(__FieldTag::__automated_agent_config),
                            "automated_agent_config" => Ok(__FieldTag::__automated_agent_config),
                            "humanAgentAssistantConfig" => {
                                Ok(__FieldTag::__human_agent_assistant_config)
                            }
                            "human_agent_assistant_config" => {
                                Ok(__FieldTag::__human_agent_assistant_config)
                            }
                            "humanAgentHandoffConfig" => {
                                Ok(__FieldTag::__human_agent_handoff_config)
                            }
                            "human_agent_handoff_config" => {
                                Ok(__FieldTag::__human_agent_handoff_config)
                            }
                            "notificationConfig" => Ok(__FieldTag::__notification_config),
                            "notification_config" => Ok(__FieldTag::__notification_config),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            "newMessageEventNotificationConfig" => {
                                Ok(__FieldTag::__new_message_event_notification_config)
                            }
                            "new_message_event_notification_config" => {
                                Ok(__FieldTag::__new_message_event_notification_config)
                            }
                            "newRecognitionResultNotificationConfig" => {
                                Ok(__FieldTag::__new_recognition_result_notification_config)
                            }
                            "new_recognition_result_notification_config" => {
                                Ok(__FieldTag::__new_recognition_result_notification_config)
                            }
                            "sttConfig" => Ok(__FieldTag::__stt_config),
                            "stt_config" => Ok(__FieldTag::__stt_config),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "securitySettings" => Ok(__FieldTag::__security_settings),
                            "security_settings" => Ok(__FieldTag::__security_settings),
                            "ttsConfig" => Ok(__FieldTag::__tts_config),
                            "tts_config" => Ok(__FieldTag::__tts_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConversationProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__automated_agent_config => {
                            if !fields.insert(__FieldTag::__automated_agent_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automated_agent_config",
                                ));
                            }
                            result.automated_agent_config = map.next_value::<std::option::Option<crate::model::AutomatedAgentConfig>>()?
                                ;
                        }
                        __FieldTag::__human_agent_assistant_config => {
                            if !fields.insert(__FieldTag::__human_agent_assistant_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for human_agent_assistant_config",
                                ));
                            }
                            result.human_agent_assistant_config = map.next_value::<std::option::Option<crate::model::HumanAgentAssistantConfig>>()?
                                ;
                        }
                        __FieldTag::__human_agent_handoff_config => {
                            if !fields.insert(__FieldTag::__human_agent_handoff_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for human_agent_handoff_config",
                                ));
                            }
                            result.human_agent_handoff_config = map.next_value::<std::option::Option<crate::model::HumanAgentHandoffConfig>>()?
                                ;
                        }
                        __FieldTag::__notification_config => {
                            if !fields.insert(__FieldTag::__notification_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_config",
                                ));
                            }
                            result.notification_config = map.next_value::<std::option::Option<crate::model::NotificationConfig>>()?
                                ;
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::__new_message_event_notification_config => {
                            if !fields.insert(__FieldTag::__new_message_event_notification_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_message_event_notification_config",
                                ));
                            }
                            result.new_message_event_notification_config = map
                                .next_value::<std::option::Option<
                                crate::model::NotificationConfig,
                            >>(
                            )?;
                        }
                        __FieldTag::__new_recognition_result_notification_config => {
                            if !fields
                                .insert(__FieldTag::__new_recognition_result_notification_config)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_recognition_result_notification_config",
                                ));
                            }
                            result.new_recognition_result_notification_config = map.next_value::<std::option::Option<crate::model::NotificationConfig>>()?
                                ;
                        }
                        __FieldTag::__stt_config => {
                            if !fields.insert(__FieldTag::__stt_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stt_config",
                                ));
                            }
                            result.stt_config = map.next_value::<std::option::Option<crate::model::SpeechToTextConfig>>()?
                                ;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__security_settings => {
                            if !fields.insert(__FieldTag::__security_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_settings",
                                ));
                            }
                            result.security_settings = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tts_config => {
                            if !fields.insert(__FieldTag::__tts_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tts_config",
                                ));
                            }
                            result.tts_config = map.next_value::<std::option::Option<crate::model::SynthesizeSpeechConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for ConversationProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.automated_agent_config.is_some() {
            state.serialize_entry("automatedAgentConfig", &self.automated_agent_config)?;
        }
        if self.human_agent_assistant_config.is_some() {
            state.serialize_entry(
                "humanAgentAssistantConfig",
                &self.human_agent_assistant_config,
            )?;
        }
        if self.human_agent_handoff_config.is_some() {
            state.serialize_entry("humanAgentHandoffConfig", &self.human_agent_handoff_config)?;
        }
        if self.notification_config.is_some() {
            state.serialize_entry("notificationConfig", &self.notification_config)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if self.new_message_event_notification_config.is_some() {
            state.serialize_entry(
                "newMessageEventNotificationConfig",
                &self.new_message_event_notification_config,
            )?;
        }
        if self.new_recognition_result_notification_config.is_some() {
            state.serialize_entry(
                "newRecognitionResultNotificationConfig",
                &self.new_recognition_result_notification_config,
            )?;
        }
        if self.stt_config.is_some() {
            state.serialize_entry("sttConfig", &self.stt_config)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if !self.security_settings.is_empty() {
            state.serialize_entry("securitySettings", &self.security_settings)?;
        }
        if self.tts_config.is_some() {
            state.serialize_entry("ttsConfig", &self.tts_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [ConversationProfiles.ListConversationProfiles][google.cloud.dialogflow.v2.ConversationProfiles.ListConversationProfiles].
///
/// [google.cloud.dialogflow.v2.ConversationProfiles.ListConversationProfiles]: crate::client::ConversationProfiles::list_conversation_profiles
#[cfg(feature = "conversation-profiles")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConversationProfilesRequest {
    /// Required. The project to list all conversation profiles from.
    /// Format: `projects/<Project ID>/locations/<Location ID>`.
    pub parent: std::string::String,

    /// The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-profiles")]
impl ListConversationProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConversationProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConversationProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConversationProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "conversation-profiles")]
impl wkt::message::Message for ListConversationProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListConversationProfilesRequest"
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConversationProfilesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationProfilesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConversationProfilesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationProfilesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for ListConversationProfilesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [ConversationProfiles.ListConversationProfiles][google.cloud.dialogflow.v2.ConversationProfiles.ListConversationProfiles].
///
/// [google.cloud.dialogflow.v2.ConversationProfiles.ListConversationProfiles]: crate::client::ConversationProfiles::list_conversation_profiles
#[cfg(feature = "conversation-profiles")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListConversationProfilesResponse {
    /// The list of project conversation profiles. There is a maximum number
    /// of items returned based on the page_size field in the request.
    pub conversation_profiles: std::vec::Vec<crate::model::ConversationProfile>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-profiles")]
impl ListConversationProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation_profiles][crate::model::ListConversationProfilesResponse::conversation_profiles].
    pub fn set_conversation_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConversationProfile>,
    {
        use std::iter::Iterator;
        self.conversation_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConversationProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "conversation-profiles")]
impl wkt::message::Message for ListConversationProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListConversationProfilesResponse"
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConversationProfilesResponse {
    type PageItem = crate::model::ConversationProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.conversation_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListConversationProfilesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_profiles,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListConversationProfilesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationProfiles" => Ok(__FieldTag::__conversation_profiles),
                            "conversation_profiles" => Ok(__FieldTag::__conversation_profiles),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListConversationProfilesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListConversationProfilesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_profiles => {
                            if !fields.insert(__FieldTag::__conversation_profiles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_profiles",
                                ));
                            }
                            result.conversation_profiles = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConversationProfile>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for ListConversationProfilesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_profiles.is_empty() {
            state.serialize_entry("conversationProfiles", &self.conversation_profiles)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [ConversationProfiles.GetConversationProfile][google.cloud.dialogflow.v2.ConversationProfiles.GetConversationProfile].
///
/// [google.cloud.dialogflow.v2.ConversationProfiles.GetConversationProfile]: crate::client::ConversationProfiles::get_conversation_profile
#[cfg(feature = "conversation-profiles")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConversationProfileRequest {
    /// Required. The resource name of the conversation profile.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversationProfiles/<Conversation Profile ID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-profiles")]
impl GetConversationProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConversationProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "conversation-profiles")]
impl wkt::message::Message for GetConversationProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetConversationProfileRequest"
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConversationProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConversationProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConversationProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConversationProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for GetConversationProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [ConversationProfiles.CreateConversationProfile][google.cloud.dialogflow.v2.ConversationProfiles.CreateConversationProfile].
///
/// [google.cloud.dialogflow.v2.ConversationProfiles.CreateConversationProfile]: crate::client::ConversationProfiles::create_conversation_profile
#[cfg(feature = "conversation-profiles")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateConversationProfileRequest {
    /// Required. The project to create a conversation profile for.
    /// Format: `projects/<Project ID>/locations/<Location ID>`.
    pub parent: std::string::String,

    /// Required. The conversation profile to create.
    pub conversation_profile: std::option::Option<crate::model::ConversationProfile>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-profiles")]
impl CreateConversationProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConversationProfileRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [conversation_profile][crate::model::CreateConversationProfileRequest::conversation_profile].
    pub fn set_conversation_profile<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConversationProfile>,
    {
        self.conversation_profile = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation_profile][crate::model::CreateConversationProfileRequest::conversation_profile].
    pub fn set_or_clear_conversation_profile<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConversationProfile>,
    {
        self.conversation_profile = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "conversation-profiles")]
impl wkt::message::Message for CreateConversationProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CreateConversationProfileRequest"
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateConversationProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __conversation_profile,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateConversationProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "conversationProfile" => Ok(__FieldTag::__conversation_profile),
                            "conversation_profile" => Ok(__FieldTag::__conversation_profile),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateConversationProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateConversationProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conversation_profile => {
                            if !fields.insert(__FieldTag::__conversation_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_profile",
                                ));
                            }
                            result.conversation_profile = map.next_value::<std::option::Option<crate::model::ConversationProfile>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateConversationProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.conversation_profile.is_some() {
            state.serialize_entry("conversationProfile", &self.conversation_profile)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [ConversationProfiles.UpdateConversationProfile][google.cloud.dialogflow.v2.ConversationProfiles.UpdateConversationProfile].
///
/// [google.cloud.dialogflow.v2.ConversationProfiles.UpdateConversationProfile]: crate::client::ConversationProfiles::update_conversation_profile
#[cfg(feature = "conversation-profiles")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateConversationProfileRequest {
    /// Required. The conversation profile to update.
    pub conversation_profile: std::option::Option<crate::model::ConversationProfile>,

    /// Required. The mask to control which fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-profiles")]
impl UpdateConversationProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation_profile][crate::model::UpdateConversationProfileRequest::conversation_profile].
    pub fn set_conversation_profile<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConversationProfile>,
    {
        self.conversation_profile = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation_profile][crate::model::UpdateConversationProfileRequest::conversation_profile].
    pub fn set_or_clear_conversation_profile<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConversationProfile>,
    {
        self.conversation_profile = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateConversationProfileRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateConversationProfileRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "conversation-profiles")]
impl wkt::message::Message for UpdateConversationProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.UpdateConversationProfileRequest"
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateConversationProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_profile,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateConversationProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationProfile" => Ok(__FieldTag::__conversation_profile),
                            "conversation_profile" => Ok(__FieldTag::__conversation_profile),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateConversationProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateConversationProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_profile => {
                            if !fields.insert(__FieldTag::__conversation_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_profile",
                                ));
                            }
                            result.conversation_profile = map.next_value::<std::option::Option<crate::model::ConversationProfile>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateConversationProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.conversation_profile.is_some() {
            state.serialize_entry("conversationProfile", &self.conversation_profile)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [ConversationProfiles.DeleteConversationProfile][google.cloud.dialogflow.v2.ConversationProfiles.DeleteConversationProfile].
///
/// This operation fails if the conversation profile is still referenced from
/// a phone number.
///
/// [google.cloud.dialogflow.v2.ConversationProfiles.DeleteConversationProfile]: crate::client::ConversationProfiles::delete_conversation_profile
#[cfg(feature = "conversation-profiles")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteConversationProfileRequest {
    /// Required. The name of the conversation profile to delete.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversationProfiles/<Conversation Profile ID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-profiles")]
impl DeleteConversationProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConversationProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "conversation-profiles")]
impl wkt::message::Message for DeleteConversationProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DeleteConversationProfileRequest"
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteConversationProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteConversationProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteConversationProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteConversationProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteConversationProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines the Automated Agent to connect to a conversation.
#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AutomatedAgentConfig {
    /// Required. ID of the Dialogflow agent environment to use.
    ///
    /// This project needs to either be the same project as the conversation or you
    /// need to grant `service-<Conversation Project
    /// Number>@gcp-sa-dialogflow.iam.gserviceaccount.com` the `Dialogflow API
    /// Service Agent` role in this project.
    ///
    /// - For ES agents, use format: `projects/<Project ID>/locations/<Location
    ///   ID>/agent/environments/<Environment ID or '-'>`. If environment is not
    ///   specified, the default `draft` environment is used. Refer to
    ///   [DetectIntentRequest](/dialogflow/docs/reference/rpc/google.cloud.dialogflow.v2#google.cloud.dialogflow.v2.DetectIntentRequest)
    ///   for more details.
    ///
    /// - For CX agents, use format `projects/<Project ID>/locations/<Location
    ///   ID>/agents/<Agent ID>/environments/<Environment ID
    ///   or '-'>`. If environment is not specified, the default `draft` environment
    ///   is used.
    ///
    pub agent: std::string::String,

    /// Optional. Configure lifetime of the Dialogflow session.
    /// By default, a Dialogflow CX session remains active and its data is stored
    /// for 30 minutes after the last request is sent for the session.
    /// This value should be no longer than 1 day.
    pub session_ttl: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
impl AutomatedAgentConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [agent][crate::model::AutomatedAgentConfig::agent].
    pub fn set_agent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.agent = v.into();
        self
    }

    /// Sets the value of [session_ttl][crate::model::AutomatedAgentConfig::session_ttl].
    pub fn set_session_ttl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.session_ttl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session_ttl][crate::model::AutomatedAgentConfig::session_ttl].
    pub fn set_or_clear_session_ttl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.session_ttl = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
impl wkt::message::Message for AutomatedAgentConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.AutomatedAgentConfig"
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutomatedAgentConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __agent,
            __session_ttl,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutomatedAgentConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "agent" => Ok(__FieldTag::__agent),
                            "sessionTtl" => Ok(__FieldTag::__session_ttl),
                            "session_ttl" => Ok(__FieldTag::__session_ttl),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutomatedAgentConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutomatedAgentConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__agent => {
                            if !fields.insert(__FieldTag::__agent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent",
                                ));
                            }
                            result.agent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__session_ttl => {
                            if !fields.insert(__FieldTag::__session_ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_ttl",
                                ));
                            }
                            result.session_ttl =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for AutomatedAgentConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.agent.is_empty() {
            state.serialize_entry("agent", &self.agent)?;
        }
        if self.session_ttl.is_some() {
            state.serialize_entry("sessionTtl", &self.session_ttl)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines the Human Agent Assist to connect to a conversation.
#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HumanAgentAssistantConfig {
    /// Pub/Sub topic on which to publish new agent assistant events.
    pub notification_config: std::option::Option<crate::model::NotificationConfig>,

    /// Configuration for agent assistance of human agent participant.
    pub human_agent_suggestion_config:
        std::option::Option<crate::model::human_agent_assistant_config::SuggestionConfig>,

    /// Configuration for agent assistance of end user participant.
    ///
    /// Currently, this feature is not general available, please contact Google
    /// to get access.
    pub end_user_suggestion_config:
        std::option::Option<crate::model::human_agent_assistant_config::SuggestionConfig>,

    /// Configuration for message analysis.
    pub message_analysis_config:
        std::option::Option<crate::model::human_agent_assistant_config::MessageAnalysisConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
impl HumanAgentAssistantConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [notification_config][crate::model::HumanAgentAssistantConfig::notification_config].
    pub fn set_notification_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.notification_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [notification_config][crate::model::HumanAgentAssistantConfig::notification_config].
    pub fn set_or_clear_notification_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.notification_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [human_agent_suggestion_config][crate::model::HumanAgentAssistantConfig::human_agent_suggestion_config].
    pub fn set_human_agent_suggestion_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::human_agent_assistant_config::SuggestionConfig>,
    {
        self.human_agent_suggestion_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [human_agent_suggestion_config][crate::model::HumanAgentAssistantConfig::human_agent_suggestion_config].
    pub fn set_or_clear_human_agent_suggestion_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::human_agent_assistant_config::SuggestionConfig>,
    {
        self.human_agent_suggestion_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_user_suggestion_config][crate::model::HumanAgentAssistantConfig::end_user_suggestion_config].
    pub fn set_end_user_suggestion_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::human_agent_assistant_config::SuggestionConfig>,
    {
        self.end_user_suggestion_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_user_suggestion_config][crate::model::HumanAgentAssistantConfig::end_user_suggestion_config].
    pub fn set_or_clear_end_user_suggestion_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::human_agent_assistant_config::SuggestionConfig>,
    {
        self.end_user_suggestion_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [message_analysis_config][crate::model::HumanAgentAssistantConfig::message_analysis_config].
    pub fn set_message_analysis_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::human_agent_assistant_config::MessageAnalysisConfig>,
    {
        self.message_analysis_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [message_analysis_config][crate::model::HumanAgentAssistantConfig::message_analysis_config].
    pub fn set_or_clear_message_analysis_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::human_agent_assistant_config::MessageAnalysisConfig>,
    {
        self.message_analysis_config = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
impl wkt::message::Message for HumanAgentAssistantConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.HumanAgentAssistantConfig"
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HumanAgentAssistantConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __notification_config,
            __human_agent_suggestion_config,
            __end_user_suggestion_config,
            __message_analysis_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HumanAgentAssistantConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "notificationConfig" => Ok(__FieldTag::__notification_config),
                            "notification_config" => Ok(__FieldTag::__notification_config),
                            "humanAgentSuggestionConfig" => {
                                Ok(__FieldTag::__human_agent_suggestion_config)
                            }
                            "human_agent_suggestion_config" => {
                                Ok(__FieldTag::__human_agent_suggestion_config)
                            }
                            "endUserSuggestionConfig" => {
                                Ok(__FieldTag::__end_user_suggestion_config)
                            }
                            "end_user_suggestion_config" => {
                                Ok(__FieldTag::__end_user_suggestion_config)
                            }
                            "messageAnalysisConfig" => Ok(__FieldTag::__message_analysis_config),
                            "message_analysis_config" => Ok(__FieldTag::__message_analysis_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HumanAgentAssistantConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HumanAgentAssistantConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__notification_config => {
                            if !fields.insert(__FieldTag::__notification_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_config",
                                ));
                            }
                            result.notification_config = map.next_value::<std::option::Option<crate::model::NotificationConfig>>()?
                                ;
                        }
                        __FieldTag::__human_agent_suggestion_config => {
                            if !fields.insert(__FieldTag::__human_agent_suggestion_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for human_agent_suggestion_config",
                                ));
                            }
                            result.human_agent_suggestion_config = map
                                .next_value::<std::option::Option<
                                    crate::model::human_agent_assistant_config::SuggestionConfig,
                                >>()?;
                        }
                        __FieldTag::__end_user_suggestion_config => {
                            if !fields.insert(__FieldTag::__end_user_suggestion_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_user_suggestion_config",
                                ));
                            }
                            result.end_user_suggestion_config = map
                                .next_value::<std::option::Option<
                                    crate::model::human_agent_assistant_config::SuggestionConfig,
                                >>()?;
                        }
                        __FieldTag::__message_analysis_config => {
                            if !fields.insert(__FieldTag::__message_analysis_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_analysis_config",
                                ));
                            }
                            result.message_analysis_config = map.next_value::<std::option::Option<
                                crate::model::human_agent_assistant_config::MessageAnalysisConfig,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for HumanAgentAssistantConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.notification_config.is_some() {
            state.serialize_entry("notificationConfig", &self.notification_config)?;
        }
        if self.human_agent_suggestion_config.is_some() {
            state.serialize_entry(
                "humanAgentSuggestionConfig",
                &self.human_agent_suggestion_config,
            )?;
        }
        if self.end_user_suggestion_config.is_some() {
            state.serialize_entry("endUserSuggestionConfig", &self.end_user_suggestion_config)?;
        }
        if self.message_analysis_config.is_some() {
            state.serialize_entry("messageAnalysisConfig", &self.message_analysis_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [HumanAgentAssistantConfig].
#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
pub mod human_agent_assistant_config {
    #[allow(unused_imports)]
    use super::*;

    /// Settings of suggestion trigger.
    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SuggestionTriggerSettings {
        /// Do not trigger if last utterance is small talk.
        pub no_smalltalk: bool,

        /// Only trigger suggestion if participant role of last utterance is
        /// END_USER.
        pub only_end_user: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl SuggestionTriggerSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [no_smalltalk][crate::model::human_agent_assistant_config::SuggestionTriggerSettings::no_smalltalk].
        pub fn set_no_smalltalk<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.no_smalltalk = v.into();
            self
        }

        /// Sets the value of [only_end_user][crate::model::human_agent_assistant_config::SuggestionTriggerSettings::only_end_user].
        pub fn set_only_end_user<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.only_end_user = v.into();
            self
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl wkt::message::Message for SuggestionTriggerSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionTriggerSettings"
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SuggestionTriggerSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __no_smalltalk,
                __only_end_user,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SuggestionTriggerSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "noSmalltalk" => Ok(__FieldTag::__no_smalltalk),
                                "no_smalltalk" => Ok(__FieldTag::__no_smalltalk),
                                "onlyEndUser" => Ok(__FieldTag::__only_end_user),
                                "only_end_user" => Ok(__FieldTag::__only_end_user),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SuggestionTriggerSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SuggestionTriggerSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__no_smalltalk => {
                                if !fields.insert(__FieldTag::__no_smalltalk) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for no_smalltalk",
                                    ));
                                }
                                result.no_smalltalk = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__only_end_user => {
                                if !fields.insert(__FieldTag::__only_end_user) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for only_end_user",
                                    ));
                                }
                                result.only_end_user = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[doc(hidden)]
    impl serde::ser::Serialize for SuggestionTriggerSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.no_smalltalk) {
                state.serialize_entry("noSmalltalk", &self.no_smalltalk)?;
            }
            if !wkt::internal::is_default(&self.only_end_user) {
                state.serialize_entry("onlyEndUser", &self.only_end_user)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Config for suggestion features.
    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SuggestionFeatureConfig {
        /// The suggestion feature.
        pub suggestion_feature: std::option::Option<crate::model::SuggestionFeature>,

        /// Automatically iterates all participants and tries to compile
        /// suggestions.
        ///
        /// Supported features: ARTICLE_SUGGESTION, FAQ, DIALOGFLOW_ASSIST,
        /// KNOWLEDGE_ASSIST.
        pub enable_event_based_suggestion: bool,

        /// Optional. Disable the logging of search queries sent by human agents. It
        /// can prevent those queries from being stored at answer records.
        ///
        /// Supported features: KNOWLEDGE_SEARCH.
        pub disable_agent_query_logging: bool,

        /// Optional. Enable query suggestion even if we can't find its answer.
        /// By default, queries are suggested only if we find its answer.
        /// Supported features: KNOWLEDGE_ASSIST
        pub enable_query_suggestion_when_no_answer: bool,

        /// Optional. Enable including conversation context during query answer
        /// generation. Supported features: KNOWLEDGE_SEARCH.
        pub enable_conversation_augmented_query: bool,

        /// Optional. Enable query suggestion only.
        /// Supported features: KNOWLEDGE_ASSIST
        pub enable_query_suggestion_only: bool,

        /// Settings of suggestion trigger.
        ///
        /// Currently, only ARTICLE_SUGGESTION and FAQ will use this field.
        pub suggestion_trigger_settings: std::option::Option<
            crate::model::human_agent_assistant_config::SuggestionTriggerSettings,
        >,

        /// Configs of query.
        pub query_config:
            std::option::Option<crate::model::human_agent_assistant_config::SuggestionQueryConfig>,

        /// Configs of custom conversation model.
        pub conversation_model_config: std::option::Option<
            crate::model::human_agent_assistant_config::ConversationModelConfig,
        >,

        /// Configs for processing conversation.
        pub conversation_process_config: std::option::Option<
            crate::model::human_agent_assistant_config::ConversationProcessConfig,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl SuggestionFeatureConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [suggestion_feature][crate::model::human_agent_assistant_config::SuggestionFeatureConfig::suggestion_feature].
        pub fn set_suggestion_feature<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::SuggestionFeature>,
        {
            self.suggestion_feature = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [suggestion_feature][crate::model::human_agent_assistant_config::SuggestionFeatureConfig::suggestion_feature].
        pub fn set_or_clear_suggestion_feature<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::SuggestionFeature>,
        {
            self.suggestion_feature = v.map(|x| x.into());
            self
        }

        /// Sets the value of [enable_event_based_suggestion][crate::model::human_agent_assistant_config::SuggestionFeatureConfig::enable_event_based_suggestion].
        pub fn set_enable_event_based_suggestion<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.enable_event_based_suggestion = v.into();
            self
        }

        /// Sets the value of [disable_agent_query_logging][crate::model::human_agent_assistant_config::SuggestionFeatureConfig::disable_agent_query_logging].
        pub fn set_disable_agent_query_logging<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.disable_agent_query_logging = v.into();
            self
        }

        /// Sets the value of [enable_query_suggestion_when_no_answer][crate::model::human_agent_assistant_config::SuggestionFeatureConfig::enable_query_suggestion_when_no_answer].
        pub fn set_enable_query_suggestion_when_no_answer<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.enable_query_suggestion_when_no_answer = v.into();
            self
        }

        /// Sets the value of [enable_conversation_augmented_query][crate::model::human_agent_assistant_config::SuggestionFeatureConfig::enable_conversation_augmented_query].
        pub fn set_enable_conversation_augmented_query<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.enable_conversation_augmented_query = v.into();
            self
        }

        /// Sets the value of [enable_query_suggestion_only][crate::model::human_agent_assistant_config::SuggestionFeatureConfig::enable_query_suggestion_only].
        pub fn set_enable_query_suggestion_only<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.enable_query_suggestion_only = v.into();
            self
        }

        /// Sets the value of [suggestion_trigger_settings][crate::model::human_agent_assistant_config::SuggestionFeatureConfig::suggestion_trigger_settings].
        pub fn set_suggestion_trigger_settings<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::human_agent_assistant_config::SuggestionTriggerSettings,
                >,
        {
            self.suggestion_trigger_settings = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [suggestion_trigger_settings][crate::model::human_agent_assistant_config::SuggestionFeatureConfig::suggestion_trigger_settings].
        pub fn set_or_clear_suggestion_trigger_settings<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<
                    crate::model::human_agent_assistant_config::SuggestionTriggerSettings,
                >,
        {
            self.suggestion_trigger_settings = v.map(|x| x.into());
            self
        }

        /// Sets the value of [query_config][crate::model::human_agent_assistant_config::SuggestionFeatureConfig::query_config].
        pub fn set_query_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::human_agent_assistant_config::SuggestionQueryConfig,
                >,
        {
            self.query_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [query_config][crate::model::human_agent_assistant_config::SuggestionFeatureConfig::query_config].
        pub fn set_or_clear_query_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::human_agent_assistant_config::SuggestionQueryConfig,
                >,
        {
            self.query_config = v.map(|x| x.into());
            self
        }

        /// Sets the value of [conversation_model_config][crate::model::human_agent_assistant_config::SuggestionFeatureConfig::conversation_model_config].
        pub fn set_conversation_model_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::human_agent_assistant_config::ConversationModelConfig,
                >,
        {
            self.conversation_model_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [conversation_model_config][crate::model::human_agent_assistant_config::SuggestionFeatureConfig::conversation_model_config].
        pub fn set_or_clear_conversation_model_config<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<
                    crate::model::human_agent_assistant_config::ConversationModelConfig,
                >,
        {
            self.conversation_model_config = v.map(|x| x.into());
            self
        }

        /// Sets the value of [conversation_process_config][crate::model::human_agent_assistant_config::SuggestionFeatureConfig::conversation_process_config].
        pub fn set_conversation_process_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::human_agent_assistant_config::ConversationProcessConfig,
                >,
        {
            self.conversation_process_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [conversation_process_config][crate::model::human_agent_assistant_config::SuggestionFeatureConfig::conversation_process_config].
        pub fn set_or_clear_conversation_process_config<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<
                    crate::model::human_agent_assistant_config::ConversationProcessConfig,
                >,
        {
            self.conversation_process_config = v.map(|x| x.into());
            self
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl wkt::message::Message for SuggestionFeatureConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionFeatureConfig"
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SuggestionFeatureConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __suggestion_feature,
                __enable_event_based_suggestion,
                __disable_agent_query_logging,
                __enable_query_suggestion_when_no_answer,
                __enable_conversation_augmented_query,
                __enable_query_suggestion_only,
                __suggestion_trigger_settings,
                __query_config,
                __conversation_model_config,
                __conversation_process_config,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SuggestionFeatureConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "suggestionFeature" => Ok(__FieldTag::__suggestion_feature),
                                "suggestion_feature" => Ok(__FieldTag::__suggestion_feature),
                                "enableEventBasedSuggestion" => {
                                    Ok(__FieldTag::__enable_event_based_suggestion)
                                }
                                "enable_event_based_suggestion" => {
                                    Ok(__FieldTag::__enable_event_based_suggestion)
                                }
                                "disableAgentQueryLogging" => {
                                    Ok(__FieldTag::__disable_agent_query_logging)
                                }
                                "disable_agent_query_logging" => {
                                    Ok(__FieldTag::__disable_agent_query_logging)
                                }
                                "enableQuerySuggestionWhenNoAnswer" => {
                                    Ok(__FieldTag::__enable_query_suggestion_when_no_answer)
                                }
                                "enable_query_suggestion_when_no_answer" => {
                                    Ok(__FieldTag::__enable_query_suggestion_when_no_answer)
                                }
                                "enableConversationAugmentedQuery" => {
                                    Ok(__FieldTag::__enable_conversation_augmented_query)
                                }
                                "enable_conversation_augmented_query" => {
                                    Ok(__FieldTag::__enable_conversation_augmented_query)
                                }
                                "enableQuerySuggestionOnly" => {
                                    Ok(__FieldTag::__enable_query_suggestion_only)
                                }
                                "enable_query_suggestion_only" => {
                                    Ok(__FieldTag::__enable_query_suggestion_only)
                                }
                                "suggestionTriggerSettings" => {
                                    Ok(__FieldTag::__suggestion_trigger_settings)
                                }
                                "suggestion_trigger_settings" => {
                                    Ok(__FieldTag::__suggestion_trigger_settings)
                                }
                                "queryConfig" => Ok(__FieldTag::__query_config),
                                "query_config" => Ok(__FieldTag::__query_config),
                                "conversationModelConfig" => {
                                    Ok(__FieldTag::__conversation_model_config)
                                }
                                "conversation_model_config" => {
                                    Ok(__FieldTag::__conversation_model_config)
                                }
                                "conversationProcessConfig" => {
                                    Ok(__FieldTag::__conversation_process_config)
                                }
                                "conversation_process_config" => {
                                    Ok(__FieldTag::__conversation_process_config)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SuggestionFeatureConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SuggestionFeatureConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__suggestion_feature => {
                                if !fields.insert(__FieldTag::__suggestion_feature) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for suggestion_feature",
                                    ));
                                }
                                result.suggestion_feature = map.next_value::<std::option::Option<crate::model::SuggestionFeature>>()?
                                    ;
                            }
                            __FieldTag::__enable_event_based_suggestion => {
                                if !fields.insert(__FieldTag::__enable_event_based_suggestion) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_event_based_suggestion",
                                    ));
                                }
                                result.enable_event_based_suggestion = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__disable_agent_query_logging => {
                                if !fields.insert(__FieldTag::__disable_agent_query_logging) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for disable_agent_query_logging",
                                    ));
                                }
                                result.disable_agent_query_logging = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__enable_query_suggestion_when_no_answer => {
                                if !fields
                                    .insert(__FieldTag::__enable_query_suggestion_when_no_answer)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_query_suggestion_when_no_answer",
                                    ));
                                }
                                result.enable_query_suggestion_when_no_answer = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__enable_conversation_augmented_query => {
                                if !fields.insert(__FieldTag::__enable_conversation_augmented_query)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_conversation_augmented_query",
                                    ));
                                }
                                result.enable_conversation_augmented_query = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__enable_query_suggestion_only => {
                                if !fields.insert(__FieldTag::__enable_query_suggestion_only) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_query_suggestion_only",
                                    ));
                                }
                                result.enable_query_suggestion_only = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__suggestion_trigger_settings => {
                                if !fields.insert(__FieldTag::__suggestion_trigger_settings) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for suggestion_trigger_settings",
                                    ));
                                }
                                result.suggestion_trigger_settings = map.next_value::<std::option::Option<crate::model::human_agent_assistant_config::SuggestionTriggerSettings>>()?
                                    ;
                            }
                            __FieldTag::__query_config => {
                                if !fields.insert(__FieldTag::__query_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for query_config",
                                    ));
                                }
                                result.query_config = map.next_value::<std::option::Option<crate::model::human_agent_assistant_config::SuggestionQueryConfig>>()?
                                    ;
                            }
                            __FieldTag::__conversation_model_config => {
                                if !fields.insert(__FieldTag::__conversation_model_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for conversation_model_config",
                                    ));
                                }
                                result.conversation_model_config = map.next_value::<std::option::Option<crate::model::human_agent_assistant_config::ConversationModelConfig>>()?
                                    ;
                            }
                            __FieldTag::__conversation_process_config => {
                                if !fields.insert(__FieldTag::__conversation_process_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for conversation_process_config",
                                    ));
                                }
                                result.conversation_process_config = map.next_value::<std::option::Option<crate::model::human_agent_assistant_config::ConversationProcessConfig>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[doc(hidden)]
    impl serde::ser::Serialize for SuggestionFeatureConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.suggestion_feature.is_some() {
                state.serialize_entry("suggestionFeature", &self.suggestion_feature)?;
            }
            if !wkt::internal::is_default(&self.enable_event_based_suggestion) {
                state.serialize_entry(
                    "enableEventBasedSuggestion",
                    &self.enable_event_based_suggestion,
                )?;
            }
            if !wkt::internal::is_default(&self.disable_agent_query_logging) {
                state.serialize_entry(
                    "disableAgentQueryLogging",
                    &self.disable_agent_query_logging,
                )?;
            }
            if !wkt::internal::is_default(&self.enable_query_suggestion_when_no_answer) {
                state.serialize_entry(
                    "enableQuerySuggestionWhenNoAnswer",
                    &self.enable_query_suggestion_when_no_answer,
                )?;
            }
            if !wkt::internal::is_default(&self.enable_conversation_augmented_query) {
                state.serialize_entry(
                    "enableConversationAugmentedQuery",
                    &self.enable_conversation_augmented_query,
                )?;
            }
            if !wkt::internal::is_default(&self.enable_query_suggestion_only) {
                state.serialize_entry(
                    "enableQuerySuggestionOnly",
                    &self.enable_query_suggestion_only,
                )?;
            }
            if self.suggestion_trigger_settings.is_some() {
                state.serialize_entry(
                    "suggestionTriggerSettings",
                    &self.suggestion_trigger_settings,
                )?;
            }
            if self.query_config.is_some() {
                state.serialize_entry("queryConfig", &self.query_config)?;
            }
            if self.conversation_model_config.is_some() {
                state
                    .serialize_entry("conversationModelConfig", &self.conversation_model_config)?;
            }
            if self.conversation_process_config.is_some() {
                state.serialize_entry(
                    "conversationProcessConfig",
                    &self.conversation_process_config,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Detail human agent assistant config.
    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SuggestionConfig {
        /// Configuration of different suggestion features. One feature can have only
        /// one config.
        pub feature_configs:
            std::vec::Vec<crate::model::human_agent_assistant_config::SuggestionFeatureConfig>,

        /// If `group_suggestion_responses` is false, and there are multiple
        /// `feature_configs` in `event based suggestion` or
        /// StreamingAnalyzeContent, we will try to deliver suggestions to customers
        /// as soon as we get new suggestion. Different type of suggestions based on
        /// the same context will be in  separate Pub/Sub event or
        /// `StreamingAnalyzeContentResponse`.
        ///
        /// If `group_suggestion_responses` set to true. All the suggestions to the
        /// same participant based on the same context will be grouped into a single
        /// Pub/Sub event or StreamingAnalyzeContentResponse.
        pub group_suggestion_responses: bool,

        /// Optional. List of various generator resource names used in the
        /// conversation profile.
        pub generators: std::vec::Vec<std::string::String>,

        /// Optional. When disable_high_latency_features_sync_delivery is true and
        /// using the AnalyzeContent API, we will not deliver the responses from high
        /// latency features in the API response. The
        /// human_agent_assistant_config.notification_config must be configured and
        /// enable_event_based_suggestion must be set to true to receive the
        /// responses from high latency features in Pub/Sub. High latency feature(s):
        /// KNOWLEDGE_ASSIST
        pub disable_high_latency_features_sync_delivery: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl SuggestionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [feature_configs][crate::model::human_agent_assistant_config::SuggestionConfig::feature_configs].
        pub fn set_feature_configs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::human_agent_assistant_config::SuggestionFeatureConfig,
                >,
        {
            use std::iter::Iterator;
            self.feature_configs = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [group_suggestion_responses][crate::model::human_agent_assistant_config::SuggestionConfig::group_suggestion_responses].
        pub fn set_group_suggestion_responses<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.group_suggestion_responses = v.into();
            self
        }

        /// Sets the value of [generators][crate::model::human_agent_assistant_config::SuggestionConfig::generators].
        pub fn set_generators<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.generators = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [disable_high_latency_features_sync_delivery][crate::model::human_agent_assistant_config::SuggestionConfig::disable_high_latency_features_sync_delivery].
        pub fn set_disable_high_latency_features_sync_delivery<T: std::convert::Into<bool>>(
            mut self,
            v: T,
        ) -> Self {
            self.disable_high_latency_features_sync_delivery = v.into();
            self
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl wkt::message::Message for SuggestionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionConfig"
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SuggestionConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __feature_configs,
                __group_suggestion_responses,
                __generators,
                __disable_high_latency_features_sync_delivery,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SuggestionConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "featureConfigs" => Ok(__FieldTag::__feature_configs),
                                "feature_configs" => Ok(__FieldTag::__feature_configs),
                                "groupSuggestionResponses" => {
                                    Ok(__FieldTag::__group_suggestion_responses)
                                }
                                "group_suggestion_responses" => {
                                    Ok(__FieldTag::__group_suggestion_responses)
                                }
                                "generators" => Ok(__FieldTag::__generators),
                                "disableHighLatencyFeaturesSyncDelivery" => {
                                    Ok(__FieldTag::__disable_high_latency_features_sync_delivery)
                                }
                                "disable_high_latency_features_sync_delivery" => {
                                    Ok(__FieldTag::__disable_high_latency_features_sync_delivery)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SuggestionConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SuggestionConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__feature_configs => {
                                if !fields.insert(__FieldTag::__feature_configs) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for feature_configs",
                                    ));
                                }
                                result.feature_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::human_agent_assistant_config::SuggestionFeatureConfig>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__group_suggestion_responses => {
                                if !fields.insert(__FieldTag::__group_suggestion_responses) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for group_suggestion_responses",
                                    ));
                                }
                                result.group_suggestion_responses = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__generators => {
                                if !fields.insert(__FieldTag::__generators) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for generators",
                                    ));
                                }
                                result.generators = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__disable_high_latency_features_sync_delivery => {
                                if !fields.insert(
                                    __FieldTag::__disable_high_latency_features_sync_delivery,
                                ) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for disable_high_latency_features_sync_delivery",
                                    ));
                                }
                                result.disable_high_latency_features_sync_delivery = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[doc(hidden)]
    impl serde::ser::Serialize for SuggestionConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.feature_configs.is_empty() {
                state.serialize_entry("featureConfigs", &self.feature_configs)?;
            }
            if !wkt::internal::is_default(&self.group_suggestion_responses) {
                state.serialize_entry(
                    "groupSuggestionResponses",
                    &self.group_suggestion_responses,
                )?;
            }
            if !self.generators.is_empty() {
                state.serialize_entry("generators", &self.generators)?;
            }
            if !wkt::internal::is_default(&self.disable_high_latency_features_sync_delivery) {
                state.serialize_entry(
                    "disableHighLatencyFeaturesSyncDelivery",
                    &self.disable_high_latency_features_sync_delivery,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Config for suggestion query.
    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SuggestionQueryConfig {

        /// Maximum number of results to return. Currently, if unset, defaults to 10.
        /// And the max number is 20.
        pub max_results: i32,

        /// Confidence threshold of query result.
        ///
        /// Agent Assist gives each suggestion a score in the range [0.0, 1.0], based
        /// on the relevance between the suggestion and the current conversation
        /// context. A score of 0.0 has no relevance, while a score of 1.0 has high
        /// relevance. Only suggestions with a score greater than or equal to the
        /// value of this field are included in the results.
        ///
        /// For a baseline model (the default), the recommended value is in the range
        /// [0.05, 0.1].
        ///
        /// For a custom model, there is no recommended value. Tune this value by
        /// starting from a very low value and slowly increasing until you have
        /// desired results.
        ///
        /// If this field is not set, it defaults to 0.0, which means that all
        /// suggestions are returned.
        ///
        /// Supported features: ARTICLE_SUGGESTION, FAQ, SMART_REPLY, SMART_COMPOSE,
        /// KNOWLEDGE_SEARCH, KNOWLEDGE_ASSIST, ENTITY_EXTRACTION.
        pub confidence_threshold: f32,

        /// Determines how recent conversation context is filtered when generating
        /// suggestions. If unspecified, no messages will be dropped.
        pub context_filter_settings: std::option::Option<crate::model::human_agent_assistant_config::suggestion_query_config::ContextFilterSettings>,

        /// Optional. The customized sections chosen to return when requesting a
        /// summary of a conversation.
        pub sections: std::option::Option<crate::model::human_agent_assistant_config::suggestion_query_config::Sections>,

        /// Optional. The number of recent messages to include in the context.
        /// Supported features: KNOWLEDGE_ASSIST.
        pub context_size: i32,

        /// Source of query.
        pub query_source: std::option::Option<crate::model::human_agent_assistant_config::suggestion_query_config::QuerySource>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl SuggestionQueryConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_results][crate::model::human_agent_assistant_config::SuggestionQueryConfig::max_results].
        pub fn set_max_results<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_results = v.into();
            self
        }

        /// Sets the value of [confidence_threshold][crate::model::human_agent_assistant_config::SuggestionQueryConfig::confidence_threshold].
        pub fn set_confidence_threshold<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.confidence_threshold = v.into();
            self
        }

        /// Sets the value of [context_filter_settings][crate::model::human_agent_assistant_config::SuggestionQueryConfig::context_filter_settings].
        pub fn set_context_filter_settings<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::human_agent_assistant_config::suggestion_query_config::ContextFilterSettings>
        {
            self.context_filter_settings = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [context_filter_settings][crate::model::human_agent_assistant_config::SuggestionQueryConfig::context_filter_settings].
        pub fn set_or_clear_context_filter_settings<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::human_agent_assistant_config::suggestion_query_config::ContextFilterSettings>
        {
            self.context_filter_settings = v.map(|x| x.into());
            self
        }

        /// Sets the value of [sections][crate::model::human_agent_assistant_config::SuggestionQueryConfig::sections].
        pub fn set_sections<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::human_agent_assistant_config::suggestion_query_config::Sections,
                >,
        {
            self.sections = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [sections][crate::model::human_agent_assistant_config::SuggestionQueryConfig::sections].
        pub fn set_or_clear_sections<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::human_agent_assistant_config::suggestion_query_config::Sections,
                >,
        {
            self.sections = v.map(|x| x.into());
            self
        }

        /// Sets the value of [context_size][crate::model::human_agent_assistant_config::SuggestionQueryConfig::context_size].
        pub fn set_context_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.context_size = v.into();
            self
        }

        /// Sets the value of [query_source][crate::model::human_agent_assistant_config::SuggestionQueryConfig::query_source].
        ///
        /// Note that all the setters affecting `query_source` are mutually
        /// exclusive.
        pub fn set_query_source<T: std::convert::Into<std::option::Option<crate::model::human_agent_assistant_config::suggestion_query_config::QuerySource>>>(mut self, v: T) -> Self
        {
            self.query_source = v.into();
            self
        }

        /// The value of [query_source][crate::model::human_agent_assistant_config::SuggestionQueryConfig::query_source]
        /// if it holds a `KnowledgeBaseQuerySource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn knowledge_base_query_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::human_agent_assistant_config::suggestion_query_config::KnowledgeBaseQuerySource>>{
            #[allow(unreachable_patterns)]
            self.query_source.as_ref().and_then(|v| match v {
                crate::model::human_agent_assistant_config::suggestion_query_config::QuerySource::KnowledgeBaseQuerySource(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [query_source][crate::model::human_agent_assistant_config::SuggestionQueryConfig::query_source]
        /// to hold a `KnowledgeBaseQuerySource`.
        ///
        /// Note that all the setters affecting `query_source` are
        /// mutually exclusive.
        pub fn set_knowledge_base_query_source<T: std::convert::Into<std::boxed::Box<crate::model::human_agent_assistant_config::suggestion_query_config::KnowledgeBaseQuerySource>>>(mut self, v: T) -> Self{
            self.query_source = std::option::Option::Some(
                crate::model::human_agent_assistant_config::suggestion_query_config::QuerySource::KnowledgeBaseQuerySource(
                    v.into()
                )
            );
            self
        }

        /// The value of [query_source][crate::model::human_agent_assistant_config::SuggestionQueryConfig::query_source]
        /// if it holds a `DocumentQuerySource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn document_query_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::human_agent_assistant_config::suggestion_query_config::DocumentQuerySource>>{
            #[allow(unreachable_patterns)]
            self.query_source.as_ref().and_then(|v| match v {
                crate::model::human_agent_assistant_config::suggestion_query_config::QuerySource::DocumentQuerySource(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [query_source][crate::model::human_agent_assistant_config::SuggestionQueryConfig::query_source]
        /// to hold a `DocumentQuerySource`.
        ///
        /// Note that all the setters affecting `query_source` are
        /// mutually exclusive.
        pub fn set_document_query_source<T: std::convert::Into<std::boxed::Box<crate::model::human_agent_assistant_config::suggestion_query_config::DocumentQuerySource>>>(mut self, v: T) -> Self{
            self.query_source = std::option::Option::Some(
                crate::model::human_agent_assistant_config::suggestion_query_config::QuerySource::DocumentQuerySource(
                    v.into()
                )
            );
            self
        }

        /// The value of [query_source][crate::model::human_agent_assistant_config::SuggestionQueryConfig::query_source]
        /// if it holds a `DialogflowQuerySource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn dialogflow_query_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::human_agent_assistant_config::suggestion_query_config::DialogflowQuerySource>>{
            #[allow(unreachable_patterns)]
            self.query_source.as_ref().and_then(|v| match v {
                crate::model::human_agent_assistant_config::suggestion_query_config::QuerySource::DialogflowQuerySource(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [query_source][crate::model::human_agent_assistant_config::SuggestionQueryConfig::query_source]
        /// to hold a `DialogflowQuerySource`.
        ///
        /// Note that all the setters affecting `query_source` are
        /// mutually exclusive.
        pub fn set_dialogflow_query_source<T: std::convert::Into<std::boxed::Box<crate::model::human_agent_assistant_config::suggestion_query_config::DialogflowQuerySource>>>(mut self, v: T) -> Self{
            self.query_source = std::option::Option::Some(
                crate::model::human_agent_assistant_config::suggestion_query_config::QuerySource::DialogflowQuerySource(
                    v.into()
                )
            );
            self
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl wkt::message::Message for SuggestionQueryConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionQueryConfig"
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SuggestionQueryConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __knowledge_base_query_source,
                __document_query_source,
                __dialogflow_query_source,
                __max_results,
                __confidence_threshold,
                __context_filter_settings,
                __sections,
                __context_size,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SuggestionQueryConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "knowledgeBaseQuerySource" => {
                                    Ok(__FieldTag::__knowledge_base_query_source)
                                }
                                "knowledge_base_query_source" => {
                                    Ok(__FieldTag::__knowledge_base_query_source)
                                }
                                "documentQuerySource" => Ok(__FieldTag::__document_query_source),
                                "document_query_source" => Ok(__FieldTag::__document_query_source),
                                "dialogflowQuerySource" => {
                                    Ok(__FieldTag::__dialogflow_query_source)
                                }
                                "dialogflow_query_source" => {
                                    Ok(__FieldTag::__dialogflow_query_source)
                                }
                                "maxResults" => Ok(__FieldTag::__max_results),
                                "max_results" => Ok(__FieldTag::__max_results),
                                "confidenceThreshold" => Ok(__FieldTag::__confidence_threshold),
                                "confidence_threshold" => Ok(__FieldTag::__confidence_threshold),
                                "contextFilterSettings" => {
                                    Ok(__FieldTag::__context_filter_settings)
                                }
                                "context_filter_settings" => {
                                    Ok(__FieldTag::__context_filter_settings)
                                }
                                "sections" => Ok(__FieldTag::__sections),
                                "contextSize" => Ok(__FieldTag::__context_size),
                                "context_size" => Ok(__FieldTag::__context_size),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SuggestionQueryConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SuggestionQueryConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__knowledge_base_query_source => {
                                if !fields.insert(__FieldTag::__knowledge_base_query_source) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for knowledge_base_query_source",
                                    ));
                                }
                                if result.query_source.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `query_source`, a oneof with full ID .google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionQueryConfig.knowledge_base_query_source, latest field was knowledgeBaseQuerySource",
                                    ));
                                }
                                result.query_source = std::option::Option::Some(
                                    crate::model::human_agent_assistant_config::suggestion_query_config::QuerySource::KnowledgeBaseQuerySource(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::human_agent_assistant_config::suggestion_query_config::KnowledgeBaseQuerySource>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__document_query_source => {
                                if !fields.insert(__FieldTag::__document_query_source) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for document_query_source",
                                    ));
                                }
                                if result.query_source.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `query_source`, a oneof with full ID .google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionQueryConfig.document_query_source, latest field was documentQuerySource",
                                    ));
                                }
                                result.query_source = std::option::Option::Some(
                                    crate::model::human_agent_assistant_config::suggestion_query_config::QuerySource::DocumentQuerySource(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::human_agent_assistant_config::suggestion_query_config::DocumentQuerySource>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__dialogflow_query_source => {
                                if !fields.insert(__FieldTag::__dialogflow_query_source) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dialogflow_query_source",
                                    ));
                                }
                                if result.query_source.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `query_source`, a oneof with full ID .google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionQueryConfig.dialogflow_query_source, latest field was dialogflowQuerySource",
                                    ));
                                }
                                result.query_source = std::option::Option::Some(
                                    crate::model::human_agent_assistant_config::suggestion_query_config::QuerySource::DialogflowQuerySource(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::human_agent_assistant_config::suggestion_query_config::DialogflowQuerySource>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__max_results => {
                                if !fields.insert(__FieldTag::__max_results) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_results",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_results =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__confidence_threshold => {
                                if !fields.insert(__FieldTag::__confidence_threshold) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for confidence_threshold",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.confidence_threshold =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__context_filter_settings => {
                                if !fields.insert(__FieldTag::__context_filter_settings) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for context_filter_settings",
                                    ));
                                }
                                result.context_filter_settings = map.next_value::<std::option::Option<crate::model::human_agent_assistant_config::suggestion_query_config::ContextFilterSettings>>()?
                                    ;
                            }
                            __FieldTag::__sections => {
                                if !fields.insert(__FieldTag::__sections) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sections",
                                    ));
                                }
                                result.sections = map.next_value::<std::option::Option<crate::model::human_agent_assistant_config::suggestion_query_config::Sections>>()?
                                    ;
                            }
                            __FieldTag::__context_size => {
                                if !fields.insert(__FieldTag::__context_size) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for context_size",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.context_size =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[doc(hidden)]
    impl serde::ser::Serialize for SuggestionQueryConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.knowledge_base_query_source() {
                state.serialize_entry("knowledgeBaseQuerySource", value)?;
            }
            if let Some(value) = self.document_query_source() {
                state.serialize_entry("documentQuerySource", value)?;
            }
            if let Some(value) = self.dialogflow_query_source() {
                state.serialize_entry("dialogflowQuerySource", value)?;
            }
            if !wkt::internal::is_default(&self.max_results) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("maxResults", &__With(&self.max_results))?;
            }
            if !wkt::internal::is_default(&self.confidence_threshold) {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state
                    .serialize_entry("confidenceThreshold", &__With(&self.confidence_threshold))?;
            }
            if self.context_filter_settings.is_some() {
                state.serialize_entry("contextFilterSettings", &self.context_filter_settings)?;
            }
            if self.sections.is_some() {
                state.serialize_entry("sections", &self.sections)?;
            }
            if !wkt::internal::is_default(&self.context_size) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("contextSize", &__With(&self.context_size))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [SuggestionQueryConfig].
    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    pub mod suggestion_query_config {
        #[allow(unused_imports)]
        use super::*;

        /// Knowledge base source settings.
        ///
        /// Supported features: ARTICLE_SUGGESTION, FAQ.
        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct KnowledgeBaseQuerySource {
            /// Required. Knowledge bases to query. Format:
            /// `projects/<Project ID>/locations/<Location
            /// ID>/knowledgeBases/<Knowledge Base ID>`. Currently, at most 5 knowledge
            /// bases are supported.
            pub knowledge_bases: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        impl KnowledgeBaseQuerySource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [knowledge_bases][crate::model::human_agent_assistant_config::suggestion_query_config::KnowledgeBaseQuerySource::knowledge_bases].
            pub fn set_knowledge_bases<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.knowledge_bases = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        impl wkt::message::Message for KnowledgeBaseQuerySource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionQueryConfig.KnowledgeBaseQuerySource"
            }
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for KnowledgeBaseQuerySource {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __knowledge_bases,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for KnowledgeBaseQuerySource")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "knowledgeBases" => Ok(__FieldTag::__knowledge_bases),
                                    "knowledge_bases" => Ok(__FieldTag::__knowledge_bases),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = KnowledgeBaseQuerySource;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct KnowledgeBaseQuerySource")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__knowledge_bases => {
                                    if !fields.insert(__FieldTag::__knowledge_bases) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for knowledge_bases",
                                            ),
                                        );
                                    }
                                    result.knowledge_bases = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        #[doc(hidden)]
        impl serde::ser::Serialize for KnowledgeBaseQuerySource {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.knowledge_bases.is_empty() {
                    state.serialize_entry("knowledgeBases", &self.knowledge_bases)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Document source settings.
        ///
        /// Supported features: SMART_REPLY, SMART_COMPOSE.
        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct DocumentQuerySource {
            /// Required. Knowledge documents to query from. Format:
            /// `projects/<Project ID>/locations/<Location
            /// ID>/knowledgeBases/<KnowledgeBase ID>/documents/<Document ID>`.
            /// Currently, at most 5 documents are supported.
            pub documents: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        impl DocumentQuerySource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [documents][crate::model::human_agent_assistant_config::suggestion_query_config::DocumentQuerySource::documents].
            pub fn set_documents<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.documents = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        impl wkt::message::Message for DocumentQuerySource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionQueryConfig.DocumentQuerySource"
            }
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for DocumentQuerySource {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __documents,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for DocumentQuerySource")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "documents" => Ok(__FieldTag::__documents),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = DocumentQuerySource;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct DocumentQuerySource")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__documents => {
                                    if !fields.insert(__FieldTag::__documents) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for documents",
                                            ),
                                        );
                                    }
                                    result.documents = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        #[doc(hidden)]
        impl serde::ser::Serialize for DocumentQuerySource {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.documents.is_empty() {
                    state.serialize_entry("documents", &self.documents)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Dialogflow source setting.
        ///
        /// Supported feature: DIALOGFLOW_ASSIST.
        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct DialogflowQuerySource {

            /// Required. The name of a Dialogflow virtual agent used for end user side
            /// intent detection and suggestion. Format: `projects/<Project
            /// ID>/locations/<Location ID>/agent`. When multiple agents are allowed in
            /// the same Dialogflow project.
            pub agent: std::string::String,

            /// Optional. The Dialogflow assist configuration for human agent.
            pub human_agent_side_config: std::option::Option<crate::model::human_agent_assistant_config::suggestion_query_config::dialogflow_query_source::HumanAgentSideConfig>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        impl DialogflowQuerySource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [agent][crate::model::human_agent_assistant_config::suggestion_query_config::DialogflowQuerySource::agent].
            pub fn set_agent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.agent = v.into();
                self
            }

            /// Sets the value of [human_agent_side_config][crate::model::human_agent_assistant_config::suggestion_query_config::DialogflowQuerySource::human_agent_side_config].
            pub fn set_human_agent_side_config<T>(mut self, v: T) -> Self
            where T: std::convert::Into<crate::model::human_agent_assistant_config::suggestion_query_config::dialogflow_query_source::HumanAgentSideConfig>
            {
                self.human_agent_side_config = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [human_agent_side_config][crate::model::human_agent_assistant_config::suggestion_query_config::DialogflowQuerySource::human_agent_side_config].
            pub fn set_or_clear_human_agent_side_config<T>(mut self, v: std::option::Option<T>) -> Self
            where T: std::convert::Into<crate::model::human_agent_assistant_config::suggestion_query_config::dialogflow_query_source::HumanAgentSideConfig>
            {
                self.human_agent_side_config = v.map(|x| x.into());
                self
            }
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        impl wkt::message::Message for DialogflowQuerySource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionQueryConfig.DialogflowQuerySource"
            }
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for DialogflowQuerySource {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __agent,
                    __human_agent_side_config,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for DialogflowQuerySource")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "agent" => Ok(__FieldTag::__agent),
                                    "humanAgentSideConfig" => {
                                        Ok(__FieldTag::__human_agent_side_config)
                                    }
                                    "human_agent_side_config" => {
                                        Ok(__FieldTag::__human_agent_side_config)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = DialogflowQuerySource;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct DialogflowQuerySource")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__agent => {
                                    if !fields.insert(__FieldTag::__agent) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for agent"),
                                        );
                                    }
                                    result.agent = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__human_agent_side_config => {
                                    if !fields.insert(__FieldTag::__human_agent_side_config) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for human_agent_side_config",
                                            ),
                                        );
                                    }
                                    result.human_agent_side_config = map.next_value::<std::option::Option<crate::model::human_agent_assistant_config::suggestion_query_config::dialogflow_query_source::HumanAgentSideConfig>>()?
                                        ;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        #[doc(hidden)]
        impl serde::ser::Serialize for DialogflowQuerySource {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.agent.is_empty() {
                    state.serialize_entry("agent", &self.agent)?;
                }
                if self.human_agent_side_config.is_some() {
                    state.serialize_entry("humanAgentSideConfig", &self.human_agent_side_config)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [DialogflowQuerySource].
        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        pub mod dialogflow_query_source {
            #[allow(unused_imports)]
            use super::*;

            /// The configuration used for human agent side Dialogflow assist
            /// suggestion.
            #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct HumanAgentSideConfig {
                /// Optional. The name of a dialogflow virtual agent used for intent
                /// detection and suggestion triggered by human agent.
                /// Format: `projects/<Project ID>/locations/<Location ID>/agent`.
                pub agent: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
            impl HumanAgentSideConfig {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [agent][crate::model::human_agent_assistant_config::suggestion_query_config::dialogflow_query_source::HumanAgentSideConfig::agent].
                pub fn set_agent<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.agent = v.into();
                    self
                }
            }

            #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
            impl wkt::message::Message for HumanAgentSideConfig {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionQueryConfig.DialogflowQuerySource.HumanAgentSideConfig"
                }
            }

            #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for HumanAgentSideConfig {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __agent,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for HumanAgentSideConfig")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "agent" => Ok(__FieldTag::__agent),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = HumanAgentSideConfig;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct HumanAgentSideConfig")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__agent => {
                                        if !fields.insert(__FieldTag::__agent) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for agent",
                                                ),
                                            );
                                        }
                                        result.agent = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
            #[doc(hidden)]
            impl serde::ser::Serialize for HumanAgentSideConfig {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.agent.is_empty() {
                        state.serialize_entry("agent", &self.agent)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }
        }

        /// Settings that determine how to filter recent conversation context when
        /// generating suggestions.
        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ContextFilterSettings {
            /// If set to true, the last message from virtual agent (hand off message)
            /// and the message before it (trigger message of hand off) are dropped.
            pub drop_handoff_messages: bool,

            /// If set to true, all messages from virtual agent are dropped.
            pub drop_virtual_agent_messages: bool,

            /// If set to true, all messages from ivr stage are dropped.
            pub drop_ivr_messages: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        impl ContextFilterSettings {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [drop_handoff_messages][crate::model::human_agent_assistant_config::suggestion_query_config::ContextFilterSettings::drop_handoff_messages].
            pub fn set_drop_handoff_messages<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.drop_handoff_messages = v.into();
                self
            }

            /// Sets the value of [drop_virtual_agent_messages][crate::model::human_agent_assistant_config::suggestion_query_config::ContextFilterSettings::drop_virtual_agent_messages].
            pub fn set_drop_virtual_agent_messages<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.drop_virtual_agent_messages = v.into();
                self
            }

            /// Sets the value of [drop_ivr_messages][crate::model::human_agent_assistant_config::suggestion_query_config::ContextFilterSettings::drop_ivr_messages].
            pub fn set_drop_ivr_messages<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.drop_ivr_messages = v.into();
                self
            }
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        impl wkt::message::Message for ContextFilterSettings {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionQueryConfig.ContextFilterSettings"
            }
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ContextFilterSettings {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __drop_handoff_messages,
                    __drop_virtual_agent_messages,
                    __drop_ivr_messages,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ContextFilterSettings")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "dropHandoffMessages" => {
                                        Ok(__FieldTag::__drop_handoff_messages)
                                    }
                                    "drop_handoff_messages" => {
                                        Ok(__FieldTag::__drop_handoff_messages)
                                    }
                                    "dropVirtualAgentMessages" => {
                                        Ok(__FieldTag::__drop_virtual_agent_messages)
                                    }
                                    "drop_virtual_agent_messages" => {
                                        Ok(__FieldTag::__drop_virtual_agent_messages)
                                    }
                                    "dropIvrMessages" => Ok(__FieldTag::__drop_ivr_messages),
                                    "drop_ivr_messages" => Ok(__FieldTag::__drop_ivr_messages),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ContextFilterSettings;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ContextFilterSettings")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__drop_handoff_messages => {
                                    if !fields.insert(__FieldTag::__drop_handoff_messages) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for drop_handoff_messages",
                                            ),
                                        );
                                    }
                                    result.drop_handoff_messages = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__drop_virtual_agent_messages => {
                                    if !fields.insert(__FieldTag::__drop_virtual_agent_messages) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for drop_virtual_agent_messages",
                                            ),
                                        );
                                    }
                                    result.drop_virtual_agent_messages = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__drop_ivr_messages => {
                                    if !fields.insert(__FieldTag::__drop_ivr_messages) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for drop_ivr_messages",
                                            ),
                                        );
                                    }
                                    result.drop_ivr_messages = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        #[doc(hidden)]
        impl serde::ser::Serialize for ContextFilterSettings {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.drop_handoff_messages) {
                    state.serialize_entry("dropHandoffMessages", &self.drop_handoff_messages)?;
                }
                if !wkt::internal::is_default(&self.drop_virtual_agent_messages) {
                    state.serialize_entry(
                        "dropVirtualAgentMessages",
                        &self.drop_virtual_agent_messages,
                    )?;
                }
                if !wkt::internal::is_default(&self.drop_ivr_messages) {
                    state.serialize_entry("dropIvrMessages", &self.drop_ivr_messages)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Custom sections to return when requesting a summary of a conversation.
        /// This is only supported when `baseline_model_version` == '2.0'.
        ///
        /// Supported features: CONVERSATION_SUMMARIZATION,
        /// CONVERSATION_SUMMARIZATION_VOICE.
        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Sections {

            /// The selected sections chosen to return when requesting a summary of a
            /// conversation. A duplicate selected section will be treated as a single
            /// selected section. If section types are not provided, the default will
            /// be {SITUATION, ACTION, RESULT}.
            pub section_types: std::vec::Vec<crate::model::human_agent_assistant_config::suggestion_query_config::sections::SectionType>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        impl Sections {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [section_types][crate::model::human_agent_assistant_config::suggestion_query_config::Sections::section_types].
            pub fn set_section_types<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::human_agent_assistant_config::suggestion_query_config::sections::SectionType>
            {
                use std::iter::Iterator;
                self.section_types = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        impl wkt::message::Message for Sections {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionQueryConfig.Sections"
            }
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Sections {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __section_types,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Sections")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "sectionTypes" => Ok(__FieldTag::__section_types),
                                    "section_types" => Ok(__FieldTag::__section_types),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Sections;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Sections")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__section_types => {
                                    if !fields.insert(__FieldTag::__section_types) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for section_types",
                                            ),
                                        );
                                    }
                                    result.section_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::human_agent_assistant_config::suggestion_query_config::sections::SectionType>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        #[doc(hidden)]
        impl serde::ser::Serialize for Sections {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.section_types.is_empty() {
                    state.serialize_entry("sectionTypes", &self.section_types)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [Sections].
        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        pub mod sections {
            #[allow(unused_imports)]
            use super::*;

            /// Selectable sections to return when requesting a summary of a
            /// conversation.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum SectionType {
                /// Undefined section type, does not return anything.
                Unspecified,
                /// What the customer needs help with or has question about.
                /// Section name: "situation".
                Situation,
                /// What the agent does to help the customer.
                /// Section name: "action".
                Action,
                /// Result of the customer service. A single word describing the result
                /// of the conversation.
                /// Section name: "resolution".
                Resolution,
                /// Reason for cancellation if the customer requests for a cancellation.
                /// "N/A" otherwise.
                /// Section name: "reason_for_cancellation".
                ReasonForCancellation,
                /// "Unsatisfied" or "Satisfied" depending on the customer's feelings at
                /// the end of the conversation.
                /// Section name: "customer_satisfaction".
                CustomerSatisfaction,
                /// Key entities extracted from the conversation, such as ticket number,
                /// order number, dollar amount, etc.
                /// Section names are prefixed by "entities/".
                Entities,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [SectionType::value] or
                /// [SectionType::name].
                UnknownValue(section_type::UnknownValue),
            }

            #[doc(hidden)]
            #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
            pub mod section_type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
            impl SectionType {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Situation => std::option::Option::Some(1),
                        Self::Action => std::option::Option::Some(2),
                        Self::Resolution => std::option::Option::Some(3),
                        Self::ReasonForCancellation => std::option::Option::Some(4),
                        Self::CustomerSatisfaction => std::option::Option::Some(5),
                        Self::Entities => std::option::Option::Some(6),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("SECTION_TYPE_UNSPECIFIED"),
                        Self::Situation => std::option::Option::Some("SITUATION"),
                        Self::Action => std::option::Option::Some("ACTION"),
                        Self::Resolution => std::option::Option::Some("RESOLUTION"),
                        Self::ReasonForCancellation => {
                            std::option::Option::Some("REASON_FOR_CANCELLATION")
                        }
                        Self::CustomerSatisfaction => {
                            std::option::Option::Some("CUSTOMER_SATISFACTION")
                        }
                        Self::Entities => std::option::Option::Some("ENTITIES"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
            impl std::default::Default for SectionType {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
            impl std::fmt::Display for SectionType {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
            impl std::convert::From<i32> for SectionType {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Situation,
                        2 => Self::Action,
                        3 => Self::Resolution,
                        4 => Self::ReasonForCancellation,
                        5 => Self::CustomerSatisfaction,
                        6 => Self::Entities,
                        _ => Self::UnknownValue(section_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
            impl std::convert::From<&str> for SectionType {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "SECTION_TYPE_UNSPECIFIED" => Self::Unspecified,
                        "SITUATION" => Self::Situation,
                        "ACTION" => Self::Action,
                        "RESOLUTION" => Self::Resolution,
                        "REASON_FOR_CANCELLATION" => Self::ReasonForCancellation,
                        "CUSTOMER_SATISFACTION" => Self::CustomerSatisfaction,
                        "ENTITIES" => Self::Entities,
                        _ => Self::UnknownValue(section_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
            impl serde::ser::Serialize for SectionType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Situation => serializer.serialize_i32(1),
                        Self::Action => serializer.serialize_i32(2),
                        Self::Resolution => serializer.serialize_i32(3),
                        Self::ReasonForCancellation => serializer.serialize_i32(4),
                        Self::CustomerSatisfaction => serializer.serialize_i32(5),
                        Self::Entities => serializer.serialize_i32(6),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
            impl<'de> serde::de::Deserialize<'de> for SectionType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<SectionType>::new(
                        ".google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionQueryConfig.Sections.SectionType"))
                }
            }
        }

        /// Source of query.
        #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum QuerySource {
            /// Query from knowledgebase. It is used by:
            /// ARTICLE_SUGGESTION, FAQ.
            KnowledgeBaseQuerySource(std::boxed::Box<crate::model::human_agent_assistant_config::suggestion_query_config::KnowledgeBaseQuerySource>),
            /// Query from knowledge base document. It is used by:
            /// SMART_REPLY, SMART_COMPOSE.
            DocumentQuerySource(std::boxed::Box<crate::model::human_agent_assistant_config::suggestion_query_config::DocumentQuerySource>),
            /// Query from Dialogflow agent. It is used by DIALOGFLOW_ASSIST.
            DialogflowQuerySource(std::boxed::Box<crate::model::human_agent_assistant_config::suggestion_query_config::DialogflowQuerySource>),
        }
    }

    /// Custom conversation models used in agent assist feature.
    ///
    /// Supported feature: ARTICLE_SUGGESTION, SMART_COMPOSE, SMART_REPLY,
    /// CONVERSATION_SUMMARIZATION.
    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConversationModelConfig {
        /// Conversation model resource name. Format: `projects/<Project
        /// ID>/conversationModels/<Model ID>`.
        pub model: std::string::String,

        /// Version of current baseline model. It will be ignored if
        /// [model][google.cloud.dialogflow.v2.HumanAgentAssistantConfig.ConversationModelConfig.model]
        /// is set. Valid versions are:
        ///
        /// - Article Suggestion baseline model:
        ///   - 0.9
        ///   - 1.0 (default)
        /// - Summarization baseline model:
        ///   - 1.0
        ///
        /// [google.cloud.dialogflow.v2.HumanAgentAssistantConfig.ConversationModelConfig.model]: crate::model::human_agent_assistant_config::ConversationModelConfig::model
        pub baseline_model_version: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl ConversationModelConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [model][crate::model::human_agent_assistant_config::ConversationModelConfig::model].
        pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.model = v.into();
            self
        }

        /// Sets the value of [baseline_model_version][crate::model::human_agent_assistant_config::ConversationModelConfig::baseline_model_version].
        pub fn set_baseline_model_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.baseline_model_version = v.into();
            self
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl wkt::message::Message for ConversationModelConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.HumanAgentAssistantConfig.ConversationModelConfig"
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConversationModelConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __model,
                __baseline_model_version,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConversationModelConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "model" => Ok(__FieldTag::__model),
                                "baselineModelVersion" => Ok(__FieldTag::__baseline_model_version),
                                "baseline_model_version" => {
                                    Ok(__FieldTag::__baseline_model_version)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConversationModelConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConversationModelConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__model => {
                                if !fields.insert(__FieldTag::__model) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for model",
                                    ));
                                }
                                result.model = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__baseline_model_version => {
                                if !fields.insert(__FieldTag::__baseline_model_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for baseline_model_version",
                                    ));
                                }
                                result.baseline_model_version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[doc(hidden)]
    impl serde::ser::Serialize for ConversationModelConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.model.is_empty() {
                state.serialize_entry("model", &self.model)?;
            }
            if !self.baseline_model_version.is_empty() {
                state.serialize_entry("baselineModelVersion", &self.baseline_model_version)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Config to process conversation.
    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConversationProcessConfig {
        /// Number of recent non-small-talk sentences to use as context for article
        /// and FAQ suggestion
        pub recent_sentences_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl ConversationProcessConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [recent_sentences_count][crate::model::human_agent_assistant_config::ConversationProcessConfig::recent_sentences_count].
        pub fn set_recent_sentences_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.recent_sentences_count = v.into();
            self
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl wkt::message::Message for ConversationProcessConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.HumanAgentAssistantConfig.ConversationProcessConfig"
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConversationProcessConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __recent_sentences_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConversationProcessConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "recentSentencesCount" => Ok(__FieldTag::__recent_sentences_count),
                                "recent_sentences_count" => {
                                    Ok(__FieldTag::__recent_sentences_count)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConversationProcessConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConversationProcessConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__recent_sentences_count => {
                                if !fields.insert(__FieldTag::__recent_sentences_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for recent_sentences_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.recent_sentences_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[doc(hidden)]
    impl serde::ser::Serialize for ConversationProcessConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.recent_sentences_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "recentSentencesCount",
                    &__With(&self.recent_sentences_count),
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Configuration for analyses to run on each conversation message.
    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MessageAnalysisConfig {
        /// Enable entity extraction in conversation messages on [agent assist
        /// stage](https://cloud.google.com/dialogflow/priv/docs/contact-center/basics#stages).
        /// If unspecified, defaults to false.
        ///
        /// Currently, this feature is not general available, please contact Google
        /// to get access.
        pub enable_entity_extraction: bool,

        /// Enable sentiment analysis in conversation messages on [agent assist
        /// stage](https://cloud.google.com/dialogflow/priv/docs/contact-center/basics#stages).
        /// If unspecified, defaults to false. Sentiment analysis inspects user input
        /// and identifies the prevailing subjective opinion, especially to determine
        /// a user's attitude as positive, negative, or neutral:
        /// <https://cloud.google.com/natural-language/docs/basics#sentiment_analysis>
        /// For
        /// [Participants.StreamingAnalyzeContent][google.cloud.dialogflow.v2.Participants.StreamingAnalyzeContent]
        /// method, result will be in
        /// [StreamingAnalyzeContentResponse.message.SentimentAnalysisResult][google.cloud.dialogflow.v2.StreamingAnalyzeContentResponse.message].
        /// For
        /// [Participants.AnalyzeContent][google.cloud.dialogflow.v2.Participants.AnalyzeContent]
        /// method, result will be in
        /// [AnalyzeContentResponse.message.SentimentAnalysisResult][google.cloud.dialogflow.v2.AnalyzeContentResponse.message]
        /// For
        /// [Conversations.ListMessages][google.cloud.dialogflow.v2.Conversations.ListMessages]
        /// method, result will be in
        /// [ListMessagesResponse.messages.SentimentAnalysisResult][google.cloud.dialogflow.v2.ListMessagesResponse.messages]
        /// If Pub/Sub notification is configured, result will be in
        /// [ConversationEvent.new_message_payload.SentimentAnalysisResult][google.cloud.dialogflow.v2.ConversationEvent.new_message_payload].
        ///
        /// [google.cloud.dialogflow.v2.AnalyzeContentResponse.message]: crate::model::AnalyzeContentResponse::message
        /// [google.cloud.dialogflow.v2.ConversationEvent.new_message_payload]: crate::model::ConversationEvent::payload
        /// [google.cloud.dialogflow.v2.Conversations.ListMessages]: crate::client::Conversations::list_messages
        /// [google.cloud.dialogflow.v2.ListMessagesResponse.messages]: crate::model::ListMessagesResponse::messages
        /// [google.cloud.dialogflow.v2.Participants.AnalyzeContent]: crate::client::Participants::analyze_content
        /// [google.cloud.dialogflow.v2.StreamingAnalyzeContentResponse.message]: crate::model::StreamingAnalyzeContentResponse::message
        pub enable_sentiment_analysis: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl MessageAnalysisConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enable_entity_extraction][crate::model::human_agent_assistant_config::MessageAnalysisConfig::enable_entity_extraction].
        pub fn set_enable_entity_extraction<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_entity_extraction = v.into();
            self
        }

        /// Sets the value of [enable_sentiment_analysis][crate::model::human_agent_assistant_config::MessageAnalysisConfig::enable_sentiment_analysis].
        pub fn set_enable_sentiment_analysis<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_sentiment_analysis = v.into();
            self
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl wkt::message::Message for MessageAnalysisConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.HumanAgentAssistantConfig.MessageAnalysisConfig"
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MessageAnalysisConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enable_entity_extraction,
                __enable_sentiment_analysis,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MessageAnalysisConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enableEntityExtraction" => {
                                    Ok(__FieldTag::__enable_entity_extraction)
                                }
                                "enable_entity_extraction" => {
                                    Ok(__FieldTag::__enable_entity_extraction)
                                }
                                "enableSentimentAnalysis" => {
                                    Ok(__FieldTag::__enable_sentiment_analysis)
                                }
                                "enable_sentiment_analysis" => {
                                    Ok(__FieldTag::__enable_sentiment_analysis)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MessageAnalysisConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MessageAnalysisConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enable_entity_extraction => {
                                if !fields.insert(__FieldTag::__enable_entity_extraction) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_entity_extraction",
                                    ));
                                }
                                result.enable_entity_extraction = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__enable_sentiment_analysis => {
                                if !fields.insert(__FieldTag::__enable_sentiment_analysis) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_sentiment_analysis",
                                    ));
                                }
                                result.enable_sentiment_analysis = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[doc(hidden)]
    impl serde::ser::Serialize for MessageAnalysisConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.enable_entity_extraction) {
                state.serialize_entry("enableEntityExtraction", &self.enable_entity_extraction)?;
            }
            if !wkt::internal::is_default(&self.enable_sentiment_analysis) {
                state
                    .serialize_entry("enableSentimentAnalysis", &self.enable_sentiment_analysis)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Defines the hand off to a live agent, typically on which external agent
/// service provider to connect to a conversation.
///
/// Currently, this feature is not general available, please contact Google
/// to get access.
#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HumanAgentHandoffConfig {
    /// Required. Specifies which agent service to connect for human agent handoff.
    pub agent_service: std::option::Option<crate::model::human_agent_handoff_config::AgentService>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
impl HumanAgentHandoffConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [agent_service][crate::model::HumanAgentHandoffConfig::agent_service].
    ///
    /// Note that all the setters affecting `agent_service` are mutually
    /// exclusive.
    pub fn set_agent_service<
        T: std::convert::Into<
                std::option::Option<crate::model::human_agent_handoff_config::AgentService>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.agent_service = v.into();
        self
    }

    /// The value of [agent_service][crate::model::HumanAgentHandoffConfig::agent_service]
    /// if it holds a `LivePersonConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn live_person_config(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::human_agent_handoff_config::LivePersonConfig>,
    > {
        #[allow(unreachable_patterns)]
        self.agent_service.as_ref().and_then(|v| match v {
            crate::model::human_agent_handoff_config::AgentService::LivePersonConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [agent_service][crate::model::HumanAgentHandoffConfig::agent_service]
    /// to hold a `LivePersonConfig`.
    ///
    /// Note that all the setters affecting `agent_service` are
    /// mutually exclusive.
    pub fn set_live_person_config<
        T: std::convert::Into<
                std::boxed::Box<crate::model::human_agent_handoff_config::LivePersonConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.agent_service = std::option::Option::Some(
            crate::model::human_agent_handoff_config::AgentService::LivePersonConfig(v.into()),
        );
        self
    }

    /// The value of [agent_service][crate::model::HumanAgentHandoffConfig::agent_service]
    /// if it holds a `SalesforceLiveAgentConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn salesforce_live_agent_config(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::human_agent_handoff_config::SalesforceLiveAgentConfig>,
    > {
        #[allow(unreachable_patterns)]
        self.agent_service.as_ref().and_then(|v| match v {
            crate::model::human_agent_handoff_config::AgentService::SalesforceLiveAgentConfig(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [agent_service][crate::model::HumanAgentHandoffConfig::agent_service]
    /// to hold a `SalesforceLiveAgentConfig`.
    ///
    /// Note that all the setters affecting `agent_service` are
    /// mutually exclusive.
    pub fn set_salesforce_live_agent_config<
        T: std::convert::Into<
                std::boxed::Box<
                    crate::model::human_agent_handoff_config::SalesforceLiveAgentConfig,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.agent_service = std::option::Option::Some(
            crate::model::human_agent_handoff_config::AgentService::SalesforceLiveAgentConfig(
                v.into(),
            ),
        );
        self
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
impl wkt::message::Message for HumanAgentHandoffConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.HumanAgentHandoffConfig"
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HumanAgentHandoffConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __live_person_config,
            __salesforce_live_agent_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HumanAgentHandoffConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "livePersonConfig" => Ok(__FieldTag::__live_person_config),
                            "live_person_config" => Ok(__FieldTag::__live_person_config),
                            "salesforceLiveAgentConfig" => {
                                Ok(__FieldTag::__salesforce_live_agent_config)
                            }
                            "salesforce_live_agent_config" => {
                                Ok(__FieldTag::__salesforce_live_agent_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HumanAgentHandoffConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HumanAgentHandoffConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__live_person_config => {
                            if !fields.insert(__FieldTag::__live_person_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for live_person_config",
                                ));
                            }
                            if result.agent_service.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent_service`, a oneof with full ID .google.cloud.dialogflow.v2.HumanAgentHandoffConfig.live_person_config, latest field was livePersonConfig",
                                ));
                            }
                            result.agent_service = std::option::Option::Some(
                                crate::model::human_agent_handoff_config::AgentService::LivePersonConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::human_agent_handoff_config::LivePersonConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__salesforce_live_agent_config => {
                            if !fields.insert(__FieldTag::__salesforce_live_agent_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for salesforce_live_agent_config",
                                ));
                            }
                            if result.agent_service.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `agent_service`, a oneof with full ID .google.cloud.dialogflow.v2.HumanAgentHandoffConfig.salesforce_live_agent_config, latest field was salesforceLiveAgentConfig",
                                ));
                            }
                            result.agent_service = std::option::Option::Some(
                                crate::model::human_agent_handoff_config::AgentService::SalesforceLiveAgentConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::human_agent_handoff_config::SalesforceLiveAgentConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for HumanAgentHandoffConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.live_person_config() {
            state.serialize_entry("livePersonConfig", value)?;
        }
        if let Some(value) = self.salesforce_live_agent_config() {
            state.serialize_entry("salesforceLiveAgentConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [HumanAgentHandoffConfig].
#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
pub mod human_agent_handoff_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration specific to [LivePerson](https://www.liveperson.com).
    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LivePersonConfig {
        /// Required. Account number of the LivePerson account to connect. This is
        /// the account number you input at the login page.
        pub account_number: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl LivePersonConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [account_number][crate::model::human_agent_handoff_config::LivePersonConfig::account_number].
        pub fn set_account_number<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.account_number = v.into();
            self
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl wkt::message::Message for LivePersonConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.HumanAgentHandoffConfig.LivePersonConfig"
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LivePersonConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __account_number,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LivePersonConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "accountNumber" => Ok(__FieldTag::__account_number),
                                "account_number" => Ok(__FieldTag::__account_number),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LivePersonConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LivePersonConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__account_number => {
                                if !fields.insert(__FieldTag::__account_number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for account_number",
                                    ));
                                }
                                result.account_number = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[doc(hidden)]
    impl serde::ser::Serialize for LivePersonConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.account_number.is_empty() {
                state.serialize_entry("accountNumber", &self.account_number)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Configuration specific to Salesforce Live Agent.
    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SalesforceLiveAgentConfig {
        /// Required. The organization ID of the Salesforce account.
        pub organization_id: std::string::String,

        /// Required. Live Agent deployment ID.
        pub deployment_id: std::string::String,

        /// Required. Live Agent chat button ID.
        pub button_id: std::string::String,

        /// Required. Domain of the Live Agent endpoint for this agent. You can find
        /// the endpoint URL in the `Live Agent settings` page. For example if URL
        /// has the form <https://d.la4-c2-phx.salesforceliveagent.com/..>.,
        /// you should fill in d.la4-c2-phx.salesforceliveagent.com.
        pub endpoint_domain: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl SalesforceLiveAgentConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [organization_id][crate::model::human_agent_handoff_config::SalesforceLiveAgentConfig::organization_id].
        pub fn set_organization_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.organization_id = v.into();
            self
        }

        /// Sets the value of [deployment_id][crate::model::human_agent_handoff_config::SalesforceLiveAgentConfig::deployment_id].
        pub fn set_deployment_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.deployment_id = v.into();
            self
        }

        /// Sets the value of [button_id][crate::model::human_agent_handoff_config::SalesforceLiveAgentConfig::button_id].
        pub fn set_button_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.button_id = v.into();
            self
        }

        /// Sets the value of [endpoint_domain][crate::model::human_agent_handoff_config::SalesforceLiveAgentConfig::endpoint_domain].
        pub fn set_endpoint_domain<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.endpoint_domain = v.into();
            self
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl wkt::message::Message for SalesforceLiveAgentConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.HumanAgentHandoffConfig.SalesforceLiveAgentConfig"
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SalesforceLiveAgentConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __organization_id,
                __deployment_id,
                __button_id,
                __endpoint_domain,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SalesforceLiveAgentConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "organizationId" => Ok(__FieldTag::__organization_id),
                                "organization_id" => Ok(__FieldTag::__organization_id),
                                "deploymentId" => Ok(__FieldTag::__deployment_id),
                                "deployment_id" => Ok(__FieldTag::__deployment_id),
                                "buttonId" => Ok(__FieldTag::__button_id),
                                "button_id" => Ok(__FieldTag::__button_id),
                                "endpointDomain" => Ok(__FieldTag::__endpoint_domain),
                                "endpoint_domain" => Ok(__FieldTag::__endpoint_domain),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SalesforceLiveAgentConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SalesforceLiveAgentConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__organization_id => {
                                if !fields.insert(__FieldTag::__organization_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for organization_id",
                                    ));
                                }
                                result.organization_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__deployment_id => {
                                if !fields.insert(__FieldTag::__deployment_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for deployment_id",
                                    ));
                                }
                                result.deployment_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__button_id => {
                                if !fields.insert(__FieldTag::__button_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for button_id",
                                    ));
                                }
                                result.button_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__endpoint_domain => {
                                if !fields.insert(__FieldTag::__endpoint_domain) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for endpoint_domain",
                                    ));
                                }
                                result.endpoint_domain = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[doc(hidden)]
    impl serde::ser::Serialize for SalesforceLiveAgentConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.organization_id.is_empty() {
                state.serialize_entry("organizationId", &self.organization_id)?;
            }
            if !self.deployment_id.is_empty() {
                state.serialize_entry("deploymentId", &self.deployment_id)?;
            }
            if !self.button_id.is_empty() {
                state.serialize_entry("buttonId", &self.button_id)?;
            }
            if !self.endpoint_domain.is_empty() {
                state.serialize_entry("endpointDomain", &self.endpoint_domain)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Required. Specifies which agent service to connect for human agent handoff.
    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AgentService {
        /// Uses [LivePerson](https://www.liveperson.com).
        LivePersonConfig(
            std::boxed::Box<crate::model::human_agent_handoff_config::LivePersonConfig>,
        ),
        /// Uses Salesforce Live Agent.
        SalesforceLiveAgentConfig(
            std::boxed::Box<crate::model::human_agent_handoff_config::SalesforceLiveAgentConfig>,
        ),
    }
}

/// Defines notification behavior.
#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NotificationConfig {
    /// Name of the Pub/Sub topic to publish conversation
    /// events like
    /// [CONVERSATION_STARTED][google.cloud.dialogflow.v2.ConversationEvent.Type.CONVERSATION_STARTED]
    /// as serialized
    /// [ConversationEvent][google.cloud.dialogflow.v2.ConversationEvent] protos.
    ///
    /// For telephony integration to receive notification, make sure either this
    /// topic is in the same project as the conversation or you grant
    /// `service-<Conversation Project
    /// Number>@gcp-sa-dialogflow.iam.gserviceaccount.com` the `Dialogflow Service
    /// Agent` role in the topic project.
    ///
    /// For chat integration to receive notification, make sure API caller has been
    /// granted the `Dialogflow Service Agent` role for the topic.
    ///
    /// Format: `projects/<Project ID>/locations/<Location ID>/topics/<Topic ID>`.
    ///
    /// [google.cloud.dialogflow.v2.ConversationEvent]: crate::model::ConversationEvent
    /// [google.cloud.dialogflow.v2.ConversationEvent.Type.CONVERSATION_STARTED]: crate::model::conversation_event::Type::ConversationStarted
    pub topic: std::string::String,

    /// Format of message.
    pub message_format: crate::model::notification_config::MessageFormat,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
impl NotificationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [topic][crate::model::NotificationConfig::topic].
    pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.topic = v.into();
        self
    }

    /// Sets the value of [message_format][crate::model::NotificationConfig::message_format].
    pub fn set_message_format<
        T: std::convert::Into<crate::model::notification_config::MessageFormat>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.message_format = v.into();
        self
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
impl wkt::message::Message for NotificationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.NotificationConfig"
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NotificationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __topic,
            __message_format,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NotificationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "topic" => Ok(__FieldTag::__topic),
                            "messageFormat" => Ok(__FieldTag::__message_format),
                            "message_format" => Ok(__FieldTag::__message_format),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NotificationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NotificationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__topic => {
                            if !fields.insert(__FieldTag::__topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topic",
                                ));
                            }
                            result.topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__message_format => {
                            if !fields.insert(__FieldTag::__message_format) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_format",
                                ));
                            }
                            result.message_format = map
                                .next_value::<std::option::Option<
                                    crate::model::notification_config::MessageFormat,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for NotificationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.topic.is_empty() {
            state.serialize_entry("topic", &self.topic)?;
        }
        if !wkt::internal::is_default(&self.message_format) {
            state.serialize_entry("messageFormat", &self.message_format)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [NotificationConfig].
#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
pub mod notification_config {
    #[allow(unused_imports)]
    use super::*;

    /// Format of cloud pub/sub message.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MessageFormat {
        /// If it is unspecified, PROTO will be used.
        Unspecified,
        /// Pub/Sub message will be serialized proto.
        Proto,
        /// Pub/Sub message will be json.
        Json,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MessageFormat::value] or
        /// [MessageFormat::name].
        UnknownValue(message_format::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    pub mod message_format {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl MessageFormat {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Proto => std::option::Option::Some(1),
                Self::Json => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MESSAGE_FORMAT_UNSPECIFIED"),
                Self::Proto => std::option::Option::Some("PROTO"),
                Self::Json => std::option::Option::Some("JSON"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl std::default::Default for MessageFormat {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl std::fmt::Display for MessageFormat {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl std::convert::From<i32> for MessageFormat {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Proto,
                2 => Self::Json,
                _ => Self::UnknownValue(message_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl std::convert::From<&str> for MessageFormat {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MESSAGE_FORMAT_UNSPECIFIED" => Self::Unspecified,
                "PROTO" => Self::Proto,
                "JSON" => Self::Json,
                _ => Self::UnknownValue(message_format::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl serde::ser::Serialize for MessageFormat {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Proto => serializer.serialize_i32(1),
                Self::Json => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl<'de> serde::de::Deserialize<'de> for MessageFormat {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MessageFormat>::new(
                ".google.cloud.dialogflow.v2.NotificationConfig.MessageFormat",
            ))
        }
    }
}

/// Defines logging behavior for conversation lifecycle events.
#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LoggingConfig {
    /// Whether to log conversation events like
    /// [CONVERSATION_STARTED][google.cloud.dialogflow.v2.ConversationEvent.Type.CONVERSATION_STARTED]
    /// to Stackdriver in the conversation project as JSON format
    /// [ConversationEvent][google.cloud.dialogflow.v2.ConversationEvent] protos.
    ///
    /// [google.cloud.dialogflow.v2.ConversationEvent]: crate::model::ConversationEvent
    /// [google.cloud.dialogflow.v2.ConversationEvent.Type.CONVERSATION_STARTED]: crate::model::conversation_event::Type::ConversationStarted
    pub enable_stackdriver_logging: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
impl LoggingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_stackdriver_logging][crate::model::LoggingConfig::enable_stackdriver_logging].
    pub fn set_enable_stackdriver_logging<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_stackdriver_logging = v.into();
        self
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
impl wkt::message::Message for LoggingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.LoggingConfig"
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LoggingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_stackdriver_logging,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoggingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableStackdriverLogging" => {
                                Ok(__FieldTag::__enable_stackdriver_logging)
                            }
                            "enable_stackdriver_logging" => {
                                Ok(__FieldTag::__enable_stackdriver_logging)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LoggingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoggingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_stackdriver_logging => {
                            if !fields.insert(__FieldTag::__enable_stackdriver_logging) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_stackdriver_logging",
                                ));
                            }
                            result.enable_stackdriver_logging = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for LoggingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_stackdriver_logging) {
            state.serialize_entry("enableStackdriverLogging", &self.enable_stackdriver_logging)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The type of Human Agent Assistant API suggestion to perform, and the maximum
/// number of results to return for that type. Multiple `Feature` objects can
/// be specified in the `features` list.
#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SuggestionFeature {
    /// Type of Human Agent Assistant API feature to request.
    pub r#type: crate::model::suggestion_feature::Type,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
impl SuggestionFeature {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::SuggestionFeature::type].
    pub fn set_type<T: std::convert::Into<crate::model::suggestion_feature::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
impl wkt::message::Message for SuggestionFeature {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SuggestionFeature"
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SuggestionFeature {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestionFeature")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SuggestionFeature;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestionFeature")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::suggestion_feature::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
#[doc(hidden)]
impl serde::ser::Serialize for SuggestionFeature {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SuggestionFeature].
#[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
pub mod suggestion_feature {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the type of Human Agent Assistant feature.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified feature type.
        Unspecified,
        /// Run article suggestion model for chat.
        ArticleSuggestion,
        /// Run FAQ model for chat.
        Faq,
        /// Run smart reply model for chat.
        SmartReply,
        /// Run conversation summarization model for chat.
        ConversationSummarization,
        /// Run knowledge search with text input from agent or text generated query.
        KnowledgeSearch,
        /// Run knowledge assist with automatic query generation.
        KnowledgeAssist,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ArticleSuggestion => std::option::Option::Some(1),
                Self::Faq => std::option::Option::Some(2),
                Self::SmartReply => std::option::Option::Some(3),
                Self::ConversationSummarization => std::option::Option::Some(8),
                Self::KnowledgeSearch => std::option::Option::Some(14),
                Self::KnowledgeAssist => std::option::Option::Some(15),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::ArticleSuggestion => std::option::Option::Some("ARTICLE_SUGGESTION"),
                Self::Faq => std::option::Option::Some("FAQ"),
                Self::SmartReply => std::option::Option::Some("SMART_REPLY"),
                Self::ConversationSummarization => {
                    std::option::Option::Some("CONVERSATION_SUMMARIZATION")
                }
                Self::KnowledgeSearch => std::option::Option::Some("KNOWLEDGE_SEARCH"),
                Self::KnowledgeAssist => std::option::Option::Some("KNOWLEDGE_ASSIST"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ArticleSuggestion,
                2 => Self::Faq,
                3 => Self::SmartReply,
                8 => Self::ConversationSummarization,
                14 => Self::KnowledgeSearch,
                15 => Self::KnowledgeAssist,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "ARTICLE_SUGGESTION" => Self::ArticleSuggestion,
                "FAQ" => Self::Faq,
                "SMART_REPLY" => Self::SmartReply,
                "CONVERSATION_SUMMARIZATION" => Self::ConversationSummarization,
                "KNOWLEDGE_SEARCH" => Self::KnowledgeSearch,
                "KNOWLEDGE_ASSIST" => Self::KnowledgeAssist,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ArticleSuggestion => serializer.serialize_i32(1),
                Self::Faq => serializer.serialize_i32(2),
                Self::SmartReply => serializer.serialize_i32(3),
                Self::ConversationSummarization => serializer.serialize_i32(8),
                Self::KnowledgeSearch => serializer.serialize_i32(14),
                Self::KnowledgeAssist => serializer.serialize_i32(15),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "conversation-profiles", feature = "conversations",))]
    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.dialogflow.v2.SuggestionFeature.Type",
            ))
        }
    }
}

/// The request message for
/// [ConversationProfiles.SetSuggestionFeatureConfig][google.cloud.dialogflow.v2.ConversationProfiles.SetSuggestionFeatureConfig].
///
/// [google.cloud.dialogflow.v2.ConversationProfiles.SetSuggestionFeatureConfig]: crate::client::ConversationProfiles::set_suggestion_feature_config
#[cfg(feature = "conversation-profiles")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SetSuggestionFeatureConfigRequest {
    /// Required. The Conversation Profile to add or update the suggestion feature
    /// config. Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversationProfiles/<Conversation Profile ID>`.
    pub conversation_profile: std::string::String,

    /// Required. The participant role to add or update the suggestion feature
    /// config. Only HUMAN_AGENT or END_USER can be used.
    pub participant_role: crate::model::participant::Role,

    /// Required. The suggestion feature config to add or update.
    pub suggestion_feature_config:
        std::option::Option<crate::model::human_agent_assistant_config::SuggestionFeatureConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-profiles")]
impl SetSuggestionFeatureConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation_profile][crate::model::SetSuggestionFeatureConfigRequest::conversation_profile].
    pub fn set_conversation_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_profile = v.into();
        self
    }

    /// Sets the value of [participant_role][crate::model::SetSuggestionFeatureConfigRequest::participant_role].
    pub fn set_participant_role<T: std::convert::Into<crate::model::participant::Role>>(
        mut self,
        v: T,
    ) -> Self {
        self.participant_role = v.into();
        self
    }

    /// Sets the value of [suggestion_feature_config][crate::model::SetSuggestionFeatureConfigRequest::suggestion_feature_config].
    pub fn set_suggestion_feature_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::human_agent_assistant_config::SuggestionFeatureConfig>,
    {
        self.suggestion_feature_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [suggestion_feature_config][crate::model::SetSuggestionFeatureConfigRequest::suggestion_feature_config].
    pub fn set_or_clear_suggestion_feature_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::human_agent_assistant_config::SuggestionFeatureConfig>,
    {
        self.suggestion_feature_config = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "conversation-profiles")]
impl wkt::message::Message for SetSuggestionFeatureConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SetSuggestionFeatureConfigRequest"
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetSuggestionFeatureConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_profile,
            __participant_role,
            __suggestion_feature_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetSuggestionFeatureConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationProfile" => Ok(__FieldTag::__conversation_profile),
                            "conversation_profile" => Ok(__FieldTag::__conversation_profile),
                            "participantRole" => Ok(__FieldTag::__participant_role),
                            "participant_role" => Ok(__FieldTag::__participant_role),
                            "suggestionFeatureConfig" => {
                                Ok(__FieldTag::__suggestion_feature_config)
                            }
                            "suggestion_feature_config" => {
                                Ok(__FieldTag::__suggestion_feature_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetSuggestionFeatureConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetSuggestionFeatureConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_profile => {
                            if !fields.insert(__FieldTag::__conversation_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_profile",
                                ));
                            }
                            result.conversation_profile = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__participant_role => {
                            if !fields.insert(__FieldTag::__participant_role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for participant_role",
                                ));
                            }
                            result.participant_role = map
                                .next_value::<std::option::Option<crate::model::participant::Role>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__suggestion_feature_config => {
                            if !fields.insert(__FieldTag::__suggestion_feature_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suggestion_feature_config",
                                ));
                            }
                            result.suggestion_feature_config = map
                                .next_value::<std::option::Option<
                                crate::model::human_agent_assistant_config::SuggestionFeatureConfig,
                            >>(
                            )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for SetSuggestionFeatureConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_profile.is_empty() {
            state.serialize_entry("conversationProfile", &self.conversation_profile)?;
        }
        if !wkt::internal::is_default(&self.participant_role) {
            state.serialize_entry("participantRole", &self.participant_role)?;
        }
        if self.suggestion_feature_config.is_some() {
            state.serialize_entry("suggestionFeatureConfig", &self.suggestion_feature_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [ConversationProfiles.ClearSuggestionFeatureConfig][google.cloud.dialogflow.v2.ConversationProfiles.ClearSuggestionFeatureConfig].
///
/// [google.cloud.dialogflow.v2.ConversationProfiles.ClearSuggestionFeatureConfig]: crate::client::ConversationProfiles::clear_suggestion_feature_config
#[cfg(feature = "conversation-profiles")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ClearSuggestionFeatureConfigRequest {
    /// Required. The Conversation Profile to add or update the suggestion feature
    /// config. Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversationProfiles/<Conversation Profile ID>`.
    pub conversation_profile: std::string::String,

    /// Required. The participant role to remove the suggestion feature
    /// config. Only HUMAN_AGENT or END_USER can be used.
    pub participant_role: crate::model::participant::Role,

    /// Required. The type of the suggestion feature to remove.
    pub suggestion_feature_type: crate::model::suggestion_feature::Type,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-profiles")]
impl ClearSuggestionFeatureConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation_profile][crate::model::ClearSuggestionFeatureConfigRequest::conversation_profile].
    pub fn set_conversation_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_profile = v.into();
        self
    }

    /// Sets the value of [participant_role][crate::model::ClearSuggestionFeatureConfigRequest::participant_role].
    pub fn set_participant_role<T: std::convert::Into<crate::model::participant::Role>>(
        mut self,
        v: T,
    ) -> Self {
        self.participant_role = v.into();
        self
    }

    /// Sets the value of [suggestion_feature_type][crate::model::ClearSuggestionFeatureConfigRequest::suggestion_feature_type].
    pub fn set_suggestion_feature_type<
        T: std::convert::Into<crate::model::suggestion_feature::Type>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.suggestion_feature_type = v.into();
        self
    }
}

#[cfg(feature = "conversation-profiles")]
impl wkt::message::Message for ClearSuggestionFeatureConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ClearSuggestionFeatureConfigRequest"
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClearSuggestionFeatureConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_profile,
            __participant_role,
            __suggestion_feature_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClearSuggestionFeatureConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationProfile" => Ok(__FieldTag::__conversation_profile),
                            "conversation_profile" => Ok(__FieldTag::__conversation_profile),
                            "participantRole" => Ok(__FieldTag::__participant_role),
                            "participant_role" => Ok(__FieldTag::__participant_role),
                            "suggestionFeatureType" => Ok(__FieldTag::__suggestion_feature_type),
                            "suggestion_feature_type" => Ok(__FieldTag::__suggestion_feature_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClearSuggestionFeatureConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClearSuggestionFeatureConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_profile => {
                            if !fields.insert(__FieldTag::__conversation_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_profile",
                                ));
                            }
                            result.conversation_profile = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__participant_role => {
                            if !fields.insert(__FieldTag::__participant_role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for participant_role",
                                ));
                            }
                            result.participant_role = map
                                .next_value::<std::option::Option<crate::model::participant::Role>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__suggestion_feature_type => {
                            if !fields.insert(__FieldTag::__suggestion_feature_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suggestion_feature_type",
                                ));
                            }
                            result.suggestion_feature_type = map.next_value::<std::option::Option<crate::model::suggestion_feature::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for ClearSuggestionFeatureConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_profile.is_empty() {
            state.serialize_entry("conversationProfile", &self.conversation_profile)?;
        }
        if !wkt::internal::is_default(&self.participant_role) {
            state.serialize_entry("participantRole", &self.participant_role)?;
        }
        if !wkt::internal::is_default(&self.suggestion_feature_type) {
            state.serialize_entry("suggestionFeatureType", &self.suggestion_feature_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for a
/// [ConversationProfiles.SetSuggestionFeatureConfig][google.cloud.dialogflow.v2.ConversationProfiles.SetSuggestionFeatureConfig]
/// operation.
///
/// [google.cloud.dialogflow.v2.ConversationProfiles.SetSuggestionFeatureConfig]: crate::client::ConversationProfiles::set_suggestion_feature_config
#[cfg(feature = "conversation-profiles")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SetSuggestionFeatureConfigOperationMetadata {
    /// The resource name of the conversation profile. Format:
    /// `projects/<Project ID>/locations/<Location
    /// ID>/conversationProfiles/<Conversation Profile ID>`
    pub conversation_profile: std::string::String,

    /// Required. The participant role to add or update the suggestion feature
    /// config. Only HUMAN_AGENT or END_USER can be used.
    pub participant_role: crate::model::participant::Role,

    /// Required. The type of the suggestion feature to add or update.
    pub suggestion_feature_type: crate::model::suggestion_feature::Type,

    /// Timestamp whe the request was created. The time is measured on server side.
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-profiles")]
impl SetSuggestionFeatureConfigOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation_profile][crate::model::SetSuggestionFeatureConfigOperationMetadata::conversation_profile].
    pub fn set_conversation_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_profile = v.into();
        self
    }

    /// Sets the value of [participant_role][crate::model::SetSuggestionFeatureConfigOperationMetadata::participant_role].
    pub fn set_participant_role<T: std::convert::Into<crate::model::participant::Role>>(
        mut self,
        v: T,
    ) -> Self {
        self.participant_role = v.into();
        self
    }

    /// Sets the value of [suggestion_feature_type][crate::model::SetSuggestionFeatureConfigOperationMetadata::suggestion_feature_type].
    pub fn set_suggestion_feature_type<
        T: std::convert::Into<crate::model::suggestion_feature::Type>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.suggestion_feature_type = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::SetSuggestionFeatureConfigOperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::SetSuggestionFeatureConfigOperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "conversation-profiles")]
impl wkt::message::Message for SetSuggestionFeatureConfigOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SetSuggestionFeatureConfigOperationMetadata"
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetSuggestionFeatureConfigOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_profile,
            __participant_role,
            __suggestion_feature_type,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for SetSuggestionFeatureConfigOperationMetadata",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationProfile" => Ok(__FieldTag::__conversation_profile),
                            "conversation_profile" => Ok(__FieldTag::__conversation_profile),
                            "participantRole" => Ok(__FieldTag::__participant_role),
                            "participant_role" => Ok(__FieldTag::__participant_role),
                            "suggestionFeatureType" => Ok(__FieldTag::__suggestion_feature_type),
                            "suggestion_feature_type" => Ok(__FieldTag::__suggestion_feature_type),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetSuggestionFeatureConfigOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetSuggestionFeatureConfigOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_profile => {
                            if !fields.insert(__FieldTag::__conversation_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_profile",
                                ));
                            }
                            result.conversation_profile = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__participant_role => {
                            if !fields.insert(__FieldTag::__participant_role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for participant_role",
                                ));
                            }
                            result.participant_role = map
                                .next_value::<std::option::Option<crate::model::participant::Role>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__suggestion_feature_type => {
                            if !fields.insert(__FieldTag::__suggestion_feature_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suggestion_feature_type",
                                ));
                            }
                            result.suggestion_feature_type = map.next_value::<std::option::Option<crate::model::suggestion_feature::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for SetSuggestionFeatureConfigOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_profile.is_empty() {
            state.serialize_entry("conversationProfile", &self.conversation_profile)?;
        }
        if !wkt::internal::is_default(&self.participant_role) {
            state.serialize_entry("participantRole", &self.participant_role)?;
        }
        if !wkt::internal::is_default(&self.suggestion_feature_type) {
            state.serialize_entry("suggestionFeatureType", &self.suggestion_feature_type)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for a
/// [ConversationProfiles.ClearSuggestionFeatureConfig][google.cloud.dialogflow.v2.ConversationProfiles.ClearSuggestionFeatureConfig]
/// operation.
///
/// [google.cloud.dialogflow.v2.ConversationProfiles.ClearSuggestionFeatureConfig]: crate::client::ConversationProfiles::clear_suggestion_feature_config
#[cfg(feature = "conversation-profiles")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ClearSuggestionFeatureConfigOperationMetadata {
    /// The resource name of the conversation profile. Format:
    /// `projects/<Project ID>/locations/<Location
    /// ID>/conversationProfiles/<Conversation Profile ID>`
    pub conversation_profile: std::string::String,

    /// Required. The participant role to remove the suggestion feature
    /// config. Only HUMAN_AGENT or END_USER can be used.
    pub participant_role: crate::model::participant::Role,

    /// Required. The type of the suggestion feature to remove.
    pub suggestion_feature_type: crate::model::suggestion_feature::Type,

    /// Timestamp whe the request was created. The time is measured on server side.
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "conversation-profiles")]
impl ClearSuggestionFeatureConfigOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation_profile][crate::model::ClearSuggestionFeatureConfigOperationMetadata::conversation_profile].
    pub fn set_conversation_profile<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.conversation_profile = v.into();
        self
    }

    /// Sets the value of [participant_role][crate::model::ClearSuggestionFeatureConfigOperationMetadata::participant_role].
    pub fn set_participant_role<T: std::convert::Into<crate::model::participant::Role>>(
        mut self,
        v: T,
    ) -> Self {
        self.participant_role = v.into();
        self
    }

    /// Sets the value of [suggestion_feature_type][crate::model::ClearSuggestionFeatureConfigOperationMetadata::suggestion_feature_type].
    pub fn set_suggestion_feature_type<
        T: std::convert::Into<crate::model::suggestion_feature::Type>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.suggestion_feature_type = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ClearSuggestionFeatureConfigOperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ClearSuggestionFeatureConfigOperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "conversation-profiles")]
impl wkt::message::Message for ClearSuggestionFeatureConfigOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ClearSuggestionFeatureConfigOperationMetadata"
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClearSuggestionFeatureConfigOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_profile,
            __participant_role,
            __suggestion_feature_type,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for ClearSuggestionFeatureConfigOperationMetadata",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationProfile" => Ok(__FieldTag::__conversation_profile),
                            "conversation_profile" => Ok(__FieldTag::__conversation_profile),
                            "participantRole" => Ok(__FieldTag::__participant_role),
                            "participant_role" => Ok(__FieldTag::__participant_role),
                            "suggestionFeatureType" => Ok(__FieldTag::__suggestion_feature_type),
                            "suggestion_feature_type" => Ok(__FieldTag::__suggestion_feature_type),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClearSuggestionFeatureConfigOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClearSuggestionFeatureConfigOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_profile => {
                            if !fields.insert(__FieldTag::__conversation_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_profile",
                                ));
                            }
                            result.conversation_profile = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__participant_role => {
                            if !fields.insert(__FieldTag::__participant_role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for participant_role",
                                ));
                            }
                            result.participant_role = map
                                .next_value::<std::option::Option<crate::model::participant::Role>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__suggestion_feature_type => {
                            if !fields.insert(__FieldTag::__suggestion_feature_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suggestion_feature_type",
                                ));
                            }
                            result.suggestion_feature_type = map.next_value::<std::option::Option<crate::model::suggestion_feature::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "conversation-profiles")]
#[doc(hidden)]
impl serde::ser::Serialize for ClearSuggestionFeatureConfigOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation_profile.is_empty() {
            state.serialize_entry("conversationProfile", &self.conversation_profile)?;
        }
        if !wkt::internal::is_default(&self.participant_role) {
            state.serialize_entry("participantRole", &self.participant_role)?;
        }
        if !wkt::internal::is_default(&self.suggestion_feature_type) {
            state.serialize_entry("suggestionFeatureType", &self.suggestion_feature_type)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A knowledge document to be used by a
/// [KnowledgeBase][google.cloud.dialogflow.v2.KnowledgeBase].
///
/// For more information, see the [knowledge base
/// guide](https://cloud.google.com/dialogflow/docs/how/knowledge-bases).
///
/// Note: The `projects.agent.knowledgeBases.documents` resource is deprecated;
/// only use `projects.knowledgeBases.documents`.
///
/// [google.cloud.dialogflow.v2.KnowledgeBase]: crate::model::KnowledgeBase
#[cfg(feature = "documents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Document {
    /// Optional. The document resource name.
    /// The name must be empty when creating a document.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/knowledgeBases/<Knowledge Base ID>/documents/<Document ID>`.
    pub name: std::string::String,

    /// Required. The display name of the document. The name must be 1024 bytes or
    /// less; otherwise, the creation request fails.
    pub display_name: std::string::String,

    /// Required. The MIME type of this document.
    pub mime_type: std::string::String,

    /// Required. The knowledge type of document content.
    pub knowledge_types: std::vec::Vec<crate::model::document::KnowledgeType>,

    /// Optional. If true, we try to automatically reload the document every day
    /// (at a time picked by the system). If false or unspecified, we don't try
    /// to automatically reload the document.
    ///
    /// Currently you can only enable automatic reload for documents sourced from
    /// a public url, see `source` field for the source types.
    ///
    /// Reload status can be tracked in `latest_reload_status`. If a reload
    /// fails, we will keep the document unchanged.
    ///
    /// If a reload fails with internal errors, the system will try to reload the
    /// document on the next day.
    /// If a reload fails with non-retriable errors (e.g. PERMISSION_DENIED), the
    /// system will not try to reload the document anymore. You need to manually
    /// reload the document successfully by calling `ReloadDocument` and clear the
    /// errors.
    pub enable_auto_reload: bool,

    /// Output only. The time and status of the latest reload.
    /// This reload may have been triggered automatically or manually
    /// and may not have succeeded.
    pub latest_reload_status: std::option::Option<crate::model::document::ReloadStatus>,

    /// Optional. Metadata for the document. The metadata supports arbitrary
    /// key-value pairs. Suggested use cases include storing a document's title,
    /// an external URL distinct from the document's content_uri, etc.
    /// The max size of a `key` or a `value` of the metadata is 1024 bytes.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The current state of the document.
    pub state: crate::model::document::State,

    /// Required. The source of this document.
    pub source: std::option::Option<crate::model::document::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "documents")]
impl Document {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Document::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Document::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [mime_type][crate::model::Document::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [knowledge_types][crate::model::Document::knowledge_types].
    pub fn set_knowledge_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::document::KnowledgeType>,
    {
        use std::iter::Iterator;
        self.knowledge_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [enable_auto_reload][crate::model::Document::enable_auto_reload].
    pub fn set_enable_auto_reload<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_auto_reload = v.into();
        self
    }

    /// Sets the value of [latest_reload_status][crate::model::Document::latest_reload_status].
    pub fn set_latest_reload_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::document::ReloadStatus>,
    {
        self.latest_reload_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [latest_reload_status][crate::model::Document::latest_reload_status].
    pub fn set_or_clear_latest_reload_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::document::ReloadStatus>,
    {
        self.latest_reload_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::Document::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [state][crate::model::Document::state].
    pub fn set_state<T: std::convert::Into<crate::model::document::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [source][crate::model::Document::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::document::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::Document::source]
    /// if it holds a `ContentUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn content_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::document::Source::ContentUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Document::source]
    /// to hold a `ContentUri`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_content_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source =
            std::option::Option::Some(crate::model::document::Source::ContentUri(v.into()));
        self
    }

    /// The value of [source][crate::model::Document::source]
    /// if it holds a `RawContent`, `None` if the field is not set or
    /// holds a different branch.
    pub fn raw_content(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::document::Source::RawContent(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::Document::source]
    /// to hold a `RawContent`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_raw_content<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.source =
            std::option::Option::Some(crate::model::document::Source::RawContent(v.into()));
        self
    }
}

#[cfg(feature = "documents")]
impl wkt::message::Message for Document {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.Document"
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Document {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __mime_type,
            __knowledge_types,
            __content_uri,
            __raw_content,
            __enable_auto_reload,
            __latest_reload_status,
            __metadata,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Document")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            "knowledgeTypes" => Ok(__FieldTag::__knowledge_types),
                            "knowledge_types" => Ok(__FieldTag::__knowledge_types),
                            "contentUri" => Ok(__FieldTag::__content_uri),
                            "content_uri" => Ok(__FieldTag::__content_uri),
                            "rawContent" => Ok(__FieldTag::__raw_content),
                            "raw_content" => Ok(__FieldTag::__raw_content),
                            "enableAutoReload" => Ok(__FieldTag::__enable_auto_reload),
                            "enable_auto_reload" => Ok(__FieldTag::__enable_auto_reload),
                            "latestReloadStatus" => Ok(__FieldTag::__latest_reload_status),
                            "latest_reload_status" => Ok(__FieldTag::__latest_reload_status),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Document;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Document")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__knowledge_types => {
                            if !fields.insert(__FieldTag::__knowledge_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for knowledge_types",
                                ));
                            }
                            result.knowledge_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::document::KnowledgeType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__content_uri => {
                            if !fields.insert(__FieldTag::__content_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content_uri",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.v2.Document.content_uri, latest field was contentUri",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::document::Source::ContentUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__raw_content => {
                            if !fields.insert(__FieldTag::__raw_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for raw_content",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.v2.Document.raw_content, latest field was rawContent",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::document::Source::RawContent(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__enable_auto_reload => {
                            if !fields.insert(__FieldTag::__enable_auto_reload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_auto_reload",
                                ));
                            }
                            result.enable_auto_reload = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__latest_reload_status => {
                            if !fields.insert(__FieldTag::__latest_reload_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_reload_status",
                                ));
                            }
                            result.latest_reload_status = map.next_value::<std::option::Option<crate::model::document::ReloadStatus>>()?
                                ;
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::document::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for Document {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self.knowledge_types.is_empty() {
            state.serialize_entry("knowledgeTypes", &self.knowledge_types)?;
        }
        if let Some(value) = self.content_uri() {
            state.serialize_entry("contentUri", value)?;
        }
        if let Some(value) = self.raw_content() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rawContent", &__With(value))?;
        }
        if !wkt::internal::is_default(&self.enable_auto_reload) {
            state.serialize_entry("enableAutoReload", &self.enable_auto_reload)?;
        }
        if self.latest_reload_status.is_some() {
            state.serialize_entry("latestReloadStatus", &self.latest_reload_status)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Document].
#[cfg(feature = "documents")]
pub mod document {
    #[allow(unused_imports)]
    use super::*;

    /// The status of a reload attempt.
    #[cfg(feature = "documents")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ReloadStatus {
        /// The time of a reload attempt.
        /// This reload may have been triggered automatically or manually and may
        /// not have succeeded.
        pub time: std::option::Option<wkt::Timestamp>,

        /// The status of a reload attempt or the initial load.
        pub status: std::option::Option<rpc::model::Status>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "documents")]
    impl ReloadStatus {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [time][crate::model::document::ReloadStatus::time].
        pub fn set_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [time][crate::model::document::ReloadStatus::time].
        pub fn set_or_clear_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [status][crate::model::document::ReloadStatus::status].
        pub fn set_status<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.status = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [status][crate::model::document::ReloadStatus::status].
        pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.status = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "documents")]
    impl wkt::message::Message for ReloadStatus {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.Document.ReloadStatus"
        }
    }

    #[cfg(feature = "documents")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ReloadStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __time,
                __status,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ReloadStatus")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "time" => Ok(__FieldTag::__time),
                                "status" => Ok(__FieldTag::__status),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ReloadStatus;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ReloadStatus")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__time => {
                                if !fields.insert(__FieldTag::__time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for time",
                                    ));
                                }
                                result.time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__status => {
                                if !fields.insert(__FieldTag::__status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for status",
                                    ));
                                }
                                result.status =
                                    map.next_value::<std::option::Option<rpc::model::Status>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "documents")]
    #[doc(hidden)]
    impl serde::ser::Serialize for ReloadStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.time.is_some() {
                state.serialize_entry("time", &self.time)?;
            }
            if self.status.is_some() {
                state.serialize_entry("status", &self.status)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The knowledge type of document content.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "documents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum KnowledgeType {
        /// The type is unspecified or arbitrary.
        Unspecified,
        /// The document content contains question and answer pairs as either HTML or
        /// CSV. Typical FAQ HTML formats are parsed accurately, but unusual formats
        /// may fail to be parsed.
        ///
        /// CSV must have questions in the first column and answers in the second,
        /// with no header. Because of this explicit format, they are always parsed
        /// accurately.
        Faq,
        /// Documents for which unstructured text is extracted and used for
        /// question answering.
        ExtractiveQa,
        /// The entire document content as a whole can be used for query results.
        /// Only for Contact Center Solutions on Dialogflow.
        ArticleSuggestion,
        /// The document contains agent-facing Smart Reply entries.
        AgentFacingSmartReply,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [KnowledgeType::value] or
        /// [KnowledgeType::name].
        UnknownValue(knowledge_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "documents")]
    pub mod knowledge_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "documents")]
    impl KnowledgeType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Faq => std::option::Option::Some(1),
                Self::ExtractiveQa => std::option::Option::Some(2),
                Self::ArticleSuggestion => std::option::Option::Some(3),
                Self::AgentFacingSmartReply => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("KNOWLEDGE_TYPE_UNSPECIFIED"),
                Self::Faq => std::option::Option::Some("FAQ"),
                Self::ExtractiveQa => std::option::Option::Some("EXTRACTIVE_QA"),
                Self::ArticleSuggestion => std::option::Option::Some("ARTICLE_SUGGESTION"),
                Self::AgentFacingSmartReply => {
                    std::option::Option::Some("AGENT_FACING_SMART_REPLY")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "documents")]
    impl std::default::Default for KnowledgeType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "documents")]
    impl std::fmt::Display for KnowledgeType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "documents")]
    impl std::convert::From<i32> for KnowledgeType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Faq,
                2 => Self::ExtractiveQa,
                3 => Self::ArticleSuggestion,
                4 => Self::AgentFacingSmartReply,
                _ => Self::UnknownValue(knowledge_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "documents")]
    impl std::convert::From<&str> for KnowledgeType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KNOWLEDGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "FAQ" => Self::Faq,
                "EXTRACTIVE_QA" => Self::ExtractiveQa,
                "ARTICLE_SUGGESTION" => Self::ArticleSuggestion,
                "AGENT_FACING_SMART_REPLY" => Self::AgentFacingSmartReply,
                _ => Self::UnknownValue(knowledge_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "documents")]
    impl serde::ser::Serialize for KnowledgeType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Faq => serializer.serialize_i32(1),
                Self::ExtractiveQa => serializer.serialize_i32(2),
                Self::ArticleSuggestion => serializer.serialize_i32(3),
                Self::AgentFacingSmartReply => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "documents")]
    impl<'de> serde::de::Deserialize<'de> for KnowledgeType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<KnowledgeType>::new(
                ".google.cloud.dialogflow.v2.Document.KnowledgeType",
            ))
        }
    }

    /// Possible states of the document
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "documents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The document state is unspecified.
        Unspecified,
        /// The document creation is in progress.
        Creating,
        /// The document is active and ready to use.
        Active,
        /// The document updation is in progress.
        Updating,
        /// The document is reloading.
        Reloading,
        /// The document deletion is in progress.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "documents")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "documents")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Reloading => std::option::Option::Some(4),
                Self::Deleting => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Reloading => std::option::Option::Some("RELOADING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "documents")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "documents")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "documents")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Updating,
                4 => Self::Reloading,
                5 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "documents")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "UPDATING" => Self::Updating,
                "RELOADING" => Self::Reloading,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "documents")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Reloading => serializer.serialize_i32(4),
                Self::Deleting => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "documents")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dialogflow.v2.Document.State",
            ))
        }
    }

    /// Required. The source of this document.
    #[cfg(feature = "documents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// The URI where the file content is located.
        ///
        /// For documents stored in Google Cloud Storage, these URIs must have
        /// the form `gs://<bucket-name>/<object-name>`.
        ///
        /// NOTE: External URLs must correspond to public webpages, i.e., they must
        /// be indexed by Google Search. In particular, URLs for showing documents in
        /// Google Cloud Storage (i.e. the URL in your browser) are not supported.
        /// Instead use the `gs://` format URI described above.
        ContentUri(std::string::String),
        /// The raw content of the document. This field is only permitted for
        /// EXTRACTIVE_QA and FAQ knowledge types.
        RawContent(::bytes::Bytes),
    }
}

/// Request message for
/// [Documents.GetDocument][google.cloud.dialogflow.v2.Documents.GetDocument].
///
/// [google.cloud.dialogflow.v2.Documents.GetDocument]: crate::client::Documents::get_document
#[cfg(feature = "documents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDocumentRequest {
    /// Required. The name of the document to retrieve.
    /// Format `projects/<Project ID>/locations/<Location
    /// ID>/knowledgeBases/<Knowledge Base ID>/documents/<Document ID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "documents")]
impl GetDocumentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDocumentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "documents")]
impl wkt::message::Message for GetDocumentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetDocumentRequest"
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDocumentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDocumentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDocumentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDocumentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for GetDocumentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [Documents.ListDocuments][google.cloud.dialogflow.v2.Documents.ListDocuments].
///
/// [google.cloud.dialogflow.v2.Documents.ListDocuments]: crate::client::Documents::list_documents
#[cfg(feature = "documents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDocumentsRequest {
    /// Required. The knowledge base to list all documents for.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/knowledgeBases/<Knowledge Base ID>`.
    pub parent: std::string::String,

    /// The maximum number of items to return in a single page. By
    /// default 10 and at most 100.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    /// The filter expression used to filter documents returned by the list method.
    /// The expression has the following syntax:
    ///
    /// \<field\> \<operator\> \<value\> [AND \<field\> \<operator\> \<value\>] ...
    ///
    /// The following fields and operators are supported:
    ///
    /// * knowledge_types with has(:) operator
    /// * display_name with has(:) operator
    /// * state with equals(=) operator
    ///
    /// Examples:
    ///
    /// * "knowledge_types:FAQ" matches documents with FAQ knowledge type.
    /// * "display_name:customer" matches documents whose display name contains
    ///   "customer".
    /// * "state=ACTIVE" matches documents with ACTIVE state.
    /// * "knowledge_types:FAQ AND state=ACTIVE" matches all active FAQ documents.
    ///
    /// For more information about filtering, see
    /// [API Filtering](https://aip.dev/160).
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "documents")]
impl ListDocumentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDocumentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDocumentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDocumentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDocumentsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

#[cfg(feature = "documents")]
impl wkt::message::Message for ListDocumentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListDocumentsRequest"
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDocumentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDocumentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDocumentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDocumentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for ListDocumentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [Documents.ListDocuments][google.cloud.dialogflow.v2.Documents.ListDocuments].
///
/// [google.cloud.dialogflow.v2.Documents.ListDocuments]: crate::client::Documents::list_documents
#[cfg(feature = "documents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDocumentsResponse {
    /// The list of documents.
    pub documents: std::vec::Vec<crate::model::Document>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "documents")]
impl ListDocumentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [documents][crate::model::ListDocumentsResponse::documents].
    pub fn set_documents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Document>,
    {
        use std::iter::Iterator;
        self.documents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDocumentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "documents")]
impl wkt::message::Message for ListDocumentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListDocumentsResponse"
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDocumentsResponse {
    type PageItem = crate::model::Document;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.documents
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDocumentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __documents,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDocumentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "documents" => Ok(__FieldTag::__documents),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDocumentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDocumentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__documents => {
                            if !fields.insert(__FieldTag::__documents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documents",
                                ));
                            }
                            result.documents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Document>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for ListDocumentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.documents.is_empty() {
            state.serialize_entry("documents", &self.documents)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [Documents.CreateDocument][google.cloud.dialogflow.v2.Documents.CreateDocument].
///
/// [google.cloud.dialogflow.v2.Documents.CreateDocument]: crate::client::Documents::create_document
#[cfg(feature = "documents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDocumentRequest {
    /// Required. The knowledge base to create a document for.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/knowledgeBases/<Knowledge Base ID>`.
    pub parent: std::string::String,

    /// Required. The document to create.
    pub document: std::option::Option<crate::model::Document>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "documents")]
impl CreateDocumentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDocumentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [document][crate::model::CreateDocumentRequest::document].
    pub fn set_document<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document][crate::model::CreateDocumentRequest::document].
    pub fn set_or_clear_document<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "documents")]
impl wkt::message::Message for CreateDocumentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CreateDocumentRequest"
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDocumentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __document,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDocumentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "document" => Ok(__FieldTag::__document),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDocumentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDocumentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__document => {
                            if !fields.insert(__FieldTag::__document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document",
                                ));
                            }
                            result.document =
                                map.next_value::<std::option::Option<crate::model::Document>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateDocumentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.document.is_some() {
            state.serialize_entry("document", &self.document)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [Documents.ImportDocuments][google.cloud.dialogflow.v2.Documents.ImportDocuments].
///
/// [google.cloud.dialogflow.v2.Documents.ImportDocuments]: crate::client::Documents::import_documents
#[cfg(feature = "documents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportDocumentsRequest {
    /// Required. The knowledge base to import documents into.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/knowledgeBases/<Knowledge Base ID>`.
    pub parent: std::string::String,

    /// Required. Document template used for importing all the documents.
    pub document_template: std::option::Option<crate::model::ImportDocumentTemplate>,

    /// Whether to import custom metadata from Google Cloud Storage.
    /// Only valid when the document source is Google Cloud Storage URI.
    pub import_gcs_custom_metadata: bool,

    /// Required. The source to use for importing documents.
    ///
    /// If the source captures multiple objects, then multiple documents will be
    /// created, one corresponding to each object, and all of these documents will
    /// be created using the same document template.
    ///
    /// Dialogflow supports up to 350 documents in each request. If you try to
    /// import more, Dialogflow will return an error.
    pub source: std::option::Option<crate::model::import_documents_request::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "documents")]
impl ImportDocumentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ImportDocumentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [document_template][crate::model::ImportDocumentsRequest::document_template].
    pub fn set_document_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImportDocumentTemplate>,
    {
        self.document_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document_template][crate::model::ImportDocumentsRequest::document_template].
    pub fn set_or_clear_document_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImportDocumentTemplate>,
    {
        self.document_template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [import_gcs_custom_metadata][crate::model::ImportDocumentsRequest::import_gcs_custom_metadata].
    pub fn set_import_gcs_custom_metadata<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.import_gcs_custom_metadata = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ImportDocumentsRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::import_documents_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImportDocumentsRequest::source]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(&self) -> std::option::Option<&std::boxed::Box<crate::model::GcsSources>> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::import_documents_request::Source::GcsSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImportDocumentsRequest::source]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_gcs_source<T: std::convert::Into<std::boxed::Box<crate::model::GcsSources>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::import_documents_request::Source::GcsSource(v.into()),
        );
        self
    }
}

#[cfg(feature = "documents")]
impl wkt::message::Message for ImportDocumentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ImportDocumentsRequest"
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportDocumentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __gcs_source,
            __document_template,
            __import_gcs_custom_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportDocumentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "gcsSource" => Ok(__FieldTag::__gcs_source),
                            "gcs_source" => Ok(__FieldTag::__gcs_source),
                            "documentTemplate" => Ok(__FieldTag::__document_template),
                            "document_template" => Ok(__FieldTag::__document_template),
                            "importGcsCustomMetadata" => {
                                Ok(__FieldTag::__import_gcs_custom_metadata)
                            }
                            "import_gcs_custom_metadata" => {
                                Ok(__FieldTag::__import_gcs_custom_metadata)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportDocumentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportDocumentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcs_source => {
                            if !fields.insert(__FieldTag::__gcs_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_source",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.v2.ImportDocumentsRequest.gcs_source, latest field was gcsSource",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::import_documents_request::Source::GcsSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsSources>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__document_template => {
                            if !fields.insert(__FieldTag::__document_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document_template",
                                ));
                            }
                            result.document_template = map.next_value::<std::option::Option<crate::model::ImportDocumentTemplate>>()?
                                ;
                        }
                        __FieldTag::__import_gcs_custom_metadata => {
                            if !fields.insert(__FieldTag::__import_gcs_custom_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_gcs_custom_metadata",
                                ));
                            }
                            result.import_gcs_custom_metadata = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for ImportDocumentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if self.document_template.is_some() {
            state.serialize_entry("documentTemplate", &self.document_template)?;
        }
        if !wkt::internal::is_default(&self.import_gcs_custom_metadata) {
            state.serialize_entry("importGcsCustomMetadata", &self.import_gcs_custom_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ImportDocumentsRequest].
#[cfg(feature = "documents")]
pub mod import_documents_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The source to use for importing documents.
    ///
    /// If the source captures multiple objects, then multiple documents will be
    /// created, one corresponding to each object, and all of these documents will
    /// be created using the same document template.
    ///
    /// Dialogflow supports up to 350 documents in each request. If you try to
    /// import more, Dialogflow will return an error.
    #[cfg(feature = "documents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Optional. The Google Cloud Storage location for the documents.
        /// The path can include a wildcard.
        ///
        /// These URIs may have the forms
        /// `gs://<bucket-name>/<object-name>`.
        /// `gs://<bucket-name>/<object-path>/*.<extension>`.
        GcsSource(std::boxed::Box<crate::model::GcsSources>),
    }
}

/// The template used for importing documents.
#[cfg(feature = "documents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportDocumentTemplate {
    /// Required. The MIME type of the document.
    pub mime_type: std::string::String,

    /// Required. The knowledge type of document content.
    pub knowledge_types: std::vec::Vec<crate::model::document::KnowledgeType>,

    /// Metadata for the document. The metadata supports arbitrary
    /// key-value pairs. Suggested use cases include storing a document's title,
    /// an external URL distinct from the document's content_uri, etc.
    /// The max size of a `key` or a `value` of the metadata is 1024 bytes.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "documents")]
impl ImportDocumentTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mime_type][crate::model::ImportDocumentTemplate::mime_type].
    pub fn set_mime_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.mime_type = v.into();
        self
    }

    /// Sets the value of [knowledge_types][crate::model::ImportDocumentTemplate::knowledge_types].
    pub fn set_knowledge_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::document::KnowledgeType>,
    {
        use std::iter::Iterator;
        self.knowledge_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::ImportDocumentTemplate::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "documents")]
impl wkt::message::Message for ImportDocumentTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ImportDocumentTemplate"
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportDocumentTemplate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mime_type,
            __knowledge_types,
            __metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportDocumentTemplate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mimeType" => Ok(__FieldTag::__mime_type),
                            "mime_type" => Ok(__FieldTag::__mime_type),
                            "knowledgeTypes" => Ok(__FieldTag::__knowledge_types),
                            "knowledge_types" => Ok(__FieldTag::__knowledge_types),
                            "metadata" => Ok(__FieldTag::__metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportDocumentTemplate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportDocumentTemplate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mime_type => {
                            if !fields.insert(__FieldTag::__mime_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mime_type",
                                ));
                            }
                            result.mime_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__knowledge_types => {
                            if !fields.insert(__FieldTag::__knowledge_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for knowledge_types",
                                ));
                            }
                            result.knowledge_types = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::document::KnowledgeType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for ImportDocumentTemplate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.mime_type.is_empty() {
            state.serialize_entry("mimeType", &self.mime_type)?;
        }
        if !self.knowledge_types.is_empty() {
            state.serialize_entry("knowledgeTypes", &self.knowledge_types)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [Documents.ImportDocuments][google.cloud.dialogflow.v2.Documents.ImportDocuments].
///
/// [google.cloud.dialogflow.v2.Documents.ImportDocuments]: crate::client::Documents::import_documents
#[cfg(feature = "documents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ImportDocumentsResponse {
    /// Includes details about skipped documents or any other warnings.
    pub warnings: std::vec::Vec<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "documents")]
impl ImportDocumentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [warnings][crate::model::ImportDocumentsResponse::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "documents")]
impl wkt::message::Message for ImportDocumentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ImportDocumentsResponse"
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImportDocumentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __warnings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImportDocumentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "warnings" => Ok(__FieldTag::__warnings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImportDocumentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImportDocumentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__warnings => {
                            if !fields.insert(__FieldTag::__warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for warnings",
                                ));
                            }
                            result.warnings = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for ImportDocumentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.warnings.is_empty() {
            state.serialize_entry("warnings", &self.warnings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [Documents.DeleteDocument][google.cloud.dialogflow.v2.Documents.DeleteDocument].
///
/// [google.cloud.dialogflow.v2.Documents.DeleteDocument]: crate::client::Documents::delete_document
#[cfg(feature = "documents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDocumentRequest {
    /// Required. The name of the document to delete.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/knowledgeBases/<Knowledge Base ID>/documents/<Document ID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "documents")]
impl DeleteDocumentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDocumentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "documents")]
impl wkt::message::Message for DeleteDocumentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DeleteDocumentRequest"
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDocumentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDocumentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDocumentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDocumentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteDocumentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [Documents.UpdateDocument][google.cloud.dialogflow.v2.Documents.UpdateDocument].
///
/// [google.cloud.dialogflow.v2.Documents.UpdateDocument]: crate::client::Documents::update_document
#[cfg(feature = "documents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDocumentRequest {
    /// Required. The document to update.
    pub document: std::option::Option<crate::model::Document>,

    /// Optional. Not specified means `update all`.
    /// Currently, only `display_name` can be updated, an InvalidArgument will be
    /// returned for attempting to update other fields.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "documents")]
impl UpdateDocumentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [document][crate::model::UpdateDocumentRequest::document].
    pub fn set_document<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [document][crate::model::UpdateDocumentRequest::document].
    pub fn set_or_clear_document<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Document>,
    {
        self.document = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateDocumentRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDocumentRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "documents")]
impl wkt::message::Message for UpdateDocumentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.UpdateDocumentRequest"
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDocumentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __document,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDocumentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "document" => Ok(__FieldTag::__document),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDocumentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDocumentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__document => {
                            if !fields.insert(__FieldTag::__document) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for document",
                                ));
                            }
                            result.document =
                                map.next_value::<std::option::Option<crate::model::Document>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateDocumentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.document.is_some() {
            state.serialize_entry("document", &self.document)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [Documents.ReloadDocument][google.cloud.dialogflow.v2.Documents.ReloadDocument].
///
/// [google.cloud.dialogflow.v2.Documents.ReloadDocument]: crate::client::Documents::reload_document
#[cfg(feature = "documents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReloadDocumentRequest {
    /// Required. The name of the document to reload.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/knowledgeBases/<Knowledge Base ID>/documents/<Document ID>`
    pub name: std::string::String,

    /// Optional. Whether to import custom metadata from Google Cloud Storage.
    /// Only valid when the document source is Google Cloud Storage URI.
    pub import_gcs_custom_metadata: bool,

    /// Optional. When enabled, the reload request is to apply partial update to
    /// the smart messaging allowlist.
    pub smart_messaging_partial_update: bool,

    /// The source for document reloading.
    ///
    /// If provided, the service will load the contents from the source
    /// and update document in the knowledge base.
    ///
    /// Reloading from a new document source is allowed for smart messaging
    /// documents only. If you want to update the source for other document types,
    /// please delete the existing document and create a new one instead.
    pub source: std::option::Option<crate::model::reload_document_request::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "documents")]
impl ReloadDocumentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReloadDocumentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [import_gcs_custom_metadata][crate::model::ReloadDocumentRequest::import_gcs_custom_metadata].
    pub fn set_import_gcs_custom_metadata<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.import_gcs_custom_metadata = v.into();
        self
    }

    /// Sets the value of [smart_messaging_partial_update][crate::model::ReloadDocumentRequest::smart_messaging_partial_update].
    pub fn set_smart_messaging_partial_update<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.smart_messaging_partial_update = v.into();
        self
    }

    /// Sets the value of [source][crate::model::ReloadDocumentRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::reload_document_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ReloadDocumentRequest::source]
    /// if it holds a `ContentUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn content_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::reload_document_request::Source::ContentUri(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ReloadDocumentRequest::source]
    /// to hold a `ContentUri`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_content_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::reload_document_request::Source::ContentUri(v.into()),
        );
        self
    }
}

#[cfg(feature = "documents")]
impl wkt::message::Message for ReloadDocumentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ReloadDocumentRequest"
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReloadDocumentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __content_uri,
            __import_gcs_custom_metadata,
            __smart_messaging_partial_update,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReloadDocumentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "contentUri" => Ok(__FieldTag::__content_uri),
                            "content_uri" => Ok(__FieldTag::__content_uri),
                            "importGcsCustomMetadata" => {
                                Ok(__FieldTag::__import_gcs_custom_metadata)
                            }
                            "import_gcs_custom_metadata" => {
                                Ok(__FieldTag::__import_gcs_custom_metadata)
                            }
                            "smartMessagingPartialUpdate" => {
                                Ok(__FieldTag::__smart_messaging_partial_update)
                            }
                            "smart_messaging_partial_update" => {
                                Ok(__FieldTag::__smart_messaging_partial_update)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReloadDocumentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReloadDocumentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__content_uri => {
                            if !fields.insert(__FieldTag::__content_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content_uri",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.v2.ReloadDocumentRequest.content_uri, latest field was contentUri",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::reload_document_request::Source::ContentUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__import_gcs_custom_metadata => {
                            if !fields.insert(__FieldTag::__import_gcs_custom_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for import_gcs_custom_metadata",
                                ));
                            }
                            result.import_gcs_custom_metadata = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__smart_messaging_partial_update => {
                            if !fields.insert(__FieldTag::__smart_messaging_partial_update) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for smart_messaging_partial_update",
                                ));
                            }
                            result.smart_messaging_partial_update = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for ReloadDocumentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.content_uri() {
            state.serialize_entry("contentUri", value)?;
        }
        if !wkt::internal::is_default(&self.import_gcs_custom_metadata) {
            state.serialize_entry("importGcsCustomMetadata", &self.import_gcs_custom_metadata)?;
        }
        if !wkt::internal::is_default(&self.smart_messaging_partial_update) {
            state.serialize_entry(
                "smartMessagingPartialUpdate",
                &self.smart_messaging_partial_update,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ReloadDocumentRequest].
#[cfg(feature = "documents")]
pub mod reload_document_request {
    #[allow(unused_imports)]
    use super::*;

    /// The source for document reloading.
    ///
    /// If provided, the service will load the contents from the source
    /// and update document in the knowledge base.
    ///
    /// Reloading from a new document source is allowed for smart messaging
    /// documents only. If you want to update the source for other document types,
    /// please delete the existing document and create a new one instead.
    #[cfg(feature = "documents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Optional. The path of gcs source file for reloading document content. For
        /// now, only gcs uri is supported.
        ///
        /// For documents stored in Google Cloud Storage, these URIs must have
        /// the form `gs://<bucket-name>/<object-name>`.
        ContentUri(std::string::String),
    }
}

/// Request message for
/// [Documents.ExportDocument][google.cloud.dialogflow.v2.Documents.ExportDocument].
///
/// [google.cloud.dialogflow.v2.Documents.ExportDocument]: crate::client::Documents::export_document
#[cfg(feature = "documents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportDocumentRequest {
    /// Required. The name of the document to export.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/knowledgeBases/<Knowledge Base ID>/documents/<Document ID>`.
    pub name: std::string::String,

    /// When enabled, export the full content of the document including empirical
    /// probability.
    pub export_full_content: bool,

    /// When enabled, export the smart messaging allowlist document for partial
    /// update.
    pub smart_messaging_partial_update: bool,

    /// Required. The destination for the export.
    pub destination: std::option::Option<crate::model::export_document_request::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "documents")]
impl ExportDocumentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExportDocumentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [export_full_content][crate::model::ExportDocumentRequest::export_full_content].
    pub fn set_export_full_content<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.export_full_content = v.into();
        self
    }

    /// Sets the value of [smart_messaging_partial_update][crate::model::ExportDocumentRequest::smart_messaging_partial_update].
    pub fn set_smart_messaging_partial_update<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.smart_messaging_partial_update = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ExportDocumentRequest::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::export_document_request::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportDocumentRequest::destination]
    /// if it holds a `GcsDestination`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_destination(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GcsDestination>> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_document_request::Destination::GcsDestination(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportDocumentRequest::destination]
    /// to hold a `GcsDestination`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_destination<
        T: std::convert::Into<std::boxed::Box<crate::model::GcsDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_document_request::Destination::GcsDestination(v.into()),
        );
        self
    }
}

#[cfg(feature = "documents")]
impl wkt::message::Message for ExportDocumentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ExportDocumentRequest"
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportDocumentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __gcs_destination,
            __export_full_content,
            __smart_messaging_partial_update,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportDocumentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "gcsDestination" => Ok(__FieldTag::__gcs_destination),
                            "gcs_destination" => Ok(__FieldTag::__gcs_destination),
                            "exportFullContent" => Ok(__FieldTag::__export_full_content),
                            "export_full_content" => Ok(__FieldTag::__export_full_content),
                            "smartMessagingPartialUpdate" => {
                                Ok(__FieldTag::__smart_messaging_partial_update)
                            }
                            "smart_messaging_partial_update" => {
                                Ok(__FieldTag::__smart_messaging_partial_update)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportDocumentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportDocumentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcs_destination => {
                            if !fields.insert(__FieldTag::__gcs_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_destination",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.dialogflow.v2.ExportDocumentRequest.gcs_destination, latest field was gcsDestination",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::export_document_request::Destination::GcsDestination(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GcsDestination>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__export_full_content => {
                            if !fields.insert(__FieldTag::__export_full_content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for export_full_content",
                                ));
                            }
                            result.export_full_content = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__smart_messaging_partial_update => {
                            if !fields.insert(__FieldTag::__smart_messaging_partial_update) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for smart_messaging_partial_update",
                                ));
                            }
                            result.smart_messaging_partial_update = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for ExportDocumentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.gcs_destination() {
            state.serialize_entry("gcsDestination", value)?;
        }
        if !wkt::internal::is_default(&self.export_full_content) {
            state.serialize_entry("exportFullContent", &self.export_full_content)?;
        }
        if !wkt::internal::is_default(&self.smart_messaging_partial_update) {
            state.serialize_entry(
                "smartMessagingPartialUpdate",
                &self.smart_messaging_partial_update,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ExportDocumentRequest].
#[cfg(feature = "documents")]
pub mod export_document_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The destination for the export.
    #[cfg(feature = "documents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Cloud Storage file path to export the document.
        GcsDestination(std::boxed::Box<crate::model::GcsDestination>),
    }
}

/// Metadata related to the Export Data Operations (e.g. ExportDocument).
#[cfg(feature = "documents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportOperationMetadata {
    /// Cloud Storage file path of the exported data.
    pub exported_gcs_destination: std::option::Option<crate::model::GcsDestination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "documents")]
impl ExportOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [exported_gcs_destination][crate::model::ExportOperationMetadata::exported_gcs_destination].
    pub fn set_exported_gcs_destination<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GcsDestination>,
    {
        self.exported_gcs_destination = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [exported_gcs_destination][crate::model::ExportOperationMetadata::exported_gcs_destination].
    pub fn set_or_clear_exported_gcs_destination<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GcsDestination>,
    {
        self.exported_gcs_destination = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "documents")]
impl wkt::message::Message for ExportOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ExportOperationMetadata"
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __exported_gcs_destination,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "exportedGcsDestination" => Ok(__FieldTag::__exported_gcs_destination),
                            "exported_gcs_destination" => {
                                Ok(__FieldTag::__exported_gcs_destination)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__exported_gcs_destination => {
                            if !fields.insert(__FieldTag::__exported_gcs_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exported_gcs_destination",
                                ));
                            }
                            result.exported_gcs_destination = map
                                .next_value::<std::option::Option<crate::model::GcsDestination>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for ExportOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.exported_gcs_destination.is_some() {
            state.serialize_entry("exportedGcsDestination", &self.exported_gcs_destination)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata in google::longrunning::Operation for Knowledge operations.
#[cfg(feature = "documents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct KnowledgeOperationMetadata {
    /// Output only. The current state of this operation.
    pub state: crate::model::knowledge_operation_metadata::State,

    /// The name of the knowledge base interacted with during the operation.
    pub knowledge_base: std::string::String,

    /// Additional metadata for the Knowledge operation.
    pub operation_metadata:
        std::option::Option<crate::model::knowledge_operation_metadata::OperationMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "documents")]
impl KnowledgeOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::KnowledgeOperationMetadata::state].
    pub fn set_state<T: std::convert::Into<crate::model::knowledge_operation_metadata::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [knowledge_base][crate::model::KnowledgeOperationMetadata::knowledge_base].
    pub fn set_knowledge_base<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.knowledge_base = v.into();
        self
    }

    /// Sets the value of [operation_metadata][crate::model::KnowledgeOperationMetadata::operation_metadata].
    ///
    /// Note that all the setters affecting `operation_metadata` are mutually
    /// exclusive.
    pub fn set_operation_metadata<
        T: std::convert::Into<
                std::option::Option<crate::model::knowledge_operation_metadata::OperationMetadata>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation_metadata = v.into();
        self
    }

    /// The value of [operation_metadata][crate::model::KnowledgeOperationMetadata::operation_metadata]
    /// if it holds a `ExportOperationMetadata`, `None` if the field is not set or
    /// holds a different branch.
    pub fn export_operation_metadata(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ExportOperationMetadata>> {
        #[allow(unreachable_patterns)]
        self.operation_metadata.as_ref().and_then(|v| match v {
            crate::model::knowledge_operation_metadata::OperationMetadata::ExportOperationMetadata(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [operation_metadata][crate::model::KnowledgeOperationMetadata::operation_metadata]
    /// to hold a `ExportOperationMetadata`.
    ///
    /// Note that all the setters affecting `operation_metadata` are
    /// mutually exclusive.
    pub fn set_export_operation_metadata<
        T: std::convert::Into<std::boxed::Box<crate::model::ExportOperationMetadata>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation_metadata = std::option::Option::Some(
            crate::model::knowledge_operation_metadata::OperationMetadata::ExportOperationMetadata(
                v.into(),
            ),
        );
        self
    }
}

#[cfg(feature = "documents")]
impl wkt::message::Message for KnowledgeOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.KnowledgeOperationMetadata"
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KnowledgeOperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __knowledge_base,
            __export_operation_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KnowledgeOperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "knowledgeBase" => Ok(__FieldTag::__knowledge_base),
                            "knowledge_base" => Ok(__FieldTag::__knowledge_base),
                            "exportOperationMetadata" => {
                                Ok(__FieldTag::__export_operation_metadata)
                            }
                            "export_operation_metadata" => {
                                Ok(__FieldTag::__export_operation_metadata)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KnowledgeOperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KnowledgeOperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<
                                    crate::model::knowledge_operation_metadata::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__knowledge_base => {
                            if !fields.insert(__FieldTag::__knowledge_base) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for knowledge_base",
                                ));
                            }
                            result.knowledge_base = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__export_operation_metadata => {
                            if !fields.insert(__FieldTag::__export_operation_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for export_operation_metadata",
                                ));
                            }
                            if result.operation_metadata.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `operation_metadata`, a oneof with full ID .google.cloud.dialogflow.v2.KnowledgeOperationMetadata.export_operation_metadata, latest field was exportOperationMetadata",
                                ));
                            }
                            result.operation_metadata = std::option::Option::Some(
                                crate::model::knowledge_operation_metadata::OperationMetadata::ExportOperationMetadata(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ExportOperationMetadata>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for KnowledgeOperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.knowledge_base.is_empty() {
            state.serialize_entry("knowledgeBase", &self.knowledge_base)?;
        }
        if let Some(value) = self.export_operation_metadata() {
            state.serialize_entry("exportOperationMetadata", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [KnowledgeOperationMetadata].
#[cfg(feature = "documents")]
pub mod knowledge_operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// States of the operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "documents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State unspecified.
        Unspecified,
        /// The operation has been created.
        Pending,
        /// The operation is currently running.
        Running,
        /// The operation is done, either cancelled or completed.
        Done,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "documents")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "documents")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Done => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "documents")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "documents")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "documents")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "documents")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "documents")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Done => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "documents")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dialogflow.v2.KnowledgeOperationMetadata.State",
            ))
        }
    }

    /// Additional metadata for the Knowledge operation.
    #[cfg(feature = "documents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OperationMetadata {
        /// Metadata for the Export Data Operation such as the destination of export.
        ExportOperationMetadata(std::boxed::Box<crate::model::ExportOperationMetadata>),
    }
}

/// The request to get location-level encryption specification.
#[cfg(feature = "encryption-spec-service")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEncryptionSpecRequest {
    /// Required. The name of the encryption spec resource to get.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "encryption-spec-service")]
impl GetEncryptionSpecRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEncryptionSpecRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "encryption-spec-service")]
impl wkt::message::Message for GetEncryptionSpecRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetEncryptionSpecRequest"
    }
}

#[cfg(feature = "encryption-spec-service")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEncryptionSpecRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEncryptionSpecRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEncryptionSpecRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEncryptionSpecRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "encryption-spec-service")]
#[doc(hidden)]
impl serde::ser::Serialize for GetEncryptionSpecRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A customer-managed encryption key specification that can be applied to all
/// created resources (e.g. Conversation).
#[cfg(feature = "encryption-spec-service")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EncryptionSpec {
    /// Immutable. The resource name of the encryption key specification resource.
    /// Format:
    /// projects/{project}/locations/{location}/encryptionSpec
    pub name: std::string::String,

    /// Required. The name of customer-managed encryption key that is used to
    /// secure a resource and its sub-resources. If empty, the resource is secured
    /// by the default Google encryption key. Only the key in the same location as
    /// this resource is allowed to be used for encryption. Format:
    /// `projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key}`
    pub kms_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "encryption-spec-service")]
impl EncryptionSpec {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EncryptionSpec::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::EncryptionSpec::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }
}

#[cfg(feature = "encryption-spec-service")]
impl wkt::message::Message for EncryptionSpec {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.EncryptionSpec"
    }
}

#[cfg(feature = "encryption-spec-service")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EncryptionSpec {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __kms_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EncryptionSpec")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "kmsKey" => Ok(__FieldTag::__kms_key),
                            "kms_key" => Ok(__FieldTag::__kms_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EncryptionSpec;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EncryptionSpec")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key => {
                            if !fields.insert(__FieldTag::__kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key",
                                ));
                            }
                            result.kms_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "encryption-spec-service")]
#[doc(hidden)]
impl serde::ser::Serialize for EncryptionSpec {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.kms_key.is_empty() {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request to initialize a location-level encryption specification.
#[cfg(feature = "encryption-spec-service")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InitializeEncryptionSpecRequest {
    /// Required. The encryption spec used for CMEK encryption. It is required that
    /// the kms key is in the same region as the endpoint. The same key will be
    /// used for all provisioned resources, if encryption is available. If the
    /// kms_key_name is left empty, no encryption will be enforced.
    pub encryption_spec: std::option::Option<crate::model::EncryptionSpec>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "encryption-spec-service")]
impl InitializeEncryptionSpecRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_spec][crate::model::InitializeEncryptionSpecRequest::encryption_spec].
    pub fn set_encryption_spec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionSpec>,
    {
        self.encryption_spec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_spec][crate::model::InitializeEncryptionSpecRequest::encryption_spec].
    pub fn set_or_clear_encryption_spec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionSpec>,
    {
        self.encryption_spec = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "encryption-spec-service")]
impl wkt::message::Message for InitializeEncryptionSpecRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.InitializeEncryptionSpecRequest"
    }
}

#[cfg(feature = "encryption-spec-service")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InitializeEncryptionSpecRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __encryption_spec,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InitializeEncryptionSpecRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "encryptionSpec" => Ok(__FieldTag::__encryption_spec),
                            "encryption_spec" => Ok(__FieldTag::__encryption_spec),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InitializeEncryptionSpecRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InitializeEncryptionSpecRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__encryption_spec => {
                            if !fields.insert(__FieldTag::__encryption_spec) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_spec",
                                ));
                            }
                            result.encryption_spec = map
                                .next_value::<std::option::Option<crate::model::EncryptionSpec>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "encryption-spec-service")]
#[doc(hidden)]
impl serde::ser::Serialize for InitializeEncryptionSpecRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.encryption_spec.is_some() {
            state.serialize_entry("encryptionSpec", &self.encryption_spec)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response to initialize a location-level encryption specification.
#[cfg(feature = "encryption-spec-service")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InitializeEncryptionSpecResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "encryption-spec-service")]
impl InitializeEncryptionSpecResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

#[cfg(feature = "encryption-spec-service")]
impl wkt::message::Message for InitializeEncryptionSpecResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.InitializeEncryptionSpecResponse"
    }
}

#[cfg(feature = "encryption-spec-service")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InitializeEncryptionSpecResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InitializeEncryptionSpecResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InitializeEncryptionSpecResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InitializeEncryptionSpecResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "encryption-spec-service")]
#[doc(hidden)]
impl serde::ser::Serialize for InitializeEncryptionSpecResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for initializing a location-level encryption specification.
#[cfg(feature = "encryption-spec-service")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InitializeEncryptionSpecMetadata {
    /// Output only. The original request for initialization.
    pub request: std::option::Option<crate::model::InitializeEncryptionSpecRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "encryption-spec-service")]
impl InitializeEncryptionSpecMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request][crate::model::InitializeEncryptionSpecMetadata::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InitializeEncryptionSpecRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::InitializeEncryptionSpecMetadata::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InitializeEncryptionSpecRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "encryption-spec-service")]
impl wkt::message::Message for InitializeEncryptionSpecMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.InitializeEncryptionSpecMetadata"
    }
}

#[cfg(feature = "encryption-spec-service")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InitializeEncryptionSpecMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __request,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InitializeEncryptionSpecMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "request" => Ok(__FieldTag::__request),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InitializeEncryptionSpecMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InitializeEncryptionSpecMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map.next_value::<std::option::Option<
                                crate::model::InitializeEncryptionSpecRequest,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "encryption-spec-service")]
#[doc(hidden)]
impl serde::ser::Serialize for InitializeEncryptionSpecMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Each intent parameter has a type, called the entity type, which dictates
/// exactly how data from an end-user expression is extracted.
///
/// Dialogflow provides predefined system entities that can match many common
/// types of data. For example, there are system entities for matching dates,
/// times, colors, email addresses, and so on. You can also create your own
/// custom entities for matching custom data. For example, you could define a
/// vegetable entity that can match the types of vegetables available for
/// purchase with a grocery store agent.
///
/// For more information, see the
/// [Entity guide](https://cloud.google.com/dialogflow/docs/entities-overview).
#[cfg(any(
    feature = "entity-types",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EntityType {
    /// The unique identifier of the entity type.
    /// Required for
    /// [EntityTypes.UpdateEntityType][google.cloud.dialogflow.v2.EntityTypes.UpdateEntityType]
    /// and
    /// [EntityTypes.BatchUpdateEntityTypes][google.cloud.dialogflow.v2.EntityTypes.BatchUpdateEntityTypes]
    /// methods. Format: `projects/<Project ID>/agent/entityTypes/<Entity Type
    /// ID>`.
    ///
    /// [google.cloud.dialogflow.v2.EntityTypes.BatchUpdateEntityTypes]: crate::client::EntityTypes::batch_update_entity_types
    /// [google.cloud.dialogflow.v2.EntityTypes.UpdateEntityType]: crate::client::EntityTypes::update_entity_type
    pub name: std::string::String,

    /// Required. The name of the entity type.
    pub display_name: std::string::String,

    /// Required. Indicates the kind of entity type.
    pub kind: crate::model::entity_type::Kind,

    /// Optional. Indicates whether the entity type can be automatically
    /// expanded.
    pub auto_expansion_mode: crate::model::entity_type::AutoExpansionMode,

    /// Optional. The collection of entity entries associated with the entity type.
    pub entities: std::vec::Vec<crate::model::entity_type::Entity>,

    /// Optional. Enables fuzzy entity extraction during classification.
    pub enable_fuzzy_extraction: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "entity-types",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
))]
impl EntityType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EntityType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::EntityType::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::EntityType::kind].
    pub fn set_kind<T: std::convert::Into<crate::model::entity_type::Kind>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [auto_expansion_mode][crate::model::EntityType::auto_expansion_mode].
    pub fn set_auto_expansion_mode<
        T: std::convert::Into<crate::model::entity_type::AutoExpansionMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.auto_expansion_mode = v.into();
        self
    }

    /// Sets the value of [entities][crate::model::EntityType::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::entity_type::Entity>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [enable_fuzzy_extraction][crate::model::EntityType::enable_fuzzy_extraction].
    pub fn set_enable_fuzzy_extraction<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_fuzzy_extraction = v.into();
        self
    }
}

#[cfg(any(
    feature = "entity-types",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
))]
impl wkt::message::Message for EntityType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.EntityType"
    }
}

#[cfg(any(
    feature = "entity-types",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EntityType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __kind,
            __auto_expansion_mode,
            __entities,
            __enable_fuzzy_extraction,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntityType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "kind" => Ok(__FieldTag::__kind),
                            "autoExpansionMode" => Ok(__FieldTag::__auto_expansion_mode),
                            "auto_expansion_mode" => Ok(__FieldTag::__auto_expansion_mode),
                            "entities" => Ok(__FieldTag::__entities),
                            "enableFuzzyExtraction" => Ok(__FieldTag::__enable_fuzzy_extraction),
                            "enable_fuzzy_extraction" => Ok(__FieldTag::__enable_fuzzy_extraction),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EntityType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntityType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<crate::model::entity_type::Kind>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auto_expansion_mode => {
                            if !fields.insert(__FieldTag::__auto_expansion_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_expansion_mode",
                                ));
                            }
                            result.auto_expansion_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::entity_type::AutoExpansionMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entities => {
                            if !fields.insert(__FieldTag::__entities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entities",
                                ));
                            }
                            result.entities = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::entity_type::Entity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_fuzzy_extraction => {
                            if !fields.insert(__FieldTag::__enable_fuzzy_extraction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_fuzzy_extraction",
                                ));
                            }
                            result.enable_fuzzy_extraction = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "entity-types",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for EntityType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.kind) {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !wkt::internal::is_default(&self.auto_expansion_mode) {
            state.serialize_entry("autoExpansionMode", &self.auto_expansion_mode)?;
        }
        if !self.entities.is_empty() {
            state.serialize_entry("entities", &self.entities)?;
        }
        if !wkt::internal::is_default(&self.enable_fuzzy_extraction) {
            state.serialize_entry("enableFuzzyExtraction", &self.enable_fuzzy_extraction)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EntityType].
#[cfg(any(
    feature = "entity-types",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
))]
pub mod entity_type {
    #[allow(unused_imports)]
    use super::*;

    /// An **entity entry** for an associated entity type.
    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Entity {
        /// Required. The primary value associated with this entity entry.
        /// For example, if the entity type is *vegetable*, the value could be
        /// *scallions*.
        ///
        /// For `KIND_MAP` entity types:
        ///
        /// * A reference value to be used in place of synonyms.
        ///
        /// For `KIND_LIST` entity types:
        ///
        /// * A string that can contain references to other entity types (with or
        ///   without aliases).
        pub value: std::string::String,

        /// Required. A collection of value synonyms. For example, if the entity type
        /// is *vegetable*, and `value` is *scallions*, a synonym could be *green
        /// onions*.
        ///
        /// For `KIND_LIST` entity types:
        ///
        /// * This collection must contain exactly one synonym equal to `value`.
        pub synonyms: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl Entity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [value][crate::model::entity_type::Entity::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }

        /// Sets the value of [synonyms][crate::model::entity_type::Entity::synonyms].
        pub fn set_synonyms<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.synonyms = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl wkt::message::Message for Entity {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.EntityType.Entity"
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Entity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __value,
                __synonyms,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Entity")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "value" => Ok(__FieldTag::__value),
                                "synonyms" => Ok(__FieldTag::__synonyms),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Entity;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Entity")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                result.value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__synonyms => {
                                if !fields.insert(__FieldTag::__synonyms) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for synonyms",
                                    ));
                                }
                                result.synonyms = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for Entity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.value.is_empty() {
                state.serialize_entry("value", &self.value)?;
            }
            if !self.synonyms.is_empty() {
                state.serialize_entry("synonyms", &self.synonyms)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Represents kinds of entities.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Kind {
        /// Not specified. This value should be never used.
        Unspecified,
        /// Map entity types allow mapping of a group of synonyms to a reference
        /// value.
        Map,
        /// List entity types contain a set of entries that do not map to reference
        /// values. However, list entity types can contain references to other entity
        /// types (with or without aliases).
        List,
        /// Regexp entity types allow to specify regular expressions in entries
        /// values.
        Regexp,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Kind::value] or
        /// [Kind::name].
        UnknownValue(kind::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    pub mod kind {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl Kind {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Map => std::option::Option::Some(1),
                Self::List => std::option::Option::Some(2),
                Self::Regexp => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("KIND_UNSPECIFIED"),
                Self::Map => std::option::Option::Some("KIND_MAP"),
                Self::List => std::option::Option::Some("KIND_LIST"),
                Self::Regexp => std::option::Option::Some("KIND_REGEXP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::default::Default for Kind {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::fmt::Display for Kind {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::convert::From<i32> for Kind {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Map,
                2 => Self::List,
                3 => Self::Regexp,
                _ => Self::UnknownValue(kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::convert::From<&str> for Kind {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KIND_UNSPECIFIED" => Self::Unspecified,
                "KIND_MAP" => Self::Map,
                "KIND_LIST" => Self::List,
                "KIND_REGEXP" => Self::Regexp,
                _ => Self::UnknownValue(kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl serde::ser::Serialize for Kind {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Map => serializer.serialize_i32(1),
                Self::List => serializer.serialize_i32(2),
                Self::Regexp => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Kind {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Kind>::new(
                ".google.cloud.dialogflow.v2.EntityType.Kind",
            ))
        }
    }

    /// Represents different entity type expansion modes. Automated expansion
    /// allows an agent to recognize values that have not been explicitly listed in
    /// the entity (for example, new kinds of shopping list items).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AutoExpansionMode {
        /// Auto expansion disabled for the entity.
        Unspecified,
        /// Allows an agent to recognize values that have not been explicitly
        /// listed in the entity.
        Default,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AutoExpansionMode::value] or
        /// [AutoExpansionMode::name].
        UnknownValue(auto_expansion_mode::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    pub mod auto_expansion_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl AutoExpansionMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Default => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AUTO_EXPANSION_MODE_UNSPECIFIED"),
                Self::Default => std::option::Option::Some("AUTO_EXPANSION_MODE_DEFAULT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::default::Default for AutoExpansionMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::fmt::Display for AutoExpansionMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::convert::From<i32> for AutoExpansionMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Default,
                _ => Self::UnknownValue(auto_expansion_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::convert::From<&str> for AutoExpansionMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AUTO_EXPANSION_MODE_UNSPECIFIED" => Self::Unspecified,
                "AUTO_EXPANSION_MODE_DEFAULT" => Self::Default,
                _ => Self::UnknownValue(auto_expansion_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl serde::ser::Serialize for AutoExpansionMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Default => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "entity-types",
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl<'de> serde::de::Deserialize<'de> for AutoExpansionMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AutoExpansionMode>::new(
                ".google.cloud.dialogflow.v2.EntityType.AutoExpansionMode",
            ))
        }
    }
}

/// The request message for
/// [EntityTypes.ListEntityTypes][google.cloud.dialogflow.v2.EntityTypes.ListEntityTypes].
///
/// [google.cloud.dialogflow.v2.EntityTypes.ListEntityTypes]: crate::client::EntityTypes::list_entity_types
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntityTypesRequest {
    /// Required. The agent to list all entity types from.
    /// Format: `projects/<Project ID>/agent`.
    pub parent: std::string::String,

    /// Optional. The language used to access language-specific data.
    /// If not specified, the agent's default language is used.
    /// For more information, see
    /// [Multilingual intent and entity
    /// data](https://cloud.google.com/dialogflow/docs/agents-multilingual#intent-entity).
    pub language_code: std::string::String,

    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl ListEntityTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntityTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::ListEntityTypesRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntityTypesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntityTypesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for ListEntityTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListEntityTypesRequest"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntityTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __language_code,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntityTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntityTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntityTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for ListEntityTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [EntityTypes.ListEntityTypes][google.cloud.dialogflow.v2.EntityTypes.ListEntityTypes].
///
/// [google.cloud.dialogflow.v2.EntityTypes.ListEntityTypes]: crate::client::EntityTypes::list_entity_types
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntityTypesResponse {
    /// The list of agent entity types. There will be a maximum number of items
    /// returned based on the page_size field in the request.
    pub entity_types: std::vec::Vec<crate::model::EntityType>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl ListEntityTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_types][crate::model::ListEntityTypesResponse::entity_types].
    pub fn set_entity_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityType>,
    {
        use std::iter::Iterator;
        self.entity_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEntityTypesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for ListEntityTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListEntityTypesResponse"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEntityTypesResponse {
    type PageItem = crate::model::EntityType;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entity_types
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntityTypesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity_types,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntityTypesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entityTypes" => Ok(__FieldTag::__entity_types),
                            "entity_types" => Ok(__FieldTag::__entity_types),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntityTypesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntityTypesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity_types => {
                            if !fields.insert(__FieldTag::__entity_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_types",
                                ));
                            }
                            result.entity_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EntityType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for ListEntityTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entity_types.is_empty() {
            state.serialize_entry("entityTypes", &self.entity_types)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [EntityTypes.GetEntityType][google.cloud.dialogflow.v2.EntityTypes.GetEntityType].
///
/// [google.cloud.dialogflow.v2.EntityTypes.GetEntityType]: crate::client::EntityTypes::get_entity_type
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEntityTypeRequest {
    /// Required. The name of the entity type.
    /// Format: `projects/<Project ID>/agent/entityTypes/<EntityType ID>`.
    pub name: std::string::String,

    /// Optional. The language used to access language-specific data.
    /// If not specified, the agent's default language is used.
    /// For more information, see
    /// [Multilingual intent and entity
    /// data](https://cloud.google.com/dialogflow/docs/agents-multilingual#intent-entity).
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl GetEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntityTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::GetEntityTypeRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for GetEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetEntityTypeRequest"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for GetEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [EntityTypes.CreateEntityType][google.cloud.dialogflow.v2.EntityTypes.CreateEntityType].
///
/// [google.cloud.dialogflow.v2.EntityTypes.CreateEntityType]: crate::client::EntityTypes::create_entity_type
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateEntityTypeRequest {
    /// Required. The agent to create a entity type for.
    /// Format: `projects/<Project ID>/agent`.
    pub parent: std::string::String,

    /// Required. The entity type to create.
    pub entity_type: std::option::Option<crate::model::EntityType>,

    /// Optional. The language used to access language-specific data.
    /// If not specified, the agent's default language is used.
    /// For more information, see
    /// [Multilingual intent and entity
    /// data](https://cloud.google.com/dialogflow/docs/agents-multilingual#intent-entity).
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl CreateEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntityTypeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entity_type][crate::model::CreateEntityTypeRequest::entity_type].
    pub fn set_entity_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EntityType>,
    {
        self.entity_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entity_type][crate::model::CreateEntityTypeRequest::entity_type].
    pub fn set_or_clear_entity_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EntityType>,
    {
        self.entity_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::CreateEntityTypeRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for CreateEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CreateEntityTypeRequest"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entity_type,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entityType" => Ok(__FieldTag::__entity_type),
                            "entity_type" => Ok(__FieldTag::__entity_type),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_type => {
                            if !fields.insert(__FieldTag::__entity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_type",
                                ));
                            }
                            result.entity_type =
                                map.next_value::<std::option::Option<crate::model::EntityType>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.entity_type.is_some() {
            state.serialize_entry("entityType", &self.entity_type)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [EntityTypes.UpdateEntityType][google.cloud.dialogflow.v2.EntityTypes.UpdateEntityType].
///
/// [google.cloud.dialogflow.v2.EntityTypes.UpdateEntityType]: crate::client::EntityTypes::update_entity_type
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateEntityTypeRequest {
    /// Required. The entity type to update.
    pub entity_type: std::option::Option<crate::model::EntityType>,

    /// Optional. The language used to access language-specific data.
    /// If not specified, the agent's default language is used.
    /// For more information, see
    /// [Multilingual intent and entity
    /// data](https://cloud.google.com/dialogflow/docs/agents-multilingual#intent-entity).
    pub language_code: std::string::String,

    /// Optional. The mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl UpdateEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_type][crate::model::UpdateEntityTypeRequest::entity_type].
    pub fn set_entity_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EntityType>,
    {
        self.entity_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entity_type][crate::model::UpdateEntityTypeRequest::entity_type].
    pub fn set_or_clear_entity_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EntityType>,
    {
        self.entity_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::UpdateEntityTypeRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEntityTypeRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEntityTypeRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for UpdateEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.UpdateEntityTypeRequest"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity_type,
            __language_code,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entityType" => Ok(__FieldTag::__entity_type),
                            "entity_type" => Ok(__FieldTag::__entity_type),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity_type => {
                            if !fields.insert(__FieldTag::__entity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_type",
                                ));
                            }
                            result.entity_type =
                                map.next_value::<std::option::Option<crate::model::EntityType>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.entity_type.is_some() {
            state.serialize_entry("entityType", &self.entity_type)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [EntityTypes.DeleteEntityType][google.cloud.dialogflow.v2.EntityTypes.DeleteEntityType].
///
/// [google.cloud.dialogflow.v2.EntityTypes.DeleteEntityType]: crate::client::EntityTypes::delete_entity_type
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteEntityTypeRequest {
    /// Required. The name of the entity type to delete.
    /// Format: `projects/<Project ID>/agent/entityTypes/<EntityType ID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl DeleteEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntityTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for DeleteEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DeleteEntityTypeRequest"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [EntityTypes.BatchUpdateEntityTypes][google.cloud.dialogflow.v2.EntityTypes.BatchUpdateEntityTypes].
///
/// [google.cloud.dialogflow.v2.EntityTypes.BatchUpdateEntityTypes]: crate::client::EntityTypes::batch_update_entity_types
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchUpdateEntityTypesRequest {
    /// Required. The name of the agent to update or create entity types in.
    /// Format: `projects/<Project ID>/agent`.
    pub parent: std::string::String,

    /// Optional. The language used to access language-specific data.
    /// If not specified, the agent's default language is used.
    /// For more information, see
    /// [Multilingual intent and entity
    /// data](https://cloud.google.com/dialogflow/docs/agents-multilingual#intent-entity).
    pub language_code: std::string::String,

    /// Optional. The mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// The source of the entity type batch.
    ///
    /// For each entity type in the batch:
    ///
    /// * If `name` is specified, we update an existing entity type.
    /// * If `name` is not specified, we create a new entity type.
    pub entity_type_batch:
        std::option::Option<crate::model::batch_update_entity_types_request::EntityTypeBatch>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl BatchUpdateEntityTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchUpdateEntityTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::BatchUpdateEntityTypesRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::BatchUpdateEntityTypesRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::BatchUpdateEntityTypesRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [entity_type_batch][crate::model::BatchUpdateEntityTypesRequest::entity_type_batch].
    ///
    /// Note that all the setters affecting `entity_type_batch` are mutually
    /// exclusive.
    pub fn set_entity_type_batch<
        T: std::convert::Into<
                std::option::Option<
                    crate::model::batch_update_entity_types_request::EntityTypeBatch,
                >,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_type_batch = v.into();
        self
    }

    /// The value of [entity_type_batch][crate::model::BatchUpdateEntityTypesRequest::entity_type_batch]
    /// if it holds a `EntityTypeBatchUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn entity_type_batch_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.entity_type_batch.as_ref().and_then(|v| match v {
            crate::model::batch_update_entity_types_request::EntityTypeBatch::EntityTypeBatchUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_type_batch][crate::model::BatchUpdateEntityTypesRequest::entity_type_batch]
    /// to hold a `EntityTypeBatchUri`.
    ///
    /// Note that all the setters affecting `entity_type_batch` are
    /// mutually exclusive.
    pub fn set_entity_type_batch_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.entity_type_batch = std::option::Option::Some(
            crate::model::batch_update_entity_types_request::EntityTypeBatch::EntityTypeBatchUri(
                v.into(),
            ),
        );
        self
    }

    /// The value of [entity_type_batch][crate::model::BatchUpdateEntityTypesRequest::entity_type_batch]
    /// if it holds a `EntityTypeBatchInline`, `None` if the field is not set or
    /// holds a different branch.
    pub fn entity_type_batch_inline(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::EntityTypeBatch>> {
        #[allow(unreachable_patterns)]
        self.entity_type_batch.as_ref().and_then(|v| match v {
            crate::model::batch_update_entity_types_request::EntityTypeBatch::EntityTypeBatchInline(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entity_type_batch][crate::model::BatchUpdateEntityTypesRequest::entity_type_batch]
    /// to hold a `EntityTypeBatchInline`.
    ///
    /// Note that all the setters affecting `entity_type_batch` are
    /// mutually exclusive.
    pub fn set_entity_type_batch_inline<
        T: std::convert::Into<std::boxed::Box<crate::model::EntityTypeBatch>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_type_batch = std::option::Option::Some(
            crate::model::batch_update_entity_types_request::EntityTypeBatch::EntityTypeBatchInline(
                v.into(),
            ),
        );
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for BatchUpdateEntityTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.BatchUpdateEntityTypesRequest"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchUpdateEntityTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entity_type_batch_uri,
            __entity_type_batch_inline,
            __language_code,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchUpdateEntityTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entityTypeBatchUri" => Ok(__FieldTag::__entity_type_batch_uri),
                            "entity_type_batch_uri" => Ok(__FieldTag::__entity_type_batch_uri),
                            "entityTypeBatchInline" => Ok(__FieldTag::__entity_type_batch_inline),
                            "entity_type_batch_inline" => {
                                Ok(__FieldTag::__entity_type_batch_inline)
                            }
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchUpdateEntityTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchUpdateEntityTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_type_batch_uri => {
                            if !fields.insert(__FieldTag::__entity_type_batch_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_type_batch_uri",
                                ));
                            }
                            if result.entity_type_batch.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entity_type_batch`, a oneof with full ID .google.cloud.dialogflow.v2.BatchUpdateEntityTypesRequest.entity_type_batch_uri, latest field was entityTypeBatchUri",
                                ));
                            }
                            result.entity_type_batch = std::option::Option::Some(
                                crate::model::batch_update_entity_types_request::EntityTypeBatch::EntityTypeBatchUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__entity_type_batch_inline => {
                            if !fields.insert(__FieldTag::__entity_type_batch_inline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_type_batch_inline",
                                ));
                            }
                            if result.entity_type_batch.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entity_type_batch`, a oneof with full ID .google.cloud.dialogflow.v2.BatchUpdateEntityTypesRequest.entity_type_batch_inline, latest field was entityTypeBatchInline",
                                ));
                            }
                            result.entity_type_batch = std::option::Option::Some(
                                crate::model::batch_update_entity_types_request::EntityTypeBatch::EntityTypeBatchInline(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::EntityTypeBatch>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for BatchUpdateEntityTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.entity_type_batch_uri() {
            state.serialize_entry("entityTypeBatchUri", value)?;
        }
        if let Some(value) = self.entity_type_batch_inline() {
            state.serialize_entry("entityTypeBatchInline", value)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BatchUpdateEntityTypesRequest].
#[cfg(feature = "entity-types")]
pub mod batch_update_entity_types_request {
    #[allow(unused_imports)]
    use super::*;

    /// The source of the entity type batch.
    ///
    /// For each entity type in the batch:
    ///
    /// * If `name` is specified, we update an existing entity type.
    /// * If `name` is not specified, we create a new entity type.
    #[cfg(feature = "entity-types")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EntityTypeBatch {
        /// The URI to a Google Cloud Storage file containing entity types to update
        /// or create. The file format can either be a serialized proto (of
        /// EntityBatch type) or a JSON object. Note: The URI must start with
        /// "gs://".
        EntityTypeBatchUri(std::string::String),
        /// The collection of entity types to update or create.
        EntityTypeBatchInline(std::boxed::Box<crate::model::EntityTypeBatch>),
    }
}

/// The response message for
/// [EntityTypes.BatchUpdateEntityTypes][google.cloud.dialogflow.v2.EntityTypes.BatchUpdateEntityTypes].
///
/// [google.cloud.dialogflow.v2.EntityTypes.BatchUpdateEntityTypes]: crate::client::EntityTypes::batch_update_entity_types
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchUpdateEntityTypesResponse {
    /// The collection of updated or created entity types.
    pub entity_types: std::vec::Vec<crate::model::EntityType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl BatchUpdateEntityTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_types][crate::model::BatchUpdateEntityTypesResponse::entity_types].
    pub fn set_entity_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityType>,
    {
        use std::iter::Iterator;
        self.entity_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for BatchUpdateEntityTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.BatchUpdateEntityTypesResponse"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchUpdateEntityTypesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchUpdateEntityTypesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entityTypes" => Ok(__FieldTag::__entity_types),
                            "entity_types" => Ok(__FieldTag::__entity_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchUpdateEntityTypesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchUpdateEntityTypesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity_types => {
                            if !fields.insert(__FieldTag::__entity_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_types",
                                ));
                            }
                            result.entity_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EntityType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for BatchUpdateEntityTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entity_types.is_empty() {
            state.serialize_entry("entityTypes", &self.entity_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [EntityTypes.BatchDeleteEntityTypes][google.cloud.dialogflow.v2.EntityTypes.BatchDeleteEntityTypes].
///
/// [google.cloud.dialogflow.v2.EntityTypes.BatchDeleteEntityTypes]: crate::client::EntityTypes::batch_delete_entity_types
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchDeleteEntityTypesRequest {
    /// Required. The name of the agent to delete all entities types for. Format:
    /// `projects/<Project ID>/agent`.
    pub parent: std::string::String,

    /// Required. The names entity types to delete. All names must point to the
    /// same agent as `parent`.
    pub entity_type_names: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl BatchDeleteEntityTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchDeleteEntityTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entity_type_names][crate::model::BatchDeleteEntityTypesRequest::entity_type_names].
    pub fn set_entity_type_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.entity_type_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for BatchDeleteEntityTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.BatchDeleteEntityTypesRequest"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchDeleteEntityTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entity_type_names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchDeleteEntityTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entityTypeNames" => Ok(__FieldTag::__entity_type_names),
                            "entity_type_names" => Ok(__FieldTag::__entity_type_names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchDeleteEntityTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchDeleteEntityTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_type_names => {
                            if !fields.insert(__FieldTag::__entity_type_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_type_names",
                                ));
                            }
                            result.entity_type_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for BatchDeleteEntityTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.entity_type_names.is_empty() {
            state.serialize_entry("entityTypeNames", &self.entity_type_names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [EntityTypes.BatchCreateEntities][google.cloud.dialogflow.v2.EntityTypes.BatchCreateEntities].
///
/// [google.cloud.dialogflow.v2.EntityTypes.BatchCreateEntities]: crate::client::EntityTypes::batch_create_entities
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchCreateEntitiesRequest {
    /// Required. The name of the entity type to create entities in. Format:
    /// `projects/<Project ID>/agent/entityTypes/<Entity Type ID>`.
    pub parent: std::string::String,

    /// Required. The entities to create.
    pub entities: std::vec::Vec<crate::model::entity_type::Entity>,

    /// Optional. The language used to access language-specific data.
    /// If not specified, the agent's default language is used.
    /// For more information, see
    /// [Multilingual intent and entity
    /// data](https://cloud.google.com/dialogflow/docs/agents-multilingual#intent-entity).
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl BatchCreateEntitiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchCreateEntitiesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entities][crate::model::BatchCreateEntitiesRequest::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::entity_type::Entity>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [language_code][crate::model::BatchCreateEntitiesRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for BatchCreateEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.BatchCreateEntitiesRequest"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchCreateEntitiesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entities,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchCreateEntitiesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entities" => Ok(__FieldTag::__entities),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchCreateEntitiesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchCreateEntitiesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entities => {
                            if !fields.insert(__FieldTag::__entities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entities",
                                ));
                            }
                            result.entities = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::entity_type::Entity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for BatchCreateEntitiesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.entities.is_empty() {
            state.serialize_entry("entities", &self.entities)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [EntityTypes.BatchUpdateEntities][google.cloud.dialogflow.v2.EntityTypes.BatchUpdateEntities].
///
/// [google.cloud.dialogflow.v2.EntityTypes.BatchUpdateEntities]: crate::client::EntityTypes::batch_update_entities
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchUpdateEntitiesRequest {
    /// Required. The name of the entity type to update or create entities in.
    /// Format: `projects/<Project ID>/agent/entityTypes/<Entity Type ID>`.
    pub parent: std::string::String,

    /// Required. The entities to update or create.
    pub entities: std::vec::Vec<crate::model::entity_type::Entity>,

    /// Optional. The language used to access language-specific data.
    /// If not specified, the agent's default language is used.
    /// For more information, see
    /// [Multilingual intent and entity
    /// data](https://cloud.google.com/dialogflow/docs/agents-multilingual#intent-entity).
    pub language_code: std::string::String,

    /// Optional. The mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl BatchUpdateEntitiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchUpdateEntitiesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entities][crate::model::BatchUpdateEntitiesRequest::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::entity_type::Entity>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [language_code][crate::model::BatchUpdateEntitiesRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::BatchUpdateEntitiesRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::BatchUpdateEntitiesRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for BatchUpdateEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.BatchUpdateEntitiesRequest"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchUpdateEntitiesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entities,
            __language_code,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchUpdateEntitiesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entities" => Ok(__FieldTag::__entities),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchUpdateEntitiesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchUpdateEntitiesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entities => {
                            if !fields.insert(__FieldTag::__entities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entities",
                                ));
                            }
                            result.entities = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::entity_type::Entity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for BatchUpdateEntitiesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.entities.is_empty() {
            state.serialize_entry("entities", &self.entities)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [EntityTypes.BatchDeleteEntities][google.cloud.dialogflow.v2.EntityTypes.BatchDeleteEntities].
///
/// [google.cloud.dialogflow.v2.EntityTypes.BatchDeleteEntities]: crate::client::EntityTypes::batch_delete_entities
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchDeleteEntitiesRequest {
    /// Required. The name of the entity type to delete entries for. Format:
    /// `projects/<Project ID>/agent/entityTypes/<Entity Type ID>`.
    pub parent: std::string::String,

    /// Required. The reference `values` of the entities to delete. Note that
    /// these are not fully-qualified names, i.e. they don't start with
    /// `projects/<Project ID>`.
    pub entity_values: std::vec::Vec<std::string::String>,

    /// Optional. The language used to access language-specific data.
    /// If not specified, the agent's default language is used.
    /// For more information, see
    /// [Multilingual intent and entity
    /// data](https://cloud.google.com/dialogflow/docs/agents-multilingual#intent-entity).
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl BatchDeleteEntitiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchDeleteEntitiesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entity_values][crate::model::BatchDeleteEntitiesRequest::entity_values].
    pub fn set_entity_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.entity_values = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [language_code][crate::model::BatchDeleteEntitiesRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for BatchDeleteEntitiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.BatchDeleteEntitiesRequest"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchDeleteEntitiesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entity_values,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchDeleteEntitiesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entityValues" => Ok(__FieldTag::__entity_values),
                            "entity_values" => Ok(__FieldTag::__entity_values),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchDeleteEntitiesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchDeleteEntitiesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_values => {
                            if !fields.insert(__FieldTag::__entity_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_values",
                                ));
                            }
                            result.entity_values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for BatchDeleteEntitiesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.entity_values.is_empty() {
            state.serialize_entry("entityValues", &self.entity_values)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// This message is a wrapper around a collection of entity types.
#[cfg(feature = "entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EntityTypeBatch {
    /// A collection of entity types.
    pub entity_types: std::vec::Vec<crate::model::EntityType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "entity-types")]
impl EntityTypeBatch {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entity_types][crate::model::EntityTypeBatch::entity_types].
    pub fn set_entity_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EntityType>,
    {
        use std::iter::Iterator;
        self.entity_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "entity-types")]
impl wkt::message::Message for EntityTypeBatch {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.EntityTypeBatch"
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EntityTypeBatch {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entity_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EntityTypeBatch")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entityTypes" => Ok(__FieldTag::__entity_types),
                            "entity_types" => Ok(__FieldTag::__entity_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EntityTypeBatch;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EntityTypeBatch")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entity_types => {
                            if !fields.insert(__FieldTag::__entity_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_types",
                                ));
                            }
                            result.entity_types = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EntityType>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for EntityTypeBatch {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entity_types.is_empty() {
            state.serialize_entry("entityTypes", &self.entity_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// You can create multiple versions of your agent and publish them to separate
/// environments.
///
/// When you edit an agent, you are editing the draft agent. At any point, you
/// can save the draft agent as an agent version, which is an immutable snapshot
/// of your agent.
///
/// When you save the draft agent, it is published to the default environment.
/// When you create agent versions, you can publish them to custom environments.
/// You can create a variety of custom environments for:
///
/// - testing
/// - development
/// - production
/// - etc.
///
/// For more information, see the [versions and environments
/// guide](https://cloud.google.com/dialogflow/docs/agents-versions).
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Environment {
    /// Output only. The unique identifier of this agent environment.
    /// Supported formats:
    ///
    /// - `projects/<Project ID>/agent/environments/<Environment ID>`
    /// - `projects/<Project ID>/locations/<Location
    ///   ID>/agent/environments/<Environment ID>`
    ///
    /// The environment ID for the default environment is `-`.
    pub name: std::string::String,

    /// Optional. The developer-provided description for this environment.
    /// The maximum length is 500 characters. If exceeded, the request is rejected.
    pub description: std::string::String,

    /// Optional. The agent version loaded into this environment.
    /// Supported formats:
    ///
    /// - `projects/<Project ID>/agent/versions/<Version ID>`
    /// - `projects/<Project ID>/locations/<Location ID>/agent/versions/<Version
    ///   ID>`
    pub agent_version: std::string::String,

    /// Output only. The state of this environment. This field is read-only, i.e.,
    /// it cannot be set by create and update methods.
    pub state: crate::model::environment::State,

    /// Output only. The last update time of this environment. This field is
    /// read-only, i.e., it cannot be set by create and update methods.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Text to speech settings for this environment.
    pub text_to_speech_settings: std::option::Option<crate::model::TextToSpeechSettings>,

    /// Optional. The fulfillment settings to use for this environment.
    pub fulfillment: std::option::Option<crate::model::Fulfillment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl Environment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Environment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Environment::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [agent_version][crate::model::Environment::agent_version].
    pub fn set_agent_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.agent_version = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Environment::state].
    pub fn set_state<T: std::convert::Into<crate::model::environment::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Environment::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Environment::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [text_to_speech_settings][crate::model::Environment::text_to_speech_settings].
    pub fn set_text_to_speech_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TextToSpeechSettings>,
    {
        self.text_to_speech_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [text_to_speech_settings][crate::model::Environment::text_to_speech_settings].
    pub fn set_or_clear_text_to_speech_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TextToSpeechSettings>,
    {
        self.text_to_speech_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fulfillment][crate::model::Environment::fulfillment].
    pub fn set_fulfillment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Fulfillment>,
    {
        self.fulfillment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fulfillment][crate::model::Environment::fulfillment].
    pub fn set_or_clear_fulfillment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Fulfillment>,
    {
        self.fulfillment = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for Environment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.Environment"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Environment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __agent_version,
            __state,
            __update_time,
            __text_to_speech_settings,
            __fulfillment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Environment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "agentVersion" => Ok(__FieldTag::__agent_version),
                            "agent_version" => Ok(__FieldTag::__agent_version),
                            "state" => Ok(__FieldTag::__state),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "textToSpeechSettings" => Ok(__FieldTag::__text_to_speech_settings),
                            "text_to_speech_settings" => Ok(__FieldTag::__text_to_speech_settings),
                            "fulfillment" => Ok(__FieldTag::__fulfillment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Environment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Environment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__agent_version => {
                            if !fields.insert(__FieldTag::__agent_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for agent_version",
                                ));
                            }
                            result.agent_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::environment::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__text_to_speech_settings => {
                            if !fields.insert(__FieldTag::__text_to_speech_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text_to_speech_settings",
                                ));
                            }
                            result.text_to_speech_settings = map.next_value::<std::option::Option<crate::model::TextToSpeechSettings>>()?
                                ;
                        }
                        __FieldTag::__fulfillment => {
                            if !fields.insert(__FieldTag::__fulfillment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fulfillment",
                                ));
                            }
                            result.fulfillment =
                                map.next_value::<std::option::Option<crate::model::Fulfillment>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for Environment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.agent_version.is_empty() {
            state.serialize_entry("agentVersion", &self.agent_version)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.text_to_speech_settings.is_some() {
            state.serialize_entry("textToSpeechSettings", &self.text_to_speech_settings)?;
        }
        if self.fulfillment.is_some() {
            state.serialize_entry("fulfillment", &self.fulfillment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Environment].
#[cfg(feature = "environments")]
pub mod environment {
    #[allow(unused_imports)]
    use super::*;

    /// Represents an environment state. When an environment is pointed to a new
    /// agent version, the environment is temporarily set to the `LOADING` state.
    /// During that time, the environment keeps on serving the previous version of
    /// the agent. After the new agent version is done loading, the environment is
    /// set back to the `RUNNING` state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "environments")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not specified. This value is not used.
        Unspecified,
        /// Stopped.
        Stopped,
        /// Loading.
        Loading,
        /// Running.
        Running,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "environments")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "environments")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Stopped => std::option::Option::Some(1),
                Self::Loading => std::option::Option::Some(2),
                Self::Running => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Loading => std::option::Option::Some("LOADING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "environments")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "environments")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "environments")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Stopped,
                2 => Self::Loading,
                3 => Self::Running,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "environments")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "STOPPED" => Self::Stopped,
                "LOADING" => Self::Loading,
                "RUNNING" => Self::Running,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "environments")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Stopped => serializer.serialize_i32(1),
                Self::Loading => serializer.serialize_i32(2),
                Self::Running => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "environments")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dialogflow.v2.Environment.State",
            ))
        }
    }
}

/// Instructs the speech synthesizer on how to generate the output audio content.
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TextToSpeechSettings {
    /// Optional. Indicates whether text to speech is enabled. Even when this field
    /// is false, other settings in this proto are still retained.
    pub enable_text_to_speech: bool,

    /// Required. Audio encoding of the synthesized audio content.
    pub output_audio_encoding: crate::model::OutputAudioEncoding,

    /// Optional. The synthesis sample rate (in hertz) for this audio. If not
    /// provided, then the synthesizer will use the default sample rate based on
    /// the audio encoding. If this is different from the voice's natural sample
    /// rate, then the synthesizer will honor this request by converting to the
    /// desired sample rate (which might result in worse audio quality).
    pub sample_rate_hertz: i32,

    /// Optional. Configuration of how speech should be synthesized, mapping from
    /// language (<https://cloud.google.com/dialogflow/docs/reference/language>) to
    /// SynthesizeSpeechConfig.
    pub synthesize_speech_configs:
        std::collections::HashMap<std::string::String, crate::model::SynthesizeSpeechConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl TextToSpeechSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_text_to_speech][crate::model::TextToSpeechSettings::enable_text_to_speech].
    pub fn set_enable_text_to_speech<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_text_to_speech = v.into();
        self
    }

    /// Sets the value of [output_audio_encoding][crate::model::TextToSpeechSettings::output_audio_encoding].
    pub fn set_output_audio_encoding<T: std::convert::Into<crate::model::OutputAudioEncoding>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_audio_encoding = v.into();
        self
    }

    /// Sets the value of [sample_rate_hertz][crate::model::TextToSpeechSettings::sample_rate_hertz].
    pub fn set_sample_rate_hertz<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.sample_rate_hertz = v.into();
        self
    }

    /// Sets the value of [synthesize_speech_configs][crate::model::TextToSpeechSettings::synthesize_speech_configs].
    pub fn set_synthesize_speech_configs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::SynthesizeSpeechConfig>,
    {
        use std::iter::Iterator;
        self.synthesize_speech_configs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for TextToSpeechSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.TextToSpeechSettings"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TextToSpeechSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_text_to_speech,
            __output_audio_encoding,
            __sample_rate_hertz,
            __synthesize_speech_configs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TextToSpeechSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableTextToSpeech" => Ok(__FieldTag::__enable_text_to_speech),
                            "enable_text_to_speech" => Ok(__FieldTag::__enable_text_to_speech),
                            "outputAudioEncoding" => Ok(__FieldTag::__output_audio_encoding),
                            "output_audio_encoding" => Ok(__FieldTag::__output_audio_encoding),
                            "sampleRateHertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "sample_rate_hertz" => Ok(__FieldTag::__sample_rate_hertz),
                            "synthesizeSpeechConfigs" => {
                                Ok(__FieldTag::__synthesize_speech_configs)
                            }
                            "synthesize_speech_configs" => {
                                Ok(__FieldTag::__synthesize_speech_configs)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TextToSpeechSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TextToSpeechSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_text_to_speech => {
                            if !fields.insert(__FieldTag::__enable_text_to_speech) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_text_to_speech",
                                ));
                            }
                            result.enable_text_to_speech = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_audio_encoding => {
                            if !fields.insert(__FieldTag::__output_audio_encoding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_audio_encoding",
                                ));
                            }
                            result.output_audio_encoding = map.next_value::<std::option::Option<crate::model::OutputAudioEncoding>>()?.unwrap_or_default();
                        }
                        __FieldTag::__sample_rate_hertz => {
                            if !fields.insert(__FieldTag::__sample_rate_hertz) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sample_rate_hertz",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sample_rate_hertz =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__synthesize_speech_configs => {
                            if !fields.insert(__FieldTag::__synthesize_speech_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for synthesize_speech_configs",
                                ));
                            }
                            result.synthesize_speech_configs = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::SynthesizeSpeechConfig,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for TextToSpeechSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_text_to_speech) {
            state.serialize_entry("enableTextToSpeech", &self.enable_text_to_speech)?;
        }
        if !wkt::internal::is_default(&self.output_audio_encoding) {
            state.serialize_entry("outputAudioEncoding", &self.output_audio_encoding)?;
        }
        if !wkt::internal::is_default(&self.sample_rate_hertz) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sampleRateHertz", &__With(&self.sample_rate_hertz))?;
        }
        if !self.synthesize_speech_configs.is_empty() {
            state.serialize_entry("synthesizeSpeechConfigs", &self.synthesize_speech_configs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Environments.ListEnvironments][google.cloud.dialogflow.v2.Environments.ListEnvironments].
///
/// [google.cloud.dialogflow.v2.Environments.ListEnvironments]: crate::client::Environments::list_environments
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEnvironmentsRequest {
    /// Required. The agent to list all environments from.
    /// Format:
    ///
    /// - `projects/<Project ID>/agent`
    /// - `projects/<Project ID>/locations/<Location ID>/agent`
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl ListEnvironmentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEnvironmentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEnvironmentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEnvironmentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for ListEnvironmentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListEnvironmentsRequest"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEnvironmentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEnvironmentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEnvironmentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEnvironmentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for ListEnvironmentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Environments.ListEnvironments][google.cloud.dialogflow.v2.Environments.ListEnvironments].
///
/// [google.cloud.dialogflow.v2.Environments.ListEnvironments]: crate::client::Environments::list_environments
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEnvironmentsResponse {
    /// The list of agent environments. There will be a maximum number of items
    /// returned based on the page_size field in the request.
    pub environments: std::vec::Vec<crate::model::Environment>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl ListEnvironmentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environments][crate::model::ListEnvironmentsResponse::environments].
    pub fn set_environments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Environment>,
    {
        use std::iter::Iterator;
        self.environments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEnvironmentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for ListEnvironmentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListEnvironmentsResponse"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEnvironmentsResponse {
    type PageItem = crate::model::Environment;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.environments
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEnvironmentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environments,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEnvironmentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environments" => Ok(__FieldTag::__environments),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEnvironmentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEnvironmentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environments => {
                            if !fields.insert(__FieldTag::__environments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environments",
                                ));
                            }
                            result.environments = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Environment>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for ListEnvironmentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.environments.is_empty() {
            state.serialize_entry("environments", &self.environments)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Environments.GetEnvironment][google.cloud.dialogflow.v2.Environments.GetEnvironment].
///
/// [google.cloud.dialogflow.v2.Environments.GetEnvironment]: crate::client::Environments::get_environment
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEnvironmentRequest {
    /// Required. The name of the environment.
    /// Supported formats:
    ///
    /// - `projects/<Project ID>/agent/environments/<Environment ID>`
    /// - `projects/<Project ID>/locations/<Location
    ///   ID>/agent/environments/<Environment ID>`
    ///
    /// The environment ID for the default environment is `-`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl GetEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEnvironmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for GetEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetEnvironmentRequest"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for GetEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Environments.CreateEnvironment][google.cloud.dialogflow.v2.Environments.CreateEnvironment].
///
/// [google.cloud.dialogflow.v2.Environments.CreateEnvironment]: crate::client::Environments::create_environment
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateEnvironmentRequest {
    /// Required. The agent to create an environment for.
    /// Supported formats:
    ///
    /// - `projects/<Project ID>/agent`
    /// - `projects/<Project ID>/locations/<Location ID>/agent`
    pub parent: std::string::String,

    /// Required. The environment to create.
    pub environment: std::option::Option<crate::model::Environment>,

    /// Required. The unique id of the new environment.
    pub environment_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl CreateEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEnvironmentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [environment][crate::model::CreateEnvironmentRequest::environment].
    pub fn set_environment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Environment>,
    {
        self.environment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [environment][crate::model::CreateEnvironmentRequest::environment].
    pub fn set_or_clear_environment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Environment>,
    {
        self.environment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [environment_id][crate::model::CreateEnvironmentRequest::environment_id].
    pub fn set_environment_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.environment_id = v.into();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for CreateEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CreateEnvironmentRequest"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __environment,
            __environment_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "environment" => Ok(__FieldTag::__environment),
                            "environmentId" => Ok(__FieldTag::__environment_id),
                            "environment_id" => Ok(__FieldTag::__environment_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment =
                                map.next_value::<std::option::Option<crate::model::Environment>>()?;
                        }
                        __FieldTag::__environment_id => {
                            if !fields.insert(__FieldTag::__environment_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment_id",
                                ));
                            }
                            result.environment_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.environment.is_some() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if !self.environment_id.is_empty() {
            state.serialize_entry("environmentId", &self.environment_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Environments.UpdateEnvironment][google.cloud.dialogflow.v2.Environments.UpdateEnvironment].
///
/// [google.cloud.dialogflow.v2.Environments.UpdateEnvironment]: crate::client::Environments::update_environment
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateEnvironmentRequest {
    /// Required. The environment to update.
    pub environment: std::option::Option<crate::model::Environment>,

    /// Required. The mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. This field is used to prevent accidental overwrite of the default
    /// environment, which is an operation that cannot be undone. To confirm that
    /// the caller desires this overwrite, this field must be explicitly set to
    /// true when updating the default environment (environment ID = `-`).
    pub allow_load_to_draft_and_discard_changes: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl UpdateEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [environment][crate::model::UpdateEnvironmentRequest::environment].
    pub fn set_environment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Environment>,
    {
        self.environment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [environment][crate::model::UpdateEnvironmentRequest::environment].
    pub fn set_or_clear_environment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Environment>,
    {
        self.environment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEnvironmentRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEnvironmentRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_load_to_draft_and_discard_changes][crate::model::UpdateEnvironmentRequest::allow_load_to_draft_and_discard_changes].
    pub fn set_allow_load_to_draft_and_discard_changes<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.allow_load_to_draft_and_discard_changes = v.into();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for UpdateEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.UpdateEnvironmentRequest"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __environment,
            __update_mask,
            __allow_load_to_draft_and_discard_changes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "environment" => Ok(__FieldTag::__environment),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "allowLoadToDraftAndDiscardChanges" => {
                                Ok(__FieldTag::__allow_load_to_draft_and_discard_changes)
                            }
                            "allow_load_to_draft_and_discard_changes" => {
                                Ok(__FieldTag::__allow_load_to_draft_and_discard_changes)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__environment => {
                            if !fields.insert(__FieldTag::__environment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for environment",
                                ));
                            }
                            result.environment =
                                map.next_value::<std::option::Option<crate::model::Environment>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__allow_load_to_draft_and_discard_changes => {
                            if !fields.insert(__FieldTag::__allow_load_to_draft_and_discard_changes)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_load_to_draft_and_discard_changes",
                                ));
                            }
                            result.allow_load_to_draft_and_discard_changes = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.environment.is_some() {
            state.serialize_entry("environment", &self.environment)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.allow_load_to_draft_and_discard_changes) {
            state.serialize_entry(
                "allowLoadToDraftAndDiscardChanges",
                &self.allow_load_to_draft_and_discard_changes,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Environments.DeleteEnvironment][google.cloud.dialogflow.v2.Environments.DeleteEnvironment].
///
/// [google.cloud.dialogflow.v2.Environments.DeleteEnvironment]: crate::client::Environments::delete_environment
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteEnvironmentRequest {
    /// Required. The name of the environment to delete.
    /// / Format:
    ///
    /// - `projects/<Project ID>/agent/environments/<Environment ID>`
    /// - `projects/<Project ID>/locations/<Location
    ///   ID>/agent/environments/<Environment ID>`
    ///
    /// The environment ID for the default environment is `-`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl DeleteEnvironmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEnvironmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for DeleteEnvironmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DeleteEnvironmentRequest"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteEnvironmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteEnvironmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteEnvironmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteEnvironmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteEnvironmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Environments.GetEnvironmentHistory][google.cloud.dialogflow.v2.Environments.GetEnvironmentHistory].
///
/// [google.cloud.dialogflow.v2.Environments.GetEnvironmentHistory]: crate::client::Environments::get_environment_history
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEnvironmentHistoryRequest {
    /// Required. The name of the environment to retrieve history for.
    /// Supported formats:
    ///
    /// - `projects/<Project ID>/agent/environments/<Environment ID>`
    /// - `projects/<Project ID>/locations/<Location
    ///   ID>/agent/environments/<Environment ID>`
    ///
    /// The environment ID for the default environment is `-`.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl GetEnvironmentHistoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GetEnvironmentHistoryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::GetEnvironmentHistoryRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::GetEnvironmentHistoryRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for GetEnvironmentHistoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetEnvironmentHistoryRequest"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEnvironmentHistoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEnvironmentHistoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEnvironmentHistoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEnvironmentHistoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for GetEnvironmentHistoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Environments.GetEnvironmentHistory][google.cloud.dialogflow.v2.Environments.GetEnvironmentHistory].
///
/// [google.cloud.dialogflow.v2.Environments.GetEnvironmentHistory]: crate::client::Environments::get_environment_history
#[cfg(feature = "environments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EnvironmentHistory {
    /// Output only. The name of the environment this history is for.
    /// Supported formats:
    ///
    /// - `projects/<Project ID>/agent/environments/<Environment ID>`
    /// - `projects/<Project ID>/locations/<Location
    ///   ID>/agent/environments/<Environment ID>`
    ///
    /// The environment ID for the default environment is `-`.
    pub parent: std::string::String,

    /// Output only. The list of agent environments. There will be a maximum number
    /// of items returned based on the page_size field in the request.
    pub entries: std::vec::Vec<crate::model::environment_history::Entry>,

    /// Output only. Token to retrieve the next page of results, or empty if there
    /// are no more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "environments")]
impl EnvironmentHistory {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::EnvironmentHistory::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entries][crate::model::EnvironmentHistory::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::environment_history::Entry>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::EnvironmentHistory::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "environments")]
impl wkt::message::Message for EnvironmentHistory {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.EnvironmentHistory"
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for EnvironmentHistory {
    type PageItem = crate::model::environment_history::Entry;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entries
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnvironmentHistory {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entries,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnvironmentHistory")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entries" => Ok(__FieldTag::__entries),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnvironmentHistory;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnvironmentHistory")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::environment_history::Entry>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "environments")]
#[doc(hidden)]
impl serde::ser::Serialize for EnvironmentHistory {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EnvironmentHistory].
#[cfg(feature = "environments")]
pub mod environment_history {
    #[allow(unused_imports)]
    use super::*;

    /// Represents an environment history entry.
    #[cfg(feature = "environments")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Entry {
        /// The agent version loaded into this environment history entry.
        pub agent_version: std::string::String,

        /// The developer-provided description for this environment history entry.
        pub description: std::string::String,

        /// The creation time of this environment history entry.
        pub create_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "environments")]
    impl Entry {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [agent_version][crate::model::environment_history::Entry::agent_version].
        pub fn set_agent_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.agent_version = v.into();
            self
        }

        /// Sets the value of [description][crate::model::environment_history::Entry::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [create_time][crate::model::environment_history::Entry::create_time].
        pub fn set_create_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.create_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [create_time][crate::model::environment_history::Entry::create_time].
        pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.create_time = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "environments")]
    impl wkt::message::Message for Entry {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.EnvironmentHistory.Entry"
        }
    }

    #[cfg(feature = "environments")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Entry {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __agent_version,
                __description,
                __create_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Entry")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "agentVersion" => Ok(__FieldTag::__agent_version),
                                "agent_version" => Ok(__FieldTag::__agent_version),
                                "description" => Ok(__FieldTag::__description),
                                "createTime" => Ok(__FieldTag::__create_time),
                                "create_time" => Ok(__FieldTag::__create_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Entry;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Entry")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__agent_version => {
                                if !fields.insert(__FieldTag::__agent_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for agent_version",
                                    ));
                                }
                                result.agent_version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__create_time => {
                                if !fields.insert(__FieldTag::__create_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for create_time",
                                    ));
                                }
                                result.create_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "environments")]
    #[doc(hidden)]
    impl serde::ser::Serialize for Entry {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.agent_version.is_empty() {
                state.serialize_entry("agentVersion", &self.agent_version)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if self.create_time.is_some() {
                state.serialize_entry("createTime", &self.create_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// By default, your agent responds to a matched intent with a static response.
/// As an alternative, you can provide a more dynamic response by using
/// fulfillment. When you enable fulfillment for an intent, Dialogflow responds
/// to that intent by calling a service that you define. For example, if an
/// end-user wants to schedule a haircut on Friday, your service can check your
/// database and respond to the end-user with availability information for
/// Friday.
///
/// For more information, see the [fulfillment
/// guide](https://cloud.google.com/dialogflow/docs/fulfillment-overview).
#[cfg(any(feature = "environments", feature = "fulfillments",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Fulfillment {
    /// Required. The unique identifier of the fulfillment.
    /// Supported formats:
    ///
    /// - `projects/<Project ID>/agent/fulfillment`
    /// - `projects/<Project ID>/locations/<Location ID>/agent/fulfillment`
    ///
    /// This field is not used for Fulfillment in an Environment.
    pub name: std::string::String,

    /// Optional. The human-readable name of the fulfillment, unique within the
    /// agent.
    ///
    /// This field is not used for Fulfillment in an Environment.
    pub display_name: std::string::String,

    /// Optional. Whether fulfillment is enabled.
    pub enabled: bool,

    /// Optional. The field defines whether the fulfillment is enabled for certain
    /// features.
    pub features: std::vec::Vec<crate::model::fulfillment::Feature>,

    /// Required. The fulfillment configuration.
    pub fulfillment: std::option::Option<crate::model::fulfillment::Fulfillment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "environments", feature = "fulfillments",))]
impl Fulfillment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Fulfillment::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Fulfillment::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [enabled][crate::model::Fulfillment::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [features][crate::model::Fulfillment::features].
    pub fn set_features<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::fulfillment::Feature>,
    {
        use std::iter::Iterator;
        self.features = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [fulfillment][crate::model::Fulfillment::fulfillment].
    ///
    /// Note that all the setters affecting `fulfillment` are mutually
    /// exclusive.
    pub fn set_fulfillment<
        T: std::convert::Into<std::option::Option<crate::model::fulfillment::Fulfillment>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.fulfillment = v.into();
        self
    }

    /// The value of [fulfillment][crate::model::Fulfillment::fulfillment]
    /// if it holds a `GenericWebService`, `None` if the field is not set or
    /// holds a different branch.
    pub fn generic_web_service(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::fulfillment::GenericWebService>> {
        #[allow(unreachable_patterns)]
        self.fulfillment.as_ref().and_then(|v| match v {
            crate::model::fulfillment::Fulfillment::GenericWebService(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [fulfillment][crate::model::Fulfillment::fulfillment]
    /// to hold a `GenericWebService`.
    ///
    /// Note that all the setters affecting `fulfillment` are
    /// mutually exclusive.
    pub fn set_generic_web_service<
        T: std::convert::Into<std::boxed::Box<crate::model::fulfillment::GenericWebService>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.fulfillment = std::option::Option::Some(
            crate::model::fulfillment::Fulfillment::GenericWebService(v.into()),
        );
        self
    }
}

#[cfg(any(feature = "environments", feature = "fulfillments",))]
impl wkt::message::Message for Fulfillment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.Fulfillment"
    }
}

#[cfg(any(feature = "environments", feature = "fulfillments",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Fulfillment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __generic_web_service,
            __enabled,
            __features,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Fulfillment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "genericWebService" => Ok(__FieldTag::__generic_web_service),
                            "generic_web_service" => Ok(__FieldTag::__generic_web_service),
                            "enabled" => Ok(__FieldTag::__enabled),
                            "features" => Ok(__FieldTag::__features),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Fulfillment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Fulfillment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generic_web_service => {
                            if !fields.insert(__FieldTag::__generic_web_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generic_web_service",
                                ));
                            }
                            if result.fulfillment.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `fulfillment`, a oneof with full ID .google.cloud.dialogflow.v2.Fulfillment.generic_web_service, latest field was genericWebService",
                                ));
                            }
                            result.fulfillment = std::option::Option::Some(
                                crate::model::fulfillment::Fulfillment::GenericWebService(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::fulfillment::GenericWebService,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__features => {
                            if !fields.insert(__FieldTag::__features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for features",
                                ));
                            }
                            result.features = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::fulfillment::Feature>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "environments", feature = "fulfillments",))]
#[doc(hidden)]
impl serde::ser::Serialize for Fulfillment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if let Some(value) = self.generic_web_service() {
            state.serialize_entry("genericWebService", value)?;
        }
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self.features.is_empty() {
            state.serialize_entry("features", &self.features)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Fulfillment].
#[cfg(any(feature = "environments", feature = "fulfillments",))]
pub mod fulfillment {
    #[allow(unused_imports)]
    use super::*;

    /// Represents configuration for a generic web service.
    /// Dialogflow supports two mechanisms for authentications:
    ///
    /// - Basic authentication with username and password.
    /// - Authentication with additional authentication headers.
    ///
    /// More information could be found at:
    /// <https://cloud.google.com/dialogflow/docs/fulfillment-configure>.
    #[cfg(any(feature = "environments", feature = "fulfillments",))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GenericWebService {
        /// Required. The fulfillment URI for receiving POST requests.
        /// It must use https protocol.
        pub uri: std::string::String,

        /// Optional. The user name for HTTP Basic authentication.
        pub username: std::string::String,

        /// Optional. The password for HTTP Basic authentication.
        pub password: std::string::String,

        /// Optional. The HTTP request headers to send together with fulfillment
        /// requests.
        pub request_headers: std::collections::HashMap<std::string::String, std::string::String>,

        /// Optional. Indicates if generic web service is created through Cloud
        /// Functions integration. Defaults to false.
        ///
        /// is_cloud_function is deprecated. Cloud functions can be configured by
        /// its uri as a regular web service now.
        #[deprecated]
        pub is_cloud_function: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "environments", feature = "fulfillments",))]
    impl GenericWebService {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uri][crate::model::fulfillment::GenericWebService::uri].
        pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uri = v.into();
            self
        }

        /// Sets the value of [username][crate::model::fulfillment::GenericWebService::username].
        pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.username = v.into();
            self
        }

        /// Sets the value of [password][crate::model::fulfillment::GenericWebService::password].
        pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.password = v.into();
            self
        }

        /// Sets the value of [request_headers][crate::model::fulfillment::GenericWebService::request_headers].
        pub fn set_request_headers<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.request_headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [is_cloud_function][crate::model::fulfillment::GenericWebService::is_cloud_function].
        #[deprecated]
        pub fn set_is_cloud_function<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.is_cloud_function = v.into();
            self
        }
    }

    #[cfg(any(feature = "environments", feature = "fulfillments",))]
    impl wkt::message::Message for GenericWebService {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.Fulfillment.GenericWebService"
        }
    }

    #[cfg(any(feature = "environments", feature = "fulfillments",))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GenericWebService {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __uri,
                __username,
                __password,
                __request_headers,
                __is_cloud_function,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GenericWebService")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "uri" => Ok(__FieldTag::__uri),
                                "username" => Ok(__FieldTag::__username),
                                "password" => Ok(__FieldTag::__password),
                                "requestHeaders" => Ok(__FieldTag::__request_headers),
                                "request_headers" => Ok(__FieldTag::__request_headers),
                                "isCloudFunction" => Ok(__FieldTag::__is_cloud_function),
                                "is_cloud_function" => Ok(__FieldTag::__is_cloud_function),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GenericWebService;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GenericWebService")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__uri => {
                                if !fields.insert(__FieldTag::__uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uri",
                                    ));
                                }
                                result.uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__username => {
                                if !fields.insert(__FieldTag::__username) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for username",
                                    ));
                                }
                                result.username = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__password => {
                                if !fields.insert(__FieldTag::__password) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for password",
                                    ));
                                }
                                result.password = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__request_headers => {
                                if !fields.insert(__FieldTag::__request_headers) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for request_headers",
                                    ));
                                }
                                result.request_headers = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__is_cloud_function => {
                                if !fields.insert(__FieldTag::__is_cloud_function) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for is_cloud_function",
                                    ));
                                }
                                result.is_cloud_function = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(feature = "environments", feature = "fulfillments",))]
    #[doc(hidden)]
    impl serde::ser::Serialize for GenericWebService {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.uri.is_empty() {
                state.serialize_entry("uri", &self.uri)?;
            }
            if !self.username.is_empty() {
                state.serialize_entry("username", &self.username)?;
            }
            if !self.password.is_empty() {
                state.serialize_entry("password", &self.password)?;
            }
            if !self.request_headers.is_empty() {
                state.serialize_entry("requestHeaders", &self.request_headers)?;
            }
            if !wkt::internal::is_default(&self.is_cloud_function) {
                state.serialize_entry("isCloudFunction", &self.is_cloud_function)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Whether fulfillment is enabled for the specific feature.
    #[cfg(any(feature = "environments", feature = "fulfillments",))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Feature {
        /// The type of the feature that enabled for fulfillment.
        pub r#type: crate::model::fulfillment::feature::Type,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "environments", feature = "fulfillments",))]
    impl Feature {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::fulfillment::Feature::type].
        pub fn set_type<T: std::convert::Into<crate::model::fulfillment::feature::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }
    }

    #[cfg(any(feature = "environments", feature = "fulfillments",))]
    impl wkt::message::Message for Feature {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.Fulfillment.Feature"
        }
    }

    #[cfg(any(feature = "environments", feature = "fulfillments",))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Feature {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Feature")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "type" => Ok(__FieldTag::__type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Feature;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Feature")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type =
                                    map.next_value::<std::option::Option<
                                        crate::model::fulfillment::feature::Type,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(feature = "environments", feature = "fulfillments",))]
    #[doc(hidden)]
    impl serde::ser::Serialize for Feature {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Feature].
    #[cfg(any(feature = "environments", feature = "fulfillments",))]
    pub mod feature {
        #[allow(unused_imports)]
        use super::*;

        /// The type of the feature.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(any(feature = "environments", feature = "fulfillments",))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// Feature type not specified.
            Unspecified,
            /// Fulfillment is enabled for SmallTalk.
            Smalltalk,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Type::value] or
            /// [Type::name].
            UnknownValue(r#type::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(any(feature = "environments", feature = "fulfillments",))]
        pub mod r#type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(any(feature = "environments", feature = "fulfillments",))]
        impl Type {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Smalltalk => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                    Self::Smalltalk => std::option::Option::Some("SMALLTALK"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(any(feature = "environments", feature = "fulfillments",))]
        impl std::default::Default for Type {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(any(feature = "environments", feature = "fulfillments",))]
        impl std::fmt::Display for Type {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(any(feature = "environments", feature = "fulfillments",))]
        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Smalltalk,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(any(feature = "environments", feature = "fulfillments",))]
        impl std::convert::From<&str> for Type {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TYPE_UNSPECIFIED" => Self::Unspecified,
                    "SMALLTALK" => Self::Smalltalk,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(any(feature = "environments", feature = "fulfillments",))]
        impl serde::ser::Serialize for Type {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Smalltalk => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(any(feature = "environments", feature = "fulfillments",))]
        impl<'de> serde::de::Deserialize<'de> for Type {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                    ".google.cloud.dialogflow.v2.Fulfillment.Feature.Type",
                ))
            }
        }
    }

    /// Required. The fulfillment configuration.
    #[cfg(any(feature = "environments", feature = "fulfillments",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Fulfillment {
        /// Configuration for a generic web service.
        GenericWebService(std::boxed::Box<crate::model::fulfillment::GenericWebService>),
    }
}

/// The request message for
/// [Fulfillments.GetFulfillment][google.cloud.dialogflow.v2.Fulfillments.GetFulfillment].
///
/// [google.cloud.dialogflow.v2.Fulfillments.GetFulfillment]: crate::client::Fulfillments::get_fulfillment
#[cfg(feature = "fulfillments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetFulfillmentRequest {
    /// Required. The name of the fulfillment.
    /// Format: `projects/<Project ID>/agent/fulfillment`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "fulfillments")]
impl GetFulfillmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetFulfillmentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "fulfillments")]
impl wkt::message::Message for GetFulfillmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetFulfillmentRequest"
    }
}

#[cfg(feature = "fulfillments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetFulfillmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetFulfillmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetFulfillmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetFulfillmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "fulfillments")]
#[doc(hidden)]
impl serde::ser::Serialize for GetFulfillmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Fulfillments.UpdateFulfillment][google.cloud.dialogflow.v2.Fulfillments.UpdateFulfillment].
///
/// [google.cloud.dialogflow.v2.Fulfillments.UpdateFulfillment]: crate::client::Fulfillments::update_fulfillment
#[cfg(feature = "fulfillments")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateFulfillmentRequest {
    /// Required. The fulfillment to update.
    pub fulfillment: std::option::Option<crate::model::Fulfillment>,

    /// Required. The mask to control which fields get updated. If the mask is not
    /// present, all fields will be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "fulfillments")]
impl UpdateFulfillmentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fulfillment][crate::model::UpdateFulfillmentRequest::fulfillment].
    pub fn set_fulfillment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Fulfillment>,
    {
        self.fulfillment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fulfillment][crate::model::UpdateFulfillmentRequest::fulfillment].
    pub fn set_or_clear_fulfillment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Fulfillment>,
    {
        self.fulfillment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateFulfillmentRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateFulfillmentRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "fulfillments")]
impl wkt::message::Message for UpdateFulfillmentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.UpdateFulfillmentRequest"
    }
}

#[cfg(feature = "fulfillments")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateFulfillmentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fulfillment,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateFulfillmentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fulfillment" => Ok(__FieldTag::__fulfillment),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateFulfillmentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateFulfillmentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fulfillment => {
                            if !fields.insert(__FieldTag::__fulfillment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fulfillment",
                                ));
                            }
                            result.fulfillment =
                                map.next_value::<std::option::Option<crate::model::Fulfillment>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "fulfillments")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateFulfillmentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.fulfillment.is_some() {
            state.serialize_entry("fulfillment", &self.fulfillment)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Google Cloud Storage location for the inputs.
#[cfg(any(feature = "conversation-datasets", feature = "documents",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsSources {
    /// Required. Google Cloud Storage URIs for the inputs. A URI is of the form:
    /// `gs://bucket/object-prefix-or-name`
    /// Whether a prefix or name is used depends on the use case.
    pub uris: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversation-datasets", feature = "documents",))]
impl GcsSources {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uris][crate::model::GcsSources::uris].
    pub fn set_uris<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.uris = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(feature = "conversation-datasets", feature = "documents",))]
impl wkt::message::Message for GcsSources {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GcsSources"
    }
}

#[cfg(any(feature = "conversation-datasets", feature = "documents",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsSources {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uris,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsSources")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uris" => Ok(__FieldTag::__uris),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsSources;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsSources")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uris => {
                            if !fields.insert(__FieldTag::__uris) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uris",
                                ));
                            }
                            result.uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversation-datasets", feature = "documents",))]
#[doc(hidden)]
impl serde::ser::Serialize for GcsSources {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uris.is_empty() {
            state.serialize_entry("uris", &self.uris)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Google Cloud Storage location for the output.
#[cfg(feature = "documents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsDestination {
    /// The Google Cloud Storage URIs for the output. A URI is of the
    /// form:
    /// `gs://bucket/object-prefix-or-name`
    /// Whether a prefix or name is used depends on the use case. The requesting
    /// user must have "write-permission" to the bucket.
    pub uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "documents")]
impl GcsDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uri][crate::model::GcsDestination::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }
}

#[cfg(feature = "documents")]
impl wkt::message::Message for GcsDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GcsDestination"
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsDestination {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsDestination")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uri" => Ok(__FieldTag::__uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsDestination;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsDestination")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "documents")]
#[doc(hidden)]
impl serde::ser::Serialize for GcsDestination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message of CreateGenerator.
#[cfg(feature = "generators")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateGeneratorRequest {
    /// Required. The project/location to create generator for. Format:
    /// `projects/<Project ID>/locations/<Location ID>`
    pub parent: std::string::String,

    /// Required. The generator to create.
    pub generator: std::option::Option<crate::model::Generator>,

    /// Optional. The ID to use for the generator, which will become the final
    /// component of the generator's resource name.
    ///
    /// The generator ID must be compliant with the regression formula
    /// `[a-zA-Z][a-zA-Z0-9_-]*` with the characters length in range of [3,64].
    /// If the field is not provided, an Id will be auto-generated.
    /// If the field is provided, the caller is responsible for
    ///
    /// 1. the uniqueness of the ID, otherwise the request will be rejected.
    /// 1. the consistency for whether to use custom ID or not under a project to
    ///    better ensure uniqueness.
    pub generator_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "generators")]
impl CreateGeneratorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateGeneratorRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [generator][crate::model::CreateGeneratorRequest::generator].
    pub fn set_generator<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Generator>,
    {
        self.generator = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [generator][crate::model::CreateGeneratorRequest::generator].
    pub fn set_or_clear_generator<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Generator>,
    {
        self.generator = v.map(|x| x.into());
        self
    }

    /// Sets the value of [generator_id][crate::model::CreateGeneratorRequest::generator_id].
    pub fn set_generator_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.generator_id = v.into();
        self
    }
}

#[cfg(feature = "generators")]
impl wkt::message::Message for CreateGeneratorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CreateGeneratorRequest"
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateGeneratorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __generator,
            __generator_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateGeneratorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "generator" => Ok(__FieldTag::__generator),
                            "generatorId" => Ok(__FieldTag::__generator_id),
                            "generator_id" => Ok(__FieldTag::__generator_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateGeneratorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateGeneratorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__generator => {
                            if !fields.insert(__FieldTag::__generator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generator",
                                ));
                            }
                            result.generator =
                                map.next_value::<std::option::Option<crate::model::Generator>>()?;
                        }
                        __FieldTag::__generator_id => {
                            if !fields.insert(__FieldTag::__generator_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generator_id",
                                ));
                            }
                            result.generator_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateGeneratorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.generator.is_some() {
            state.serialize_entry("generator", &self.generator)?;
        }
        if !self.generator_id.is_empty() {
            state.serialize_entry("generatorId", &self.generator_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message of GetGenerator.
#[cfg(feature = "generators")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetGeneratorRequest {
    /// Required. The generator resource name to retrieve. Format:
    /// `projects/<Project ID>/locations/<Location ID>/generators/<Generator ID>`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "generators")]
impl GetGeneratorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGeneratorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "generators")]
impl wkt::message::Message for GetGeneratorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetGeneratorRequest"
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetGeneratorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetGeneratorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetGeneratorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetGeneratorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for GetGeneratorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message of ListGenerators.
#[cfg(feature = "generators")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGeneratorsRequest {
    /// Required. The project/location to list generators for. Format:
    /// `projects/<Project ID>/locations/<Location ID>`
    pub parent: std::string::String,

    /// Optional. Maximum number of conversation models to return in a single page.
    /// Default to 10.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "generators")]
impl ListGeneratorsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGeneratorsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGeneratorsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGeneratorsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "generators")]
impl wkt::message::Message for ListGeneratorsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListGeneratorsRequest"
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGeneratorsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGeneratorsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGeneratorsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGeneratorsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for ListGeneratorsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response of ListGenerators.
#[cfg(feature = "generators")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGeneratorsResponse {
    /// List of generators retrieved.
    pub generators: std::vec::Vec<crate::model::Generator>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "generators")]
impl ListGeneratorsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generators][crate::model::ListGeneratorsResponse::generators].
    pub fn set_generators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Generator>,
    {
        use std::iter::Iterator;
        self.generators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListGeneratorsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "generators")]
impl wkt::message::Message for ListGeneratorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListGeneratorsResponse"
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListGeneratorsResponse {
    type PageItem = crate::model::Generator;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.generators
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGeneratorsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generators,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGeneratorsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generators" => Ok(__FieldTag::__generators),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGeneratorsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGeneratorsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generators => {
                            if !fields.insert(__FieldTag::__generators) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generators",
                                ));
                            }
                            result.generators = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Generator>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for ListGeneratorsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.generators.is_empty() {
            state.serialize_entry("generators", &self.generators)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request of DeleteGenerator.
#[cfg(feature = "generators")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteGeneratorRequest {
    /// Required. The generator resource name to delete. Format:
    /// `projects/<Project ID>/locations/<Location ID>/generators/<Generator ID>`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "generators")]
impl DeleteGeneratorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGeneratorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "generators")]
impl wkt::message::Message for DeleteGeneratorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DeleteGeneratorRequest"
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteGeneratorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteGeneratorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteGeneratorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteGeneratorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteGeneratorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request of UpdateGenerator.
#[cfg(feature = "generators")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateGeneratorRequest {
    /// Required. The generator to update.
    /// The name field of generator is to identify the generator to update.
    pub generator: std::option::Option<crate::model::Generator>,

    /// Optional. The list of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "generators")]
impl UpdateGeneratorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generator][crate::model::UpdateGeneratorRequest::generator].
    pub fn set_generator<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Generator>,
    {
        self.generator = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [generator][crate::model::UpdateGeneratorRequest::generator].
    pub fn set_or_clear_generator<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Generator>,
    {
        self.generator = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateGeneratorRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateGeneratorRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "generators")]
impl wkt::message::Message for UpdateGeneratorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.UpdateGeneratorRequest"
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateGeneratorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generator,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateGeneratorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generator" => Ok(__FieldTag::__generator),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateGeneratorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateGeneratorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generator => {
                            if !fields.insert(__FieldTag::__generator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generator",
                                ));
                            }
                            result.generator =
                                map.next_value::<std::option::Option<crate::model::Generator>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "generators")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateGeneratorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.generator.is_some() {
            state.serialize_entry("generator", &self.generator)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a message entry of a conversation.
#[cfg(any(feature = "conversations", feature = "generators",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MessageEntry {
    /// Optional. Participant role of the message.
    pub role: crate::model::message_entry::Role,

    /// Optional. Transcript content of the message.
    pub text: std::string::String,

    /// Optional. The language of the text. See [Language
    /// Support](https://cloud.google.com/dialogflow/docs/reference/language) for a
    /// list of the currently supported language codes.
    pub language_code: std::string::String,

    /// Optional. Create time of the message entry.
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl MessageEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [role][crate::model::MessageEntry::role].
    pub fn set_role<T: std::convert::Into<crate::model::message_entry::Role>>(
        mut self,
        v: T,
    ) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [text][crate::model::MessageEntry::text].
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.text = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::MessageEntry::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::MessageEntry::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::MessageEntry::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl wkt::message::Message for MessageEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.MessageEntry"
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MessageEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __role,
            __text,
            __language_code,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "role" => Ok(__FieldTag::__role),
                            "text" => Ok(__FieldTag::__text),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MessageEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__role => {
                            if !fields.insert(__FieldTag::__role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role",
                                ));
                            }
                            result.role = map.next_value::<std::option::Option<crate::model::message_entry::Role>>()?.unwrap_or_default();
                        }
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            result.text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl serde::ser::Serialize for MessageEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.role) {
            state.serialize_entry("role", &self.role)?;
        }
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [MessageEntry].
#[cfg(any(feature = "conversations", feature = "generators",))]
pub mod message_entry {
    #[allow(unused_imports)]
    use super::*;

    /// Enumeration of the roles a participant can play in a conversation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "conversations", feature = "generators",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Role {
        /// Participant role not set.
        Unspecified,
        /// Participant is a human agent.
        HumanAgent,
        /// Participant is an automated agent, such as a Dialogflow agent.
        AutomatedAgent,
        /// Participant is an end user that has called or chatted with
        /// Dialogflow services.
        EndUser,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Role::value] or
        /// [Role::name].
        UnknownValue(role::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "conversations", feature = "generators",))]
    pub mod role {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "conversations", feature = "generators",))]
    impl Role {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::HumanAgent => std::option::Option::Some(1),
                Self::AutomatedAgent => std::option::Option::Some(2),
                Self::EndUser => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLE_UNSPECIFIED"),
                Self::HumanAgent => std::option::Option::Some("HUMAN_AGENT"),
                Self::AutomatedAgent => std::option::Option::Some("AUTOMATED_AGENT"),
                Self::EndUser => std::option::Option::Some("END_USER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "conversations", feature = "generators",))]
    impl std::default::Default for Role {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "conversations", feature = "generators",))]
    impl std::fmt::Display for Role {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "conversations", feature = "generators",))]
    impl std::convert::From<i32> for Role {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::HumanAgent,
                2 => Self::AutomatedAgent,
                3 => Self::EndUser,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "conversations", feature = "generators",))]
    impl std::convert::From<&str> for Role {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLE_UNSPECIFIED" => Self::Unspecified,
                "HUMAN_AGENT" => Self::HumanAgent,
                "AUTOMATED_AGENT" => Self::AutomatedAgent,
                "END_USER" => Self::EndUser,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "conversations", feature = "generators",))]
    impl serde::ser::Serialize for Role {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::HumanAgent => serializer.serialize_i32(1),
                Self::AutomatedAgent => serializer.serialize_i32(2),
                Self::EndUser => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "conversations", feature = "generators",))]
    impl<'de> serde::de::Deserialize<'de> for Role {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Role>::new(
                ".google.cloud.dialogflow.v2.MessageEntry.Role",
            ))
        }
    }
}

/// Context of the conversation, including transcripts.
#[cfg(any(feature = "conversations", feature = "generators",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ConversationContext {
    /// Optional. List of message transcripts in the conversation.
    pub message_entries: std::vec::Vec<crate::model::MessageEntry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl ConversationContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message_entries][crate::model::ConversationContext::message_entries].
    pub fn set_message_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MessageEntry>,
    {
        use std::iter::Iterator;
        self.message_entries = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl wkt::message::Message for ConversationContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ConversationContext"
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConversationContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message_entries,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConversationContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "messageEntries" => Ok(__FieldTag::__message_entries),
                            "message_entries" => Ok(__FieldTag::__message_entries),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConversationContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConversationContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message_entries => {
                            if !fields.insert(__FieldTag::__message_entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_entries",
                                ));
                            }
                            result.message_entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MessageEntry>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl serde::ser::Serialize for ConversationContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message_entries.is_empty() {
            state.serialize_entry("messageEntries", &self.message_entries)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// List of summarization sections.
#[cfg(any(feature = "conversations", feature = "generators",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SummarizationSectionList {
    /// Optional. Summarization sections.
    pub summarization_sections: std::vec::Vec<crate::model::SummarizationSection>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl SummarizationSectionList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [summarization_sections][crate::model::SummarizationSectionList::summarization_sections].
    pub fn set_summarization_sections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SummarizationSection>,
    {
        use std::iter::Iterator;
        self.summarization_sections = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl wkt::message::Message for SummarizationSectionList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SummarizationSectionList"
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SummarizationSectionList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __summarization_sections,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SummarizationSectionList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "summarizationSections" => Ok(__FieldTag::__summarization_sections),
                            "summarization_sections" => Ok(__FieldTag::__summarization_sections),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SummarizationSectionList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SummarizationSectionList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__summarization_sections => {
                            if !fields.insert(__FieldTag::__summarization_sections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for summarization_sections",
                                ));
                            }
                            result.summarization_sections = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SummarizationSection>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl serde::ser::Serialize for SummarizationSectionList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.summarization_sections.is_empty() {
            state.serialize_entry("summarizationSections", &self.summarization_sections)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Providing examples in the generator (i.e. building a few-shot generator)
/// helps convey the desired format of the LLM response.
#[cfg(any(feature = "conversations", feature = "generators",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FewShotExample {
    /// Optional. Conversation transcripts.
    pub conversation_context: std::option::Option<crate::model::ConversationContext>,

    /// Optional. Key is the placeholder field name in input, value is the value of
    /// the placeholder. E.g. instruction contains "@price", and ingested data has
    /// <"price", "10">
    pub extra_info: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Example output of the model.
    pub output: std::option::Option<crate::model::GeneratorSuggestion>,

    /// Instruction list of this few_shot example.
    pub instruction_list: std::option::Option<crate::model::few_shot_example::InstructionList>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl FewShotExample {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation_context][crate::model::FewShotExample::conversation_context].
    pub fn set_conversation_context<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConversationContext>,
    {
        self.conversation_context = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [conversation_context][crate::model::FewShotExample::conversation_context].
    pub fn set_or_clear_conversation_context<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConversationContext>,
    {
        self.conversation_context = v.map(|x| x.into());
        self
    }

    /// Sets the value of [extra_info][crate::model::FewShotExample::extra_info].
    pub fn set_extra_info<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.extra_info = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [output][crate::model::FewShotExample::output].
    pub fn set_output<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GeneratorSuggestion>,
    {
        self.output = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output][crate::model::FewShotExample::output].
    pub fn set_or_clear_output<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GeneratorSuggestion>,
    {
        self.output = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instruction_list][crate::model::FewShotExample::instruction_list].
    ///
    /// Note that all the setters affecting `instruction_list` are mutually
    /// exclusive.
    pub fn set_instruction_list<
        T: std::convert::Into<std::option::Option<crate::model::few_shot_example::InstructionList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instruction_list = v.into();
        self
    }

    /// The value of [instruction_list][crate::model::FewShotExample::instruction_list]
    /// if it holds a `SummarizationSectionList`, `None` if the field is not set or
    /// holds a different branch.
    pub fn summarization_section_list(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SummarizationSectionList>> {
        #[allow(unreachable_patterns)]
        self.instruction_list.as_ref().and_then(|v| match v {
            crate::model::few_shot_example::InstructionList::SummarizationSectionList(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [instruction_list][crate::model::FewShotExample::instruction_list]
    /// to hold a `SummarizationSectionList`.
    ///
    /// Note that all the setters affecting `instruction_list` are
    /// mutually exclusive.
    pub fn set_summarization_section_list<
        T: std::convert::Into<std::boxed::Box<crate::model::SummarizationSectionList>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.instruction_list = std::option::Option::Some(
            crate::model::few_shot_example::InstructionList::SummarizationSectionList(v.into()),
        );
        self
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl wkt::message::Message for FewShotExample {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.FewShotExample"
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FewShotExample {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation_context,
            __extra_info,
            __summarization_section_list,
            __output,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FewShotExample")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversationContext" => Ok(__FieldTag::__conversation_context),
                            "conversation_context" => Ok(__FieldTag::__conversation_context),
                            "extraInfo" => Ok(__FieldTag::__extra_info),
                            "extra_info" => Ok(__FieldTag::__extra_info),
                            "summarizationSectionList" => {
                                Ok(__FieldTag::__summarization_section_list)
                            }
                            "summarization_section_list" => {
                                Ok(__FieldTag::__summarization_section_list)
                            }
                            "output" => Ok(__FieldTag::__output),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FewShotExample;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FewShotExample")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation_context => {
                            if !fields.insert(__FieldTag::__conversation_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation_context",
                                ));
                            }
                            result.conversation_context = map.next_value::<std::option::Option<crate::model::ConversationContext>>()?
                                ;
                        }
                        __FieldTag::__extra_info => {
                            if !fields.insert(__FieldTag::__extra_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extra_info",
                                ));
                            }
                            result.extra_info = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__summarization_section_list => {
                            if !fields.insert(__FieldTag::__summarization_section_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for summarization_section_list",
                                ));
                            }
                            if result.instruction_list.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `instruction_list`, a oneof with full ID .google.cloud.dialogflow.v2.FewShotExample.summarization_section_list, latest field was summarizationSectionList",
                                ));
                            }
                            result.instruction_list = std::option::Option::Some(
                                crate::model::few_shot_example::InstructionList::SummarizationSectionList(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SummarizationSectionList>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__output => {
                            if !fields.insert(__FieldTag::__output) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output",
                                ));
                            }
                            result.output = map.next_value::<std::option::Option<crate::model::GeneratorSuggestion>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl serde::ser::Serialize for FewShotExample {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.conversation_context.is_some() {
            state.serialize_entry("conversationContext", &self.conversation_context)?;
        }
        if !self.extra_info.is_empty() {
            state.serialize_entry("extraInfo", &self.extra_info)?;
        }
        if let Some(value) = self.summarization_section_list() {
            state.serialize_entry("summarizationSectionList", value)?;
        }
        if self.output.is_some() {
            state.serialize_entry("output", &self.output)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [FewShotExample].
#[cfg(any(feature = "conversations", feature = "generators",))]
pub mod few_shot_example {
    #[allow(unused_imports)]
    use super::*;

    /// Instruction list of this few_shot example.
    #[cfg(any(feature = "conversations", feature = "generators",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstructionList {
        /// Summarization sections.
        SummarizationSectionList(std::boxed::Box<crate::model::SummarizationSectionList>),
    }
}

/// The parameters of inference.
#[cfg(any(feature = "conversations", feature = "generators",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InferenceParameter {
    /// Optional. Maximum number of the output tokens for the generator.
    pub max_output_tokens: std::option::Option<i32>,

    /// Optional. Controls the randomness of LLM predictions.
    /// Low temperature = less random. High temperature = more random.
    /// If unset (or 0), uses a default value of 0.
    pub temperature: std::option::Option<f64>,

    /// Optional. Top-k changes how the model selects tokens for output. A top-k of
    /// 1 means the selected token is the most probable among all tokens in the
    /// model's vocabulary (also called greedy decoding), while a top-k of 3 means
    /// that the next token is selected from among the 3 most probable tokens
    /// (using temperature). For each token selection step, the top K tokens with
    /// the highest probabilities are sampled. Then tokens are further filtered
    /// based on topP with the final token selected using temperature sampling.
    /// Specify a lower value for less random responses and a higher value for more
    /// random responses. Acceptable value is [1, 40], default to 40.
    pub top_k: std::option::Option<i32>,

    /// Optional. Top-p changes how the model selects tokens for output. Tokens are
    /// selected from most K (see topK parameter) probable to least until the sum
    /// of their probabilities equals the top-p value. For example, if tokens A, B,
    /// and C have a probability of 0.3, 0.2, and 0.1 and the top-p value is 0.5,
    /// then the model will select either A or B as the next token (using
    /// temperature) and doesn't consider C. The default top-p value is 0.95.
    /// Specify a lower value for less random responses and a higher value for more
    /// random responses. Acceptable value is [0.0, 1.0], default to 0.95.
    pub top_p: std::option::Option<f64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl InferenceParameter {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_output_tokens][crate::model::InferenceParameter::max_output_tokens].
    pub fn set_max_output_tokens<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.max_output_tokens = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_output_tokens][crate::model::InferenceParameter::max_output_tokens].
    pub fn set_or_clear_max_output_tokens<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.max_output_tokens = v.map(|x| x.into());
        self
    }

    /// Sets the value of [temperature][crate::model::InferenceParameter::temperature].
    pub fn set_temperature<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.temperature = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [temperature][crate::model::InferenceParameter::temperature].
    pub fn set_or_clear_temperature<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.temperature = v.map(|x| x.into());
        self
    }

    /// Sets the value of [top_k][crate::model::InferenceParameter::top_k].
    pub fn set_top_k<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.top_k = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [top_k][crate::model::InferenceParameter::top_k].
    pub fn set_or_clear_top_k<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.top_k = v.map(|x| x.into());
        self
    }

    /// Sets the value of [top_p][crate::model::InferenceParameter::top_p].
    pub fn set_top_p<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.top_p = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [top_p][crate::model::InferenceParameter::top_p].
    pub fn set_or_clear_top_p<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.top_p = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl wkt::message::Message for InferenceParameter {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.InferenceParameter"
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InferenceParameter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_output_tokens,
            __temperature,
            __top_k,
            __top_p,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InferenceParameter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxOutputTokens" => Ok(__FieldTag::__max_output_tokens),
                            "max_output_tokens" => Ok(__FieldTag::__max_output_tokens),
                            "temperature" => Ok(__FieldTag::__temperature),
                            "topK" => Ok(__FieldTag::__top_k),
                            "top_k" => Ok(__FieldTag::__top_k),
                            "topP" => Ok(__FieldTag::__top_p),
                            "top_p" => Ok(__FieldTag::__top_p),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InferenceParameter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InferenceParameter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_output_tokens => {
                            if !fields.insert(__FieldTag::__max_output_tokens) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_output_tokens",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_output_tokens = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__temperature => {
                            if !fields.insert(__FieldTag::__temperature) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for temperature",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.temperature = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__top_k => {
                            if !fields.insert(__FieldTag::__top_k) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for top_k",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.top_k = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__top_p => {
                            if !fields.insert(__FieldTag::__top_p) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for top_p",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.top_p = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl serde::ser::Serialize for InferenceParameter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.max_output_tokens.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("maxOutputTokens", &__With(&self.max_output_tokens))?;
        }
        if self.temperature.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("temperature", &__With(&self.temperature))?;
        }
        if self.top_k.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("topK", &__With(&self.top_k))?;
        }
        if self.top_p.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("topP", &__With(&self.top_p))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the section of summarization.
#[cfg(any(feature = "conversations", feature = "generators",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SummarizationSection {
    /// Optional. Name of the section, for example, "situation".
    pub key: std::string::String,

    /// Optional. Definition of the section, for example, "what the customer needs
    /// help with or has question about."
    pub definition: std::string::String,

    /// Optional. Type of the summarization section.
    pub r#type: crate::model::summarization_section::Type,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl SummarizationSection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::SummarizationSection::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [definition][crate::model::SummarizationSection::definition].
    pub fn set_definition<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.definition = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::SummarizationSection::type].
    pub fn set_type<T: std::convert::Into<crate::model::summarization_section::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl wkt::message::Message for SummarizationSection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SummarizationSection"
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SummarizationSection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __definition,
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SummarizationSection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "definition" => Ok(__FieldTag::__definition),
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SummarizationSection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SummarizationSection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__definition => {
                            if !fields.insert(__FieldTag::__definition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for definition",
                                ));
                            }
                            result.definition = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::summarization_section::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl serde::ser::Serialize for SummarizationSection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self.definition.is_empty() {
            state.serialize_entry("definition", &self.definition)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SummarizationSection].
#[cfg(any(feature = "conversations", feature = "generators",))]
pub mod summarization_section {
    #[allow(unused_imports)]
    use super::*;

    /// Type enum of the summarization sections.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "conversations", feature = "generators",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Undefined section type, does not return anything.
        Unspecified,
        /// What the customer needs help with or has question about.
        /// Section name: "situation".
        Situation,
        /// What the agent does to help the customer.
        /// Section name: "action".
        Action,
        /// Result of the customer service. A single word describing the result
        /// of the conversation.
        /// Section name: "resolution".
        Resolution,
        /// Reason for cancellation if the customer requests for a cancellation.
        /// "N/A" otherwise.
        /// Section name: "reason_for_cancellation".
        ReasonForCancellation,
        /// "Unsatisfied" or "Satisfied" depending on the customer's feelings at
        /// the end of the conversation.
        /// Section name: "customer_satisfaction".
        CustomerSatisfaction,
        /// Key entities extracted from the conversation, such as ticket number,
        /// order number, dollar amount, etc.
        /// Section names are prefixed by "entities/".
        Entities,
        /// Customer defined sections.
        CustomerDefined,
        /// Concise version of the situation section. This type is only available if
        /// type SITUATION is not selected.
        SituationConcise,
        /// Concise version of the action section. This type is only available if
        /// type ACTION is not selected.
        ActionConcise,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "conversations", feature = "generators",))]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "conversations", feature = "generators",))]
    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Situation => std::option::Option::Some(1),
                Self::Action => std::option::Option::Some(2),
                Self::Resolution => std::option::Option::Some(3),
                Self::ReasonForCancellation => std::option::Option::Some(4),
                Self::CustomerSatisfaction => std::option::Option::Some(5),
                Self::Entities => std::option::Option::Some(6),
                Self::CustomerDefined => std::option::Option::Some(7),
                Self::SituationConcise => std::option::Option::Some(9),
                Self::ActionConcise => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Situation => std::option::Option::Some("SITUATION"),
                Self::Action => std::option::Option::Some("ACTION"),
                Self::Resolution => std::option::Option::Some("RESOLUTION"),
                Self::ReasonForCancellation => std::option::Option::Some("REASON_FOR_CANCELLATION"),
                Self::CustomerSatisfaction => std::option::Option::Some("CUSTOMER_SATISFACTION"),
                Self::Entities => std::option::Option::Some("ENTITIES"),
                Self::CustomerDefined => std::option::Option::Some("CUSTOMER_DEFINED"),
                Self::SituationConcise => std::option::Option::Some("SITUATION_CONCISE"),
                Self::ActionConcise => std::option::Option::Some("ACTION_CONCISE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "conversations", feature = "generators",))]
    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "conversations", feature = "generators",))]
    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "conversations", feature = "generators",))]
    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Situation,
                2 => Self::Action,
                3 => Self::Resolution,
                4 => Self::ReasonForCancellation,
                5 => Self::CustomerSatisfaction,
                6 => Self::Entities,
                7 => Self::CustomerDefined,
                9 => Self::SituationConcise,
                10 => Self::ActionConcise,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "conversations", feature = "generators",))]
    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "SITUATION" => Self::Situation,
                "ACTION" => Self::Action,
                "RESOLUTION" => Self::Resolution,
                "REASON_FOR_CANCELLATION" => Self::ReasonForCancellation,
                "CUSTOMER_SATISFACTION" => Self::CustomerSatisfaction,
                "ENTITIES" => Self::Entities,
                "CUSTOMER_DEFINED" => Self::CustomerDefined,
                "SITUATION_CONCISE" => Self::SituationConcise,
                "ACTION_CONCISE" => Self::ActionConcise,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "conversations", feature = "generators",))]
    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Situation => serializer.serialize_i32(1),
                Self::Action => serializer.serialize_i32(2),
                Self::Resolution => serializer.serialize_i32(3),
                Self::ReasonForCancellation => serializer.serialize_i32(4),
                Self::CustomerSatisfaction => serializer.serialize_i32(5),
                Self::Entities => serializer.serialize_i32(6),
                Self::CustomerDefined => serializer.serialize_i32(7),
                Self::SituationConcise => serializer.serialize_i32(9),
                Self::ActionConcise => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "conversations", feature = "generators",))]
    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.dialogflow.v2.SummarizationSection.Type",
            ))
        }
    }
}

/// Summarization context that customer can configure.
#[cfg(any(feature = "conversations", feature = "generators",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SummarizationContext {
    /// Optional. List of sections. Note it contains both predefined section sand
    /// customer defined sections.
    pub summarization_sections: std::vec::Vec<crate::model::SummarizationSection>,

    /// Optional. List of few shot examples.
    pub few_shot_examples: std::vec::Vec<crate::model::FewShotExample>,

    /// Optional. Version of the feature. If not set, default to latest version.
    /// Current candidates are ["1.0"].
    pub version: std::string::String,

    /// Optional. The target language of the generated summary. The language code
    /// for conversation will be used if this field is empty. Supported 2.0 and
    /// later versions.
    pub output_language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl SummarizationContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [summarization_sections][crate::model::SummarizationContext::summarization_sections].
    pub fn set_summarization_sections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SummarizationSection>,
    {
        use std::iter::Iterator;
        self.summarization_sections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [few_shot_examples][crate::model::SummarizationContext::few_shot_examples].
    pub fn set_few_shot_examples<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FewShotExample>,
    {
        use std::iter::Iterator;
        self.few_shot_examples = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [version][crate::model::SummarizationContext::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [output_language_code][crate::model::SummarizationContext::output_language_code].
    pub fn set_output_language_code<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.output_language_code = v.into();
        self
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl wkt::message::Message for SummarizationContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SummarizationContext"
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SummarizationContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __summarization_sections,
            __few_shot_examples,
            __version,
            __output_language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SummarizationContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "summarizationSections" => Ok(__FieldTag::__summarization_sections),
                            "summarization_sections" => Ok(__FieldTag::__summarization_sections),
                            "fewShotExamples" => Ok(__FieldTag::__few_shot_examples),
                            "few_shot_examples" => Ok(__FieldTag::__few_shot_examples),
                            "version" => Ok(__FieldTag::__version),
                            "outputLanguageCode" => Ok(__FieldTag::__output_language_code),
                            "output_language_code" => Ok(__FieldTag::__output_language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SummarizationContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SummarizationContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__summarization_sections => {
                            if !fields.insert(__FieldTag::__summarization_sections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for summarization_sections",
                                ));
                            }
                            result.summarization_sections = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SummarizationSection>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__few_shot_examples => {
                            if !fields.insert(__FieldTag::__few_shot_examples) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for few_shot_examples",
                                ));
                            }
                            result.few_shot_examples =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::FewShotExample>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_language_code => {
                            if !fields.insert(__FieldTag::__output_language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_language_code",
                                ));
                            }
                            result.output_language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl serde::ser::Serialize for SummarizationContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.summarization_sections.is_empty() {
            state.serialize_entry("summarizationSections", &self.summarization_sections)?;
        }
        if !self.few_shot_examples.is_empty() {
            state.serialize_entry("fewShotExamples", &self.few_shot_examples)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.output_language_code.is_empty() {
            state.serialize_entry("outputLanguageCode", &self.output_language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Free form generator context that customer can configure.
#[cfg(any(feature = "conversations", feature = "generators",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FreeFormContext {
    /// Optional. Free form text input to LLM.
    pub text: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl FreeFormContext {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [text][crate::model::FreeFormContext::text].
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.text = v.into();
        self
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl wkt::message::Message for FreeFormContext {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.FreeFormContext"
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FreeFormContext {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FreeFormContext")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FreeFormContext;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FreeFormContext")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            result.text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl serde::ser::Serialize for FreeFormContext {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// LLM generator.
#[cfg(any(feature = "conversations", feature = "generators",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Generator {
    /// Output only. Identifier. The resource name of the generator. Format:
    /// `projects/<Project ID>/locations/<Location ID>/generators/<Generator ID>`
    pub name: std::string::String,

    /// Optional. Human readable description of the generator.
    pub description: std::string::String,

    /// Optional. Inference parameters for this generator.
    pub inference_parameter: std::option::Option<crate::model::InferenceParameter>,

    /// Optional. The trigger event of the generator. It defines when the generator
    /// is triggered in a conversation.
    pub trigger_event: crate::model::TriggerEvent,

    /// Output only. Creation time of this generator.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time of this generator.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. Input context of the generator.
    pub context: std::option::Option<crate::model::generator::Context>,

    /// The foundation model to use for generating suggestions. If a foundation
    /// model isn't specified here, a model specifically tuned for the feature
    /// type (and version when applicable) will be used.
    pub foundation_model: std::option::Option<crate::model::generator::FoundationModel>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl Generator {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Generator::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Generator::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [inference_parameter][crate::model::Generator::inference_parameter].
    pub fn set_inference_parameter<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InferenceParameter>,
    {
        self.inference_parameter = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [inference_parameter][crate::model::Generator::inference_parameter].
    pub fn set_or_clear_inference_parameter<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InferenceParameter>,
    {
        self.inference_parameter = v.map(|x| x.into());
        self
    }

    /// Sets the value of [trigger_event][crate::model::Generator::trigger_event].
    pub fn set_trigger_event<T: std::convert::Into<crate::model::TriggerEvent>>(
        mut self,
        v: T,
    ) -> Self {
        self.trigger_event = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Generator::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Generator::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Generator::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Generator::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [context][crate::model::Generator::context].
    ///
    /// Note that all the setters affecting `context` are mutually
    /// exclusive.
    pub fn set_context<
        T: std::convert::Into<std::option::Option<crate::model::generator::Context>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.context = v.into();
        self
    }

    /// The value of [context][crate::model::Generator::context]
    /// if it holds a `FreeFormContext`, `None` if the field is not set or
    /// holds a different branch.
    pub fn free_form_context(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FreeFormContext>> {
        #[allow(unreachable_patterns)]
        self.context.as_ref().and_then(|v| match v {
            crate::model::generator::Context::FreeFormContext(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [context][crate::model::Generator::context]
    /// to hold a `FreeFormContext`.
    ///
    /// Note that all the setters affecting `context` are
    /// mutually exclusive.
    pub fn set_free_form_context<
        T: std::convert::Into<std::boxed::Box<crate::model::FreeFormContext>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.context =
            std::option::Option::Some(crate::model::generator::Context::FreeFormContext(v.into()));
        self
    }

    /// The value of [context][crate::model::Generator::context]
    /// if it holds a `SummarizationContext`, `None` if the field is not set or
    /// holds a different branch.
    pub fn summarization_context(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SummarizationContext>> {
        #[allow(unreachable_patterns)]
        self.context.as_ref().and_then(|v| match v {
            crate::model::generator::Context::SummarizationContext(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [context][crate::model::Generator::context]
    /// to hold a `SummarizationContext`.
    ///
    /// Note that all the setters affecting `context` are
    /// mutually exclusive.
    pub fn set_summarization_context<
        T: std::convert::Into<std::boxed::Box<crate::model::SummarizationContext>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.context = std::option::Option::Some(
            crate::model::generator::Context::SummarizationContext(v.into()),
        );
        self
    }

    /// Sets the value of [foundation_model][crate::model::Generator::foundation_model].
    ///
    /// Note that all the setters affecting `foundation_model` are mutually
    /// exclusive.
    pub fn set_foundation_model<
        T: std::convert::Into<std::option::Option<crate::model::generator::FoundationModel>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.foundation_model = v.into();
        self
    }

    /// The value of [foundation_model][crate::model::Generator::foundation_model]
    /// if it holds a `PublishedModel`, `None` if the field is not set or
    /// holds a different branch.
    pub fn published_model(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.foundation_model.as_ref().and_then(|v| match v {
            crate::model::generator::FoundationModel::PublishedModel(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [foundation_model][crate::model::Generator::foundation_model]
    /// to hold a `PublishedModel`.
    ///
    /// Note that all the setters affecting `foundation_model` are
    /// mutually exclusive.
    pub fn set_published_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.foundation_model = std::option::Option::Some(
            crate::model::generator::FoundationModel::PublishedModel(v.into()),
        );
        self
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl wkt::message::Message for Generator {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.Generator"
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Generator {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __free_form_context,
            __summarization_context,
            __inference_parameter,
            __trigger_event,
            __published_model,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Generator")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "freeFormContext" => Ok(__FieldTag::__free_form_context),
                            "free_form_context" => Ok(__FieldTag::__free_form_context),
                            "summarizationContext" => Ok(__FieldTag::__summarization_context),
                            "summarization_context" => Ok(__FieldTag::__summarization_context),
                            "inferenceParameter" => Ok(__FieldTag::__inference_parameter),
                            "inference_parameter" => Ok(__FieldTag::__inference_parameter),
                            "triggerEvent" => Ok(__FieldTag::__trigger_event),
                            "trigger_event" => Ok(__FieldTag::__trigger_event),
                            "publishedModel" => Ok(__FieldTag::__published_model),
                            "published_model" => Ok(__FieldTag::__published_model),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Generator;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Generator")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__free_form_context => {
                            if !fields.insert(__FieldTag::__free_form_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for free_form_context",
                                ));
                            }
                            if result.context.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `context`, a oneof with full ID .google.cloud.dialogflow.v2.Generator.free_form_context, latest field was freeFormContext",
                                ));
                            }
                            result.context = std::option::Option::Some(
                                crate::model::generator::Context::FreeFormContext(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::FreeFormContext>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__summarization_context => {
                            if !fields.insert(__FieldTag::__summarization_context) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for summarization_context",
                                ));
                            }
                            if result.context.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `context`, a oneof with full ID .google.cloud.dialogflow.v2.Generator.summarization_context, latest field was summarizationContext",
                                ));
                            }
                            result.context = std::option::Option::Some(
                                crate::model::generator::Context::SummarizationContext(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SummarizationContext>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__inference_parameter => {
                            if !fields.insert(__FieldTag::__inference_parameter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inference_parameter",
                                ));
                            }
                            result.inference_parameter = map.next_value::<std::option::Option<crate::model::InferenceParameter>>()?
                                ;
                        }
                        __FieldTag::__trigger_event => {
                            if !fields.insert(__FieldTag::__trigger_event) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trigger_event",
                                ));
                            }
                            result.trigger_event = map
                                .next_value::<std::option::Option<crate::model::TriggerEvent>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__published_model => {
                            if !fields.insert(__FieldTag::__published_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for published_model",
                                ));
                            }
                            if result.foundation_model.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `foundation_model`, a oneof with full ID .google.cloud.dialogflow.v2.Generator.published_model, latest field was publishedModel",
                                ));
                            }
                            result.foundation_model = std::option::Option::Some(
                                crate::model::generator::FoundationModel::PublishedModel(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
#[doc(hidden)]
impl serde::ser::Serialize for Generator {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if let Some(value) = self.free_form_context() {
            state.serialize_entry("freeFormContext", value)?;
        }
        if let Some(value) = self.summarization_context() {
            state.serialize_entry("summarizationContext", value)?;
        }
        if self.inference_parameter.is_some() {
            state.serialize_entry("inferenceParameter", &self.inference_parameter)?;
        }
        if !wkt::internal::is_default(&self.trigger_event) {
            state.serialize_entry("triggerEvent", &self.trigger_event)?;
        }
        if let Some(value) = self.published_model() {
            state.serialize_entry("publishedModel", value)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Generator].
#[cfg(any(feature = "conversations", feature = "generators",))]
pub mod generator {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Input context of the generator.
    #[cfg(any(feature = "conversations", feature = "generators",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Context {
        /// Input of free from generator to LLM.
        FreeFormContext(std::boxed::Box<crate::model::FreeFormContext>),
        /// Input of prebuilt Summarization feature.
        SummarizationContext(std::boxed::Box<crate::model::SummarizationContext>),
    }

    /// The foundation model to use for generating suggestions. If a foundation
    /// model isn't specified here, a model specifically tuned for the feature
    /// type (and version when applicable) will be used.
    #[cfg(any(feature = "conversations", feature = "generators",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FoundationModel {
        /// Optional. The published Large Language Model name.
        ///
        /// * To use the latest model version, specify the model name without version
        ///   number. Example: `text-bison`
        /// * To use a stable model version, specify the version number as well.
        ///   Example: `text-bison@002`.
        PublishedModel(std::string::String),
    }
}

/// Suggestion generated using free form generator.
#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FreeFormSuggestion {
    /// Required. Free form suggestion.
    pub response: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
impl FreeFormSuggestion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [response][crate::model::FreeFormSuggestion::response].
    pub fn set_response<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.response = v.into();
        self
    }
}

#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
impl wkt::message::Message for FreeFormSuggestion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.FreeFormSuggestion"
    }
}

#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FreeFormSuggestion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __response,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FreeFormSuggestion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "response" => Ok(__FieldTag::__response),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FreeFormSuggestion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FreeFormSuggestion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__response => {
                            if !fields.insert(__FieldTag::__response) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response",
                                ));
                            }
                            result.response = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
#[doc(hidden)]
impl serde::ser::Serialize for FreeFormSuggestion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.response.is_empty() {
            state.serialize_entry("response", &self.response)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Suggested summary of the conversation.
#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SummarySuggestion {
    /// Required. All the parts of generated summary.
    pub summary_sections: std::vec::Vec<crate::model::summary_suggestion::SummarySection>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
impl SummarySuggestion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [summary_sections][crate::model::SummarySuggestion::summary_sections].
    pub fn set_summary_sections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::summary_suggestion::SummarySection>,
    {
        use std::iter::Iterator;
        self.summary_sections = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
impl wkt::message::Message for SummarySuggestion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SummarySuggestion"
    }
}

#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SummarySuggestion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __summary_sections,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SummarySuggestion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "summarySections" => Ok(__FieldTag::__summary_sections),
                            "summary_sections" => Ok(__FieldTag::__summary_sections),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SummarySuggestion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SummarySuggestion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__summary_sections => {
                            if !fields.insert(__FieldTag::__summary_sections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for summary_sections",
                                ));
                            }
                            result.summary_sections = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::summary_suggestion::SummarySection>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
#[doc(hidden)]
impl serde::ser::Serialize for SummarySuggestion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.summary_sections.is_empty() {
            state.serialize_entry("summarySections", &self.summary_sections)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SummarySuggestion].
#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
pub mod summary_suggestion {
    #[allow(unused_imports)]
    use super::*;

    /// A component of the generated summary.
    #[cfg(any(
        feature = "conversations",
        feature = "generators",
        feature = "participants",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SummarySection {
        /// Required. Name of the section.
        pub section: std::string::String,

        /// Required. Summary text for the section.
        pub summary: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "conversations",
        feature = "generators",
        feature = "participants",
    ))]
    impl SummarySection {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [section][crate::model::summary_suggestion::SummarySection::section].
        pub fn set_section<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.section = v.into();
            self
        }

        /// Sets the value of [summary][crate::model::summary_suggestion::SummarySection::summary].
        pub fn set_summary<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.summary = v.into();
            self
        }
    }

    #[cfg(any(
        feature = "conversations",
        feature = "generators",
        feature = "participants",
    ))]
    impl wkt::message::Message for SummarySection {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.SummarySuggestion.SummarySection"
        }
    }

    #[cfg(any(
        feature = "conversations",
        feature = "generators",
        feature = "participants",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SummarySection {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __section,
                __summary,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SummarySection")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "section" => Ok(__FieldTag::__section),
                                "summary" => Ok(__FieldTag::__summary),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SummarySection;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SummarySection")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__section => {
                                if !fields.insert(__FieldTag::__section) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for section",
                                    ));
                                }
                                result.section = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__summary => {
                                if !fields.insert(__FieldTag::__summary) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for summary",
                                    ));
                                }
                                result.summary = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "conversations",
        feature = "generators",
        feature = "participants",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for SummarySection {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.section.is_empty() {
                state.serialize_entry("section", &self.section)?;
            }
            if !self.summary.is_empty() {
                state.serialize_entry("summary", &self.summary)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Suggestion generated using a Generator.
#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GeneratorSuggestion {
    /// The suggestion could be one of the many types
    pub suggestion: std::option::Option<crate::model::generator_suggestion::Suggestion>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
impl GeneratorSuggestion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [suggestion][crate::model::GeneratorSuggestion::suggestion].
    ///
    /// Note that all the setters affecting `suggestion` are mutually
    /// exclusive.
    pub fn set_suggestion<
        T: std::convert::Into<std::option::Option<crate::model::generator_suggestion::Suggestion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.suggestion = v.into();
        self
    }

    /// The value of [suggestion][crate::model::GeneratorSuggestion::suggestion]
    /// if it holds a `FreeFormSuggestion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn free_form_suggestion(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::FreeFormSuggestion>> {
        #[allow(unreachable_patterns)]
        self.suggestion.as_ref().and_then(|v| match v {
            crate::model::generator_suggestion::Suggestion::FreeFormSuggestion(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [suggestion][crate::model::GeneratorSuggestion::suggestion]
    /// to hold a `FreeFormSuggestion`.
    ///
    /// Note that all the setters affecting `suggestion` are
    /// mutually exclusive.
    pub fn set_free_form_suggestion<
        T: std::convert::Into<std::boxed::Box<crate::model::FreeFormSuggestion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.suggestion = std::option::Option::Some(
            crate::model::generator_suggestion::Suggestion::FreeFormSuggestion(v.into()),
        );
        self
    }

    /// The value of [suggestion][crate::model::GeneratorSuggestion::suggestion]
    /// if it holds a `SummarySuggestion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn summary_suggestion(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SummarySuggestion>> {
        #[allow(unreachable_patterns)]
        self.suggestion.as_ref().and_then(|v| match v {
            crate::model::generator_suggestion::Suggestion::SummarySuggestion(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [suggestion][crate::model::GeneratorSuggestion::suggestion]
    /// to hold a `SummarySuggestion`.
    ///
    /// Note that all the setters affecting `suggestion` are
    /// mutually exclusive.
    pub fn set_summary_suggestion<
        T: std::convert::Into<std::boxed::Box<crate::model::SummarySuggestion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.suggestion = std::option::Option::Some(
            crate::model::generator_suggestion::Suggestion::SummarySuggestion(v.into()),
        );
        self
    }
}

#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
impl wkt::message::Message for GeneratorSuggestion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GeneratorSuggestion"
    }
}

#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GeneratorSuggestion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __free_form_suggestion,
            __summary_suggestion,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GeneratorSuggestion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "freeFormSuggestion" => Ok(__FieldTag::__free_form_suggestion),
                            "free_form_suggestion" => Ok(__FieldTag::__free_form_suggestion),
                            "summarySuggestion" => Ok(__FieldTag::__summary_suggestion),
                            "summary_suggestion" => Ok(__FieldTag::__summary_suggestion),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GeneratorSuggestion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GeneratorSuggestion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__free_form_suggestion => {
                            if !fields.insert(__FieldTag::__free_form_suggestion) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for free_form_suggestion",
                                ));
                            }
                            if result.suggestion.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `suggestion`, a oneof with full ID .google.cloud.dialogflow.v2.GeneratorSuggestion.free_form_suggestion, latest field was freeFormSuggestion",
                                ));
                            }
                            result.suggestion = std::option::Option::Some(
                                crate::model::generator_suggestion::Suggestion::FreeFormSuggestion(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::FreeFormSuggestion>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__summary_suggestion => {
                            if !fields.insert(__FieldTag::__summary_suggestion) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for summary_suggestion",
                                ));
                            }
                            if result.suggestion.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `suggestion`, a oneof with full ID .google.cloud.dialogflow.v2.GeneratorSuggestion.summary_suggestion, latest field was summarySuggestion",
                                ));
                            }
                            result.suggestion = std::option::Option::Some(
                                crate::model::generator_suggestion::Suggestion::SummarySuggestion(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SummarySuggestion>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
#[doc(hidden)]
impl serde::ser::Serialize for GeneratorSuggestion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.free_form_suggestion() {
            state.serialize_entry("freeFormSuggestion", value)?;
        }
        if let Some(value) = self.summary_suggestion() {
            state.serialize_entry("summarySuggestion", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GeneratorSuggestion].
#[cfg(any(
    feature = "conversations",
    feature = "generators",
    feature = "participants",
))]
pub mod generator_suggestion {
    #[allow(unused_imports)]
    use super::*;

    /// The suggestion could be one of the many types
    #[cfg(any(
        feature = "conversations",
        feature = "generators",
        feature = "participants",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Suggestion {
        /// Optional. Free form suggestion.
        FreeFormSuggestion(std::boxed::Box<crate::model::FreeFormSuggestion>),
        /// Optional. Suggested summary.
        SummarySuggestion(std::boxed::Box<crate::model::SummarySuggestion>),
    }
}

/// Represents a notification sent to Cloud Pub/Sub subscribers for
/// human agent assistant events in a specific conversation.
#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HumanAgentAssistantEvent {
    /// The conversation this notification refers to.
    /// Format: `projects/<Project ID>/conversations/<Conversation ID>`.
    pub conversation: std::string::String,

    /// The participant that the suggestion is compiled for.
    /// Format: `projects/<Project ID>/conversations/<Conversation
    /// ID>/participants/<Participant ID>`. It will not be set in legacy workflow.
    pub participant: std::string::String,

    /// The suggestion results payload that this notification refers to.
    pub suggestion_results: std::vec::Vec<crate::model::SuggestionResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
impl HumanAgentAssistantEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [conversation][crate::model::HumanAgentAssistantEvent::conversation].
    pub fn set_conversation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.conversation = v.into();
        self
    }

    /// Sets the value of [participant][crate::model::HumanAgentAssistantEvent::participant].
    pub fn set_participant<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.participant = v.into();
        self
    }

    /// Sets the value of [suggestion_results][crate::model::HumanAgentAssistantEvent::suggestion_results].
    pub fn set_suggestion_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SuggestionResult>,
    {
        use std::iter::Iterator;
        self.suggestion_results = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
impl wkt::message::Message for HumanAgentAssistantEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.HumanAgentAssistantEvent"
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HumanAgentAssistantEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __conversation,
            __participant,
            __suggestion_results,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HumanAgentAssistantEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "conversation" => Ok(__FieldTag::__conversation),
                            "participant" => Ok(__FieldTag::__participant),
                            "suggestionResults" => Ok(__FieldTag::__suggestion_results),
                            "suggestion_results" => Ok(__FieldTag::__suggestion_results),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HumanAgentAssistantEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HumanAgentAssistantEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__conversation => {
                            if !fields.insert(__FieldTag::__conversation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conversation",
                                ));
                            }
                            result.conversation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__participant => {
                            if !fields.insert(__FieldTag::__participant) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for participant",
                                ));
                            }
                            result.participant = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__suggestion_results => {
                            if !fields.insert(__FieldTag::__suggestion_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suggestion_results",
                                ));
                            }
                            result.suggestion_results =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SuggestionResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for HumanAgentAssistantEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.conversation.is_empty() {
            state.serialize_entry("conversation", &self.conversation)?;
        }
        if !self.participant.is_empty() {
            state.serialize_entry("participant", &self.participant)?;
        }
        if !self.suggestion_results.is_empty() {
            state.serialize_entry("suggestionResults", &self.suggestion_results)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An intent categorizes an end-user's intention for one conversation turn. For
/// each agent, you define many intents, where your combined intents can handle a
/// complete conversation. When an end-user writes or says something, referred to
/// as an end-user expression or end-user input, Dialogflow matches the end-user
/// input to the best intent in your agent. Matching an intent is also known as
/// intent classification.
///
/// For more information, see the [intent
/// guide](https://cloud.google.com/dialogflow/docs/intents-overview).
#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Intent {
    /// Optional. The unique identifier of this intent.
    /// Required for
    /// [Intents.UpdateIntent][google.cloud.dialogflow.v2.Intents.UpdateIntent] and
    /// [Intents.BatchUpdateIntents][google.cloud.dialogflow.v2.Intents.BatchUpdateIntents]
    /// methods.
    /// Format: `projects/<Project ID>/agent/intents/<Intent ID>`.
    ///
    /// [google.cloud.dialogflow.v2.Intents.BatchUpdateIntents]: crate::client::Intents::batch_update_intents
    /// [google.cloud.dialogflow.v2.Intents.UpdateIntent]: crate::client::Intents::update_intent
    pub name: std::string::String,

    /// Required. The name of this intent.
    pub display_name: std::string::String,

    /// Optional. Indicates whether webhooks are enabled for the intent.
    pub webhook_state: crate::model::intent::WebhookState,

    /// Optional. The priority of this intent. Higher numbers represent higher
    /// priorities.
    ///
    /// - If the supplied value is unspecified or 0, the service
    ///   translates the value to 500,000, which corresponds to the
    ///   `Normal` priority in the console.
    /// - If the supplied value is negative, the intent is ignored
    ///   in runtime detect intent requests.
    pub priority: i32,

    /// Optional. Indicates whether this is a fallback intent.
    pub is_fallback: bool,

    /// Optional. Indicates whether Machine Learning is disabled for the intent.
    /// Note: If `ml_disabled` setting is set to true, then this intent is not
    /// taken into account during inference in `ML ONLY` match mode. Also,
    /// auto-markup in the UI is turned off.
    pub ml_disabled: bool,

    /// Optional. Indicates that a live agent should be brought in to handle the
    /// interaction with the user. In most cases, when you set this flag to true,
    /// you would also want to set end_interaction to true as well. Default is
    /// false.
    pub live_agent_handoff: bool,

    /// Optional. Indicates that this intent ends an interaction. Some integrations
    /// (e.g., Actions on Google or Dialogflow phone gateway) use this information
    /// to close interaction with an end user. Default is false.
    pub end_interaction: bool,

    /// Optional. The list of context names required for this intent to be
    /// triggered.
    /// Format: `projects/<Project ID>/agent/sessions/-/contexts/<Context ID>`.
    pub input_context_names: std::vec::Vec<std::string::String>,

    /// Optional. The collection of event names that trigger the intent.
    /// If the collection of input contexts is not empty, all of the contexts must
    /// be present in the active user session for an event to trigger this intent.
    /// Event names are limited to 150 characters.
    pub events: std::vec::Vec<std::string::String>,

    /// Optional. The collection of examples that the agent is
    /// trained on.
    pub training_phrases: std::vec::Vec<crate::model::intent::TrainingPhrase>,

    /// Optional. The name of the action associated with the intent.
    /// Note: The action name must not contain whitespaces.
    pub action: std::string::String,

    /// Optional. The collection of contexts that are activated when the intent
    /// is matched. Context messages in this collection should not set the
    /// parameters field. Setting the `lifespan_count` to 0 will reset the context
    /// when the intent is matched.
    /// Format: `projects/<Project ID>/agent/sessions/-/contexts/<Context ID>`.
    pub output_contexts: std::vec::Vec<crate::model::Context>,

    /// Optional. Indicates whether to delete all contexts in the current
    /// session when this intent is matched.
    pub reset_contexts: bool,

    /// Optional. The collection of parameters associated with the intent.
    pub parameters: std::vec::Vec<crate::model::intent::Parameter>,

    /// Optional. The collection of rich messages corresponding to the
    /// `Response` field in the Dialogflow console.
    pub messages: std::vec::Vec<crate::model::intent::Message>,

    /// Optional. The list of platforms for which the first responses will be
    /// copied from the messages in PLATFORM_UNSPECIFIED (i.e. default platform).
    pub default_response_platforms: std::vec::Vec<crate::model::intent::message::Platform>,

    /// Output only.
    /// Read-only. The unique identifier of the root intent in the chain of
    /// followup intents. It identifies the correct followup intents chain for
    /// this intent. We populate this field only in the output.
    ///
    /// Format: `projects/<Project ID>/agent/intents/<Intent ID>`.
    pub root_followup_intent_name: std::string::String,

    /// Read-only after creation. The unique identifier of the parent intent in the
    /// chain of followup intents. You can set this field when creating an intent,
    /// for example with
    /// [CreateIntent][google.cloud.dialogflow.v2.Intents.CreateIntent] or
    /// [BatchUpdateIntents][google.cloud.dialogflow.v2.Intents.BatchUpdateIntents],
    /// in order to make this intent a followup intent.
    ///
    /// It identifies the parent followup intent.
    /// Format: `projects/<Project ID>/agent/intents/<Intent ID>`.
    ///
    /// [google.cloud.dialogflow.v2.Intents.BatchUpdateIntents]: crate::client::Intents::batch_update_intents
    /// [google.cloud.dialogflow.v2.Intents.CreateIntent]: crate::client::Intents::create_intent
    pub parent_followup_intent_name: std::string::String,

    /// Output only. Read-only. Information about all followup intents that have
    /// this intent as a direct or indirect parent. We populate this field only in
    /// the output.
    pub followup_intent_info: std::vec::Vec<crate::model::intent::FollowupIntentInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
impl Intent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Intent::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Intent::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [webhook_state][crate::model::Intent::webhook_state].
    pub fn set_webhook_state<T: std::convert::Into<crate::model::intent::WebhookState>>(
        mut self,
        v: T,
    ) -> Self {
        self.webhook_state = v.into();
        self
    }

    /// Sets the value of [priority][crate::model::Intent::priority].
    pub fn set_priority<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.priority = v.into();
        self
    }

    /// Sets the value of [is_fallback][crate::model::Intent::is_fallback].
    pub fn set_is_fallback<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_fallback = v.into();
        self
    }

    /// Sets the value of [ml_disabled][crate::model::Intent::ml_disabled].
    pub fn set_ml_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ml_disabled = v.into();
        self
    }

    /// Sets the value of [live_agent_handoff][crate::model::Intent::live_agent_handoff].
    pub fn set_live_agent_handoff<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.live_agent_handoff = v.into();
        self
    }

    /// Sets the value of [end_interaction][crate::model::Intent::end_interaction].
    pub fn set_end_interaction<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.end_interaction = v.into();
        self
    }

    /// Sets the value of [input_context_names][crate::model::Intent::input_context_names].
    pub fn set_input_context_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.input_context_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [events][crate::model::Intent::events].
    pub fn set_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [training_phrases][crate::model::Intent::training_phrases].
    pub fn set_training_phrases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::intent::TrainingPhrase>,
    {
        use std::iter::Iterator;
        self.training_phrases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [action][crate::model::Intent::action].
    pub fn set_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [output_contexts][crate::model::Intent::output_contexts].
    pub fn set_output_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Context>,
    {
        use std::iter::Iterator;
        self.output_contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [reset_contexts][crate::model::Intent::reset_contexts].
    pub fn set_reset_contexts<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reset_contexts = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::Intent::parameters].
    pub fn set_parameters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::intent::Parameter>,
    {
        use std::iter::Iterator;
        self.parameters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [messages][crate::model::Intent::messages].
    pub fn set_messages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::intent::Message>,
    {
        use std::iter::Iterator;
        self.messages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [default_response_platforms][crate::model::Intent::default_response_platforms].
    pub fn set_default_response_platforms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::intent::message::Platform>,
    {
        use std::iter::Iterator;
        self.default_response_platforms = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [root_followup_intent_name][crate::model::Intent::root_followup_intent_name].
    pub fn set_root_followup_intent_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.root_followup_intent_name = v.into();
        self
    }

    /// Sets the value of [parent_followup_intent_name][crate::model::Intent::parent_followup_intent_name].
    pub fn set_parent_followup_intent_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.parent_followup_intent_name = v.into();
        self
    }

    /// Sets the value of [followup_intent_info][crate::model::Intent::followup_intent_info].
    pub fn set_followup_intent_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::intent::FollowupIntentInfo>,
    {
        use std::iter::Iterator;
        self.followup_intent_info = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
impl wkt::message::Message for Intent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.Intent"
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Intent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __webhook_state,
            __priority,
            __is_fallback,
            __ml_disabled,
            __live_agent_handoff,
            __end_interaction,
            __input_context_names,
            __events,
            __training_phrases,
            __action,
            __output_contexts,
            __reset_contexts,
            __parameters,
            __messages,
            __default_response_platforms,
            __root_followup_intent_name,
            __parent_followup_intent_name,
            __followup_intent_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Intent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "webhookState" => Ok(__FieldTag::__webhook_state),
                            "webhook_state" => Ok(__FieldTag::__webhook_state),
                            "priority" => Ok(__FieldTag::__priority),
                            "isFallback" => Ok(__FieldTag::__is_fallback),
                            "is_fallback" => Ok(__FieldTag::__is_fallback),
                            "mlDisabled" => Ok(__FieldTag::__ml_disabled),
                            "ml_disabled" => Ok(__FieldTag::__ml_disabled),
                            "liveAgentHandoff" => Ok(__FieldTag::__live_agent_handoff),
                            "live_agent_handoff" => Ok(__FieldTag::__live_agent_handoff),
                            "endInteraction" => Ok(__FieldTag::__end_interaction),
                            "end_interaction" => Ok(__FieldTag::__end_interaction),
                            "inputContextNames" => Ok(__FieldTag::__input_context_names),
                            "input_context_names" => Ok(__FieldTag::__input_context_names),
                            "events" => Ok(__FieldTag::__events),
                            "trainingPhrases" => Ok(__FieldTag::__training_phrases),
                            "training_phrases" => Ok(__FieldTag::__training_phrases),
                            "action" => Ok(__FieldTag::__action),
                            "outputContexts" => Ok(__FieldTag::__output_contexts),
                            "output_contexts" => Ok(__FieldTag::__output_contexts),
                            "resetContexts" => Ok(__FieldTag::__reset_contexts),
                            "reset_contexts" => Ok(__FieldTag::__reset_contexts),
                            "parameters" => Ok(__FieldTag::__parameters),
                            "messages" => Ok(__FieldTag::__messages),
                            "defaultResponsePlatforms" => {
                                Ok(__FieldTag::__default_response_platforms)
                            }
                            "default_response_platforms" => {
                                Ok(__FieldTag::__default_response_platforms)
                            }
                            "rootFollowupIntentName" => Ok(__FieldTag::__root_followup_intent_name),
                            "root_followup_intent_name" => {
                                Ok(__FieldTag::__root_followup_intent_name)
                            }
                            "parentFollowupIntentName" => {
                                Ok(__FieldTag::__parent_followup_intent_name)
                            }
                            "parent_followup_intent_name" => {
                                Ok(__FieldTag::__parent_followup_intent_name)
                            }
                            "followupIntentInfo" => Ok(__FieldTag::__followup_intent_info),
                            "followup_intent_info" => Ok(__FieldTag::__followup_intent_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Intent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Intent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__webhook_state => {
                            if !fields.insert(__FieldTag::__webhook_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_state",
                                ));
                            }
                            result.webhook_state = map.next_value::<std::option::Option<crate::model::intent::WebhookState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__priority => {
                            if !fields.insert(__FieldTag::__priority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for priority",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.priority = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__is_fallback => {
                            if !fields.insert(__FieldTag::__is_fallback) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_fallback",
                                ));
                            }
                            result.is_fallback = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ml_disabled => {
                            if !fields.insert(__FieldTag::__ml_disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ml_disabled",
                                ));
                            }
                            result.ml_disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__live_agent_handoff => {
                            if !fields.insert(__FieldTag::__live_agent_handoff) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for live_agent_handoff",
                                ));
                            }
                            result.live_agent_handoff = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__end_interaction => {
                            if !fields.insert(__FieldTag::__end_interaction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_interaction",
                                ));
                            }
                            result.end_interaction = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__input_context_names => {
                            if !fields.insert(__FieldTag::__input_context_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_context_names",
                                ));
                            }
                            result.input_context_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__events => {
                            if !fields.insert(__FieldTag::__events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for events",
                                ));
                            }
                            result.events = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__training_phrases => {
                            if !fields.insert(__FieldTag::__training_phrases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for training_phrases",
                                ));
                            }
                            result.training_phrases = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::intent::TrainingPhrase>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            result.action = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_contexts => {
                            if !fields.insert(__FieldTag::__output_contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_contexts",
                                ));
                            }
                            result.output_contexts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Context>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__reset_contexts => {
                            if !fields.insert(__FieldTag::__reset_contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reset_contexts",
                                ));
                            }
                            result.reset_contexts = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::intent::Parameter>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__messages => {
                            if !fields.insert(__FieldTag::__messages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for messages",
                                ));
                            }
                            result.messages =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::intent::Message>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_response_platforms => {
                            if !fields.insert(__FieldTag::__default_response_platforms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_response_platforms",
                                ));
                            }
                            result.default_response_platforms = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::intent::message::Platform>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__root_followup_intent_name => {
                            if !fields.insert(__FieldTag::__root_followup_intent_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for root_followup_intent_name",
                                ));
                            }
                            result.root_followup_intent_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent_followup_intent_name => {
                            if !fields.insert(__FieldTag::__parent_followup_intent_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent_followup_intent_name",
                                ));
                            }
                            result.parent_followup_intent_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__followup_intent_info => {
                            if !fields.insert(__FieldTag::__followup_intent_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for followup_intent_info",
                                ));
                            }
                            result.followup_intent_info = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::intent::FollowupIntentInfo>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for Intent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.webhook_state) {
            state.serialize_entry("webhookState", &self.webhook_state)?;
        }
        if !wkt::internal::is_default(&self.priority) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("priority", &__With(&self.priority))?;
        }
        if !wkt::internal::is_default(&self.is_fallback) {
            state.serialize_entry("isFallback", &self.is_fallback)?;
        }
        if !wkt::internal::is_default(&self.ml_disabled) {
            state.serialize_entry("mlDisabled", &self.ml_disabled)?;
        }
        if !wkt::internal::is_default(&self.live_agent_handoff) {
            state.serialize_entry("liveAgentHandoff", &self.live_agent_handoff)?;
        }
        if !wkt::internal::is_default(&self.end_interaction) {
            state.serialize_entry("endInteraction", &self.end_interaction)?;
        }
        if !self.input_context_names.is_empty() {
            state.serialize_entry("inputContextNames", &self.input_context_names)?;
        }
        if !self.events.is_empty() {
            state.serialize_entry("events", &self.events)?;
        }
        if !self.training_phrases.is_empty() {
            state.serialize_entry("trainingPhrases", &self.training_phrases)?;
        }
        if !self.action.is_empty() {
            state.serialize_entry("action", &self.action)?;
        }
        if !self.output_contexts.is_empty() {
            state.serialize_entry("outputContexts", &self.output_contexts)?;
        }
        if !wkt::internal::is_default(&self.reset_contexts) {
            state.serialize_entry("resetContexts", &self.reset_contexts)?;
        }
        if !self.parameters.is_empty() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self.messages.is_empty() {
            state.serialize_entry("messages", &self.messages)?;
        }
        if !self.default_response_platforms.is_empty() {
            state.serialize_entry("defaultResponsePlatforms", &self.default_response_platforms)?;
        }
        if !self.root_followup_intent_name.is_empty() {
            state.serialize_entry("rootFollowupIntentName", &self.root_followup_intent_name)?;
        }
        if !self.parent_followup_intent_name.is_empty() {
            state.serialize_entry(
                "parentFollowupIntentName",
                &self.parent_followup_intent_name,
            )?;
        }
        if !self.followup_intent_info.is_empty() {
            state.serialize_entry("followupIntentInfo", &self.followup_intent_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Intent].
#[cfg(any(
    feature = "answer-records",
    feature = "intents",
    feature = "participants",
    feature = "sessions",
))]
pub mod intent {
    #[allow(unused_imports)]
    use super::*;

    /// Represents an example that the agent is trained on.
    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TrainingPhrase {
        /// Output only. The unique identifier of this training phrase.
        pub name: std::string::String,

        /// Required. The type of the training phrase.
        pub r#type: crate::model::intent::training_phrase::Type,

        /// Required. The ordered list of training phrase parts.
        /// The parts are concatenated in order to form the training phrase.
        ///
        /// Note: The API does not automatically annotate training phrases like the
        /// Dialogflow Console does.
        ///
        /// Note: Do not forget to include whitespace at part boundaries,
        /// so the training phrase is well formatted when the parts are concatenated.
        ///
        /// If the training phrase does not need to be annotated with parameters,
        /// you just need a single part with only the
        /// [Part.text][google.cloud.dialogflow.v2.Intent.TrainingPhrase.Part.text]
        /// field set.
        ///
        /// If you want to annotate the training phrase, you must create multiple
        /// parts, where the fields of each part are populated in one of two ways:
        ///
        /// - `Part.text` is set to a part of the phrase that has no parameters.
        /// - `Part.text` is set to a part of the phrase that you want to annotate,
        ///   and the `entity_type`, `alias`, and `user_defined` fields are all
        ///   set.
        ///
        /// [google.cloud.dialogflow.v2.Intent.TrainingPhrase.Part.text]: crate::model::intent::training_phrase::Part::text
        pub parts: std::vec::Vec<crate::model::intent::training_phrase::Part>,

        /// Optional. Indicates how many times this example was added to
        /// the intent. Each time a developer adds an existing sample by editing an
        /// intent or training, this counter is increased.
        pub times_added_count: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    impl TrainingPhrase {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::intent::TrainingPhrase::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::intent::TrainingPhrase::type].
        pub fn set_type<T: std::convert::Into<crate::model::intent::training_phrase::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [parts][crate::model::intent::TrainingPhrase::parts].
        pub fn set_parts<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::intent::training_phrase::Part>,
        {
            use std::iter::Iterator;
            self.parts = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [times_added_count][crate::model::intent::TrainingPhrase::times_added_count].
        pub fn set_times_added_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.times_added_count = v.into();
            self
        }
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    impl wkt::message::Message for TrainingPhrase {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.Intent.TrainingPhrase"
        }
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TrainingPhrase {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __type,
                __parts,
                __times_added_count,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TrainingPhrase")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "type" => Ok(__FieldTag::__type),
                                "parts" => Ok(__FieldTag::__parts),
                                "timesAddedCount" => Ok(__FieldTag::__times_added_count),
                                "times_added_count" => Ok(__FieldTag::__times_added_count),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TrainingPhrase;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TrainingPhrase")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<
                                        crate::model::intent::training_phrase::Type,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__parts => {
                                if !fields.insert(__FieldTag::__parts) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parts",
                                    ));
                                }
                                result.parts = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::intent::training_phrase::Part>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__times_added_count => {
                                if !fields.insert(__FieldTag::__times_added_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for times_added_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.times_added_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for TrainingPhrase {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self.parts.is_empty() {
                state.serialize_entry("parts", &self.parts)?;
            }
            if !wkt::internal::is_default(&self.times_added_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("timesAddedCount", &__With(&self.times_added_count))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [TrainingPhrase].
    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    pub mod training_phrase {
        #[allow(unused_imports)]
        use super::*;

        /// Represents a part of a training phrase.
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Part {
            /// Required. The text for this part.
            pub text: std::string::String,

            /// Optional. The entity type name prefixed with `@`.
            /// This field is required for annotated parts of the training phrase.
            pub entity_type: std::string::String,

            /// Optional. The parameter name for the value extracted from the
            /// annotated part of the example.
            /// This field is required for annotated parts of the training phrase.
            pub alias: std::string::String,

            /// Optional. Indicates whether the text was manually annotated.
            /// This field is set to true when the Dialogflow Console is used to
            /// manually annotate the part. When creating an annotated part with the
            /// API, you must set this to true.
            pub user_defined: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl Part {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [text][crate::model::intent::training_phrase::Part::text].
            pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.text = v.into();
                self
            }

            /// Sets the value of [entity_type][crate::model::intent::training_phrase::Part::entity_type].
            pub fn set_entity_type<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.entity_type = v.into();
                self
            }

            /// Sets the value of [alias][crate::model::intent::training_phrase::Part::alias].
            pub fn set_alias<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.alias = v.into();
                self
            }

            /// Sets the value of [user_defined][crate::model::intent::training_phrase::Part::user_defined].
            pub fn set_user_defined<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.user_defined = v.into();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for Part {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.TrainingPhrase.Part"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Part {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __text,
                    __entity_type,
                    __alias,
                    __user_defined,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Part")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "text" => Ok(__FieldTag::__text),
                                    "entityType" => Ok(__FieldTag::__entity_type),
                                    "entity_type" => Ok(__FieldTag::__entity_type),
                                    "alias" => Ok(__FieldTag::__alias),
                                    "userDefined" => Ok(__FieldTag::__user_defined),
                                    "user_defined" => Ok(__FieldTag::__user_defined),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Part;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Part")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__text => {
                                    if !fields.insert(__FieldTag::__text) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for text"),
                                        );
                                    }
                                    result.text = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__entity_type => {
                                    if !fields.insert(__FieldTag::__entity_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for entity_type",
                                            ),
                                        );
                                    }
                                    result.entity_type = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__alias => {
                                    if !fields.insert(__FieldTag::__alias) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for alias"),
                                        );
                                    }
                                    result.alias = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__user_defined => {
                                    if !fields.insert(__FieldTag::__user_defined) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for user_defined",
                                            ),
                                        );
                                    }
                                    result.user_defined = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for Part {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.text.is_empty() {
                    state.serialize_entry("text", &self.text)?;
                }
                if !self.entity_type.is_empty() {
                    state.serialize_entry("entityType", &self.entity_type)?;
                }
                if !self.alias.is_empty() {
                    state.serialize_entry("alias", &self.alias)?;
                }
                if !wkt::internal::is_default(&self.user_defined) {
                    state.serialize_entry("userDefined", &self.user_defined)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Represents different types of training phrases.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// Not specified. This value should never be used.
            Unspecified,
            /// Examples do not contain @-prefixed entity type names, but example parts
            /// can be annotated with entity types.
            Example,
            /// Templates are not annotated with entity types, but they can contain
            /// @-prefixed entity type names as substrings.
            /// Template mode has been deprecated. Example mode is the only supported
            /// way to create new training phrases. If you have existing training
            /// phrases that you've created in template mode, those will continue to
            /// work.
            #[deprecated]
            Template,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Type::value] or
            /// [Type::name].
            UnknownValue(r#type::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        pub mod r#type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl Type {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Example => std::option::Option::Some(1),
                    Self::Template => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                    Self::Example => std::option::Option::Some("EXAMPLE"),
                    Self::Template => std::option::Option::Some("TEMPLATE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl std::default::Default for Type {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl std::fmt::Display for Type {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Example,
                    2 => Self::Template,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl std::convert::From<&str> for Type {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TYPE_UNSPECIFIED" => Self::Unspecified,
                    "EXAMPLE" => Self::Example,
                    "TEMPLATE" => Self::Template,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl serde::ser::Serialize for Type {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Example => serializer.serialize_i32(1),
                    Self::Template => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl<'de> serde::de::Deserialize<'de> for Type {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                    ".google.cloud.dialogflow.v2.Intent.TrainingPhrase.Type",
                ))
            }
        }
    }

    /// Represents intent parameters.
    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Parameter {
        /// The unique identifier of this parameter.
        pub name: std::string::String,

        /// Required. The name of the parameter.
        pub display_name: std::string::String,

        /// Optional. The definition of the parameter value. It can be:
        ///
        /// - a constant string,
        /// - a parameter value defined as `$parameter_name`,
        /// - an original parameter value defined as `$parameter_name.original`,
        /// - a parameter value from some context defined as
        ///   `#context_name.parameter_name`.
        pub value: std::string::String,

        /// Optional. The default value to use when the `value` yields an empty
        /// result.
        /// Default values can be extracted from contexts by using the following
        /// syntax: `#context_name.parameter_name`.
        pub default_value: std::string::String,

        /// Optional. The name of the entity type, prefixed with `@`, that
        /// describes values of the parameter. If the parameter is
        /// required, this must be provided.
        pub entity_type_display_name: std::string::String,

        /// Optional. Indicates whether the parameter is required. That is,
        /// whether the intent cannot be completed without collecting the parameter
        /// value.
        pub mandatory: bool,

        /// Optional. The collection of prompts that the agent can present to the
        /// user in order to collect a value for the parameter.
        pub prompts: std::vec::Vec<std::string::String>,

        /// Optional. Indicates whether the parameter represents a list of values.
        pub is_list: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    impl Parameter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::intent::Parameter::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [display_name][crate::model::intent::Parameter::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [value][crate::model::intent::Parameter::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }

        /// Sets the value of [default_value][crate::model::intent::Parameter::default_value].
        pub fn set_default_value<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.default_value = v.into();
            self
        }

        /// Sets the value of [entity_type_display_name][crate::model::intent::Parameter::entity_type_display_name].
        pub fn set_entity_type_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.entity_type_display_name = v.into();
            self
        }

        /// Sets the value of [mandatory][crate::model::intent::Parameter::mandatory].
        pub fn set_mandatory<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.mandatory = v.into();
            self
        }

        /// Sets the value of [prompts][crate::model::intent::Parameter::prompts].
        pub fn set_prompts<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.prompts = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [is_list][crate::model::intent::Parameter::is_list].
        pub fn set_is_list<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.is_list = v.into();
            self
        }
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    impl wkt::message::Message for Parameter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Parameter"
        }
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Parameter {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __display_name,
                __value,
                __default_value,
                __entity_type_display_name,
                __mandatory,
                __prompts,
                __is_list,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Parameter")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                "value" => Ok(__FieldTag::__value),
                                "defaultValue" => Ok(__FieldTag::__default_value),
                                "default_value" => Ok(__FieldTag::__default_value),
                                "entityTypeDisplayName" => {
                                    Ok(__FieldTag::__entity_type_display_name)
                                }
                                "entity_type_display_name" => {
                                    Ok(__FieldTag::__entity_type_display_name)
                                }
                                "mandatory" => Ok(__FieldTag::__mandatory),
                                "prompts" => Ok(__FieldTag::__prompts),
                                "isList" => Ok(__FieldTag::__is_list),
                                "is_list" => Ok(__FieldTag::__is_list),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Parameter;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Parameter")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                result.value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__default_value => {
                                if !fields.insert(__FieldTag::__default_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for default_value",
                                    ));
                                }
                                result.default_value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__entity_type_display_name => {
                                if !fields.insert(__FieldTag::__entity_type_display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for entity_type_display_name",
                                    ));
                                }
                                result.entity_type_display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__mandatory => {
                                if !fields.insert(__FieldTag::__mandatory) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mandatory",
                                    ));
                                }
                                result.mandatory = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__prompts => {
                                if !fields.insert(__FieldTag::__prompts) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for prompts",
                                    ));
                                }
                                result.prompts = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__is_list => {
                                if !fields.insert(__FieldTag::__is_list) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for is_list",
                                    ));
                                }
                                result.is_list = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for Parameter {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self.value.is_empty() {
                state.serialize_entry("value", &self.value)?;
            }
            if !self.default_value.is_empty() {
                state.serialize_entry("defaultValue", &self.default_value)?;
            }
            if !self.entity_type_display_name.is_empty() {
                state.serialize_entry("entityTypeDisplayName", &self.entity_type_display_name)?;
            }
            if !wkt::internal::is_default(&self.mandatory) {
                state.serialize_entry("mandatory", &self.mandatory)?;
            }
            if !self.prompts.is_empty() {
                state.serialize_entry("prompts", &self.prompts)?;
            }
            if !wkt::internal::is_default(&self.is_list) {
                state.serialize_entry("isList", &self.is_list)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A rich response message.
    /// Corresponds to the intent `Response` field in the Dialogflow console.
    /// For more information, see
    /// [Rich response
    /// messages](https://cloud.google.com/dialogflow/docs/intents-rich-messages).
    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Message {
        /// Optional. The platform that this message is intended for.
        pub platform: crate::model::intent::message::Platform,

        /// Required. The rich response message.
        pub message: std::option::Option<crate::model::intent::message::Message>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    impl Message {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [platform][crate::model::intent::Message::platform].
        pub fn set_platform<T: std::convert::Into<crate::model::intent::message::Platform>>(
            mut self,
            v: T,
        ) -> Self {
            self.platform = v.into();
            self
        }

        /// Sets the value of [message][crate::model::intent::Message::message].
        ///
        /// Note that all the setters affecting `message` are mutually
        /// exclusive.
        pub fn set_message<
            T: std::convert::Into<std::option::Option<crate::model::intent::message::Message>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.message = v.into();
            self
        }

        /// The value of [message][crate::model::intent::Message::message]
        /// if it holds a `Text`, `None` if the field is not set or
        /// holds a different branch.
        pub fn text(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::intent::message::Text>> {
            #[allow(unreachable_patterns)]
            self.message.as_ref().and_then(|v| match v {
                crate::model::intent::message::Message::Text(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [message][crate::model::intent::Message::message]
        /// to hold a `Text`.
        ///
        /// Note that all the setters affecting `message` are
        /// mutually exclusive.
        pub fn set_text<
            T: std::convert::Into<std::boxed::Box<crate::model::intent::message::Text>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.message =
                std::option::Option::Some(crate::model::intent::message::Message::Text(v.into()));
            self
        }

        /// The value of [message][crate::model::intent::Message::message]
        /// if it holds a `Image`, `None` if the field is not set or
        /// holds a different branch.
        pub fn image(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::intent::message::Image>> {
            #[allow(unreachable_patterns)]
            self.message.as_ref().and_then(|v| match v {
                crate::model::intent::message::Message::Image(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [message][crate::model::intent::Message::message]
        /// to hold a `Image`.
        ///
        /// Note that all the setters affecting `message` are
        /// mutually exclusive.
        pub fn set_image<
            T: std::convert::Into<std::boxed::Box<crate::model::intent::message::Image>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.message =
                std::option::Option::Some(crate::model::intent::message::Message::Image(v.into()));
            self
        }

        /// The value of [message][crate::model::intent::Message::message]
        /// if it holds a `QuickReplies`, `None` if the field is not set or
        /// holds a different branch.
        pub fn quick_replies(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::intent::message::QuickReplies>>
        {
            #[allow(unreachable_patterns)]
            self.message.as_ref().and_then(|v| match v {
                crate::model::intent::message::Message::QuickReplies(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [message][crate::model::intent::Message::message]
        /// to hold a `QuickReplies`.
        ///
        /// Note that all the setters affecting `message` are
        /// mutually exclusive.
        pub fn set_quick_replies<
            T: std::convert::Into<std::boxed::Box<crate::model::intent::message::QuickReplies>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.message = std::option::Option::Some(
                crate::model::intent::message::Message::QuickReplies(v.into()),
            );
            self
        }

        /// The value of [message][crate::model::intent::Message::message]
        /// if it holds a `Card`, `None` if the field is not set or
        /// holds a different branch.
        pub fn card(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::intent::message::Card>> {
            #[allow(unreachable_patterns)]
            self.message.as_ref().and_then(|v| match v {
                crate::model::intent::message::Message::Card(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [message][crate::model::intent::Message::message]
        /// to hold a `Card`.
        ///
        /// Note that all the setters affecting `message` are
        /// mutually exclusive.
        pub fn set_card<
            T: std::convert::Into<std::boxed::Box<crate::model::intent::message::Card>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.message =
                std::option::Option::Some(crate::model::intent::message::Message::Card(v.into()));
            self
        }

        /// The value of [message][crate::model::intent::Message::message]
        /// if it holds a `Payload`, `None` if the field is not set or
        /// holds a different branch.
        pub fn payload(&self) -> std::option::Option<&std::boxed::Box<wkt::Struct>> {
            #[allow(unreachable_patterns)]
            self.message.as_ref().and_then(|v| match v {
                crate::model::intent::message::Message::Payload(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [message][crate::model::intent::Message::message]
        /// to hold a `Payload`.
        ///
        /// Note that all the setters affecting `message` are
        /// mutually exclusive.
        pub fn set_payload<T: std::convert::Into<std::boxed::Box<wkt::Struct>>>(
            mut self,
            v: T,
        ) -> Self {
            self.message = std::option::Option::Some(
                crate::model::intent::message::Message::Payload(v.into()),
            );
            self
        }

        /// The value of [message][crate::model::intent::Message::message]
        /// if it holds a `SimpleResponses`, `None` if the field is not set or
        /// holds a different branch.
        pub fn simple_responses(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::intent::message::SimpleResponses>>
        {
            #[allow(unreachable_patterns)]
            self.message.as_ref().and_then(|v| match v {
                crate::model::intent::message::Message::SimpleResponses(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [message][crate::model::intent::Message::message]
        /// to hold a `SimpleResponses`.
        ///
        /// Note that all the setters affecting `message` are
        /// mutually exclusive.
        pub fn set_simple_responses<
            T: std::convert::Into<std::boxed::Box<crate::model::intent::message::SimpleResponses>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.message = std::option::Option::Some(
                crate::model::intent::message::Message::SimpleResponses(v.into()),
            );
            self
        }

        /// The value of [message][crate::model::intent::Message::message]
        /// if it holds a `BasicCard`, `None` if the field is not set or
        /// holds a different branch.
        pub fn basic_card(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::intent::message::BasicCard>>
        {
            #[allow(unreachable_patterns)]
            self.message.as_ref().and_then(|v| match v {
                crate::model::intent::message::Message::BasicCard(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [message][crate::model::intent::Message::message]
        /// to hold a `BasicCard`.
        ///
        /// Note that all the setters affecting `message` are
        /// mutually exclusive.
        pub fn set_basic_card<
            T: std::convert::Into<std::boxed::Box<crate::model::intent::message::BasicCard>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.message = std::option::Option::Some(
                crate::model::intent::message::Message::BasicCard(v.into()),
            );
            self
        }

        /// The value of [message][crate::model::intent::Message::message]
        /// if it holds a `Suggestions`, `None` if the field is not set or
        /// holds a different branch.
        pub fn suggestions(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::intent::message::Suggestions>>
        {
            #[allow(unreachable_patterns)]
            self.message.as_ref().and_then(|v| match v {
                crate::model::intent::message::Message::Suggestions(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [message][crate::model::intent::Message::message]
        /// to hold a `Suggestions`.
        ///
        /// Note that all the setters affecting `message` are
        /// mutually exclusive.
        pub fn set_suggestions<
            T: std::convert::Into<std::boxed::Box<crate::model::intent::message::Suggestions>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.message = std::option::Option::Some(
                crate::model::intent::message::Message::Suggestions(v.into()),
            );
            self
        }

        /// The value of [message][crate::model::intent::Message::message]
        /// if it holds a `LinkOutSuggestion`, `None` if the field is not set or
        /// holds a different branch.
        pub fn link_out_suggestion(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::intent::message::LinkOutSuggestion>>
        {
            #[allow(unreachable_patterns)]
            self.message.as_ref().and_then(|v| match v {
                crate::model::intent::message::Message::LinkOutSuggestion(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [message][crate::model::intent::Message::message]
        /// to hold a `LinkOutSuggestion`.
        ///
        /// Note that all the setters affecting `message` are
        /// mutually exclusive.
        pub fn set_link_out_suggestion<
            T: std::convert::Into<std::boxed::Box<crate::model::intent::message::LinkOutSuggestion>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.message = std::option::Option::Some(
                crate::model::intent::message::Message::LinkOutSuggestion(v.into()),
            );
            self
        }

        /// The value of [message][crate::model::intent::Message::message]
        /// if it holds a `ListSelect`, `None` if the field is not set or
        /// holds a different branch.
        pub fn list_select(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::intent::message::ListSelect>>
        {
            #[allow(unreachable_patterns)]
            self.message.as_ref().and_then(|v| match v {
                crate::model::intent::message::Message::ListSelect(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [message][crate::model::intent::Message::message]
        /// to hold a `ListSelect`.
        ///
        /// Note that all the setters affecting `message` are
        /// mutually exclusive.
        pub fn set_list_select<
            T: std::convert::Into<std::boxed::Box<crate::model::intent::message::ListSelect>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.message = std::option::Option::Some(
                crate::model::intent::message::Message::ListSelect(v.into()),
            );
            self
        }

        /// The value of [message][crate::model::intent::Message::message]
        /// if it holds a `CarouselSelect`, `None` if the field is not set or
        /// holds a different branch.
        pub fn carousel_select(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::intent::message::CarouselSelect>>
        {
            #[allow(unreachable_patterns)]
            self.message.as_ref().and_then(|v| match v {
                crate::model::intent::message::Message::CarouselSelect(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [message][crate::model::intent::Message::message]
        /// to hold a `CarouselSelect`.
        ///
        /// Note that all the setters affecting `message` are
        /// mutually exclusive.
        pub fn set_carousel_select<
            T: std::convert::Into<std::boxed::Box<crate::model::intent::message::CarouselSelect>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.message = std::option::Option::Some(
                crate::model::intent::message::Message::CarouselSelect(v.into()),
            );
            self
        }

        /// The value of [message][crate::model::intent::Message::message]
        /// if it holds a `BrowseCarouselCard`, `None` if the field is not set or
        /// holds a different branch.
        pub fn browse_carousel_card(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::intent::message::BrowseCarouselCard>>
        {
            #[allow(unreachable_patterns)]
            self.message.as_ref().and_then(|v| match v {
                crate::model::intent::message::Message::BrowseCarouselCard(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [message][crate::model::intent::Message::message]
        /// to hold a `BrowseCarouselCard`.
        ///
        /// Note that all the setters affecting `message` are
        /// mutually exclusive.
        pub fn set_browse_carousel_card<
            T: std::convert::Into<std::boxed::Box<crate::model::intent::message::BrowseCarouselCard>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.message = std::option::Option::Some(
                crate::model::intent::message::Message::BrowseCarouselCard(v.into()),
            );
            self
        }

        /// The value of [message][crate::model::intent::Message::message]
        /// if it holds a `TableCard`, `None` if the field is not set or
        /// holds a different branch.
        pub fn table_card(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::intent::message::TableCard>>
        {
            #[allow(unreachable_patterns)]
            self.message.as_ref().and_then(|v| match v {
                crate::model::intent::message::Message::TableCard(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [message][crate::model::intent::Message::message]
        /// to hold a `TableCard`.
        ///
        /// Note that all the setters affecting `message` are
        /// mutually exclusive.
        pub fn set_table_card<
            T: std::convert::Into<std::boxed::Box<crate::model::intent::message::TableCard>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.message = std::option::Option::Some(
                crate::model::intent::message::Message::TableCard(v.into()),
            );
            self
        }

        /// The value of [message][crate::model::intent::Message::message]
        /// if it holds a `MediaContent`, `None` if the field is not set or
        /// holds a different branch.
        pub fn media_content(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::intent::message::MediaContent>>
        {
            #[allow(unreachable_patterns)]
            self.message.as_ref().and_then(|v| match v {
                crate::model::intent::message::Message::MediaContent(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [message][crate::model::intent::Message::message]
        /// to hold a `MediaContent`.
        ///
        /// Note that all the setters affecting `message` are
        /// mutually exclusive.
        pub fn set_media_content<
            T: std::convert::Into<std::boxed::Box<crate::model::intent::message::MediaContent>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.message = std::option::Option::Some(
                crate::model::intent::message::Message::MediaContent(v.into()),
            );
            self
        }
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    impl wkt::message::Message for Message {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message"
        }
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Message {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __text,
                __image,
                __quick_replies,
                __card,
                __payload,
                __simple_responses,
                __basic_card,
                __suggestions,
                __link_out_suggestion,
                __list_select,
                __carousel_select,
                __browse_carousel_card,
                __table_card,
                __media_content,
                __platform,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Message")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "text" => Ok(__FieldTag::__text),
                                "image" => Ok(__FieldTag::__image),
                                "quickReplies" => Ok(__FieldTag::__quick_replies),
                                "quick_replies" => Ok(__FieldTag::__quick_replies),
                                "card" => Ok(__FieldTag::__card),
                                "payload" => Ok(__FieldTag::__payload),
                                "simpleResponses" => Ok(__FieldTag::__simple_responses),
                                "simple_responses" => Ok(__FieldTag::__simple_responses),
                                "basicCard" => Ok(__FieldTag::__basic_card),
                                "basic_card" => Ok(__FieldTag::__basic_card),
                                "suggestions" => Ok(__FieldTag::__suggestions),
                                "linkOutSuggestion" => Ok(__FieldTag::__link_out_suggestion),
                                "link_out_suggestion" => Ok(__FieldTag::__link_out_suggestion),
                                "listSelect" => Ok(__FieldTag::__list_select),
                                "list_select" => Ok(__FieldTag::__list_select),
                                "carouselSelect" => Ok(__FieldTag::__carousel_select),
                                "carousel_select" => Ok(__FieldTag::__carousel_select),
                                "browseCarouselCard" => Ok(__FieldTag::__browse_carousel_card),
                                "browse_carousel_card" => Ok(__FieldTag::__browse_carousel_card),
                                "tableCard" => Ok(__FieldTag::__table_card),
                                "table_card" => Ok(__FieldTag::__table_card),
                                "mediaContent" => Ok(__FieldTag::__media_content),
                                "media_content" => Ok(__FieldTag::__media_content),
                                "platform" => Ok(__FieldTag::__platform),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Message;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Message")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__text => {
                                if !fields.insert(__FieldTag::__text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for text",
                                    ));
                                }
                                if result.message.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.text, latest field was text",
                                    ));
                                }
                                result.message = std::option::Option::Some(
                                    crate::model::intent::message::Message::Text(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::intent::message::Text>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__image => {
                                if !fields.insert(__FieldTag::__image) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for image",
                                    ));
                                }
                                if result.message.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.image, latest field was image",
                                    ));
                                }
                                result.message = std::option::Option::Some(
                                    crate::model::intent::message::Message::Image(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::intent::message::Image>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__quick_replies => {
                                if !fields.insert(__FieldTag::__quick_replies) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for quick_replies",
                                    ));
                                }
                                if result.message.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.quick_replies, latest field was quickReplies",
                                    ));
                                }
                                result.message = std::option::Option::Some(
                                    crate::model::intent::message::Message::QuickReplies(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::intent::message::QuickReplies,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__card => {
                                if !fields.insert(__FieldTag::__card) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for card",
                                    ));
                                }
                                if result.message.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.card, latest field was card",
                                    ));
                                }
                                result.message = std::option::Option::Some(
                                    crate::model::intent::message::Message::Card(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::intent::message::Card>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__payload => {
                                if !fields.insert(__FieldTag::__payload) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for payload",
                                    ));
                                }
                                if result.message.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.payload, latest field was payload",
                                    ));
                                }
                                result.message = std::option::Option::Some(
                                    crate::model::intent::message::Message::Payload(
                                        map.next_value::<std::option::Option<std::boxed::Box<wkt::Struct>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__simple_responses => {
                                if !fields.insert(__FieldTag::__simple_responses) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for simple_responses",
                                    ));
                                }
                                if result.message.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.simple_responses, latest field was simpleResponses",
                                    ));
                                }
                                result.message = std::option::Option::Some(
                                    crate::model::intent::message::Message::SimpleResponses(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::intent::message::SimpleResponses,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__basic_card => {
                                if !fields.insert(__FieldTag::__basic_card) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for basic_card",
                                    ));
                                }
                                if result.message.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.basic_card, latest field was basicCard",
                                    ));
                                }
                                result.message = std::option::Option::Some(
                                    crate::model::intent::message::Message::BasicCard(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::intent::message::BasicCard,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__suggestions => {
                                if !fields.insert(__FieldTag::__suggestions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for suggestions",
                                    ));
                                }
                                if result.message.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.suggestions, latest field was suggestions",
                                    ));
                                }
                                result.message = std::option::Option::Some(
                                    crate::model::intent::message::Message::Suggestions(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::intent::message::Suggestions,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__link_out_suggestion => {
                                if !fields.insert(__FieldTag::__link_out_suggestion) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for link_out_suggestion",
                                    ));
                                }
                                if result.message.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.link_out_suggestion, latest field was linkOutSuggestion",
                                    ));
                                }
                                result.message = std::option::Option::Some(
                                    crate::model::intent::message::Message::LinkOutSuggestion(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::intent::message::LinkOutSuggestion,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__list_select => {
                                if !fields.insert(__FieldTag::__list_select) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for list_select",
                                    ));
                                }
                                if result.message.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.list_select, latest field was listSelect",
                                    ));
                                }
                                result.message = std::option::Option::Some(
                                    crate::model::intent::message::Message::ListSelect(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::intent::message::ListSelect,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__carousel_select => {
                                if !fields.insert(__FieldTag::__carousel_select) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for carousel_select",
                                    ));
                                }
                                if result.message.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.carousel_select, latest field was carouselSelect",
                                    ));
                                }
                                result.message = std::option::Option::Some(
                                    crate::model::intent::message::Message::CarouselSelect(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::intent::message::CarouselSelect,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__browse_carousel_card => {
                                if !fields.insert(__FieldTag::__browse_carousel_card) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for browse_carousel_card",
                                    ));
                                }
                                if result.message.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.browse_carousel_card, latest field was browseCarouselCard",
                                    ));
                                }
                                result.message = std::option::Option::Some(
                                    crate::model::intent::message::Message::BrowseCarouselCard(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::intent::message::BrowseCarouselCard,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__table_card => {
                                if !fields.insert(__FieldTag::__table_card) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for table_card",
                                    ));
                                }
                                if result.message.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.table_card, latest field was tableCard",
                                    ));
                                }
                                result.message = std::option::Option::Some(
                                    crate::model::intent::message::Message::TableCard(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::intent::message::TableCard,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__media_content => {
                                if !fields.insert(__FieldTag::__media_content) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for media_content",
                                    ));
                                }
                                if result.message.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `message`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.media_content, latest field was mediaContent",
                                    ));
                                }
                                result.message = std::option::Option::Some(
                                    crate::model::intent::message::Message::MediaContent(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::intent::message::MediaContent,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__platform => {
                                if !fields.insert(__FieldTag::__platform) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for platform",
                                    ));
                                }
                                result.platform =
                                    map.next_value::<std::option::Option<
                                        crate::model::intent::message::Platform,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for Message {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.text() {
                state.serialize_entry("text", value)?;
            }
            if let Some(value) = self.image() {
                state.serialize_entry("image", value)?;
            }
            if let Some(value) = self.quick_replies() {
                state.serialize_entry("quickReplies", value)?;
            }
            if let Some(value) = self.card() {
                state.serialize_entry("card", value)?;
            }
            if let Some(value) = self.payload() {
                state.serialize_entry("payload", value)?;
            }
            if let Some(value) = self.simple_responses() {
                state.serialize_entry("simpleResponses", value)?;
            }
            if let Some(value) = self.basic_card() {
                state.serialize_entry("basicCard", value)?;
            }
            if let Some(value) = self.suggestions() {
                state.serialize_entry("suggestions", value)?;
            }
            if let Some(value) = self.link_out_suggestion() {
                state.serialize_entry("linkOutSuggestion", value)?;
            }
            if let Some(value) = self.list_select() {
                state.serialize_entry("listSelect", value)?;
            }
            if let Some(value) = self.carousel_select() {
                state.serialize_entry("carouselSelect", value)?;
            }
            if let Some(value) = self.browse_carousel_card() {
                state.serialize_entry("browseCarouselCard", value)?;
            }
            if let Some(value) = self.table_card() {
                state.serialize_entry("tableCard", value)?;
            }
            if let Some(value) = self.media_content() {
                state.serialize_entry("mediaContent", value)?;
            }
            if !wkt::internal::is_default(&self.platform) {
                state.serialize_entry("platform", &self.platform)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Message].
    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    pub mod message {
        #[allow(unused_imports)]
        use super::*;

        /// The text response message.
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Text {
            /// Optional. The collection of the agent's responses.
            pub text: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl Text {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [text][crate::model::intent::message::Text::text].
            pub fn set_text<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.text = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for Text {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.Text"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Text {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __text,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Text")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "text" => Ok(__FieldTag::__text),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Text;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Text")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__text => {
                                    if !fields.insert(__FieldTag::__text) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for text"),
                                        );
                                    }
                                    result.text = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for Text {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.text.is_empty() {
                    state.serialize_entry("text", &self.text)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The image response message.
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Image {
            /// Optional. The public URI to an image file.
            pub image_uri: std::string::String,

            /// Optional. A text description of the image to be used for accessibility,
            /// e.g., screen readers.
            pub accessibility_text: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl Image {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [image_uri][crate::model::intent::message::Image::image_uri].
            pub fn set_image_uri<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.image_uri = v.into();
                self
            }

            /// Sets the value of [accessibility_text][crate::model::intent::message::Image::accessibility_text].
            pub fn set_accessibility_text<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.accessibility_text = v.into();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for Image {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.Image"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Image {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __image_uri,
                    __accessibility_text,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Image")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "imageUri" => Ok(__FieldTag::__image_uri),
                                    "image_uri" => Ok(__FieldTag::__image_uri),
                                    "accessibilityText" => Ok(__FieldTag::__accessibility_text),
                                    "accessibility_text" => Ok(__FieldTag::__accessibility_text),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Image;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Image")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__image_uri => {
                                    if !fields.insert(__FieldTag::__image_uri) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for image_uri",
                                            ),
                                        );
                                    }
                                    result.image_uri = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__accessibility_text => {
                                    if !fields.insert(__FieldTag::__accessibility_text) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for accessibility_text",
                                            ),
                                        );
                                    }
                                    result.accessibility_text = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for Image {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.image_uri.is_empty() {
                    state.serialize_entry("imageUri", &self.image_uri)?;
                }
                if !self.accessibility_text.is_empty() {
                    state.serialize_entry("accessibilityText", &self.accessibility_text)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The quick replies response message.
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct QuickReplies {
            /// Optional. The title of the collection of quick replies.
            pub title: std::string::String,

            /// Optional. The collection of quick replies.
            pub quick_replies: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl QuickReplies {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [title][crate::model::intent::message::QuickReplies::title].
            pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.title = v.into();
                self
            }

            /// Sets the value of [quick_replies][crate::model::intent::message::QuickReplies::quick_replies].
            pub fn set_quick_replies<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.quick_replies = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for QuickReplies {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.QuickReplies"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for QuickReplies {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __title,
                    __quick_replies,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for QuickReplies")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "title" => Ok(__FieldTag::__title),
                                    "quickReplies" => Ok(__FieldTag::__quick_replies),
                                    "quick_replies" => Ok(__FieldTag::__quick_replies),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = QuickReplies;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct QuickReplies")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__title => {
                                    if !fields.insert(__FieldTag::__title) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for title"),
                                        );
                                    }
                                    result.title = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__quick_replies => {
                                    if !fields.insert(__FieldTag::__quick_replies) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for quick_replies",
                                            ),
                                        );
                                    }
                                    result.quick_replies = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for QuickReplies {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.title.is_empty() {
                    state.serialize_entry("title", &self.title)?;
                }
                if !self.quick_replies.is_empty() {
                    state.serialize_entry("quickReplies", &self.quick_replies)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The card response message.
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Card {
            /// Optional. The title of the card.
            pub title: std::string::String,

            /// Optional. The subtitle of the card.
            pub subtitle: std::string::String,

            /// Optional. The public URI to an image file for the card.
            pub image_uri: std::string::String,

            /// Optional. The collection of card buttons.
            pub buttons: std::vec::Vec<crate::model::intent::message::card::Button>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl Card {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [title][crate::model::intent::message::Card::title].
            pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.title = v.into();
                self
            }

            /// Sets the value of [subtitle][crate::model::intent::message::Card::subtitle].
            pub fn set_subtitle<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.subtitle = v.into();
                self
            }

            /// Sets the value of [image_uri][crate::model::intent::message::Card::image_uri].
            pub fn set_image_uri<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.image_uri = v.into();
                self
            }

            /// Sets the value of [buttons][crate::model::intent::message::Card::buttons].
            pub fn set_buttons<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::intent::message::card::Button>,
            {
                use std::iter::Iterator;
                self.buttons = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for Card {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.Card"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Card {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __title,
                    __subtitle,
                    __image_uri,
                    __buttons,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Card")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "title" => Ok(__FieldTag::__title),
                                    "subtitle" => Ok(__FieldTag::__subtitle),
                                    "imageUri" => Ok(__FieldTag::__image_uri),
                                    "image_uri" => Ok(__FieldTag::__image_uri),
                                    "buttons" => Ok(__FieldTag::__buttons),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Card;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Card")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__title => {
                                    if !fields.insert(__FieldTag::__title) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for title"),
                                        );
                                    }
                                    result.title = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__subtitle => {
                                    if !fields.insert(__FieldTag::__subtitle) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for subtitle",
                                            ),
                                        );
                                    }
                                    result.subtitle = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__image_uri => {
                                    if !fields.insert(__FieldTag::__image_uri) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for image_uri",
                                            ),
                                        );
                                    }
                                    result.image_uri = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__buttons => {
                                    if !fields.insert(__FieldTag::__buttons) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for buttons",
                                            ),
                                        );
                                    }
                                    result.buttons = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::intent::message::card::Button,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for Card {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.title.is_empty() {
                    state.serialize_entry("title", &self.title)?;
                }
                if !self.subtitle.is_empty() {
                    state.serialize_entry("subtitle", &self.subtitle)?;
                }
                if !self.image_uri.is_empty() {
                    state.serialize_entry("imageUri", &self.image_uri)?;
                }
                if !self.buttons.is_empty() {
                    state.serialize_entry("buttons", &self.buttons)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [Card].
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        pub mod card {
            #[allow(unused_imports)]
            use super::*;

            /// Contains information about a button.
            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Button {
                /// Optional. The text to show on the button.
                pub text: std::string::String,

                /// Optional. The text to send back to the Dialogflow API or a URI to
                /// open.
                pub postback: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl Button {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [text][crate::model::intent::message::card::Button::text].
                pub fn set_text<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.text = v.into();
                    self
                }

                /// Sets the value of [postback][crate::model::intent::message::card::Button::postback].
                pub fn set_postback<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.postback = v.into();
                    self
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl wkt::message::Message for Button {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.Card.Button"
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Button {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __text,
                        __postback,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Button")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "text" => Ok(__FieldTag::__text),
                                        "postback" => Ok(__FieldTag::__postback),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Button;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Button")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__text => {
                                        if !fields.insert(__FieldTag::__text) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for text",
                                                ),
                                            );
                                        }
                                        result.text = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__postback => {
                                        if !fields.insert(__FieldTag::__postback) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for postback",
                                                ),
                                            );
                                        }
                                        result.postback = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[doc(hidden)]
            impl serde::ser::Serialize for Button {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.text.is_empty() {
                        state.serialize_entry("text", &self.text)?;
                    }
                    if !self.postback.is_empty() {
                        state.serialize_entry("postback", &self.postback)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }
        }

        /// The simple response message containing speech or text.
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct SimpleResponse {
            /// One of text_to_speech or ssml must be provided. The plain text of the
            /// speech output. Mutually exclusive with ssml.
            pub text_to_speech: std::string::String,

            /// One of text_to_speech or ssml must be provided. Structured spoken
            /// response to the user in the SSML format. Mutually exclusive with
            /// text_to_speech.
            pub ssml: std::string::String,

            /// Optional. The text to display.
            pub display_text: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl SimpleResponse {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [text_to_speech][crate::model::intent::message::SimpleResponse::text_to_speech].
            pub fn set_text_to_speech<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.text_to_speech = v.into();
                self
            }

            /// Sets the value of [ssml][crate::model::intent::message::SimpleResponse::ssml].
            pub fn set_ssml<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.ssml = v.into();
                self
            }

            /// Sets the value of [display_text][crate::model::intent::message::SimpleResponse::display_text].
            pub fn set_display_text<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.display_text = v.into();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for SimpleResponse {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.SimpleResponse"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for SimpleResponse {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __text_to_speech,
                    __ssml,
                    __display_text,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for SimpleResponse")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "textToSpeech" => Ok(__FieldTag::__text_to_speech),
                                    "text_to_speech" => Ok(__FieldTag::__text_to_speech),
                                    "ssml" => Ok(__FieldTag::__ssml),
                                    "displayText" => Ok(__FieldTag::__display_text),
                                    "display_text" => Ok(__FieldTag::__display_text),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = SimpleResponse;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct SimpleResponse")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__text_to_speech => {
                                    if !fields.insert(__FieldTag::__text_to_speech) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for text_to_speech",
                                            ),
                                        );
                                    }
                                    result.text_to_speech = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__ssml => {
                                    if !fields.insert(__FieldTag::__ssml) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for ssml"),
                                        );
                                    }
                                    result.ssml = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__display_text => {
                                    if !fields.insert(__FieldTag::__display_text) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for display_text",
                                            ),
                                        );
                                    }
                                    result.display_text = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for SimpleResponse {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.text_to_speech.is_empty() {
                    state.serialize_entry("textToSpeech", &self.text_to_speech)?;
                }
                if !self.ssml.is_empty() {
                    state.serialize_entry("ssml", &self.ssml)?;
                }
                if !self.display_text.is_empty() {
                    state.serialize_entry("displayText", &self.display_text)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The collection of simple response candidates.
        /// This message in `QueryResult.fulfillment_messages` and
        /// `WebhookResponse.fulfillment_messages` should contain only one
        /// `SimpleResponse`.
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct SimpleResponses {
            /// Required. The list of simple responses.
            pub simple_responses: std::vec::Vec<crate::model::intent::message::SimpleResponse>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl SimpleResponses {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [simple_responses][crate::model::intent::message::SimpleResponses::simple_responses].
            pub fn set_simple_responses<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::intent::message::SimpleResponse>,
            {
                use std::iter::Iterator;
                self.simple_responses = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for SimpleResponses {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.SimpleResponses"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for SimpleResponses {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __simple_responses,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for SimpleResponses")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "simpleResponses" => Ok(__FieldTag::__simple_responses),
                                    "simple_responses" => Ok(__FieldTag::__simple_responses),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = SimpleResponses;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct SimpleResponses")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__simple_responses => {
                                    if !fields.insert(__FieldTag::__simple_responses) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for simple_responses",
                                            ),
                                        );
                                    }
                                    result.simple_responses = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::intent::message::SimpleResponse,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for SimpleResponses {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.simple_responses.is_empty() {
                    state.serialize_entry("simpleResponses", &self.simple_responses)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The basic card message. Useful for displaying information.
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct BasicCard {
            /// Optional. The title of the card.
            pub title: std::string::String,

            /// Optional. The subtitle of the card.
            pub subtitle: std::string::String,

            /// Required, unless image is present. The body text of the card.
            pub formatted_text: std::string::String,

            /// Optional. The image for the card.
            pub image: std::option::Option<crate::model::intent::message::Image>,

            /// Optional. The collection of card buttons.
            pub buttons: std::vec::Vec<crate::model::intent::message::basic_card::Button>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl BasicCard {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [title][crate::model::intent::message::BasicCard::title].
            pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.title = v.into();
                self
            }

            /// Sets the value of [subtitle][crate::model::intent::message::BasicCard::subtitle].
            pub fn set_subtitle<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.subtitle = v.into();
                self
            }

            /// Sets the value of [formatted_text][crate::model::intent::message::BasicCard::formatted_text].
            pub fn set_formatted_text<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.formatted_text = v.into();
                self
            }

            /// Sets the value of [image][crate::model::intent::message::BasicCard::image].
            pub fn set_image<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::intent::message::Image>,
            {
                self.image = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [image][crate::model::intent::message::BasicCard::image].
            pub fn set_or_clear_image<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::intent::message::Image>,
            {
                self.image = v.map(|x| x.into());
                self
            }

            /// Sets the value of [buttons][crate::model::intent::message::BasicCard::buttons].
            pub fn set_buttons<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::intent::message::basic_card::Button>,
            {
                use std::iter::Iterator;
                self.buttons = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for BasicCard {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.BasicCard"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for BasicCard {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __title,
                    __subtitle,
                    __formatted_text,
                    __image,
                    __buttons,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for BasicCard")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "title" => Ok(__FieldTag::__title),
                                    "subtitle" => Ok(__FieldTag::__subtitle),
                                    "formattedText" => Ok(__FieldTag::__formatted_text),
                                    "formatted_text" => Ok(__FieldTag::__formatted_text),
                                    "image" => Ok(__FieldTag::__image),
                                    "buttons" => Ok(__FieldTag::__buttons),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = BasicCard;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct BasicCard")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__title => {
                                    if !fields.insert(__FieldTag::__title) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for title"),
                                        );
                                    }
                                    result.title = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__subtitle => {
                                    if !fields.insert(__FieldTag::__subtitle) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for subtitle",
                                            ),
                                        );
                                    }
                                    result.subtitle = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__formatted_text => {
                                    if !fields.insert(__FieldTag::__formatted_text) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for formatted_text",
                                            ),
                                        );
                                    }
                                    result.formatted_text = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__image => {
                                    if !fields.insert(__FieldTag::__image) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for image"),
                                        );
                                    }
                                    result.image =
                                        map.next_value::<std::option::Option<
                                            crate::model::intent::message::Image,
                                        >>()?;
                                }
                                __FieldTag::__buttons => {
                                    if !fields.insert(__FieldTag::__buttons) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for buttons",
                                            ),
                                        );
                                    }
                                    result.buttons = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::intent::message::basic_card::Button,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for BasicCard {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.title.is_empty() {
                    state.serialize_entry("title", &self.title)?;
                }
                if !self.subtitle.is_empty() {
                    state.serialize_entry("subtitle", &self.subtitle)?;
                }
                if !self.formatted_text.is_empty() {
                    state.serialize_entry("formattedText", &self.formatted_text)?;
                }
                if self.image.is_some() {
                    state.serialize_entry("image", &self.image)?;
                }
                if !self.buttons.is_empty() {
                    state.serialize_entry("buttons", &self.buttons)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [BasicCard].
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        pub mod basic_card {
            #[allow(unused_imports)]
            use super::*;

            /// The button object that appears at the bottom of a card.
            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Button {
                /// Required. The title of the button.
                pub title: std::string::String,

                /// Required. Action to take when a user taps on the button.
                pub open_uri_action: std::option::Option<
                    crate::model::intent::message::basic_card::button::OpenUriAction,
                >,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl Button {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [title][crate::model::intent::message::basic_card::Button::title].
                pub fn set_title<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.title = v.into();
                    self
                }

                /// Sets the value of [open_uri_action][crate::model::intent::message::basic_card::Button::open_uri_action].
                pub fn set_open_uri_action<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<
                            crate::model::intent::message::basic_card::button::OpenUriAction,
                        >,
                {
                    self.open_uri_action = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [open_uri_action][crate::model::intent::message::basic_card::Button::open_uri_action].
                pub fn set_or_clear_open_uri_action<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<
                            crate::model::intent::message::basic_card::button::OpenUriAction,
                        >,
                {
                    self.open_uri_action = v.map(|x| x.into());
                    self
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl wkt::message::Message for Button {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.BasicCard.Button"
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Button {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __title,
                        __open_uri_action,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Button")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "title" => Ok(__FieldTag::__title),
                                        "openUriAction" => Ok(__FieldTag::__open_uri_action),
                                        "open_uri_action" => Ok(__FieldTag::__open_uri_action),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Button;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Button")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__title => {
                                        if !fields.insert(__FieldTag::__title) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for title",
                                                ),
                                            );
                                        }
                                        result.title = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__open_uri_action => {
                                        if !fields.insert(__FieldTag::__open_uri_action) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for open_uri_action",
                                                ),
                                            );
                                        }
                                        result.open_uri_action = map.next_value::<std::option::Option<crate::model::intent::message::basic_card::button::OpenUriAction>>()?
                                            ;
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[doc(hidden)]
            impl serde::ser::Serialize for Button {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.title.is_empty() {
                        state.serialize_entry("title", &self.title)?;
                    }
                    if self.open_uri_action.is_some() {
                        state.serialize_entry("openUriAction", &self.open_uri_action)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Defines additional types related to [Button].
            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            pub mod button {
                #[allow(unused_imports)]
                use super::*;

                /// Opens the given URI.
                #[cfg(any(
                    feature = "answer-records",
                    feature = "intents",
                    feature = "participants",
                    feature = "sessions",
                ))]
                #[derive(Clone, Debug, Default, PartialEq)]
                #[non_exhaustive]
                pub struct OpenUriAction {
                    /// Required. The HTTP or HTTPS scheme URI.
                    pub uri: std::string::String,

                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                #[cfg(any(
                    feature = "answer-records",
                    feature = "intents",
                    feature = "participants",
                    feature = "sessions",
                ))]
                impl OpenUriAction {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [uri][crate::model::intent::message::basic_card::button::OpenUriAction::uri].
                    pub fn set_uri<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.uri = v.into();
                        self
                    }
                }

                #[cfg(any(
                    feature = "answer-records",
                    feature = "intents",
                    feature = "participants",
                    feature = "sessions",
                ))]
                impl wkt::message::Message for OpenUriAction {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.BasicCard.Button.OpenUriAction"
                    }
                }

                #[cfg(any(
                    feature = "answer-records",
                    feature = "intents",
                    feature = "participants",
                    feature = "sessions",
                ))]
                #[doc(hidden)]
                impl<'de> serde::de::Deserialize<'de> for OpenUriAction {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        #[derive(PartialEq, Eq, Hash)]
                        enum __FieldTag {
                            __uri,
                            Unknown(std::string::String),
                        }
                        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                            fn deserialize<D>(
                                deserializer: D,
                            ) -> std::result::Result<Self, D::Error>
                            where
                                D: serde::Deserializer<'de>,
                            {
                                struct Visitor;
                                impl<'de> serde::de::Visitor<'de> for Visitor {
                                    type Value = __FieldTag;
                                    fn expecting(
                                        &self,
                                        formatter: &mut std::fmt::Formatter,
                                    ) -> std::fmt::Result {
                                        formatter.write_str("a field name for OpenUriAction")
                                    }
                                    fn visit_str<E>(
                                        self,
                                        value: &str,
                                    ) -> std::result::Result<Self::Value, E>
                                    where
                                        E: serde::de::Error,
                                    {
                                        use std::result::Result::Ok;
                                        use std::string::ToString;
                                        match value {
                                            "uri" => Ok(__FieldTag::__uri),
                                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                                        }
                                    }
                                }
                                deserializer.deserialize_identifier(Visitor)
                            }
                        }
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = OpenUriAction;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("struct OpenUriAction")
                            }
                            fn visit_map<A>(
                                self,
                                mut map: A,
                            ) -> std::result::Result<Self::Value, A::Error>
                            where
                                A: serde::de::MapAccess<'de>,
                            {
                                #[allow(unused_imports)]
                                use serde::de::Error;
                                use std::option::Option::Some;
                                let mut fields = std::collections::HashSet::new();
                                let mut result = Self::Value::new();
                                while let Some(tag) = map.next_key::<__FieldTag>()? {
                                    #[allow(clippy::match_single_binding)]
                                    match tag {
                                        __FieldTag::__uri => {
                                            if !fields.insert(__FieldTag::__uri) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for uri",
                                                    ),
                                                );
                                            }
                                            result.uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                                        }
                                        __FieldTag::Unknown(key) => {
                                            let value = map.next_value::<serde_json::Value>()?;
                                            result._unknown_fields.insert(key, value);
                                        }
                                    }
                                }
                                std::result::Result::Ok(result)
                            }
                        }
                        deserializer.deserialize_any(Visitor)
                    }
                }

                #[cfg(any(
                    feature = "answer-records",
                    feature = "intents",
                    feature = "participants",
                    feature = "sessions",
                ))]
                #[doc(hidden)]
                impl serde::ser::Serialize for OpenUriAction {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        use serde::ser::SerializeMap;
                        #[allow(unused_imports)]
                        use std::option::Option::Some;
                        let mut state = serializer.serialize_map(std::option::Option::None)?;
                        if !self.uri.is_empty() {
                            state.serialize_entry("uri", &self.uri)?;
                        }
                        if !self._unknown_fields.is_empty() {
                            for (key, value) in self._unknown_fields.iter() {
                                state.serialize_entry(key, &value)?;
                            }
                        }
                        state.end()
                    }
                }
            }
        }

        /// The suggestion chip message that the user can tap to quickly post a reply
        /// to the conversation.
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Suggestion {
            /// Required. The text shown the in the suggestion chip.
            pub title: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl Suggestion {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [title][crate::model::intent::message::Suggestion::title].
            pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.title = v.into();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for Suggestion {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.Suggestion"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Suggestion {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __title,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Suggestion")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "title" => Ok(__FieldTag::__title),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Suggestion;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Suggestion")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__title => {
                                    if !fields.insert(__FieldTag::__title) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for title"),
                                        );
                                    }
                                    result.title = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for Suggestion {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.title.is_empty() {
                    state.serialize_entry("title", &self.title)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The collection of suggestions.
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Suggestions {
            /// Required. The list of suggested replies.
            pub suggestions: std::vec::Vec<crate::model::intent::message::Suggestion>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl Suggestions {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [suggestions][crate::model::intent::message::Suggestions::suggestions].
            pub fn set_suggestions<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::intent::message::Suggestion>,
            {
                use std::iter::Iterator;
                self.suggestions = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for Suggestions {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.Suggestions"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Suggestions {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __suggestions,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Suggestions")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "suggestions" => Ok(__FieldTag::__suggestions),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Suggestions;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Suggestions")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__suggestions => {
                                    if !fields.insert(__FieldTag::__suggestions) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for suggestions",
                                            ),
                                        );
                                    }
                                    result.suggestions = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::intent::message::Suggestion,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for Suggestions {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.suggestions.is_empty() {
                    state.serialize_entry("suggestions", &self.suggestions)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The suggestion chip message that allows the user to jump out to the app
        /// or website associated with this agent.
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct LinkOutSuggestion {
            /// Required. The name of the app or site this chip is linking to.
            pub destination_name: std::string::String,

            /// Required. The URI of the app or site to open when the user taps the
            /// suggestion chip.
            pub uri: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl LinkOutSuggestion {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [destination_name][crate::model::intent::message::LinkOutSuggestion::destination_name].
            pub fn set_destination_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.destination_name = v.into();
                self
            }

            /// Sets the value of [uri][crate::model::intent::message::LinkOutSuggestion::uri].
            pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.uri = v.into();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for LinkOutSuggestion {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.LinkOutSuggestion"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for LinkOutSuggestion {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __destination_name,
                    __uri,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for LinkOutSuggestion")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "destinationName" => Ok(__FieldTag::__destination_name),
                                    "destination_name" => Ok(__FieldTag::__destination_name),
                                    "uri" => Ok(__FieldTag::__uri),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = LinkOutSuggestion;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct LinkOutSuggestion")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__destination_name => {
                                    if !fields.insert(__FieldTag::__destination_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for destination_name",
                                            ),
                                        );
                                    }
                                    result.destination_name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__uri => {
                                    if !fields.insert(__FieldTag::__uri) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for uri"),
                                        );
                                    }
                                    result.uri = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for LinkOutSuggestion {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.destination_name.is_empty() {
                    state.serialize_entry("destinationName", &self.destination_name)?;
                }
                if !self.uri.is_empty() {
                    state.serialize_entry("uri", &self.uri)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The card for presenting a list of options to select from.
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ListSelect {
            /// Optional. The overall title of the list.
            pub title: std::string::String,

            /// Required. List items.
            pub items: std::vec::Vec<crate::model::intent::message::list_select::Item>,

            /// Optional. Subtitle of the list.
            pub subtitle: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl ListSelect {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [title][crate::model::intent::message::ListSelect::title].
            pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.title = v.into();
                self
            }

            /// Sets the value of [items][crate::model::intent::message::ListSelect::items].
            pub fn set_items<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::intent::message::list_select::Item>,
            {
                use std::iter::Iterator;
                self.items = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [subtitle][crate::model::intent::message::ListSelect::subtitle].
            pub fn set_subtitle<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.subtitle = v.into();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for ListSelect {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.ListSelect"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ListSelect {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __title,
                    __items,
                    __subtitle,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ListSelect")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "title" => Ok(__FieldTag::__title),
                                    "items" => Ok(__FieldTag::__items),
                                    "subtitle" => Ok(__FieldTag::__subtitle),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ListSelect;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ListSelect")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__title => {
                                    if !fields.insert(__FieldTag::__title) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for title"),
                                        );
                                    }
                                    result.title = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__items => {
                                    if !fields.insert(__FieldTag::__items) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for items"),
                                        );
                                    }
                                    result.items = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::intent::message::list_select::Item,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__subtitle => {
                                    if !fields.insert(__FieldTag::__subtitle) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for subtitle",
                                            ),
                                        );
                                    }
                                    result.subtitle = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for ListSelect {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.title.is_empty() {
                    state.serialize_entry("title", &self.title)?;
                }
                if !self.items.is_empty() {
                    state.serialize_entry("items", &self.items)?;
                }
                if !self.subtitle.is_empty() {
                    state.serialize_entry("subtitle", &self.subtitle)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [ListSelect].
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        pub mod list_select {
            #[allow(unused_imports)]
            use super::*;

            /// An item in the list.
            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Item {
                /// Required. Additional information about this option.
                pub info: std::option::Option<crate::model::intent::message::SelectItemInfo>,

                /// Required. The title of the list item.
                pub title: std::string::String,

                /// Optional. The main text describing the item.
                pub description: std::string::String,

                /// Optional. The image to display.
                pub image: std::option::Option<crate::model::intent::message::Image>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl Item {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [info][crate::model::intent::message::list_select::Item::info].
                pub fn set_info<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::intent::message::SelectItemInfo>,
                {
                    self.info = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [info][crate::model::intent::message::list_select::Item::info].
                pub fn set_or_clear_info<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::intent::message::SelectItemInfo>,
                {
                    self.info = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [title][crate::model::intent::message::list_select::Item::title].
                pub fn set_title<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.title = v.into();
                    self
                }

                /// Sets the value of [description][crate::model::intent::message::list_select::Item::description].
                pub fn set_description<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.description = v.into();
                    self
                }

                /// Sets the value of [image][crate::model::intent::message::list_select::Item::image].
                pub fn set_image<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::intent::message::Image>,
                {
                    self.image = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [image][crate::model::intent::message::list_select::Item::image].
                pub fn set_or_clear_image<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::intent::message::Image>,
                {
                    self.image = v.map(|x| x.into());
                    self
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl wkt::message::Message for Item {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.ListSelect.Item"
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Item {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __info,
                        __title,
                        __description,
                        __image,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Item")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "info" => Ok(__FieldTag::__info),
                                        "title" => Ok(__FieldTag::__title),
                                        "description" => Ok(__FieldTag::__description),
                                        "image" => Ok(__FieldTag::__image),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Item;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Item")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__info => {
                                        if !fields.insert(__FieldTag::__info) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for info",
                                                ),
                                            );
                                        }
                                        result.info = map
                                            .next_value::<std::option::Option<
                                                crate::model::intent::message::SelectItemInfo,
                                            >>()?;
                                    }
                                    __FieldTag::__title => {
                                        if !fields.insert(__FieldTag::__title) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for title",
                                                ),
                                            );
                                        }
                                        result.title = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__description => {
                                        if !fields.insert(__FieldTag::__description) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for description",
                                                ),
                                            );
                                        }
                                        result.description = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__image => {
                                        if !fields.insert(__FieldTag::__image) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for image",
                                                ),
                                            );
                                        }
                                        result.image = map
                                            .next_value::<std::option::Option<
                                                crate::model::intent::message::Image,
                                            >>()?;
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[doc(hidden)]
            impl serde::ser::Serialize for Item {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if self.info.is_some() {
                        state.serialize_entry("info", &self.info)?;
                    }
                    if !self.title.is_empty() {
                        state.serialize_entry("title", &self.title)?;
                    }
                    if !self.description.is_empty() {
                        state.serialize_entry("description", &self.description)?;
                    }
                    if self.image.is_some() {
                        state.serialize_entry("image", &self.image)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }
        }

        /// The card for presenting a carousel of options to select from.
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CarouselSelect {
            /// Required. Carousel items.
            pub items: std::vec::Vec<crate::model::intent::message::carousel_select::Item>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl CarouselSelect {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [items][crate::model::intent::message::CarouselSelect::items].
            pub fn set_items<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::intent::message::carousel_select::Item>,
            {
                use std::iter::Iterator;
                self.items = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for CarouselSelect {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.CarouselSelect"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for CarouselSelect {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __items,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for CarouselSelect")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "items" => Ok(__FieldTag::__items),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = CarouselSelect;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct CarouselSelect")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__items => {
                                    if !fields.insert(__FieldTag::__items) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for items"),
                                        );
                                    }
                                    result.items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::message::carousel_select::Item>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for CarouselSelect {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.items.is_empty() {
                    state.serialize_entry("items", &self.items)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [CarouselSelect].
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        pub mod carousel_select {
            #[allow(unused_imports)]
            use super::*;

            /// An item in the carousel.
            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Item {
                /// Required. Additional info about the option item.
                pub info: std::option::Option<crate::model::intent::message::SelectItemInfo>,

                /// Required. Title of the carousel item.
                pub title: std::string::String,

                /// Optional. The body text of the card.
                pub description: std::string::String,

                /// Optional. The image to display.
                pub image: std::option::Option<crate::model::intent::message::Image>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl Item {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [info][crate::model::intent::message::carousel_select::Item::info].
                pub fn set_info<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::intent::message::SelectItemInfo>,
                {
                    self.info = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [info][crate::model::intent::message::carousel_select::Item::info].
                pub fn set_or_clear_info<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::intent::message::SelectItemInfo>,
                {
                    self.info = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [title][crate::model::intent::message::carousel_select::Item::title].
                pub fn set_title<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.title = v.into();
                    self
                }

                /// Sets the value of [description][crate::model::intent::message::carousel_select::Item::description].
                pub fn set_description<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.description = v.into();
                    self
                }

                /// Sets the value of [image][crate::model::intent::message::carousel_select::Item::image].
                pub fn set_image<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::intent::message::Image>,
                {
                    self.image = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [image][crate::model::intent::message::carousel_select::Item::image].
                pub fn set_or_clear_image<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::intent::message::Image>,
                {
                    self.image = v.map(|x| x.into());
                    self
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl wkt::message::Message for Item {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.CarouselSelect.Item"
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Item {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __info,
                        __title,
                        __description,
                        __image,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Item")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "info" => Ok(__FieldTag::__info),
                                        "title" => Ok(__FieldTag::__title),
                                        "description" => Ok(__FieldTag::__description),
                                        "image" => Ok(__FieldTag::__image),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Item;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Item")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__info => {
                                        if !fields.insert(__FieldTag::__info) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for info",
                                                ),
                                            );
                                        }
                                        result.info = map
                                            .next_value::<std::option::Option<
                                                crate::model::intent::message::SelectItemInfo,
                                            >>()?;
                                    }
                                    __FieldTag::__title => {
                                        if !fields.insert(__FieldTag::__title) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for title",
                                                ),
                                            );
                                        }
                                        result.title = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__description => {
                                        if !fields.insert(__FieldTag::__description) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for description",
                                                ),
                                            );
                                        }
                                        result.description = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__image => {
                                        if !fields.insert(__FieldTag::__image) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for image",
                                                ),
                                            );
                                        }
                                        result.image = map
                                            .next_value::<std::option::Option<
                                                crate::model::intent::message::Image,
                                            >>()?;
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[doc(hidden)]
            impl serde::ser::Serialize for Item {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if self.info.is_some() {
                        state.serialize_entry("info", &self.info)?;
                    }
                    if !self.title.is_empty() {
                        state.serialize_entry("title", &self.title)?;
                    }
                    if !self.description.is_empty() {
                        state.serialize_entry("description", &self.description)?;
                    }
                    if self.image.is_some() {
                        state.serialize_entry("image", &self.image)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }
        }

        /// Additional info about the select item for when it is triggered in a
        /// dialog.
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct SelectItemInfo {
            /// Required. A unique key that will be sent back to the agent if this
            /// response is given.
            pub key: std::string::String,

            /// Optional. A list of synonyms that can also be used to trigger this
            /// item in dialog.
            pub synonyms: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl SelectItemInfo {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::intent::message::SelectItemInfo::key].
            pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.key = v.into();
                self
            }

            /// Sets the value of [synonyms][crate::model::intent::message::SelectItemInfo::synonyms].
            pub fn set_synonyms<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.synonyms = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for SelectItemInfo {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.SelectItemInfo"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for SelectItemInfo {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __key,
                    __synonyms,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for SelectItemInfo")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "key" => Ok(__FieldTag::__key),
                                    "synonyms" => Ok(__FieldTag::__synonyms),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = SelectItemInfo;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct SelectItemInfo")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__key => {
                                    if !fields.insert(__FieldTag::__key) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for key"),
                                        );
                                    }
                                    result.key = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__synonyms => {
                                    if !fields.insert(__FieldTag::__synonyms) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for synonyms",
                                            ),
                                        );
                                    }
                                    result.synonyms = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for SelectItemInfo {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.key.is_empty() {
                    state.serialize_entry("key", &self.key)?;
                }
                if !self.synonyms.is_empty() {
                    state.serialize_entry("synonyms", &self.synonyms)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The media content card for Actions on Google.
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct MediaContent {
            /// Optional. What type of media is the content (ie "audio").
            pub media_type: crate::model::intent::message::media_content::ResponseMediaType,

            /// Required. List of media objects.
            pub media_objects:
                std::vec::Vec<crate::model::intent::message::media_content::ResponseMediaObject>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl MediaContent {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [media_type][crate::model::intent::message::MediaContent::media_type].
            pub fn set_media_type<
                T: std::convert::Into<crate::model::intent::message::media_content::ResponseMediaType>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.media_type = v.into();
                self
            }

            /// Sets the value of [media_objects][crate::model::intent::message::MediaContent::media_objects].
            pub fn set_media_objects<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::intent::message::media_content::ResponseMediaObject,
                    >,
            {
                use std::iter::Iterator;
                self.media_objects = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for MediaContent {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.MediaContent"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for MediaContent {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __media_type,
                    __media_objects,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for MediaContent")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "mediaType" => Ok(__FieldTag::__media_type),
                                    "media_type" => Ok(__FieldTag::__media_type),
                                    "mediaObjects" => Ok(__FieldTag::__media_objects),
                                    "media_objects" => Ok(__FieldTag::__media_objects),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = MediaContent;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct MediaContent")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__media_type => {
                                    if !fields.insert(__FieldTag::__media_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for media_type",
                                            ),
                                        );
                                    }
                                    result.media_type = map.next_value::<std::option::Option<crate::model::intent::message::media_content::ResponseMediaType>>()?.unwrap_or_default();
                                }
                                __FieldTag::__media_objects => {
                                    if !fields.insert(__FieldTag::__media_objects) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for media_objects",
                                            ),
                                        );
                                    }
                                    result.media_objects = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::message::media_content::ResponseMediaObject>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for MediaContent {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.media_type) {
                    state.serialize_entry("mediaType", &self.media_type)?;
                }
                if !self.media_objects.is_empty() {
                    state.serialize_entry("mediaObjects", &self.media_objects)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [MediaContent].
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        pub mod media_content {
            #[allow(unused_imports)]
            use super::*;

            /// Response media object for media content card.
            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct ResponseMediaObject {
                /// Required. Name of media card.
                pub name: std::string::String,

                /// Optional. Description of media card.
                pub description: std::string::String,

                /// Required. Url where the media is stored.
                pub content_url: std::string::String,

                /// Image to show with the media card.
                pub image: std::option::Option<
                    crate::model::intent::message::media_content::response_media_object::Image,
                >,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl ResponseMediaObject {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [name][crate::model::intent::message::media_content::ResponseMediaObject::name].
                pub fn set_name<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.name = v.into();
                    self
                }

                /// Sets the value of [description][crate::model::intent::message::media_content::ResponseMediaObject::description].
                pub fn set_description<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.description = v.into();
                    self
                }

                /// Sets the value of [content_url][crate::model::intent::message::media_content::ResponseMediaObject::content_url].
                pub fn set_content_url<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.content_url = v.into();
                    self
                }

                /// Sets the value of [image][crate::model::intent::message::media_content::ResponseMediaObject::image].
                ///
                /// Note that all the setters affecting `image` are mutually
                /// exclusive.
                pub fn set_image<T: std::convert::Into<std::option::Option<crate::model::intent::message::media_content::response_media_object::Image>>>(mut self, v: T) -> Self
                {
                    self.image = v.into();
                    self
                }

                /// The value of [image][crate::model::intent::message::media_content::ResponseMediaObject::image]
                /// if it holds a `LargeImage`, `None` if the field is not set or
                /// holds a different branch.
                pub fn large_image(
                    &self,
                ) -> std::option::Option<&std::boxed::Box<crate::model::intent::message::Image>>
                {
                    #[allow(unreachable_patterns)]
                    self.image.as_ref().and_then(|v| match v {
                        crate::model::intent::message::media_content::response_media_object::Image::LargeImage(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [image][crate::model::intent::message::media_content::ResponseMediaObject::image]
                /// to hold a `LargeImage`.
                ///
                /// Note that all the setters affecting `image` are
                /// mutually exclusive.
                pub fn set_large_image<
                    T: std::convert::Into<std::boxed::Box<crate::model::intent::message::Image>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.image = std::option::Option::Some(
                        crate::model::intent::message::media_content::response_media_object::Image::LargeImage(
                            v.into()
                        )
                    );
                    self
                }

                /// The value of [image][crate::model::intent::message::media_content::ResponseMediaObject::image]
                /// if it holds a `Icon`, `None` if the field is not set or
                /// holds a different branch.
                pub fn icon(
                    &self,
                ) -> std::option::Option<&std::boxed::Box<crate::model::intent::message::Image>>
                {
                    #[allow(unreachable_patterns)]
                    self.image.as_ref().and_then(|v| match v {
                        crate::model::intent::message::media_content::response_media_object::Image::Icon(v) => std::option::Option::Some(v),
                        _ => std::option::Option::None,
                    })
                }

                /// Sets the value of [image][crate::model::intent::message::media_content::ResponseMediaObject::image]
                /// to hold a `Icon`.
                ///
                /// Note that all the setters affecting `image` are
                /// mutually exclusive.
                pub fn set_icon<
                    T: std::convert::Into<std::boxed::Box<crate::model::intent::message::Image>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.image = std::option::Option::Some(
                        crate::model::intent::message::media_content::response_media_object::Image::Icon(
                            v.into()
                        )
                    );
                    self
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl wkt::message::Message for ResponseMediaObject {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.MediaContent.ResponseMediaObject"
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for ResponseMediaObject {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __name,
                        __description,
                        __large_image,
                        __icon,
                        __content_url,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for ResponseMediaObject")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "name" => Ok(__FieldTag::__name),
                                        "description" => Ok(__FieldTag::__description),
                                        "largeImage" => Ok(__FieldTag::__large_image),
                                        "large_image" => Ok(__FieldTag::__large_image),
                                        "icon" => Ok(__FieldTag::__icon),
                                        "contentUrl" => Ok(__FieldTag::__content_url),
                                        "content_url" => Ok(__FieldTag::__content_url),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = ResponseMediaObject;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct ResponseMediaObject")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__name => {
                                        if !fields.insert(__FieldTag::__name) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for name",
                                                ),
                                            );
                                        }
                                        result.name = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__description => {
                                        if !fields.insert(__FieldTag::__description) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for description",
                                                ),
                                            );
                                        }
                                        result.description = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__large_image => {
                                        if !fields.insert(__FieldTag::__large_image) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for large_image",
                                                ),
                                            );
                                        }
                                        if result.image.is_some() {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for `image`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.MediaContent.ResponseMediaObject.large_image, latest field was largeImage",
                                                ),
                                            );
                                        }
                                        result.image = std::option::Option::Some(
                                            crate::model::intent::message::media_content::response_media_object::Image::LargeImage(
                                                map.next_value::<std::option::Option<std::boxed::Box<crate::model::intent::message::Image>>>()?.unwrap_or_default()
                                            ),
                                        );
                                    }
                                    __FieldTag::__icon => {
                                        if !fields.insert(__FieldTag::__icon) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for icon",
                                                ),
                                            );
                                        }
                                        if result.image.is_some() {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for `image`, a oneof with full ID .google.cloud.dialogflow.v2.Intent.Message.MediaContent.ResponseMediaObject.icon, latest field was icon",
                                                ),
                                            );
                                        }
                                        result.image = std::option::Option::Some(
                                            crate::model::intent::message::media_content::response_media_object::Image::Icon(
                                                map.next_value::<std::option::Option<std::boxed::Box<crate::model::intent::message::Image>>>()?.unwrap_or_default()
                                            ),
                                        );
                                    }
                                    __FieldTag::__content_url => {
                                        if !fields.insert(__FieldTag::__content_url) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for content_url",
                                                ),
                                            );
                                        }
                                        result.content_url = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[doc(hidden)]
            impl serde::ser::Serialize for ResponseMediaObject {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.name.is_empty() {
                        state.serialize_entry("name", &self.name)?;
                    }
                    if !self.description.is_empty() {
                        state.serialize_entry("description", &self.description)?;
                    }
                    if let Some(value) = self.large_image() {
                        state.serialize_entry("largeImage", value)?;
                    }
                    if let Some(value) = self.icon() {
                        state.serialize_entry("icon", value)?;
                    }
                    if !self.content_url.is_empty() {
                        state.serialize_entry("contentUrl", &self.content_url)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Defines additional types related to [ResponseMediaObject].
            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            pub mod response_media_object {
                #[allow(unused_imports)]
                use super::*;

                /// Image to show with the media card.
                #[cfg(any(
                    feature = "answer-records",
                    feature = "intents",
                    feature = "participants",
                    feature = "sessions",
                ))]
                #[derive(Clone, Debug, PartialEq)]
                #[non_exhaustive]
                pub enum Image {
                    /// Optional. Image to display above media content.
                    LargeImage(std::boxed::Box<crate::model::intent::message::Image>),
                    /// Optional. Icon to display above media content.
                    Icon(std::boxed::Box<crate::model::intent::message::Image>),
                }
            }

            /// Format of response media type.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum ResponseMediaType {
                /// Unspecified.
                Unspecified,
                /// Response media type is audio.
                Audio,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [ResponseMediaType::value] or
                /// [ResponseMediaType::name].
                UnknownValue(response_media_type::UnknownValue),
            }

            #[doc(hidden)]
            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            pub mod response_media_type {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl ResponseMediaType {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Audio => std::option::Option::Some(1),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("RESPONSE_MEDIA_TYPE_UNSPECIFIED")
                        }
                        Self::Audio => std::option::Option::Some("AUDIO"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl std::default::Default for ResponseMediaType {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl std::fmt::Display for ResponseMediaType {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl std::convert::From<i32> for ResponseMediaType {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Audio,
                        _ => Self::UnknownValue(response_media_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl std::convert::From<&str> for ResponseMediaType {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "RESPONSE_MEDIA_TYPE_UNSPECIFIED" => Self::Unspecified,
                        "AUDIO" => Self::Audio,
                        _ => Self::UnknownValue(response_media_type::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl serde::ser::Serialize for ResponseMediaType {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Audio => serializer.serialize_i32(1),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl<'de> serde::de::Deserialize<'de> for ResponseMediaType {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResponseMediaType>::new(
                        ".google.cloud.dialogflow.v2.Intent.Message.MediaContent.ResponseMediaType"))
                }
            }
        }

        /// Browse Carousel Card for Actions on Google.
        /// <https://developers.google.com/actions/assistant/responses#browsing_carousel>
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct BrowseCarouselCard {
            /// Required. List of items in the Browse Carousel Card. Minimum of two
            /// items, maximum of ten.
            pub items: std::vec::Vec<
                crate::model::intent::message::browse_carousel_card::BrowseCarouselCardItem,
            >,

            /// Optional. Settings for displaying the image. Applies to every image in
            /// [items][google.cloud.dialogflow.v2.Intent.Message.BrowseCarouselCard.items].
            ///
            /// [google.cloud.dialogflow.v2.Intent.Message.BrowseCarouselCard.items]: crate::model::intent::message::BrowseCarouselCard::items
            pub image_display_options:
                crate::model::intent::message::browse_carousel_card::ImageDisplayOptions,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl BrowseCarouselCard {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [items][crate::model::intent::message::BrowseCarouselCard::items].
            pub fn set_items<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::intent::message::browse_carousel_card::BrowseCarouselCardItem,
                    >,
            {
                use std::iter::Iterator;
                self.items = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [image_display_options][crate::model::intent::message::BrowseCarouselCard::image_display_options].
            pub fn set_image_display_options<
                T: std::convert::Into<
                        crate::model::intent::message::browse_carousel_card::ImageDisplayOptions,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.image_display_options = v.into();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for BrowseCarouselCard {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.BrowseCarouselCard"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for BrowseCarouselCard {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __items,
                    __image_display_options,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for BrowseCarouselCard")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "items" => Ok(__FieldTag::__items),
                                    "imageDisplayOptions" => {
                                        Ok(__FieldTag::__image_display_options)
                                    }
                                    "image_display_options" => {
                                        Ok(__FieldTag::__image_display_options)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = BrowseCarouselCard;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct BrowseCarouselCard")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__items => {
                                    if !fields.insert(__FieldTag::__items) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for items"),
                                        );
                                    }
                                    result.items = map.next_value::<std::option::Option<std::vec::Vec<crate::model::intent::message::browse_carousel_card::BrowseCarouselCardItem>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__image_display_options => {
                                    if !fields.insert(__FieldTag::__image_display_options) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for image_display_options",
                                            ),
                                        );
                                    }
                                    result.image_display_options = map.next_value::<std::option::Option<crate::model::intent::message::browse_carousel_card::ImageDisplayOptions>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for BrowseCarouselCard {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.items.is_empty() {
                    state.serialize_entry("items", &self.items)?;
                }
                if !wkt::internal::is_default(&self.image_display_options) {
                    state.serialize_entry("imageDisplayOptions", &self.image_display_options)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [BrowseCarouselCard].
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        pub mod browse_carousel_card {
            #[allow(unused_imports)]
            use super::*;

            /// Browsing carousel tile
            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct BrowseCarouselCardItem {

                /// Required. Action to present to the user.
                pub open_uri_action: std::option::Option<crate::model::intent::message::browse_carousel_card::browse_carousel_card_item::OpenUrlAction>,

                /// Required. Title of the carousel item. Maximum of two lines of text.
                pub title: std::string::String,

                /// Optional. Description of the carousel item. Maximum of four lines of
                /// text.
                pub description: std::string::String,

                /// Optional. Hero image for the carousel item.
                pub image: std::option::Option<crate::model::intent::message::Image>,

                /// Optional. Text that appears at the bottom of the Browse Carousel
                /// Card. Maximum of one line of text.
                pub footer: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl BrowseCarouselCardItem {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [open_uri_action][crate::model::intent::message::browse_carousel_card::BrowseCarouselCardItem::open_uri_action].
                pub fn set_open_uri_action<T>(mut self, v: T) -> Self
                where T: std::convert::Into<crate::model::intent::message::browse_carousel_card::browse_carousel_card_item::OpenUrlAction>
                {
                    self.open_uri_action = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [open_uri_action][crate::model::intent::message::browse_carousel_card::BrowseCarouselCardItem::open_uri_action].
                pub fn set_or_clear_open_uri_action<T>(mut self, v: std::option::Option<T>) -> Self
                where T: std::convert::Into<crate::model::intent::message::browse_carousel_card::browse_carousel_card_item::OpenUrlAction>
                {
                    self.open_uri_action = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [title][crate::model::intent::message::browse_carousel_card::BrowseCarouselCardItem::title].
                pub fn set_title<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.title = v.into();
                    self
                }

                /// Sets the value of [description][crate::model::intent::message::browse_carousel_card::BrowseCarouselCardItem::description].
                pub fn set_description<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.description = v.into();
                    self
                }

                /// Sets the value of [image][crate::model::intent::message::browse_carousel_card::BrowseCarouselCardItem::image].
                pub fn set_image<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::intent::message::Image>,
                {
                    self.image = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [image][crate::model::intent::message::browse_carousel_card::BrowseCarouselCardItem::image].
                pub fn set_or_clear_image<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::intent::message::Image>,
                {
                    self.image = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [footer][crate::model::intent::message::browse_carousel_card::BrowseCarouselCardItem::footer].
                pub fn set_footer<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.footer = v.into();
                    self
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl wkt::message::Message for BrowseCarouselCardItem {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.BrowseCarouselCard.BrowseCarouselCardItem"
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for BrowseCarouselCardItem {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __open_uri_action,
                        __title,
                        __description,
                        __image,
                        __footer,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for BrowseCarouselCardItem")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "openUriAction" => Ok(__FieldTag::__open_uri_action),
                                        "open_uri_action" => Ok(__FieldTag::__open_uri_action),
                                        "title" => Ok(__FieldTag::__title),
                                        "description" => Ok(__FieldTag::__description),
                                        "image" => Ok(__FieldTag::__image),
                                        "footer" => Ok(__FieldTag::__footer),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = BrowseCarouselCardItem;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct BrowseCarouselCardItem")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__open_uri_action => {
                                        if !fields.insert(__FieldTag::__open_uri_action) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for open_uri_action",
                                                ),
                                            );
                                        }
                                        result.open_uri_action = map.next_value::<std::option::Option<crate::model::intent::message::browse_carousel_card::browse_carousel_card_item::OpenUrlAction>>()?
                                            ;
                                    }
                                    __FieldTag::__title => {
                                        if !fields.insert(__FieldTag::__title) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for title",
                                                ),
                                            );
                                        }
                                        result.title = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__description => {
                                        if !fields.insert(__FieldTag::__description) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for description",
                                                ),
                                            );
                                        }
                                        result.description = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__image => {
                                        if !fields.insert(__FieldTag::__image) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for image",
                                                ),
                                            );
                                        }
                                        result.image = map
                                            .next_value::<std::option::Option<
                                                crate::model::intent::message::Image,
                                            >>()?;
                                    }
                                    __FieldTag::__footer => {
                                        if !fields.insert(__FieldTag::__footer) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for footer",
                                                ),
                                            );
                                        }
                                        result.footer = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[doc(hidden)]
            impl serde::ser::Serialize for BrowseCarouselCardItem {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if self.open_uri_action.is_some() {
                        state.serialize_entry("openUriAction", &self.open_uri_action)?;
                    }
                    if !self.title.is_empty() {
                        state.serialize_entry("title", &self.title)?;
                    }
                    if !self.description.is_empty() {
                        state.serialize_entry("description", &self.description)?;
                    }
                    if self.image.is_some() {
                        state.serialize_entry("image", &self.image)?;
                    }
                    if !self.footer.is_empty() {
                        state.serialize_entry("footer", &self.footer)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Defines additional types related to [BrowseCarouselCardItem].
            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            pub mod browse_carousel_card_item {
                #[allow(unused_imports)]
                use super::*;

                /// Actions on Google action to open a given url.
                #[cfg(any(
                    feature = "answer-records",
                    feature = "intents",
                    feature = "participants",
                    feature = "sessions",
                ))]
                #[derive(Clone, Debug, Default, PartialEq)]
                #[non_exhaustive]
                pub struct OpenUrlAction {

                    /// Required. URL
                    pub url: std::string::String,

                    /// Optional. Specifies the type of viewer that is used when opening
                    /// the URL. Defaults to opening via web browser.
                    pub url_type_hint: crate::model::intent::message::browse_carousel_card::browse_carousel_card_item::open_url_action::UrlTypeHint,

                    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
                }

                #[cfg(any(
                    feature = "answer-records",
                    feature = "intents",
                    feature = "participants",
                    feature = "sessions",
                ))]
                impl OpenUrlAction {
                    pub fn new() -> Self {
                        std::default::Default::default()
                    }

                    /// Sets the value of [url][crate::model::intent::message::browse_carousel_card::browse_carousel_card_item::OpenUrlAction::url].
                    pub fn set_url<T: std::convert::Into<std::string::String>>(
                        mut self,
                        v: T,
                    ) -> Self {
                        self.url = v.into();
                        self
                    }

                    /// Sets the value of [url_type_hint][crate::model::intent::message::browse_carousel_card::browse_carousel_card_item::OpenUrlAction::url_type_hint].
                    pub fn set_url_type_hint<T: std::convert::Into<crate::model::intent::message::browse_carousel_card::browse_carousel_card_item::open_url_action::UrlTypeHint>>(mut self, v: T) -> Self{
                        self.url_type_hint = v.into();
                        self
                    }
                }

                #[cfg(any(
                    feature = "answer-records",
                    feature = "intents",
                    feature = "participants",
                    feature = "sessions",
                ))]
                impl wkt::message::Message for OpenUrlAction {
                    fn typename() -> &'static str {
                        "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.BrowseCarouselCard.BrowseCarouselCardItem.OpenUrlAction"
                    }
                }

                #[cfg(any(
                    feature = "answer-records",
                    feature = "intents",
                    feature = "participants",
                    feature = "sessions",
                ))]
                #[doc(hidden)]
                impl<'de> serde::de::Deserialize<'de> for OpenUrlAction {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        #[doc(hidden)]
                        #[derive(PartialEq, Eq, Hash)]
                        enum __FieldTag {
                            __url,
                            __url_type_hint,
                            Unknown(std::string::String),
                        }
                        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                            fn deserialize<D>(
                                deserializer: D,
                            ) -> std::result::Result<Self, D::Error>
                            where
                                D: serde::Deserializer<'de>,
                            {
                                struct Visitor;
                                impl<'de> serde::de::Visitor<'de> for Visitor {
                                    type Value = __FieldTag;
                                    fn expecting(
                                        &self,
                                        formatter: &mut std::fmt::Formatter,
                                    ) -> std::fmt::Result {
                                        formatter.write_str("a field name for OpenUrlAction")
                                    }
                                    fn visit_str<E>(
                                        self,
                                        value: &str,
                                    ) -> std::result::Result<Self::Value, E>
                                    where
                                        E: serde::de::Error,
                                    {
                                        use std::result::Result::Ok;
                                        use std::string::ToString;
                                        match value {
                                            "url" => Ok(__FieldTag::__url),
                                            "urlTypeHint" => Ok(__FieldTag::__url_type_hint),
                                            "url_type_hint" => Ok(__FieldTag::__url_type_hint),
                                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                                        }
                                    }
                                }
                                deserializer.deserialize_identifier(Visitor)
                            }
                        }
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = OpenUrlAction;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("struct OpenUrlAction")
                            }
                            fn visit_map<A>(
                                self,
                                mut map: A,
                            ) -> std::result::Result<Self::Value, A::Error>
                            where
                                A: serde::de::MapAccess<'de>,
                            {
                                #[allow(unused_imports)]
                                use serde::de::Error;
                                use std::option::Option::Some;
                                let mut fields = std::collections::HashSet::new();
                                let mut result = Self::Value::new();
                                while let Some(tag) = map.next_key::<__FieldTag>()? {
                                    #[allow(clippy::match_single_binding)]
                                    match tag {
                                        __FieldTag::__url => {
                                            if !fields.insert(__FieldTag::__url) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for url",
                                                    ),
                                                );
                                            }
                                            result.url = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                                        }
                                        __FieldTag::__url_type_hint => {
                                            if !fields.insert(__FieldTag::__url_type_hint) {
                                                return std::result::Result::Err(
                                                    A::Error::duplicate_field(
                                                        "multiple values for url_type_hint",
                                                    ),
                                                );
                                            }
                                            result.url_type_hint = map.next_value::<std::option::Option<crate::model::intent::message::browse_carousel_card::browse_carousel_card_item::open_url_action::UrlTypeHint>>()?.unwrap_or_default();
                                        }
                                        __FieldTag::Unknown(key) => {
                                            let value = map.next_value::<serde_json::Value>()?;
                                            result._unknown_fields.insert(key, value);
                                        }
                                    }
                                }
                                std::result::Result::Ok(result)
                            }
                        }
                        deserializer.deserialize_any(Visitor)
                    }
                }

                #[cfg(any(
                    feature = "answer-records",
                    feature = "intents",
                    feature = "participants",
                    feature = "sessions",
                ))]
                #[doc(hidden)]
                impl serde::ser::Serialize for OpenUrlAction {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        use serde::ser::SerializeMap;
                        #[allow(unused_imports)]
                        use std::option::Option::Some;
                        let mut state = serializer.serialize_map(std::option::Option::None)?;
                        if !self.url.is_empty() {
                            state.serialize_entry("url", &self.url)?;
                        }
                        if !wkt::internal::is_default(&self.url_type_hint) {
                            state.serialize_entry("urlTypeHint", &self.url_type_hint)?;
                        }
                        if !self._unknown_fields.is_empty() {
                            for (key, value) in self._unknown_fields.iter() {
                                state.serialize_entry(key, &value)?;
                            }
                        }
                        state.end()
                    }
                }

                /// Defines additional types related to [OpenUrlAction].
                #[cfg(any(
                    feature = "answer-records",
                    feature = "intents",
                    feature = "participants",
                    feature = "sessions",
                ))]
                pub mod open_url_action {
                    #[allow(unused_imports)]
                    use super::*;

                    /// Type of the URI.
                    ///
                    /// # Working with unknown values
                    ///
                    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
                    /// additional enum variants at any time. Adding new variants is not considered
                    /// a breaking change. Applications should write their code in anticipation of:
                    ///
                    /// - New values appearing in future releases of the client library, **and**
                    /// - New values received dynamically, without application changes.
                    ///
                    /// Please consult the [Working with enums] section in the user guide for some
                    /// guidelines.
                    ///
                    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
                    #[cfg(any(
                        feature = "answer-records",
                        feature = "intents",
                        feature = "participants",
                        feature = "sessions",
                    ))]
                    #[derive(Clone, Debug, PartialEq)]
                    #[non_exhaustive]
                    pub enum UrlTypeHint {
                        /// Unspecified
                        Unspecified,
                        /// Url would be an amp action
                        AmpAction,
                        /// URL that points directly to AMP content, or to a canonical URL
                        /// which refers to AMP content via \<link rel="amphtml"\>.
                        AmpContent,
                        /// If set, the enum was initialized with an unknown value.
                        ///
                        /// Applications can examine the value using [UrlTypeHint::value] or
                        /// [UrlTypeHint::name].
                        UnknownValue(url_type_hint::UnknownValue),
                    }

                    #[doc(hidden)]
                    #[cfg(any(
                        feature = "answer-records",
                        feature = "intents",
                        feature = "participants",
                        feature = "sessions",
                    ))]
                    pub mod url_type_hint {
                        #[allow(unused_imports)]
                        use super::*;
                        #[derive(Clone, Debug, PartialEq)]
                        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
                    }

                    #[cfg(any(
                        feature = "answer-records",
                        feature = "intents",
                        feature = "participants",
                        feature = "sessions",
                    ))]
                    impl UrlTypeHint {
                        /// Gets the enum value.
                        ///
                        /// Returns `None` if the enum contains an unknown value deserialized from
                        /// the string representation of enums.
                        pub fn value(&self) -> std::option::Option<i32> {
                            match self {
                                Self::Unspecified => std::option::Option::Some(0),
                                Self::AmpAction => std::option::Option::Some(1),
                                Self::AmpContent => std::option::Option::Some(2),
                                Self::UnknownValue(u) => u.0.value(),
                            }
                        }

                        /// Gets the enum value as a string.
                        ///
                        /// Returns `None` if the enum contains an unknown value deserialized from
                        /// the integer representation of enums.
                        pub fn name(&self) -> std::option::Option<&str> {
                            match self {
                                Self::Unspecified => {
                                    std::option::Option::Some("URL_TYPE_HINT_UNSPECIFIED")
                                }
                                Self::AmpAction => std::option::Option::Some("AMP_ACTION"),
                                Self::AmpContent => std::option::Option::Some("AMP_CONTENT"),
                                Self::UnknownValue(u) => u.0.name(),
                            }
                        }
                    }

                    #[cfg(any(
                        feature = "answer-records",
                        feature = "intents",
                        feature = "participants",
                        feature = "sessions",
                    ))]
                    impl std::default::Default for UrlTypeHint {
                        fn default() -> Self {
                            use std::convert::From;
                            Self::from(0)
                        }
                    }

                    #[cfg(any(
                        feature = "answer-records",
                        feature = "intents",
                        feature = "participants",
                        feature = "sessions",
                    ))]
                    impl std::fmt::Display for UrlTypeHint {
                        fn fmt(
                            &self,
                            f: &mut std::fmt::Formatter<'_>,
                        ) -> std::result::Result<(), std::fmt::Error> {
                            wkt::internal::display_enum(f, self.name(), self.value())
                        }
                    }

                    #[cfg(any(
                        feature = "answer-records",
                        feature = "intents",
                        feature = "participants",
                        feature = "sessions",
                    ))]
                    impl std::convert::From<i32> for UrlTypeHint {
                        fn from(value: i32) -> Self {
                            match value {
                                0 => Self::Unspecified,
                                1 => Self::AmpAction,
                                2 => Self::AmpContent,
                                _ => Self::UnknownValue(url_type_hint::UnknownValue(
                                    wkt::internal::UnknownEnumValue::Integer(value),
                                )),
                            }
                        }
                    }

                    #[cfg(any(
                        feature = "answer-records",
                        feature = "intents",
                        feature = "participants",
                        feature = "sessions",
                    ))]
                    impl std::convert::From<&str> for UrlTypeHint {
                        fn from(value: &str) -> Self {
                            use std::string::ToString;
                            match value {
                                "URL_TYPE_HINT_UNSPECIFIED" => Self::Unspecified,
                                "AMP_ACTION" => Self::AmpAction,
                                "AMP_CONTENT" => Self::AmpContent,
                                _ => Self::UnknownValue(url_type_hint::UnknownValue(
                                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                                )),
                            }
                        }
                    }

                    #[cfg(any(
                        feature = "answer-records",
                        feature = "intents",
                        feature = "participants",
                        feature = "sessions",
                    ))]
                    impl serde::ser::Serialize for UrlTypeHint {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::Serializer,
                        {
                            match self {
                                Self::Unspecified => serializer.serialize_i32(0),
                                Self::AmpAction => serializer.serialize_i32(1),
                                Self::AmpContent => serializer.serialize_i32(2),
                                Self::UnknownValue(u) => u.0.serialize(serializer),
                            }
                        }
                    }

                    #[cfg(any(
                        feature = "answer-records",
                        feature = "intents",
                        feature = "participants",
                        feature = "sessions",
                    ))]
                    impl<'de> serde::de::Deserialize<'de> for UrlTypeHint {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            deserializer.deserialize_any(wkt::internal::EnumVisitor::<UrlTypeHint>::new(
                                ".google.cloud.dialogflow.v2.Intent.Message.BrowseCarouselCard.BrowseCarouselCardItem.OpenUrlAction.UrlTypeHint"))
                        }
                    }
                }
            }

            /// Image display options for Actions on Google. This should be used for
            /// when the image's aspect ratio does not match the image container's
            /// aspect ratio.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum ImageDisplayOptions {
                /// Fill the gaps between the image and the image container with gray
                /// bars.
                Unspecified,
                /// Fill the gaps between the image and the image container with gray
                /// bars.
                Gray,
                /// Fill the gaps between the image and the image container with white
                /// bars.
                White,
                /// Image is scaled such that the image width and height match or exceed
                /// the container dimensions. This may crop the top and bottom of the
                /// image if the scaled image height is greater than the container
                /// height, or crop the left and right of the image if the scaled image
                /// width is greater than the container width. This is similar to "Zoom
                /// Mode" on a widescreen TV when playing a 4:3 video.
                Cropped,
                /// Pad the gaps between image and image frame with a blurred copy of the
                /// same image.
                BlurredBackground,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [ImageDisplayOptions::value] or
                /// [ImageDisplayOptions::name].
                UnknownValue(image_display_options::UnknownValue),
            }

            #[doc(hidden)]
            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            pub mod image_display_options {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl ImageDisplayOptions {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Gray => std::option::Option::Some(1),
                        Self::White => std::option::Option::Some(2),
                        Self::Cropped => std::option::Option::Some(3),
                        Self::BlurredBackground => std::option::Option::Some(4),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("IMAGE_DISPLAY_OPTIONS_UNSPECIFIED")
                        }
                        Self::Gray => std::option::Option::Some("GRAY"),
                        Self::White => std::option::Option::Some("WHITE"),
                        Self::Cropped => std::option::Option::Some("CROPPED"),
                        Self::BlurredBackground => std::option::Option::Some("BLURRED_BACKGROUND"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl std::default::Default for ImageDisplayOptions {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl std::fmt::Display for ImageDisplayOptions {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl std::convert::From<i32> for ImageDisplayOptions {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Gray,
                        2 => Self::White,
                        3 => Self::Cropped,
                        4 => Self::BlurredBackground,
                        _ => Self::UnknownValue(image_display_options::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl std::convert::From<&str> for ImageDisplayOptions {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "IMAGE_DISPLAY_OPTIONS_UNSPECIFIED" => Self::Unspecified,
                        "GRAY" => Self::Gray,
                        "WHITE" => Self::White,
                        "CROPPED" => Self::Cropped,
                        "BLURRED_BACKGROUND" => Self::BlurredBackground,
                        _ => Self::UnknownValue(image_display_options::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl serde::ser::Serialize for ImageDisplayOptions {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Gray => serializer.serialize_i32(1),
                        Self::White => serializer.serialize_i32(2),
                        Self::Cropped => serializer.serialize_i32(3),
                        Self::BlurredBackground => serializer.serialize_i32(4),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl<'de> serde::de::Deserialize<'de> for ImageDisplayOptions {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<ImageDisplayOptions>::new(
                        ".google.cloud.dialogflow.v2.Intent.Message.BrowseCarouselCard.ImageDisplayOptions"))
                }
            }
        }

        /// Table card for Actions on Google.
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct TableCard {
            /// Required. Title of the card.
            pub title: std::string::String,

            /// Optional. Subtitle to the title.
            pub subtitle: std::string::String,

            /// Optional. Image which should be displayed on the card.
            pub image: std::option::Option<crate::model::intent::message::Image>,

            /// Optional. Display properties for the columns in this table.
            pub column_properties: std::vec::Vec<crate::model::intent::message::ColumnProperties>,

            /// Optional. Rows in this table of data.
            pub rows: std::vec::Vec<crate::model::intent::message::TableCardRow>,

            /// Optional. List of buttons for the card.
            pub buttons: std::vec::Vec<crate::model::intent::message::basic_card::Button>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl TableCard {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [title][crate::model::intent::message::TableCard::title].
            pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.title = v.into();
                self
            }

            /// Sets the value of [subtitle][crate::model::intent::message::TableCard::subtitle].
            pub fn set_subtitle<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.subtitle = v.into();
                self
            }

            /// Sets the value of [image][crate::model::intent::message::TableCard::image].
            pub fn set_image<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::intent::message::Image>,
            {
                self.image = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [image][crate::model::intent::message::TableCard::image].
            pub fn set_or_clear_image<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::intent::message::Image>,
            {
                self.image = v.map(|x| x.into());
                self
            }

            /// Sets the value of [column_properties][crate::model::intent::message::TableCard::column_properties].
            pub fn set_column_properties<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::intent::message::ColumnProperties>,
            {
                use std::iter::Iterator;
                self.column_properties = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [rows][crate::model::intent::message::TableCard::rows].
            pub fn set_rows<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::intent::message::TableCardRow>,
            {
                use std::iter::Iterator;
                self.rows = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [buttons][crate::model::intent::message::TableCard::buttons].
            pub fn set_buttons<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::intent::message::basic_card::Button>,
            {
                use std::iter::Iterator;
                self.buttons = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for TableCard {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.TableCard"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for TableCard {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __title,
                    __subtitle,
                    __image,
                    __column_properties,
                    __rows,
                    __buttons,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for TableCard")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "title" => Ok(__FieldTag::__title),
                                    "subtitle" => Ok(__FieldTag::__subtitle),
                                    "image" => Ok(__FieldTag::__image),
                                    "columnProperties" => Ok(__FieldTag::__column_properties),
                                    "column_properties" => Ok(__FieldTag::__column_properties),
                                    "rows" => Ok(__FieldTag::__rows),
                                    "buttons" => Ok(__FieldTag::__buttons),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = TableCard;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct TableCard")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__title => {
                                    if !fields.insert(__FieldTag::__title) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for title"),
                                        );
                                    }
                                    result.title = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__subtitle => {
                                    if !fields.insert(__FieldTag::__subtitle) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for subtitle",
                                            ),
                                        );
                                    }
                                    result.subtitle = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__image => {
                                    if !fields.insert(__FieldTag::__image) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for image"),
                                        );
                                    }
                                    result.image =
                                        map.next_value::<std::option::Option<
                                            crate::model::intent::message::Image,
                                        >>()?;
                                }
                                __FieldTag::__column_properties => {
                                    if !fields.insert(__FieldTag::__column_properties) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for column_properties",
                                            ),
                                        );
                                    }
                                    result.column_properties = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::intent::message::ColumnProperties,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__rows => {
                                    if !fields.insert(__FieldTag::__rows) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for rows"),
                                        );
                                    }
                                    result.rows = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::intent::message::TableCardRow,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__buttons => {
                                    if !fields.insert(__FieldTag::__buttons) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for buttons",
                                            ),
                                        );
                                    }
                                    result.buttons = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::intent::message::basic_card::Button,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for TableCard {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.title.is_empty() {
                    state.serialize_entry("title", &self.title)?;
                }
                if !self.subtitle.is_empty() {
                    state.serialize_entry("subtitle", &self.subtitle)?;
                }
                if self.image.is_some() {
                    state.serialize_entry("image", &self.image)?;
                }
                if !self.column_properties.is_empty() {
                    state.serialize_entry("columnProperties", &self.column_properties)?;
                }
                if !self.rows.is_empty() {
                    state.serialize_entry("rows", &self.rows)?;
                }
                if !self.buttons.is_empty() {
                    state.serialize_entry("buttons", &self.buttons)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Column properties for
        /// [TableCard][google.cloud.dialogflow.v2.Intent.Message.TableCard].
        ///
        /// [google.cloud.dialogflow.v2.Intent.Message.TableCard]: crate::model::intent::message::TableCard
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ColumnProperties {
            /// Required. Column heading.
            pub header: std::string::String,

            /// Optional. Defines text alignment for all cells in this column.
            pub horizontal_alignment:
                crate::model::intent::message::column_properties::HorizontalAlignment,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl ColumnProperties {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [header][crate::model::intent::message::ColumnProperties::header].
            pub fn set_header<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.header = v.into();
                self
            }

            /// Sets the value of [horizontal_alignment][crate::model::intent::message::ColumnProperties::horizontal_alignment].
            pub fn set_horizontal_alignment<
                T: std::convert::Into<
                        crate::model::intent::message::column_properties::HorizontalAlignment,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.horizontal_alignment = v.into();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for ColumnProperties {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.ColumnProperties"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ColumnProperties {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __header,
                    __horizontal_alignment,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ColumnProperties")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "header" => Ok(__FieldTag::__header),
                                    "horizontalAlignment" => Ok(__FieldTag::__horizontal_alignment),
                                    "horizontal_alignment" => {
                                        Ok(__FieldTag::__horizontal_alignment)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ColumnProperties;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ColumnProperties")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__header => {
                                    if !fields.insert(__FieldTag::__header) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for header"),
                                        );
                                    }
                                    result.header = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__horizontal_alignment => {
                                    if !fields.insert(__FieldTag::__horizontal_alignment) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for horizontal_alignment",
                                            ),
                                        );
                                    }
                                    result.horizontal_alignment = map.next_value::<std::option::Option<crate::model::intent::message::column_properties::HorizontalAlignment>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for ColumnProperties {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.header.is_empty() {
                    state.serialize_entry("header", &self.header)?;
                }
                if !wkt::internal::is_default(&self.horizontal_alignment) {
                    state.serialize_entry("horizontalAlignment", &self.horizontal_alignment)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [ColumnProperties].
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        pub mod column_properties {
            #[allow(unused_imports)]
            use super::*;

            /// Text alignments within a cell.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum HorizontalAlignment {
                /// Text is aligned to the leading edge of the column.
                Unspecified,
                /// Text is aligned to the leading edge of the column.
                Leading,
                /// Text is centered in the column.
                Center,
                /// Text is aligned to the trailing edge of the column.
                Trailing,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [HorizontalAlignment::value] or
                /// [HorizontalAlignment::name].
                UnknownValue(horizontal_alignment::UnknownValue),
            }

            #[doc(hidden)]
            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            pub mod horizontal_alignment {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl HorizontalAlignment {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Leading => std::option::Option::Some(1),
                        Self::Center => std::option::Option::Some(2),
                        Self::Trailing => std::option::Option::Some(3),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("HORIZONTAL_ALIGNMENT_UNSPECIFIED")
                        }
                        Self::Leading => std::option::Option::Some("LEADING"),
                        Self::Center => std::option::Option::Some("CENTER"),
                        Self::Trailing => std::option::Option::Some("TRAILING"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl std::default::Default for HorizontalAlignment {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl std::fmt::Display for HorizontalAlignment {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl std::convert::From<i32> for HorizontalAlignment {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Leading,
                        2 => Self::Center,
                        3 => Self::Trailing,
                        _ => Self::UnknownValue(horizontal_alignment::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl std::convert::From<&str> for HorizontalAlignment {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "HORIZONTAL_ALIGNMENT_UNSPECIFIED" => Self::Unspecified,
                        "LEADING" => Self::Leading,
                        "CENTER" => Self::Center,
                        "TRAILING" => Self::Trailing,
                        _ => Self::UnknownValue(horizontal_alignment::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl serde::ser::Serialize for HorizontalAlignment {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Leading => serializer.serialize_i32(1),
                        Self::Center => serializer.serialize_i32(2),
                        Self::Trailing => serializer.serialize_i32(3),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            #[cfg(any(
                feature = "answer-records",
                feature = "intents",
                feature = "participants",
                feature = "sessions",
            ))]
            impl<'de> serde::de::Deserialize<'de> for HorizontalAlignment {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<HorizontalAlignment>::new(
                        ".google.cloud.dialogflow.v2.Intent.Message.ColumnProperties.HorizontalAlignment"))
                }
            }
        }

        /// Row of [TableCard][google.cloud.dialogflow.v2.Intent.Message.TableCard].
        ///
        /// [google.cloud.dialogflow.v2.Intent.Message.TableCard]: crate::model::intent::message::TableCard
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct TableCardRow {
            /// Optional. List of cells that make up this row.
            pub cells: std::vec::Vec<crate::model::intent::message::TableCardCell>,

            /// Optional. Whether to add a visual divider after this row.
            pub divider_after: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl TableCardRow {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [cells][crate::model::intent::message::TableCardRow::cells].
            pub fn set_cells<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::intent::message::TableCardCell>,
            {
                use std::iter::Iterator;
                self.cells = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [divider_after][crate::model::intent::message::TableCardRow::divider_after].
            pub fn set_divider_after<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.divider_after = v.into();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for TableCardRow {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.TableCardRow"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for TableCardRow {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __cells,
                    __divider_after,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for TableCardRow")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "cells" => Ok(__FieldTag::__cells),
                                    "dividerAfter" => Ok(__FieldTag::__divider_after),
                                    "divider_after" => Ok(__FieldTag::__divider_after),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = TableCardRow;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct TableCardRow")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__cells => {
                                    if !fields.insert(__FieldTag::__cells) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for cells"),
                                        );
                                    }
                                    result.cells = map
                                        .next_value::<std::option::Option<
                                            std::vec::Vec<
                                                crate::model::intent::message::TableCardCell,
                                            >,
                                        >>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__divider_after => {
                                    if !fields.insert(__FieldTag::__divider_after) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for divider_after",
                                            ),
                                        );
                                    }
                                    result.divider_after = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for TableCardRow {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.cells.is_empty() {
                    state.serialize_entry("cells", &self.cells)?;
                }
                if !wkt::internal::is_default(&self.divider_after) {
                    state.serialize_entry("dividerAfter", &self.divider_after)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Cell of
        /// [TableCardRow][google.cloud.dialogflow.v2.Intent.Message.TableCardRow].
        ///
        /// [google.cloud.dialogflow.v2.Intent.Message.TableCardRow]: crate::model::intent::message::TableCardRow
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct TableCardCell {
            /// Required. Text in this cell.
            pub text: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl TableCardCell {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [text][crate::model::intent::message::TableCardCell::text].
            pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.text = v.into();
                self
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl wkt::message::Message for TableCardCell {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.Intent.Message.TableCardCell"
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for TableCardCell {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __text,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for TableCardCell")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "text" => Ok(__FieldTag::__text),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = TableCardCell;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct TableCardCell")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__text => {
                                    if !fields.insert(__FieldTag::__text) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for text"),
                                        );
                                    }
                                    result.text = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[doc(hidden)]
        impl serde::ser::Serialize for TableCardCell {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.text.is_empty() {
                    state.serialize_entry("text", &self.text)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The rich response message integration platform. See
        /// [Integrations](https://cloud.google.com/dialogflow/docs/integrations).
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Platform {
            /// Default platform.
            Unspecified,
            /// Facebook.
            Facebook,
            /// Slack.
            Slack,
            /// Telegram.
            Telegram,
            /// Kik.
            Kik,
            /// Skype.
            Skype,
            /// Line.
            Line,
            /// Viber.
            Viber,
            /// Google Assistant
            /// See [Dialogflow webhook
            /// format](https://developers.google.com/assistant/actions/build/json/dialogflow-webhook-json)
            ActionsOnGoogle,
            /// Google Hangouts.
            GoogleHangouts,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Platform::value] or
            /// [Platform::name].
            UnknownValue(platform::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        pub mod platform {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl Platform {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Facebook => std::option::Option::Some(1),
                    Self::Slack => std::option::Option::Some(2),
                    Self::Telegram => std::option::Option::Some(3),
                    Self::Kik => std::option::Option::Some(4),
                    Self::Skype => std::option::Option::Some(5),
                    Self::Line => std::option::Option::Some(6),
                    Self::Viber => std::option::Option::Some(7),
                    Self::ActionsOnGoogle => std::option::Option::Some(8),
                    Self::GoogleHangouts => std::option::Option::Some(11),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("PLATFORM_UNSPECIFIED"),
                    Self::Facebook => std::option::Option::Some("FACEBOOK"),
                    Self::Slack => std::option::Option::Some("SLACK"),
                    Self::Telegram => std::option::Option::Some("TELEGRAM"),
                    Self::Kik => std::option::Option::Some("KIK"),
                    Self::Skype => std::option::Option::Some("SKYPE"),
                    Self::Line => std::option::Option::Some("LINE"),
                    Self::Viber => std::option::Option::Some("VIBER"),
                    Self::ActionsOnGoogle => std::option::Option::Some("ACTIONS_ON_GOOGLE"),
                    Self::GoogleHangouts => std::option::Option::Some("GOOGLE_HANGOUTS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl std::default::Default for Platform {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl std::fmt::Display for Platform {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl std::convert::From<i32> for Platform {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Facebook,
                    2 => Self::Slack,
                    3 => Self::Telegram,
                    4 => Self::Kik,
                    5 => Self::Skype,
                    6 => Self::Line,
                    7 => Self::Viber,
                    8 => Self::ActionsOnGoogle,
                    11 => Self::GoogleHangouts,
                    _ => Self::UnknownValue(platform::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl std::convert::From<&str> for Platform {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "PLATFORM_UNSPECIFIED" => Self::Unspecified,
                    "FACEBOOK" => Self::Facebook,
                    "SLACK" => Self::Slack,
                    "TELEGRAM" => Self::Telegram,
                    "KIK" => Self::Kik,
                    "SKYPE" => Self::Skype,
                    "LINE" => Self::Line,
                    "VIBER" => Self::Viber,
                    "ACTIONS_ON_GOOGLE" => Self::ActionsOnGoogle,
                    "GOOGLE_HANGOUTS" => Self::GoogleHangouts,
                    _ => Self::UnknownValue(platform::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl serde::ser::Serialize for Platform {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Facebook => serializer.serialize_i32(1),
                    Self::Slack => serializer.serialize_i32(2),
                    Self::Telegram => serializer.serialize_i32(3),
                    Self::Kik => serializer.serialize_i32(4),
                    Self::Skype => serializer.serialize_i32(5),
                    Self::Line => serializer.serialize_i32(6),
                    Self::Viber => serializer.serialize_i32(7),
                    Self::ActionsOnGoogle => serializer.serialize_i32(8),
                    Self::GoogleHangouts => serializer.serialize_i32(11),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        impl<'de> serde::de::Deserialize<'de> for Platform {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Platform>::new(
                    ".google.cloud.dialogflow.v2.Intent.Message.Platform",
                ))
            }
        }

        /// Required. The rich response message.
        #[cfg(any(
            feature = "answer-records",
            feature = "intents",
            feature = "participants",
            feature = "sessions",
        ))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Message {
            /// The text response.
            Text(std::boxed::Box<crate::model::intent::message::Text>),
            /// The image response.
            Image(std::boxed::Box<crate::model::intent::message::Image>),
            /// The quick replies response.
            QuickReplies(std::boxed::Box<crate::model::intent::message::QuickReplies>),
            /// The card response.
            Card(std::boxed::Box<crate::model::intent::message::Card>),
            /// A custom platform-specific response.
            Payload(std::boxed::Box<wkt::Struct>),
            /// The voice and text-only responses for Actions on Google.
            SimpleResponses(std::boxed::Box<crate::model::intent::message::SimpleResponses>),
            /// The basic card response for Actions on Google.
            BasicCard(std::boxed::Box<crate::model::intent::message::BasicCard>),
            /// The suggestion chips for Actions on Google.
            Suggestions(std::boxed::Box<crate::model::intent::message::Suggestions>),
            /// The link out suggestion chip for Actions on Google.
            LinkOutSuggestion(std::boxed::Box<crate::model::intent::message::LinkOutSuggestion>),
            /// The list card response for Actions on Google.
            ListSelect(std::boxed::Box<crate::model::intent::message::ListSelect>),
            /// The carousel card response for Actions on Google.
            CarouselSelect(std::boxed::Box<crate::model::intent::message::CarouselSelect>),
            /// Browse carousel card for Actions on Google.
            BrowseCarouselCard(std::boxed::Box<crate::model::intent::message::BrowseCarouselCard>),
            /// Table card for Actions on Google.
            TableCard(std::boxed::Box<crate::model::intent::message::TableCard>),
            /// The media content card for Actions on Google.
            MediaContent(std::boxed::Box<crate::model::intent::message::MediaContent>),
        }
    }

    /// Represents a single followup intent in the chain.
    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FollowupIntentInfo {
        /// The unique identifier of the followup intent.
        /// Format: `projects/<Project ID>/agent/intents/<Intent ID>`.
        pub followup_intent_name: std::string::String,

        /// The unique identifier of the followup intent's parent.
        /// Format: `projects/<Project ID>/agent/intents/<Intent ID>`.
        pub parent_followup_intent_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    impl FollowupIntentInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [followup_intent_name][crate::model::intent::FollowupIntentInfo::followup_intent_name].
        pub fn set_followup_intent_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.followup_intent_name = v.into();
            self
        }

        /// Sets the value of [parent_followup_intent_name][crate::model::intent::FollowupIntentInfo::parent_followup_intent_name].
        pub fn set_parent_followup_intent_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.parent_followup_intent_name = v.into();
            self
        }
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    impl wkt::message::Message for FollowupIntentInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.Intent.FollowupIntentInfo"
        }
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FollowupIntentInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __followup_intent_name,
                __parent_followup_intent_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FollowupIntentInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "followupIntentName" => Ok(__FieldTag::__followup_intent_name),
                                "followup_intent_name" => Ok(__FieldTag::__followup_intent_name),
                                "parentFollowupIntentName" => {
                                    Ok(__FieldTag::__parent_followup_intent_name)
                                }
                                "parent_followup_intent_name" => {
                                    Ok(__FieldTag::__parent_followup_intent_name)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FollowupIntentInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FollowupIntentInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__followup_intent_name => {
                                if !fields.insert(__FieldTag::__followup_intent_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for followup_intent_name",
                                    ));
                                }
                                result.followup_intent_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__parent_followup_intent_name => {
                                if !fields.insert(__FieldTag::__parent_followup_intent_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parent_followup_intent_name",
                                    ));
                                }
                                result.parent_followup_intent_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    #[doc(hidden)]
    impl serde::ser::Serialize for FollowupIntentInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.followup_intent_name.is_empty() {
                state.serialize_entry("followupIntentName", &self.followup_intent_name)?;
            }
            if !self.parent_followup_intent_name.is_empty() {
                state.serialize_entry(
                    "parentFollowupIntentName",
                    &self.parent_followup_intent_name,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Represents the different states that webhooks can be in.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum WebhookState {
        /// Webhook is disabled in the agent and in the intent.
        Unspecified,
        /// Webhook is enabled in the agent and in the intent.
        Enabled,
        /// Webhook is enabled in the agent and in the intent. Also, each slot
        /// filling prompt is forwarded to the webhook.
        EnabledForSlotFilling,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [WebhookState::value] or
        /// [WebhookState::name].
        UnknownValue(webhook_state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    pub mod webhook_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    impl WebhookState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::EnabledForSlotFilling => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("WEBHOOK_STATE_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("WEBHOOK_STATE_ENABLED"),
                Self::EnabledForSlotFilling => {
                    std::option::Option::Some("WEBHOOK_STATE_ENABLED_FOR_SLOT_FILLING")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    impl std::default::Default for WebhookState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    impl std::fmt::Display for WebhookState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    impl std::convert::From<i32> for WebhookState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::EnabledForSlotFilling,
                _ => Self::UnknownValue(webhook_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    impl std::convert::From<&str> for WebhookState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "WEBHOOK_STATE_UNSPECIFIED" => Self::Unspecified,
                "WEBHOOK_STATE_ENABLED" => Self::Enabled,
                "WEBHOOK_STATE_ENABLED_FOR_SLOT_FILLING" => Self::EnabledForSlotFilling,
                _ => Self::UnknownValue(webhook_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    impl serde::ser::Serialize for WebhookState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::EnabledForSlotFilling => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "answer-records",
        feature = "intents",
        feature = "participants",
        feature = "sessions",
    ))]
    impl<'de> serde::de::Deserialize<'de> for WebhookState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<WebhookState>::new(
                ".google.cloud.dialogflow.v2.Intent.WebhookState",
            ))
        }
    }
}

/// The request message for
/// [Intents.ListIntents][google.cloud.dialogflow.v2.Intents.ListIntents].
///
/// [google.cloud.dialogflow.v2.Intents.ListIntents]: crate::client::Intents::list_intents
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIntentsRequest {
    /// Required. The agent to list all intents from.
    /// Format: `projects/<Project ID>/agent` or `projects/<Project
    /// ID>/locations/<Location ID>/agent`.
    ///
    /// Alternatively, you can specify the environment to list intents for.
    /// Format: `projects/<Project ID>/agent/environments/<Environment ID>`
    /// or `projects/<Project ID>/locations/<Location
    /// ID>/agent/environments/<Environment ID>`.
    /// Note: training phrases of the intents will not be returned for non-draft
    /// environment.
    pub parent: std::string::String,

    /// Optional. The language used to access language-specific data.
    /// If not specified, the agent's default language is used.
    /// For more information, see
    /// [Multilingual intent and entity
    /// data](https://cloud.google.com/dialogflow/docs/agents-multilingual#intent-entity).
    pub language_code: std::string::String,

    /// Optional. The resource view to apply to the returned intent.
    pub intent_view: crate::model::IntentView,

    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl ListIntentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListIntentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::ListIntentsRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [intent_view][crate::model::ListIntentsRequest::intent_view].
    pub fn set_intent_view<T: std::convert::Into<crate::model::IntentView>>(
        mut self,
        v: T,
    ) -> Self {
        self.intent_view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListIntentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListIntentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for ListIntentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListIntentsRequest"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListIntentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __language_code,
            __intent_view,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListIntentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "intentView" => Ok(__FieldTag::__intent_view),
                            "intent_view" => Ok(__FieldTag::__intent_view),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListIntentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIntentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__intent_view => {
                            if !fields.insert(__FieldTag::__intent_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent_view",
                                ));
                            }
                            result.intent_view = map
                                .next_value::<std::option::Option<crate::model::IntentView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for ListIntentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.intent_view) {
            state.serialize_entry("intentView", &self.intent_view)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Intents.ListIntents][google.cloud.dialogflow.v2.Intents.ListIntents].
///
/// [google.cloud.dialogflow.v2.Intents.ListIntents]: crate::client::Intents::list_intents
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListIntentsResponse {
    /// The list of agent intents. There will be a maximum number of items
    /// returned based on the page_size field in the request.
    pub intents: std::vec::Vec<crate::model::Intent>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl ListIntentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [intents][crate::model::ListIntentsResponse::intents].
    pub fn set_intents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Intent>,
    {
        use std::iter::Iterator;
        self.intents = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListIntentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for ListIntentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListIntentsResponse"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListIntentsResponse {
    type PageItem = crate::model::Intent;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.intents
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListIntentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __intents,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListIntentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "intents" => Ok(__FieldTag::__intents),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListIntentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListIntentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__intents => {
                            if !fields.insert(__FieldTag::__intents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intents",
                                ));
                            }
                            result.intents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Intent>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for ListIntentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.intents.is_empty() {
            state.serialize_entry("intents", &self.intents)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Intents.GetIntent][google.cloud.dialogflow.v2.Intents.GetIntent].
///
/// [google.cloud.dialogflow.v2.Intents.GetIntent]: crate::client::Intents::get_intent
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetIntentRequest {
    /// Required. The name of the intent.
    /// Format: `projects/<Project ID>/agent/intents/<Intent ID>`.
    pub name: std::string::String,

    /// Optional. The language used to access language-specific data.
    /// If not specified, the agent's default language is used.
    /// For more information, see
    /// [Multilingual intent and entity
    /// data](https://cloud.google.com/dialogflow/docs/agents-multilingual#intent-entity).
    pub language_code: std::string::String,

    /// Optional. The resource view to apply to the returned intent.
    pub intent_view: crate::model::IntentView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl GetIntentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetIntentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::GetIntentRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [intent_view][crate::model::GetIntentRequest::intent_view].
    pub fn set_intent_view<T: std::convert::Into<crate::model::IntentView>>(
        mut self,
        v: T,
    ) -> Self {
        self.intent_view = v.into();
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for GetIntentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetIntentRequest"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __language_code,
            __intent_view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "intentView" => Ok(__FieldTag::__intent_view),
                            "intent_view" => Ok(__FieldTag::__intent_view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__intent_view => {
                            if !fields.insert(__FieldTag::__intent_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent_view",
                                ));
                            }
                            result.intent_view = map
                                .next_value::<std::option::Option<crate::model::IntentView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for GetIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.intent_view) {
            state.serialize_entry("intentView", &self.intent_view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Intents.CreateIntent][google.cloud.dialogflow.v2.Intents.CreateIntent].
///
/// [google.cloud.dialogflow.v2.Intents.CreateIntent]: crate::client::Intents::create_intent
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateIntentRequest {
    /// Required. The agent to create a intent for.
    /// Format: `projects/<Project ID>/agent`.
    pub parent: std::string::String,

    /// Required. The intent to create.
    pub intent: std::option::Option<crate::model::Intent>,

    /// Optional. The language used to access language-specific data.
    /// If not specified, the agent's default language is used.
    /// For more information, see
    /// [Multilingual intent and entity
    /// data](https://cloud.google.com/dialogflow/docs/agents-multilingual#intent-entity).
    pub language_code: std::string::String,

    /// Optional. The resource view to apply to the returned intent.
    pub intent_view: crate::model::IntentView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl CreateIntentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateIntentRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [intent][crate::model::CreateIntentRequest::intent].
    pub fn set_intent<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Intent>,
    {
        self.intent = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [intent][crate::model::CreateIntentRequest::intent].
    pub fn set_or_clear_intent<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Intent>,
    {
        self.intent = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::CreateIntentRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [intent_view][crate::model::CreateIntentRequest::intent_view].
    pub fn set_intent_view<T: std::convert::Into<crate::model::IntentView>>(
        mut self,
        v: T,
    ) -> Self {
        self.intent_view = v.into();
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for CreateIntentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CreateIntentRequest"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __intent,
            __language_code,
            __intent_view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "intent" => Ok(__FieldTag::__intent),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "intentView" => Ok(__FieldTag::__intent_view),
                            "intent_view" => Ok(__FieldTag::__intent_view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__intent => {
                            if !fields.insert(__FieldTag::__intent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent",
                                ));
                            }
                            result.intent =
                                map.next_value::<std::option::Option<crate::model::Intent>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__intent_view => {
                            if !fields.insert(__FieldTag::__intent_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent_view",
                                ));
                            }
                            result.intent_view = map
                                .next_value::<std::option::Option<crate::model::IntentView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.intent.is_some() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.intent_view) {
            state.serialize_entry("intentView", &self.intent_view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Intents.UpdateIntent][google.cloud.dialogflow.v2.Intents.UpdateIntent].
///
/// [google.cloud.dialogflow.v2.Intents.UpdateIntent]: crate::client::Intents::update_intent
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateIntentRequest {
    /// Required. The intent to update.
    pub intent: std::option::Option<crate::model::Intent>,

    /// Optional. The language used to access language-specific data.
    /// If not specified, the agent's default language is used.
    /// For more information, see
    /// [Multilingual intent and entity
    /// data](https://cloud.google.com/dialogflow/docs/agents-multilingual#intent-entity).
    pub language_code: std::string::String,

    /// Optional. The mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. The resource view to apply to the returned intent.
    pub intent_view: crate::model::IntentView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl UpdateIntentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [intent][crate::model::UpdateIntentRequest::intent].
    pub fn set_intent<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Intent>,
    {
        self.intent = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [intent][crate::model::UpdateIntentRequest::intent].
    pub fn set_or_clear_intent<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Intent>,
    {
        self.intent = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::UpdateIntentRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateIntentRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateIntentRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [intent_view][crate::model::UpdateIntentRequest::intent_view].
    pub fn set_intent_view<T: std::convert::Into<crate::model::IntentView>>(
        mut self,
        v: T,
    ) -> Self {
        self.intent_view = v.into();
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for UpdateIntentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.UpdateIntentRequest"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __intent,
            __language_code,
            __update_mask,
            __intent_view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "intent" => Ok(__FieldTag::__intent),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "intentView" => Ok(__FieldTag::__intent_view),
                            "intent_view" => Ok(__FieldTag::__intent_view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__intent => {
                            if !fields.insert(__FieldTag::__intent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent",
                                ));
                            }
                            result.intent =
                                map.next_value::<std::option::Option<crate::model::Intent>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__intent_view => {
                            if !fields.insert(__FieldTag::__intent_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent_view",
                                ));
                            }
                            result.intent_view = map
                                .next_value::<std::option::Option<crate::model::IntentView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.intent.is_some() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.intent_view) {
            state.serialize_entry("intentView", &self.intent_view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Intents.DeleteIntent][google.cloud.dialogflow.v2.Intents.DeleteIntent].
///
/// [google.cloud.dialogflow.v2.Intents.DeleteIntent]: crate::client::Intents::delete_intent
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteIntentRequest {
    /// Required. The name of the intent to delete. If this intent has direct or
    /// indirect followup intents, we also delete them.
    /// Format: `projects/<Project ID>/agent/intents/<Intent ID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl DeleteIntentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteIntentRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for DeleteIntentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DeleteIntentRequest"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchUpdateIntentsRequest {
    /// Required. The name of the agent to update or create intents in.
    /// Format: `projects/<Project ID>/agent`.
    pub parent: std::string::String,

    /// Optional. The language used to access language-specific data.
    /// If not specified, the agent's default language is used.
    /// For more information, see
    /// [Multilingual intent and entity
    /// data](https://cloud.google.com/dialogflow/docs/agents-multilingual#intent-entity).
    pub language_code: std::string::String,

    /// Optional. The mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. The resource view to apply to the returned intent.
    pub intent_view: crate::model::IntentView,

    /// The source of the intent batch.
    pub intent_batch: std::option::Option<crate::model::batch_update_intents_request::IntentBatch>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl BatchUpdateIntentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchUpdateIntentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::BatchUpdateIntentsRequest::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::BatchUpdateIntentsRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::BatchUpdateIntentsRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [intent_view][crate::model::BatchUpdateIntentsRequest::intent_view].
    pub fn set_intent_view<T: std::convert::Into<crate::model::IntentView>>(
        mut self,
        v: T,
    ) -> Self {
        self.intent_view = v.into();
        self
    }

    /// Sets the value of [intent_batch][crate::model::BatchUpdateIntentsRequest::intent_batch].
    ///
    /// Note that all the setters affecting `intent_batch` are mutually
    /// exclusive.
    pub fn set_intent_batch<
        T: std::convert::Into<
                std::option::Option<crate::model::batch_update_intents_request::IntentBatch>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.intent_batch = v.into();
        self
    }

    /// The value of [intent_batch][crate::model::BatchUpdateIntentsRequest::intent_batch]
    /// if it holds a `IntentBatchUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn intent_batch_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.intent_batch.as_ref().and_then(|v| match v {
            crate::model::batch_update_intents_request::IntentBatch::IntentBatchUri(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [intent_batch][crate::model::BatchUpdateIntentsRequest::intent_batch]
    /// to hold a `IntentBatchUri`.
    ///
    /// Note that all the setters affecting `intent_batch` are
    /// mutually exclusive.
    pub fn set_intent_batch_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.intent_batch = std::option::Option::Some(
            crate::model::batch_update_intents_request::IntentBatch::IntentBatchUri(v.into()),
        );
        self
    }

    /// The value of [intent_batch][crate::model::BatchUpdateIntentsRequest::intent_batch]
    /// if it holds a `IntentBatchInline`, `None` if the field is not set or
    /// holds a different branch.
    pub fn intent_batch_inline(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IntentBatch>> {
        #[allow(unreachable_patterns)]
        self.intent_batch.as_ref().and_then(|v| match v {
            crate::model::batch_update_intents_request::IntentBatch::IntentBatchInline(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [intent_batch][crate::model::BatchUpdateIntentsRequest::intent_batch]
    /// to hold a `IntentBatchInline`.
    ///
    /// Note that all the setters affecting `intent_batch` are
    /// mutually exclusive.
    pub fn set_intent_batch_inline<
        T: std::convert::Into<std::boxed::Box<crate::model::IntentBatch>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.intent_batch = std::option::Option::Some(
            crate::model::batch_update_intents_request::IntentBatch::IntentBatchInline(v.into()),
        );
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for BatchUpdateIntentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.BatchUpdateIntentsRequest"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchUpdateIntentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __intent_batch_uri,
            __intent_batch_inline,
            __language_code,
            __update_mask,
            __intent_view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchUpdateIntentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "intentBatchUri" => Ok(__FieldTag::__intent_batch_uri),
                            "intent_batch_uri" => Ok(__FieldTag::__intent_batch_uri),
                            "intentBatchInline" => Ok(__FieldTag::__intent_batch_inline),
                            "intent_batch_inline" => Ok(__FieldTag::__intent_batch_inline),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "intentView" => Ok(__FieldTag::__intent_view),
                            "intent_view" => Ok(__FieldTag::__intent_view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchUpdateIntentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchUpdateIntentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__intent_batch_uri => {
                            if !fields.insert(__FieldTag::__intent_batch_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent_batch_uri",
                                ));
                            }
                            if result.intent_batch.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `intent_batch`, a oneof with full ID .google.cloud.dialogflow.v2.BatchUpdateIntentsRequest.intent_batch_uri, latest field was intentBatchUri",
                                ));
                            }
                            result.intent_batch = std::option::Option::Some(
                                crate::model::batch_update_intents_request::IntentBatch::IntentBatchUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__intent_batch_inline => {
                            if !fields.insert(__FieldTag::__intent_batch_inline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent_batch_inline",
                                ));
                            }
                            if result.intent_batch.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `intent_batch`, a oneof with full ID .google.cloud.dialogflow.v2.BatchUpdateIntentsRequest.intent_batch_inline, latest field was intentBatchInline",
                                ));
                            }
                            result.intent_batch = std::option::Option::Some(
                                crate::model::batch_update_intents_request::IntentBatch::IntentBatchInline(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::IntentBatch>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__intent_view => {
                            if !fields.insert(__FieldTag::__intent_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent_view",
                                ));
                            }
                            result.intent_view = map
                                .next_value::<std::option::Option<crate::model::IntentView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for BatchUpdateIntentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if let Some(value) = self.intent_batch_uri() {
            state.serialize_entry("intentBatchUri", value)?;
        }
        if let Some(value) = self.intent_batch_inline() {
            state.serialize_entry("intentBatchInline", value)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.intent_view) {
            state.serialize_entry("intentView", &self.intent_view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BatchUpdateIntentsRequest].
#[cfg(feature = "intents")]
pub mod batch_update_intents_request {
    #[allow(unused_imports)]
    use super::*;

    /// The source of the intent batch.
    #[cfg(feature = "intents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IntentBatch {
        /// The URI to a Google Cloud Storage file containing intents to update or
        /// create. The file format can either be a serialized proto (of IntentBatch
        /// type) or JSON object. Note: The URI must start with "gs://".
        IntentBatchUri(std::string::String),
        /// The collection of intents to update or create.
        IntentBatchInline(std::boxed::Box<crate::model::IntentBatch>),
    }
}

/// The response message for
/// [Intents.BatchUpdateIntents][google.cloud.dialogflow.v2.Intents.BatchUpdateIntents].
///
/// [google.cloud.dialogflow.v2.Intents.BatchUpdateIntents]: crate::client::Intents::batch_update_intents
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchUpdateIntentsResponse {
    /// The collection of updated or created intents.
    pub intents: std::vec::Vec<crate::model::Intent>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl BatchUpdateIntentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [intents][crate::model::BatchUpdateIntentsResponse::intents].
    pub fn set_intents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Intent>,
    {
        use std::iter::Iterator;
        self.intents = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for BatchUpdateIntentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.BatchUpdateIntentsResponse"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchUpdateIntentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __intents,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchUpdateIntentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "intents" => Ok(__FieldTag::__intents),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchUpdateIntentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchUpdateIntentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__intents => {
                            if !fields.insert(__FieldTag::__intents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intents",
                                ));
                            }
                            result.intents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Intent>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for BatchUpdateIntentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.intents.is_empty() {
            state.serialize_entry("intents", &self.intents)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Intents.BatchDeleteIntents][google.cloud.dialogflow.v2.Intents.BatchDeleteIntents].
///
/// [google.cloud.dialogflow.v2.Intents.BatchDeleteIntents]: crate::client::Intents::batch_delete_intents
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchDeleteIntentsRequest {
    /// Required. The name of the agent to delete all entities types for. Format:
    /// `projects/<Project ID>/agent`.
    pub parent: std::string::String,

    /// Required. The collection of intents to delete. Only intent `name` must be
    /// filled in.
    pub intents: std::vec::Vec<crate::model::Intent>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl BatchDeleteIntentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchDeleteIntentsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [intents][crate::model::BatchDeleteIntentsRequest::intents].
    pub fn set_intents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Intent>,
    {
        use std::iter::Iterator;
        self.intents = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for BatchDeleteIntentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.BatchDeleteIntentsRequest"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchDeleteIntentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __intents,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchDeleteIntentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "intents" => Ok(__FieldTag::__intents),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchDeleteIntentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchDeleteIntentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__intents => {
                            if !fields.insert(__FieldTag::__intents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intents",
                                ));
                            }
                            result.intents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Intent>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for BatchDeleteIntentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.intents.is_empty() {
            state.serialize_entry("intents", &self.intents)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// This message is a wrapper around a collection of intents.
#[cfg(feature = "intents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct IntentBatch {
    /// A collection of intents.
    pub intents: std::vec::Vec<crate::model::Intent>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "intents")]
impl IntentBatch {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [intents][crate::model::IntentBatch::intents].
    pub fn set_intents<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Intent>,
    {
        use std::iter::Iterator;
        self.intents = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "intents")]
impl wkt::message::Message for IntentBatch {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.IntentBatch"
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IntentBatch {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __intents,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IntentBatch")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "intents" => Ok(__FieldTag::__intents),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IntentBatch;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IntentBatch")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__intents => {
                            if !fields.insert(__FieldTag::__intents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intents",
                                ));
                            }
                            result.intents = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Intent>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "intents")]
#[doc(hidden)]
impl serde::ser::Serialize for IntentBatch {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.intents.is_empty() {
            state.serialize_entry("intents", &self.intents)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A knowledge base represents a collection of knowledge documents that you
/// provide to Dialogflow. Your knowledge documents contain information that may
/// be useful during conversations with end-users. Some Dialogflow features use
/// knowledge bases when looking for a response to an end-user input.
///
/// For more information, see the [knowledge base
/// guide](https://cloud.google.com/dialogflow/docs/how/knowledge-bases).
///
/// Note: The `projects.agent.knowledgeBases` resource is deprecated;
/// only use `projects.knowledgeBases`.
#[cfg(feature = "knowledge-bases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct KnowledgeBase {
    /// The knowledge base resource name.
    /// The name must be empty when creating a knowledge base.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/knowledgeBases/<Knowledge Base ID>`.
    pub name: std::string::String,

    /// Required. The display name of the knowledge base. The name must be 1024
    /// bytes or less; otherwise, the creation request fails.
    pub display_name: std::string::String,

    /// Language which represents the KnowledgeBase. When the KnowledgeBase is
    /// created/updated, expect this to be present for non en-us languages. When
    /// unspecified, the default language code en-us applies.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "knowledge-bases")]
impl KnowledgeBase {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::KnowledgeBase::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::KnowledgeBase::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::KnowledgeBase::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "knowledge-bases")]
impl wkt::message::Message for KnowledgeBase {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.KnowledgeBase"
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KnowledgeBase {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KnowledgeBase")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KnowledgeBase;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KnowledgeBase")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl serde::ser::Serialize for KnowledgeBase {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KnowledgeBases.ListKnowledgeBases][google.cloud.dialogflow.v2.KnowledgeBases.ListKnowledgeBases].
///
/// [google.cloud.dialogflow.v2.KnowledgeBases.ListKnowledgeBases]: crate::client::KnowledgeBases::list_knowledge_bases
#[cfg(feature = "knowledge-bases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListKnowledgeBasesRequest {
    /// Required. The project to list of knowledge bases for.
    /// Format: `projects/<Project ID>/locations/<Location ID>`.
    pub parent: std::string::String,

    /// The maximum number of items to return in a single page. By
    /// default 10 and at most 100.
    pub page_size: i32,

    /// The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    /// The filter expression used to filter knowledge bases returned by the list
    /// method. The expression has the following syntax:
    ///
    /// \<field\> \<operator\> \<value\> [AND \<field\> \<operator\> \<value\>] ...
    ///
    /// The following fields and operators are supported:
    ///
    /// * display_name with has(:) operator
    /// * language_code with equals(=) operator
    ///
    /// Examples:
    ///
    /// * 'language_code=en-us' matches knowledge bases with en-us language code.
    /// * 'display_name:articles' matches knowledge bases whose display name
    ///   contains "articles".
    /// * 'display_name:"Best Articles"' matches knowledge bases whose display
    ///   name contains "Best Articles".
    /// * 'language_code=en-gb AND display_name=articles' matches all knowledge
    ///   bases whose display name contains "articles" and whose language code is
    ///   "en-gb".
    ///
    /// Note: An empty filter string (i.e. "") is a no-op and will result in no
    /// filtering.
    ///
    /// For more information about filtering, see
    /// [API Filtering](https://aip.dev/160).
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "knowledge-bases")]
impl ListKnowledgeBasesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListKnowledgeBasesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListKnowledgeBasesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListKnowledgeBasesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListKnowledgeBasesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

#[cfg(feature = "knowledge-bases")]
impl wkt::message::Message for ListKnowledgeBasesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListKnowledgeBasesRequest"
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListKnowledgeBasesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListKnowledgeBasesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListKnowledgeBasesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListKnowledgeBasesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl serde::ser::Serialize for ListKnowledgeBasesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [KnowledgeBases.ListKnowledgeBases][google.cloud.dialogflow.v2.KnowledgeBases.ListKnowledgeBases].
///
/// [google.cloud.dialogflow.v2.KnowledgeBases.ListKnowledgeBases]: crate::client::KnowledgeBases::list_knowledge_bases
#[cfg(feature = "knowledge-bases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListKnowledgeBasesResponse {
    /// The list of knowledge bases.
    pub knowledge_bases: std::vec::Vec<crate::model::KnowledgeBase>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "knowledge-bases")]
impl ListKnowledgeBasesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [knowledge_bases][crate::model::ListKnowledgeBasesResponse::knowledge_bases].
    pub fn set_knowledge_bases<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::KnowledgeBase>,
    {
        use std::iter::Iterator;
        self.knowledge_bases = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListKnowledgeBasesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "knowledge-bases")]
impl wkt::message::Message for ListKnowledgeBasesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListKnowledgeBasesResponse"
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListKnowledgeBasesResponse {
    type PageItem = crate::model::KnowledgeBase;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.knowledge_bases
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListKnowledgeBasesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __knowledge_bases,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListKnowledgeBasesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "knowledgeBases" => Ok(__FieldTag::__knowledge_bases),
                            "knowledge_bases" => Ok(__FieldTag::__knowledge_bases),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListKnowledgeBasesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListKnowledgeBasesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__knowledge_bases => {
                            if !fields.insert(__FieldTag::__knowledge_bases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for knowledge_bases",
                                ));
                            }
                            result.knowledge_bases = map.next_value::<std::option::Option<std::vec::Vec<crate::model::KnowledgeBase>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl serde::ser::Serialize for ListKnowledgeBasesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.knowledge_bases.is_empty() {
            state.serialize_entry("knowledgeBases", &self.knowledge_bases)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KnowledgeBases.GetKnowledgeBase][google.cloud.dialogflow.v2.KnowledgeBases.GetKnowledgeBase].
///
/// [google.cloud.dialogflow.v2.KnowledgeBases.GetKnowledgeBase]: crate::client::KnowledgeBases::get_knowledge_base
#[cfg(feature = "knowledge-bases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetKnowledgeBaseRequest {
    /// Required. The name of the knowledge base to retrieve.
    /// Format `projects/<Project ID>/locations/<Location
    /// ID>/knowledgeBases/<Knowledge Base ID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "knowledge-bases")]
impl GetKnowledgeBaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetKnowledgeBaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "knowledge-bases")]
impl wkt::message::Message for GetKnowledgeBaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetKnowledgeBaseRequest"
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetKnowledgeBaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetKnowledgeBaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetKnowledgeBaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetKnowledgeBaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl serde::ser::Serialize for GetKnowledgeBaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KnowledgeBases.CreateKnowledgeBase][google.cloud.dialogflow.v2.KnowledgeBases.CreateKnowledgeBase].
///
/// [google.cloud.dialogflow.v2.KnowledgeBases.CreateKnowledgeBase]: crate::client::KnowledgeBases::create_knowledge_base
#[cfg(feature = "knowledge-bases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateKnowledgeBaseRequest {
    /// Required. The project to create a knowledge base for.
    /// Format: `projects/<Project ID>/locations/<Location ID>`.
    pub parent: std::string::String,

    /// Required. The knowledge base to create.
    pub knowledge_base: std::option::Option<crate::model::KnowledgeBase>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "knowledge-bases")]
impl CreateKnowledgeBaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateKnowledgeBaseRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [knowledge_base][crate::model::CreateKnowledgeBaseRequest::knowledge_base].
    pub fn set_knowledge_base<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KnowledgeBase>,
    {
        self.knowledge_base = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [knowledge_base][crate::model::CreateKnowledgeBaseRequest::knowledge_base].
    pub fn set_or_clear_knowledge_base<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KnowledgeBase>,
    {
        self.knowledge_base = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "knowledge-bases")]
impl wkt::message::Message for CreateKnowledgeBaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CreateKnowledgeBaseRequest"
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateKnowledgeBaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __knowledge_base,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateKnowledgeBaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "knowledgeBase" => Ok(__FieldTag::__knowledge_base),
                            "knowledge_base" => Ok(__FieldTag::__knowledge_base),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateKnowledgeBaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateKnowledgeBaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__knowledge_base => {
                            if !fields.insert(__FieldTag::__knowledge_base) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for knowledge_base",
                                ));
                            }
                            result.knowledge_base = map
                                .next_value::<std::option::Option<crate::model::KnowledgeBase>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateKnowledgeBaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.knowledge_base.is_some() {
            state.serialize_entry("knowledgeBase", &self.knowledge_base)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KnowledgeBases.DeleteKnowledgeBase][google.cloud.dialogflow.v2.KnowledgeBases.DeleteKnowledgeBase].
///
/// [google.cloud.dialogflow.v2.KnowledgeBases.DeleteKnowledgeBase]: crate::client::KnowledgeBases::delete_knowledge_base
#[cfg(feature = "knowledge-bases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteKnowledgeBaseRequest {
    /// Required. The name of the knowledge base to delete.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/knowledgeBases/<Knowledge Base ID>`.
    pub name: std::string::String,

    /// Optional. Force deletes the knowledge base. When set to true, any documents
    /// in the knowledge base are also deleted.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "knowledge-bases")]
impl DeleteKnowledgeBaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteKnowledgeBaseRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteKnowledgeBaseRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

#[cfg(feature = "knowledge-bases")]
impl wkt::message::Message for DeleteKnowledgeBaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DeleteKnowledgeBaseRequest"
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteKnowledgeBaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteKnowledgeBaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteKnowledgeBaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteKnowledgeBaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteKnowledgeBaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [KnowledgeBases.UpdateKnowledgeBase][google.cloud.dialogflow.v2.KnowledgeBases.UpdateKnowledgeBase].
///
/// [google.cloud.dialogflow.v2.KnowledgeBases.UpdateKnowledgeBase]: crate::client::KnowledgeBases::update_knowledge_base
#[cfg(feature = "knowledge-bases")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateKnowledgeBaseRequest {
    /// Required. The knowledge base to update.
    pub knowledge_base: std::option::Option<crate::model::KnowledgeBase>,

    /// Optional. Not specified means `update all`.
    /// Currently, only `display_name` can be updated, an InvalidArgument will be
    /// returned for attempting to update other fields.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "knowledge-bases")]
impl UpdateKnowledgeBaseRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [knowledge_base][crate::model::UpdateKnowledgeBaseRequest::knowledge_base].
    pub fn set_knowledge_base<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KnowledgeBase>,
    {
        self.knowledge_base = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [knowledge_base][crate::model::UpdateKnowledgeBaseRequest::knowledge_base].
    pub fn set_or_clear_knowledge_base<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KnowledgeBase>,
    {
        self.knowledge_base = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateKnowledgeBaseRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateKnowledgeBaseRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "knowledge-bases")]
impl wkt::message::Message for UpdateKnowledgeBaseRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.UpdateKnowledgeBaseRequest"
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateKnowledgeBaseRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __knowledge_base,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateKnowledgeBaseRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "knowledgeBase" => Ok(__FieldTag::__knowledge_base),
                            "knowledge_base" => Ok(__FieldTag::__knowledge_base),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateKnowledgeBaseRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateKnowledgeBaseRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__knowledge_base => {
                            if !fields.insert(__FieldTag::__knowledge_base) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for knowledge_base",
                                ));
                            }
                            result.knowledge_base = map
                                .next_value::<std::option::Option<crate::model::KnowledgeBase>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "knowledge-bases")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateKnowledgeBaseRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.knowledge_base.is_some() {
            state.serialize_entry("knowledgeBase", &self.knowledge_base)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a conversation participant (human agent, virtual agent, end-user).
#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Participant {
    /// Optional. The unique identifier of this participant.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
    pub name: std::string::String,

    /// Immutable. The role this participant plays in the conversation. This field
    /// must be set during participant creation and is then immutable.
    pub role: crate::model::participant::Role,

    /// Optional. Label applied to streams representing this participant in SIPREC
    /// XML metadata and SDP. This is used to assign transcriptions from that
    /// media stream to this participant. This field can be updated.
    pub sip_recording_media_label: std::string::String,

    /// Optional. Obfuscated user id that should be associated with the created
    /// participant.
    ///
    /// You can specify a user id as follows:
    ///
    /// 1. If you set this field in
    ///    [CreateParticipantRequest][google.cloud.dialogflow.v2.CreateParticipantRequest.participant]
    ///    or
    ///    [UpdateParticipantRequest][google.cloud.dialogflow.v2.UpdateParticipantRequest.participant],
    ///    Dialogflow adds the obfuscated user id with the participant.
    ///
    /// 1. If you set this field in
    ///    [AnalyzeContent][google.cloud.dialogflow.v2.AnalyzeContentRequest.participant]
    ///    or
    ///    [StreamingAnalyzeContent][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.participant],
    ///    Dialogflow will update
    ///    [Participant.obfuscated_external_user_id][google.cloud.dialogflow.v2.Participant.obfuscated_external_user_id].
    ///
    ///
    /// Dialogflow returns an error if you try to add a user id for a
    /// non-[END_USER][google.cloud.dialogflow.v2.Participant.Role.END_USER]
    /// participant.
    ///
    /// Dialogflow uses this user id for billing and measurement purposes. For
    /// example, Dialogflow determines whether a user in one conversation returned
    /// in a later conversation.
    ///
    /// Note:
    ///
    /// * Please never pass raw user ids to Dialogflow. Always obfuscate your user
    ///   id first.
    /// * Dialogflow only accepts a UTF-8 encoded string, e.g., a hex digest of a
    ///   hash function like SHA-512.
    /// * The length of the user id must be <= 256 characters.
    ///
    /// [google.cloud.dialogflow.v2.AnalyzeContentRequest.participant]: crate::model::AnalyzeContentRequest::participant
    /// [google.cloud.dialogflow.v2.CreateParticipantRequest.participant]: crate::model::CreateParticipantRequest::participant
    /// [google.cloud.dialogflow.v2.Participant.Role.END_USER]: crate::model::participant::Role::EndUser
    /// [google.cloud.dialogflow.v2.Participant.obfuscated_external_user_id]: crate::model::Participant::obfuscated_external_user_id
    /// [google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.participant]: crate::model::StreamingAnalyzeContentRequest::participant
    /// [google.cloud.dialogflow.v2.UpdateParticipantRequest.participant]: crate::model::UpdateParticipantRequest::participant
    pub obfuscated_external_user_id: std::string::String,

    /// Optional. Key-value filters on the metadata of documents returned by
    /// article suggestion. If specified, article suggestion only returns suggested
    /// documents that match all filters in their
    /// [Document.metadata][google.cloud.dialogflow.v2.Document.metadata]. Multiple
    /// values for a metadata key should be concatenated by comma. For example,
    /// filters to match all documents that have 'US' or 'CA' in their market
    /// metadata values and 'agent' in their user metadata values will be
    ///
    /// ```norust
    /// documents_metadata_filters {
    ///   key: "market"
    ///   value: "US,CA"
    /// }
    /// documents_metadata_filters {
    ///   key: "user"
    ///   value: "agent"
    /// }
    /// ```
    ///
    /// [google.cloud.dialogflow.v2.Document.metadata]: crate::model::Document::metadata
    pub documents_metadata_filters:
        std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
))]
impl Participant {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Participant::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [role][crate::model::Participant::role].
    pub fn set_role<T: std::convert::Into<crate::model::participant::Role>>(
        mut self,
        v: T,
    ) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [sip_recording_media_label][crate::model::Participant::sip_recording_media_label].
    pub fn set_sip_recording_media_label<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.sip_recording_media_label = v.into();
        self
    }

    /// Sets the value of [obfuscated_external_user_id][crate::model::Participant::obfuscated_external_user_id].
    pub fn set_obfuscated_external_user_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.obfuscated_external_user_id = v.into();
        self
    }

    /// Sets the value of [documents_metadata_filters][crate::model::Participant::documents_metadata_filters].
    pub fn set_documents_metadata_filters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.documents_metadata_filters =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
))]
impl wkt::message::Message for Participant {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.Participant"
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Participant {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __role,
            __sip_recording_media_label,
            __obfuscated_external_user_id,
            __documents_metadata_filters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Participant")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "role" => Ok(__FieldTag::__role),
                            "sipRecordingMediaLabel" => Ok(__FieldTag::__sip_recording_media_label),
                            "sip_recording_media_label" => {
                                Ok(__FieldTag::__sip_recording_media_label)
                            }
                            "obfuscatedExternalUserId" => {
                                Ok(__FieldTag::__obfuscated_external_user_id)
                            }
                            "obfuscated_external_user_id" => {
                                Ok(__FieldTag::__obfuscated_external_user_id)
                            }
                            "documentsMetadataFilters" => {
                                Ok(__FieldTag::__documents_metadata_filters)
                            }
                            "documents_metadata_filters" => {
                                Ok(__FieldTag::__documents_metadata_filters)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Participant;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Participant")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__role => {
                            if !fields.insert(__FieldTag::__role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role",
                                ));
                            }
                            result.role = map
                                .next_value::<std::option::Option<crate::model::participant::Role>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__sip_recording_media_label => {
                            if !fields.insert(__FieldTag::__sip_recording_media_label) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sip_recording_media_label",
                                ));
                            }
                            result.sip_recording_media_label = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__obfuscated_external_user_id => {
                            if !fields.insert(__FieldTag::__obfuscated_external_user_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for obfuscated_external_user_id",
                                ));
                            }
                            result.obfuscated_external_user_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__documents_metadata_filters => {
                            if !fields.insert(__FieldTag::__documents_metadata_filters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documents_metadata_filters",
                                ));
                            }
                            result.documents_metadata_filters = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
))]
#[doc(hidden)]
impl serde::ser::Serialize for Participant {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.role) {
            state.serialize_entry("role", &self.role)?;
        }
        if !self.sip_recording_media_label.is_empty() {
            state.serialize_entry("sipRecordingMediaLabel", &self.sip_recording_media_label)?;
        }
        if !self.obfuscated_external_user_id.is_empty() {
            state.serialize_entry(
                "obfuscatedExternalUserId",
                &self.obfuscated_external_user_id,
            )?;
        }
        if !self.documents_metadata_filters.is_empty() {
            state.serialize_entry("documentsMetadataFilters", &self.documents_metadata_filters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Participant].
#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
))]
pub mod participant {
    #[allow(unused_imports)]
    use super::*;

    /// Enumeration of the roles a participant can play in a conversation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "conversation-profiles",
        feature = "conversations",
        feature = "participants",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Role {
        /// Participant role not set.
        Unspecified,
        /// Participant is a human agent.
        HumanAgent,
        /// Participant is an automated agent, such as a Dialogflow agent.
        AutomatedAgent,
        /// Participant is an end user that has called or chatted with
        /// Dialogflow services.
        EndUser,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Role::value] or
        /// [Role::name].
        UnknownValue(role::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "conversation-profiles",
        feature = "conversations",
        feature = "participants",
    ))]
    pub mod role {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "conversation-profiles",
        feature = "conversations",
        feature = "participants",
    ))]
    impl Role {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::HumanAgent => std::option::Option::Some(1),
                Self::AutomatedAgent => std::option::Option::Some(2),
                Self::EndUser => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLE_UNSPECIFIED"),
                Self::HumanAgent => std::option::Option::Some("HUMAN_AGENT"),
                Self::AutomatedAgent => std::option::Option::Some("AUTOMATED_AGENT"),
                Self::EndUser => std::option::Option::Some("END_USER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "conversation-profiles",
        feature = "conversations",
        feature = "participants",
    ))]
    impl std::default::Default for Role {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "conversation-profiles",
        feature = "conversations",
        feature = "participants",
    ))]
    impl std::fmt::Display for Role {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "conversation-profiles",
        feature = "conversations",
        feature = "participants",
    ))]
    impl std::convert::From<i32> for Role {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::HumanAgent,
                2 => Self::AutomatedAgent,
                3 => Self::EndUser,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "conversation-profiles",
        feature = "conversations",
        feature = "participants",
    ))]
    impl std::convert::From<&str> for Role {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLE_UNSPECIFIED" => Self::Unspecified,
                "HUMAN_AGENT" => Self::HumanAgent,
                "AUTOMATED_AGENT" => Self::AutomatedAgent,
                "END_USER" => Self::EndUser,
                _ => Self::UnknownValue(role::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "conversation-profiles",
        feature = "conversations",
        feature = "participants",
    ))]
    impl serde::ser::Serialize for Role {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::HumanAgent => serializer.serialize_i32(1),
                Self::AutomatedAgent => serializer.serialize_i32(2),
                Self::EndUser => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "conversation-profiles",
        feature = "conversations",
        feature = "participants",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Role {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Role>::new(
                ".google.cloud.dialogflow.v2.Participant.Role",
            ))
        }
    }
}

/// Represents a message posted into a conversation.
#[cfg(any(feature = "conversations", feature = "participants",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Message {
    /// Optional. The unique identifier of the message.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/messages/<Message ID>`.
    pub name: std::string::String,

    /// Required. The message content.
    pub content: std::string::String,

    /// Optional. The message language.
    /// This should be a [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt)
    /// language tag. Example: "en-US".
    pub language_code: std::string::String,

    /// Output only. The participant that sends this message.
    pub participant: std::string::String,

    /// Output only. The role of the participant.
    pub participant_role: crate::model::participant::Role,

    /// Output only. The time when the message was created in Contact Center AI.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The time when the message was sent. For voice messages, this is
    /// the time when an utterance started.
    pub send_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The annotation for the message.
    pub message_annotation: std::option::Option<crate::model::MessageAnnotation>,

    /// Output only. The sentiment analysis result for the message.
    pub sentiment_analysis: std::option::Option<crate::model::SentimentAnalysisResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversations", feature = "participants",))]
impl Message {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Message::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [content][crate::model::Message::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::Message::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [participant][crate::model::Message::participant].
    pub fn set_participant<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.participant = v.into();
        self
    }

    /// Sets the value of [participant_role][crate::model::Message::participant_role].
    pub fn set_participant_role<T: std::convert::Into<crate::model::participant::Role>>(
        mut self,
        v: T,
    ) -> Self {
        self.participant_role = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Message::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Message::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [send_time][crate::model::Message::send_time].
    pub fn set_send_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.send_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [send_time][crate::model::Message::send_time].
    pub fn set_or_clear_send_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.send_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [message_annotation][crate::model::Message::message_annotation].
    pub fn set_message_annotation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MessageAnnotation>,
    {
        self.message_annotation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [message_annotation][crate::model::Message::message_annotation].
    pub fn set_or_clear_message_annotation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MessageAnnotation>,
    {
        self.message_annotation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sentiment_analysis][crate::model::Message::sentiment_analysis].
    pub fn set_sentiment_analysis<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SentimentAnalysisResult>,
    {
        self.sentiment_analysis = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sentiment_analysis][crate::model::Message::sentiment_analysis].
    pub fn set_or_clear_sentiment_analysis<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SentimentAnalysisResult>,
    {
        self.sentiment_analysis = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
impl wkt::message::Message for Message {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.Message"
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Message {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __content,
            __language_code,
            __participant,
            __participant_role,
            __create_time,
            __send_time,
            __message_annotation,
            __sentiment_analysis,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Message")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "content" => Ok(__FieldTag::__content),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "participant" => Ok(__FieldTag::__participant),
                            "participantRole" => Ok(__FieldTag::__participant_role),
                            "participant_role" => Ok(__FieldTag::__participant_role),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "sendTime" => Ok(__FieldTag::__send_time),
                            "send_time" => Ok(__FieldTag::__send_time),
                            "messageAnnotation" => Ok(__FieldTag::__message_annotation),
                            "message_annotation" => Ok(__FieldTag::__message_annotation),
                            "sentimentAnalysis" => Ok(__FieldTag::__sentiment_analysis),
                            "sentiment_analysis" => Ok(__FieldTag::__sentiment_analysis),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Message;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Message")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__participant => {
                            if !fields.insert(__FieldTag::__participant) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for participant",
                                ));
                            }
                            result.participant = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__participant_role => {
                            if !fields.insert(__FieldTag::__participant_role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for participant_role",
                                ));
                            }
                            result.participant_role = map
                                .next_value::<std::option::Option<crate::model::participant::Role>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__send_time => {
                            if !fields.insert(__FieldTag::__send_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for send_time",
                                ));
                            }
                            result.send_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__message_annotation => {
                            if !fields.insert(__FieldTag::__message_annotation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_annotation",
                                ));
                            }
                            result.message_annotation = map
                                .next_value::<std::option::Option<crate::model::MessageAnnotation>>(
                                )?;
                        }
                        __FieldTag::__sentiment_analysis => {
                            if !fields.insert(__FieldTag::__sentiment_analysis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sentiment_analysis",
                                ));
                            }
                            result.sentiment_analysis = map.next_value::<std::option::Option<crate::model::SentimentAnalysisResult>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
#[doc(hidden)]
impl serde::ser::Serialize for Message {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self.participant.is_empty() {
            state.serialize_entry("participant", &self.participant)?;
        }
        if !wkt::internal::is_default(&self.participant_role) {
            state.serialize_entry("participantRole", &self.participant_role)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.send_time.is_some() {
            state.serialize_entry("sendTime", &self.send_time)?;
        }
        if self.message_annotation.is_some() {
            state.serialize_entry("messageAnnotation", &self.message_annotation)?;
        }
        if self.sentiment_analysis.is_some() {
            state.serialize_entry("sentimentAnalysis", &self.sentiment_analysis)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Participants.CreateParticipant][google.cloud.dialogflow.v2.Participants.CreateParticipant].
///
/// [google.cloud.dialogflow.v2.Participants.CreateParticipant]: crate::client::Participants::create_participant
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateParticipantRequest {
    /// Required. Resource identifier of the conversation adding the participant.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>`.
    pub parent: std::string::String,

    /// Required. The participant to create.
    pub participant: std::option::Option<crate::model::Participant>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl CreateParticipantRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateParticipantRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [participant][crate::model::CreateParticipantRequest::participant].
    pub fn set_participant<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Participant>,
    {
        self.participant = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [participant][crate::model::CreateParticipantRequest::participant].
    pub fn set_or_clear_participant<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Participant>,
    {
        self.participant = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for CreateParticipantRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CreateParticipantRequest"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateParticipantRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __participant,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateParticipantRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "participant" => Ok(__FieldTag::__participant),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateParticipantRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateParticipantRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__participant => {
                            if !fields.insert(__FieldTag::__participant) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for participant",
                                ));
                            }
                            result.participant =
                                map.next_value::<std::option::Option<crate::model::Participant>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateParticipantRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.participant.is_some() {
            state.serialize_entry("participant", &self.participant)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Participants.GetParticipant][google.cloud.dialogflow.v2.Participants.GetParticipant].
///
/// [google.cloud.dialogflow.v2.Participants.GetParticipant]: crate::client::Participants::get_participant
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetParticipantRequest {
    /// Required. The name of the participant. Format:
    /// `projects/<Project ID>/locations/<Location ID>/conversations/<Conversation
    /// ID>/participants/<Participant ID>`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl GetParticipantRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetParticipantRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for GetParticipantRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetParticipantRequest"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetParticipantRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetParticipantRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetParticipantRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetParticipantRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for GetParticipantRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Participants.ListParticipants][google.cloud.dialogflow.v2.Participants.ListParticipants].
///
/// [google.cloud.dialogflow.v2.Participants.ListParticipants]: crate::client::Participants::list_participants
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListParticipantsRequest {
    /// Required. The conversation to list all participants from.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>`.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl ListParticipantsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListParticipantsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListParticipantsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListParticipantsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for ListParticipantsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListParticipantsRequest"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListParticipantsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListParticipantsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListParticipantsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListParticipantsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for ListParticipantsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Participants.ListParticipants][google.cloud.dialogflow.v2.Participants.ListParticipants].
///
/// [google.cloud.dialogflow.v2.Participants.ListParticipants]: crate::client::Participants::list_participants
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListParticipantsResponse {
    /// The list of participants. There is a maximum number of items
    /// returned based on the page_size field in the request.
    pub participants: std::vec::Vec<crate::model::Participant>,

    /// Token to retrieve the next page of results or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl ListParticipantsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [participants][crate::model::ListParticipantsResponse::participants].
    pub fn set_participants<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Participant>,
    {
        use std::iter::Iterator;
        self.participants = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListParticipantsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for ListParticipantsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListParticipantsResponse"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListParticipantsResponse {
    type PageItem = crate::model::Participant;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.participants
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListParticipantsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __participants,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListParticipantsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "participants" => Ok(__FieldTag::__participants),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListParticipantsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListParticipantsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__participants => {
                            if !fields.insert(__FieldTag::__participants) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for participants",
                                ));
                            }
                            result.participants = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Participant>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for ListParticipantsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.participants.is_empty() {
            state.serialize_entry("participants", &self.participants)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Participants.UpdateParticipant][google.cloud.dialogflow.v2.Participants.UpdateParticipant].
///
/// [google.cloud.dialogflow.v2.Participants.UpdateParticipant]: crate::client::Participants::update_participant
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateParticipantRequest {
    /// Required. The participant to update.
    pub participant: std::option::Option<crate::model::Participant>,

    /// Required. The mask to specify which fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl UpdateParticipantRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [participant][crate::model::UpdateParticipantRequest::participant].
    pub fn set_participant<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Participant>,
    {
        self.participant = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [participant][crate::model::UpdateParticipantRequest::participant].
    pub fn set_or_clear_participant<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Participant>,
    {
        self.participant = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateParticipantRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateParticipantRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for UpdateParticipantRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.UpdateParticipantRequest"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateParticipantRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __participant,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateParticipantRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "participant" => Ok(__FieldTag::__participant),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateParticipantRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateParticipantRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__participant => {
                            if !fields.insert(__FieldTag::__participant) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for participant",
                                ));
                            }
                            result.participant =
                                map.next_value::<std::option::Option<crate::model::Participant>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateParticipantRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.participant.is_some() {
            state.serialize_entry("participant", &self.participant)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Participants.AnalyzeContent][google.cloud.dialogflow.v2.Participants.AnalyzeContent].
///
/// [google.cloud.dialogflow.v2.Participants.AnalyzeContent]: crate::client::Participants::analyze_content
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeContentRequest {
    /// Required. The name of the participant this text comes from.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
    pub participant: std::string::String,

    /// Speech synthesis configuration.
    /// The speech synthesis settings for a virtual agent that may be configured
    /// for the associated conversation profile are not used when calling
    /// AnalyzeContent. If this configuration is not supplied, speech synthesis
    /// is disabled.
    pub reply_audio_config: std::option::Option<crate::model::OutputAudioConfig>,

    /// Parameters for a Dialogflow virtual-agent query.
    pub query_params: std::option::Option<crate::model::QueryParameters>,

    /// Parameters for a human assist query.
    pub assist_query_params: std::option::Option<crate::model::AssistQueryParameters>,

    /// Additional parameters to be put into Dialogflow CX session parameters. To
    /// remove a parameter from the session, clients should explicitly set the
    /// parameter value to null.
    ///
    /// Note: this field should only be used if you are connecting to a Dialogflow
    /// CX agent.
    pub cx_parameters: std::option::Option<wkt::Struct>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters.
    /// A random UUID is recommended.
    /// This request is only idempotent if a `request_id` is provided.
    pub request_id: std::string::String,

    /// Required. The input content.
    pub input: std::option::Option<crate::model::analyze_content_request::Input>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl AnalyzeContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [participant][crate::model::AnalyzeContentRequest::participant].
    pub fn set_participant<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.participant = v.into();
        self
    }

    /// Sets the value of [reply_audio_config][crate::model::AnalyzeContentRequest::reply_audio_config].
    pub fn set_reply_audio_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.reply_audio_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reply_audio_config][crate::model::AnalyzeContentRequest::reply_audio_config].
    pub fn set_or_clear_reply_audio_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.reply_audio_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query_params][crate::model::AnalyzeContentRequest::query_params].
    pub fn set_query_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameters>,
    {
        self.query_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_params][crate::model::AnalyzeContentRequest::query_params].
    pub fn set_or_clear_query_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameters>,
    {
        self.query_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [assist_query_params][crate::model::AnalyzeContentRequest::assist_query_params].
    pub fn set_assist_query_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AssistQueryParameters>,
    {
        self.assist_query_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [assist_query_params][crate::model::AnalyzeContentRequest::assist_query_params].
    pub fn set_or_clear_assist_query_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AssistQueryParameters>,
    {
        self.assist_query_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cx_parameters][crate::model::AnalyzeContentRequest::cx_parameters].
    pub fn set_cx_parameters<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.cx_parameters = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cx_parameters][crate::model::AnalyzeContentRequest::cx_parameters].
    pub fn set_or_clear_cx_parameters<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.cx_parameters = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::AnalyzeContentRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [input][crate::model::AnalyzeContentRequest::input].
    ///
    /// Note that all the setters affecting `input` are mutually
    /// exclusive.
    pub fn set_input<
        T: std::convert::Into<std::option::Option<crate::model::analyze_content_request::Input>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input = v.into();
        self
    }

    /// The value of [input][crate::model::AnalyzeContentRequest::input]
    /// if it holds a `TextInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text_input(&self) -> std::option::Option<&std::boxed::Box<crate::model::TextInput>> {
        #[allow(unreachable_patterns)]
        self.input.as_ref().and_then(|v| match v {
            crate::model::analyze_content_request::Input::TextInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input][crate::model::AnalyzeContentRequest::input]
    /// to hold a `TextInput`.
    ///
    /// Note that all the setters affecting `input` are
    /// mutually exclusive.
    pub fn set_text_input<T: std::convert::Into<std::boxed::Box<crate::model::TextInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.input = std::option::Option::Some(
            crate::model::analyze_content_request::Input::TextInput(v.into()),
        );
        self
    }

    /// The value of [input][crate::model::AnalyzeContentRequest::input]
    /// if it holds a `AudioInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn audio_input(&self) -> std::option::Option<&std::boxed::Box<crate::model::AudioInput>> {
        #[allow(unreachable_patterns)]
        self.input.as_ref().and_then(|v| match v {
            crate::model::analyze_content_request::Input::AudioInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input][crate::model::AnalyzeContentRequest::input]
    /// to hold a `AudioInput`.
    ///
    /// Note that all the setters affecting `input` are
    /// mutually exclusive.
    pub fn set_audio_input<T: std::convert::Into<std::boxed::Box<crate::model::AudioInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.input = std::option::Option::Some(
            crate::model::analyze_content_request::Input::AudioInput(v.into()),
        );
        self
    }

    /// The value of [input][crate::model::AnalyzeContentRequest::input]
    /// if it holds a `EventInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn event_input(&self) -> std::option::Option<&std::boxed::Box<crate::model::EventInput>> {
        #[allow(unreachable_patterns)]
        self.input.as_ref().and_then(|v| match v {
            crate::model::analyze_content_request::Input::EventInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input][crate::model::AnalyzeContentRequest::input]
    /// to hold a `EventInput`.
    ///
    /// Note that all the setters affecting `input` are
    /// mutually exclusive.
    pub fn set_event_input<T: std::convert::Into<std::boxed::Box<crate::model::EventInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.input = std::option::Option::Some(
            crate::model::analyze_content_request::Input::EventInput(v.into()),
        );
        self
    }

    /// The value of [input][crate::model::AnalyzeContentRequest::input]
    /// if it holds a `SuggestionInput`, `None` if the field is not set or
    /// holds a different branch.
    pub fn suggestion_input(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SuggestionInput>> {
        #[allow(unreachable_patterns)]
        self.input.as_ref().and_then(|v| match v {
            crate::model::analyze_content_request::Input::SuggestionInput(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input][crate::model::AnalyzeContentRequest::input]
    /// to hold a `SuggestionInput`.
    ///
    /// Note that all the setters affecting `input` are
    /// mutually exclusive.
    pub fn set_suggestion_input<
        T: std::convert::Into<std::boxed::Box<crate::model::SuggestionInput>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input = std::option::Option::Some(
            crate::model::analyze_content_request::Input::SuggestionInput(v.into()),
        );
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for AnalyzeContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.AnalyzeContentRequest"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeContentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __participant,
            __text_input,
            __audio_input,
            __event_input,
            __suggestion_input,
            __reply_audio_config,
            __query_params,
            __assist_query_params,
            __cx_parameters,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzeContentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "participant" => Ok(__FieldTag::__participant),
                            "textInput" => Ok(__FieldTag::__text_input),
                            "text_input" => Ok(__FieldTag::__text_input),
                            "audioInput" => Ok(__FieldTag::__audio_input),
                            "audio_input" => Ok(__FieldTag::__audio_input),
                            "eventInput" => Ok(__FieldTag::__event_input),
                            "event_input" => Ok(__FieldTag::__event_input),
                            "suggestionInput" => Ok(__FieldTag::__suggestion_input),
                            "suggestion_input" => Ok(__FieldTag::__suggestion_input),
                            "replyAudioConfig" => Ok(__FieldTag::__reply_audio_config),
                            "reply_audio_config" => Ok(__FieldTag::__reply_audio_config),
                            "queryParams" => Ok(__FieldTag::__query_params),
                            "query_params" => Ok(__FieldTag::__query_params),
                            "assistQueryParams" => Ok(__FieldTag::__assist_query_params),
                            "assist_query_params" => Ok(__FieldTag::__assist_query_params),
                            "cxParameters" => Ok(__FieldTag::__cx_parameters),
                            "cx_parameters" => Ok(__FieldTag::__cx_parameters),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeContentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeContentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__participant => {
                            if !fields.insert(__FieldTag::__participant) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for participant",
                                ));
                            }
                            result.participant = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__text_input => {
                            if !fields.insert(__FieldTag::__text_input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text_input",
                                ));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.AnalyzeContentRequest.text_input, latest field was textInput",
                                ));
                            }
                            result.input = std::option::Option::Some(
                                crate::model::analyze_content_request::Input::TextInput(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TextInput>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__audio_input => {
                            if !fields.insert(__FieldTag::__audio_input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_input",
                                ));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.AnalyzeContentRequest.audio_input, latest field was audioInput",
                                ));
                            }
                            result.input = std::option::Option::Some(
                                crate::model::analyze_content_request::Input::AudioInput(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AudioInput>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__event_input => {
                            if !fields.insert(__FieldTag::__event_input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_input",
                                ));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.AnalyzeContentRequest.event_input, latest field was eventInput",
                                ));
                            }
                            result.input = std::option::Option::Some(
                                crate::model::analyze_content_request::Input::EventInput(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::EventInput>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__suggestion_input => {
                            if !fields.insert(__FieldTag::__suggestion_input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suggestion_input",
                                ));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.AnalyzeContentRequest.suggestion_input, latest field was suggestionInput",
                                ));
                            }
                            result.input = std::option::Option::Some(
                                crate::model::analyze_content_request::Input::SuggestionInput(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::SuggestionInput>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__reply_audio_config => {
                            if !fields.insert(__FieldTag::__reply_audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reply_audio_config",
                                ));
                            }
                            result.reply_audio_config = map
                                .next_value::<std::option::Option<crate::model::OutputAudioConfig>>(
                                )?;
                        }
                        __FieldTag::__query_params => {
                            if !fields.insert(__FieldTag::__query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_params",
                                ));
                            }
                            result.query_params = map
                                .next_value::<std::option::Option<crate::model::QueryParameters>>(
                                )?;
                        }
                        __FieldTag::__assist_query_params => {
                            if !fields.insert(__FieldTag::__assist_query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assist_query_params",
                                ));
                            }
                            result.assist_query_params = map.next_value::<std::option::Option<crate::model::AssistQueryParameters>>()?
                                ;
                        }
                        __FieldTag::__cx_parameters => {
                            if !fields.insert(__FieldTag::__cx_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cx_parameters",
                                ));
                            }
                            result.cx_parameters =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeContentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.participant.is_empty() {
            state.serialize_entry("participant", &self.participant)?;
        }
        if let Some(value) = self.text_input() {
            state.serialize_entry("textInput", value)?;
        }
        if let Some(value) = self.audio_input() {
            state.serialize_entry("audioInput", value)?;
        }
        if let Some(value) = self.event_input() {
            state.serialize_entry("eventInput", value)?;
        }
        if let Some(value) = self.suggestion_input() {
            state.serialize_entry("suggestionInput", value)?;
        }
        if self.reply_audio_config.is_some() {
            state.serialize_entry("replyAudioConfig", &self.reply_audio_config)?;
        }
        if self.query_params.is_some() {
            state.serialize_entry("queryParams", &self.query_params)?;
        }
        if self.assist_query_params.is_some() {
            state.serialize_entry("assistQueryParams", &self.assist_query_params)?;
        }
        if self.cx_parameters.is_some() {
            state.serialize_entry("cxParameters", &self.cx_parameters)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AnalyzeContentRequest].
#[cfg(feature = "participants")]
pub mod analyze_content_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The input content.
    #[cfg(feature = "participants")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Input {
        /// The natural language text to be processed.
        TextInput(std::boxed::Box<crate::model::TextInput>),
        /// The natural language speech audio to be processed.
        AudioInput(std::boxed::Box<crate::model::AudioInput>),
        /// An input event to send to Dialogflow.
        EventInput(std::boxed::Box<crate::model::EventInput>),
        /// An input representing the selection of a suggestion.
        SuggestionInput(std::boxed::Box<crate::model::SuggestionInput>),
    }
}

/// The message in the response that indicates the parameters of DTMF.
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DtmfParameters {
    /// Indicates whether DTMF input can be handled in the next request.
    pub accepts_dtmf_input: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl DtmfParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [accepts_dtmf_input][crate::model::DtmfParameters::accepts_dtmf_input].
    pub fn set_accepts_dtmf_input<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.accepts_dtmf_input = v.into();
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for DtmfParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DtmfParameters"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DtmfParameters {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __accepts_dtmf_input,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DtmfParameters")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "acceptsDtmfInput" => Ok(__FieldTag::__accepts_dtmf_input),
                            "accepts_dtmf_input" => Ok(__FieldTag::__accepts_dtmf_input),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DtmfParameters;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DtmfParameters")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__accepts_dtmf_input => {
                            if !fields.insert(__FieldTag::__accepts_dtmf_input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accepts_dtmf_input",
                                ));
                            }
                            result.accepts_dtmf_input = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for DtmfParameters {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.accepts_dtmf_input) {
            state.serialize_entry("acceptsDtmfInput", &self.accepts_dtmf_input)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Participants.AnalyzeContent][google.cloud.dialogflow.v2.Participants.AnalyzeContent].
///
/// [google.cloud.dialogflow.v2.Participants.AnalyzeContent]: crate::client::Participants::analyze_content
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AnalyzeContentResponse {
    /// The output text content.
    /// This field is set if the automated agent responded with text to show to
    /// the user.
    pub reply_text: std::string::String,

    /// The audio data bytes encoded as specified in the request.
    /// This field is set if:
    ///
    /// - `reply_audio_config` was specified in the request, or
    /// - The automated agent responded with audio to play to the user. In such
    ///   case, `reply_audio.config` contains settings used to synthesize the
    ///   speech.
    ///
    /// In some scenarios, multiple output audio fields may be present in the
    /// response structure. In these cases, only the top-most-level audio output
    /// has content.
    pub reply_audio: std::option::Option<crate::model::OutputAudio>,

    /// Only set if a Dialogflow automated agent has responded.
    /// Note that in [AutomatedAgentReply.DetectIntentResponse][],
    /// [Sessions.DetectIntentResponse.output_audio][]
    /// and [Sessions.DetectIntentResponse.output_audio_config][]
    /// are always empty, use
    /// [reply_audio][google.cloud.dialogflow.v2.AnalyzeContentResponse.reply_audio]
    /// instead.
    ///
    /// [google.cloud.dialogflow.v2.AnalyzeContentResponse.reply_audio]: crate::model::AnalyzeContentResponse::reply_audio
    pub automated_agent_reply: std::option::Option<crate::model::AutomatedAgentReply>,

    /// Message analyzed by CCAI.
    pub message: std::option::Option<crate::model::Message>,

    /// The suggestions for most recent human agent. The order is the same as
    /// [HumanAgentAssistantConfig.SuggestionConfig.feature_configs][google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionConfig.feature_configs]
    /// of
    /// [HumanAgentAssistantConfig.human_agent_suggestion_config][google.cloud.dialogflow.v2.HumanAgentAssistantConfig.human_agent_suggestion_config].
    ///
    /// Note that any failure of Agent Assist features will not lead to the overall
    /// failure of an AnalyzeContent API call. Instead, the features will
    /// fail silently with the error field set in the corresponding
    /// SuggestionResult.
    ///
    /// [google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionConfig.feature_configs]: crate::model::human_agent_assistant_config::SuggestionConfig::feature_configs
    /// [google.cloud.dialogflow.v2.HumanAgentAssistantConfig.human_agent_suggestion_config]: crate::model::HumanAgentAssistantConfig::human_agent_suggestion_config
    pub human_agent_suggestion_results: std::vec::Vec<crate::model::SuggestionResult>,

    /// The suggestions for end user. The order is the same as
    /// [HumanAgentAssistantConfig.SuggestionConfig.feature_configs][google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionConfig.feature_configs]
    /// of
    /// [HumanAgentAssistantConfig.end_user_suggestion_config][google.cloud.dialogflow.v2.HumanAgentAssistantConfig.end_user_suggestion_config].
    ///
    /// Same as human_agent_suggestion_results, any failure of Agent Assist
    /// features will not lead to the overall failure of an AnalyzeContent API
    /// call. Instead, the features will fail silently with the error field set in
    /// the corresponding SuggestionResult.
    ///
    /// [google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionConfig.feature_configs]: crate::model::human_agent_assistant_config::SuggestionConfig::feature_configs
    /// [google.cloud.dialogflow.v2.HumanAgentAssistantConfig.end_user_suggestion_config]: crate::model::HumanAgentAssistantConfig::end_user_suggestion_config
    pub end_user_suggestion_results: std::vec::Vec<crate::model::SuggestionResult>,

    /// Indicates the parameters of DTMF.
    pub dtmf_parameters: std::option::Option<crate::model::DtmfParameters>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl AnalyzeContentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reply_text][crate::model::AnalyzeContentResponse::reply_text].
    pub fn set_reply_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reply_text = v.into();
        self
    }

    /// Sets the value of [reply_audio][crate::model::AnalyzeContentResponse::reply_audio].
    pub fn set_reply_audio<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudio>,
    {
        self.reply_audio = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reply_audio][crate::model::AnalyzeContentResponse::reply_audio].
    pub fn set_or_clear_reply_audio<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudio>,
    {
        self.reply_audio = v.map(|x| x.into());
        self
    }

    /// Sets the value of [automated_agent_reply][crate::model::AnalyzeContentResponse::automated_agent_reply].
    pub fn set_automated_agent_reply<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutomatedAgentReply>,
    {
        self.automated_agent_reply = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automated_agent_reply][crate::model::AnalyzeContentResponse::automated_agent_reply].
    pub fn set_or_clear_automated_agent_reply<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutomatedAgentReply>,
    {
        self.automated_agent_reply = v.map(|x| x.into());
        self
    }

    /// Sets the value of [message][crate::model::AnalyzeContentResponse::message].
    pub fn set_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Message>,
    {
        self.message = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [message][crate::model::AnalyzeContentResponse::message].
    pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Message>,
    {
        self.message = v.map(|x| x.into());
        self
    }

    /// Sets the value of [human_agent_suggestion_results][crate::model::AnalyzeContentResponse::human_agent_suggestion_results].
    pub fn set_human_agent_suggestion_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SuggestionResult>,
    {
        use std::iter::Iterator;
        self.human_agent_suggestion_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [end_user_suggestion_results][crate::model::AnalyzeContentResponse::end_user_suggestion_results].
    pub fn set_end_user_suggestion_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SuggestionResult>,
    {
        use std::iter::Iterator;
        self.end_user_suggestion_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dtmf_parameters][crate::model::AnalyzeContentResponse::dtmf_parameters].
    pub fn set_dtmf_parameters<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DtmfParameters>,
    {
        self.dtmf_parameters = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dtmf_parameters][crate::model::AnalyzeContentResponse::dtmf_parameters].
    pub fn set_or_clear_dtmf_parameters<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DtmfParameters>,
    {
        self.dtmf_parameters = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for AnalyzeContentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.AnalyzeContentResponse"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnalyzeContentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __reply_text,
            __reply_audio,
            __automated_agent_reply,
            __message,
            __human_agent_suggestion_results,
            __end_user_suggestion_results,
            __dtmf_parameters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnalyzeContentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "replyText" => Ok(__FieldTag::__reply_text),
                            "reply_text" => Ok(__FieldTag::__reply_text),
                            "replyAudio" => Ok(__FieldTag::__reply_audio),
                            "reply_audio" => Ok(__FieldTag::__reply_audio),
                            "automatedAgentReply" => Ok(__FieldTag::__automated_agent_reply),
                            "automated_agent_reply" => Ok(__FieldTag::__automated_agent_reply),
                            "message" => Ok(__FieldTag::__message),
                            "humanAgentSuggestionResults" => {
                                Ok(__FieldTag::__human_agent_suggestion_results)
                            }
                            "human_agent_suggestion_results" => {
                                Ok(__FieldTag::__human_agent_suggestion_results)
                            }
                            "endUserSuggestionResults" => {
                                Ok(__FieldTag::__end_user_suggestion_results)
                            }
                            "end_user_suggestion_results" => {
                                Ok(__FieldTag::__end_user_suggestion_results)
                            }
                            "dtmfParameters" => Ok(__FieldTag::__dtmf_parameters),
                            "dtmf_parameters" => Ok(__FieldTag::__dtmf_parameters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnalyzeContentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnalyzeContentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__reply_text => {
                            if !fields.insert(__FieldTag::__reply_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reply_text",
                                ));
                            }
                            result.reply_text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reply_audio => {
                            if !fields.insert(__FieldTag::__reply_audio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reply_audio",
                                ));
                            }
                            result.reply_audio =
                                map.next_value::<std::option::Option<crate::model::OutputAudio>>()?;
                        }
                        __FieldTag::__automated_agent_reply => {
                            if !fields.insert(__FieldTag::__automated_agent_reply) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automated_agent_reply",
                                ));
                            }
                            result.automated_agent_reply = map.next_value::<std::option::Option<crate::model::AutomatedAgentReply>>()?
                                ;
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message =
                                map.next_value::<std::option::Option<crate::model::Message>>()?;
                        }
                        __FieldTag::__human_agent_suggestion_results => {
                            if !fields.insert(__FieldTag::__human_agent_suggestion_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for human_agent_suggestion_results",
                                ));
                            }
                            result.human_agent_suggestion_results =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SuggestionResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__end_user_suggestion_results => {
                            if !fields.insert(__FieldTag::__end_user_suggestion_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_user_suggestion_results",
                                ));
                            }
                            result.end_user_suggestion_results =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SuggestionResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dtmf_parameters => {
                            if !fields.insert(__FieldTag::__dtmf_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dtmf_parameters",
                                ));
                            }
                            result.dtmf_parameters = map
                                .next_value::<std::option::Option<crate::model::DtmfParameters>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for AnalyzeContentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.reply_text.is_empty() {
            state.serialize_entry("replyText", &self.reply_text)?;
        }
        if self.reply_audio.is_some() {
            state.serialize_entry("replyAudio", &self.reply_audio)?;
        }
        if self.automated_agent_reply.is_some() {
            state.serialize_entry("automatedAgentReply", &self.automated_agent_reply)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.human_agent_suggestion_results.is_empty() {
            state.serialize_entry(
                "humanAgentSuggestionResults",
                &self.human_agent_suggestion_results,
            )?;
        }
        if !self.end_user_suggestion_results.is_empty() {
            state.serialize_entry(
                "endUserSuggestionResults",
                &self.end_user_suggestion_results,
            )?;
        }
        if self.dtmf_parameters.is_some() {
            state.serialize_entry("dtmfParameters", &self.dtmf_parameters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The top-level message sent by the client to the
/// [Participants.StreamingAnalyzeContent][google.cloud.dialogflow.v2.Participants.StreamingAnalyzeContent]
/// method.
///
/// Multiple request messages should be sent in order:
///
/// 1. The first message must contain
///    [participant][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.participant],
///    [config][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.config]
///    and optionally
///    [query_params][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.query_params].
///    If you want to receive an audio response, it should also contain
///    [reply_audio_config][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.reply_audio_config].
///    The message must not contain
///    [input][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.input].
///
/// 1. If
///    [config][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.config] in
///    the first message
///    was set to
///    [audio_config][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.audio_config],
///    all subsequent messages must contain
///    [input_audio][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.input_audio]
///    to continue with Speech recognition. However, note that:
///
///    * Dialogflow will bill you for the audio so far.
///    * Dialogflow discards all Speech recognition results in favor of the
///      text input.
/// 1. If
///    [StreamingAnalyzeContentRequest.config][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.config]
///    in the first message was set
///    to
///    [StreamingAnalyzeContentRequest.text_config][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.text_config],
///    then the second message must contain only
///    [input_text][google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.input_text].
///    Moreover, you must not send more than two messages.
///
///
/// After you sent all input, you must half-close or abort the request stream.
///
/// [google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.audio_config]: crate::model::StreamingAnalyzeContentRequest::config
/// [google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.config]: crate::model::StreamingAnalyzeContentRequest::config
/// [google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.input]: crate::model::StreamingAnalyzeContentRequest::input
/// [google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.input_audio]: crate::model::StreamingAnalyzeContentRequest::input
/// [google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.input_text]: crate::model::StreamingAnalyzeContentRequest::input
/// [google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.participant]: crate::model::StreamingAnalyzeContentRequest::participant
/// [google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.query_params]: crate::model::StreamingAnalyzeContentRequest::query_params
/// [google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.reply_audio_config]: crate::model::StreamingAnalyzeContentRequest::reply_audio_config
/// [google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.text_config]: crate::model::StreamingAnalyzeContentRequest::config
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingAnalyzeContentRequest {
    /// Required. The name of the participant this text comes from.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
    pub participant: std::string::String,

    /// Speech synthesis configuration.
    /// The speech synthesis settings for a virtual agent that may be configured
    /// for the associated conversation profile are not used when calling
    /// StreamingAnalyzeContent. If this configuration is not supplied, speech
    /// synthesis is disabled.
    pub reply_audio_config: std::option::Option<crate::model::OutputAudioConfig>,

    /// Parameters for a Dialogflow virtual-agent query.
    pub query_params: std::option::Option<crate::model::QueryParameters>,

    /// Parameters for a human assist query.
    pub assist_query_params: std::option::Option<crate::model::AssistQueryParameters>,

    /// Additional parameters to be put into Dialogflow CX session parameters. To
    /// remove a parameter from the session, clients should explicitly set the
    /// parameter value to null.
    ///
    /// Note: this field should only be used if you are connecting to a Dialogflow
    /// CX agent.
    pub cx_parameters: std::option::Option<wkt::Struct>,

    /// Optional. Enable full bidirectional streaming. You can keep streaming the
    /// audio until timeout, and there's no need to half close the stream to get
    /// the response.
    ///
    /// Restrictions:
    ///
    /// - Timeout: 3 mins.
    /// - Audio Encoding: only supports
    ///   [AudioEncoding.AUDIO_ENCODING_LINEAR_16][google.cloud.dialogflow.v2.AudioEncoding.AUDIO_ENCODING_LINEAR_16]
    ///   and
    ///   [AudioEncoding.AUDIO_ENCODING_MULAW][google.cloud.dialogflow.v2.AudioEncoding.AUDIO_ENCODING_MULAW]
    /// - Lifecycle: conversation should be in `Assist Stage`, go to
    ///   [Conversations.CreateConversation][google.cloud.dialogflow.v2.Conversations.CreateConversation]
    ///   for more information.
    ///
    /// InvalidArgument Error will be returned if the one of restriction checks
    /// failed.
    ///
    /// You can find more details in
    /// <https://cloud.google.com/agent-assist/docs/extended-streaming>
    ///
    /// [google.cloud.dialogflow.v2.AudioEncoding.AUDIO_ENCODING_LINEAR_16]: crate::model::AudioEncoding::Linear16
    /// [google.cloud.dialogflow.v2.AudioEncoding.AUDIO_ENCODING_MULAW]: crate::model::AudioEncoding::Mulaw
    /// [google.cloud.dialogflow.v2.Conversations.CreateConversation]: crate::client::Conversations::create_conversation
    pub enable_extended_streaming: bool,

    /// Optional. Enable partial responses from Dialogflow CX agent. If this flag
    /// is not enabled, response stream still contains only one final response even
    /// if some `Fulfillment`s in Dialogflow CX agent have been configured to
    /// return partial responses.
    pub enable_partial_automated_agent_reply: bool,

    /// If true, `StreamingAnalyzeContentResponse.debugging_info` will get
    /// populated.
    pub enable_debugging_info: bool,

    /// The input config.
    pub config: std::option::Option<crate::model::streaming_analyze_content_request::Config>,

    /// The input.
    pub input: std::option::Option<crate::model::streaming_analyze_content_request::Input>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl StreamingAnalyzeContentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [participant][crate::model::StreamingAnalyzeContentRequest::participant].
    pub fn set_participant<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.participant = v.into();
        self
    }

    /// Sets the value of [reply_audio_config][crate::model::StreamingAnalyzeContentRequest::reply_audio_config].
    pub fn set_reply_audio_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.reply_audio_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reply_audio_config][crate::model::StreamingAnalyzeContentRequest::reply_audio_config].
    pub fn set_or_clear_reply_audio_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.reply_audio_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query_params][crate::model::StreamingAnalyzeContentRequest::query_params].
    pub fn set_query_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameters>,
    {
        self.query_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_params][crate::model::StreamingAnalyzeContentRequest::query_params].
    pub fn set_or_clear_query_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameters>,
    {
        self.query_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [assist_query_params][crate::model::StreamingAnalyzeContentRequest::assist_query_params].
    pub fn set_assist_query_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AssistQueryParameters>,
    {
        self.assist_query_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [assist_query_params][crate::model::StreamingAnalyzeContentRequest::assist_query_params].
    pub fn set_or_clear_assist_query_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AssistQueryParameters>,
    {
        self.assist_query_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cx_parameters][crate::model::StreamingAnalyzeContentRequest::cx_parameters].
    pub fn set_cx_parameters<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.cx_parameters = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cx_parameters][crate::model::StreamingAnalyzeContentRequest::cx_parameters].
    pub fn set_or_clear_cx_parameters<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.cx_parameters = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_extended_streaming][crate::model::StreamingAnalyzeContentRequest::enable_extended_streaming].
    pub fn set_enable_extended_streaming<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_extended_streaming = v.into();
        self
    }

    /// Sets the value of [enable_partial_automated_agent_reply][crate::model::StreamingAnalyzeContentRequest::enable_partial_automated_agent_reply].
    pub fn set_enable_partial_automated_agent_reply<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_partial_automated_agent_reply = v.into();
        self
    }

    /// Sets the value of [enable_debugging_info][crate::model::StreamingAnalyzeContentRequest::enable_debugging_info].
    pub fn set_enable_debugging_info<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_debugging_info = v.into();
        self
    }

    /// Sets the value of [config][crate::model::StreamingAnalyzeContentRequest::config].
    ///
    /// Note that all the setters affecting `config` are mutually
    /// exclusive.
    pub fn set_config<
        T: std::convert::Into<
                std::option::Option<crate::model::streaming_analyze_content_request::Config>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// The value of [config][crate::model::StreamingAnalyzeContentRequest::config]
    /// if it holds a `AudioConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn audio_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InputAudioConfig>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::streaming_analyze_content_request::Config::AudioConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::StreamingAnalyzeContentRequest::config]
    /// to hold a `AudioConfig`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_audio_config<
        T: std::convert::Into<std::boxed::Box<crate::model::InputAudioConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(
            crate::model::streaming_analyze_content_request::Config::AudioConfig(v.into()),
        );
        self
    }

    /// The value of [config][crate::model::StreamingAnalyzeContentRequest::config]
    /// if it holds a `TextConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InputTextConfig>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::streaming_analyze_content_request::Config::TextConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::StreamingAnalyzeContentRequest::config]
    /// to hold a `TextConfig`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_text_config<
        T: std::convert::Into<std::boxed::Box<crate::model::InputTextConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config = std::option::Option::Some(
            crate::model::streaming_analyze_content_request::Config::TextConfig(v.into()),
        );
        self
    }

    /// Sets the value of [input][crate::model::StreamingAnalyzeContentRequest::input].
    ///
    /// Note that all the setters affecting `input` are mutually
    /// exclusive.
    pub fn set_input<
        T: std::convert::Into<
                std::option::Option<crate::model::streaming_analyze_content_request::Input>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input = v.into();
        self
    }

    /// The value of [input][crate::model::StreamingAnalyzeContentRequest::input]
    /// if it holds a `InputAudio`, `None` if the field is not set or
    /// holds a different branch.
    pub fn input_audio(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.input.as_ref().and_then(|v| match v {
            crate::model::streaming_analyze_content_request::Input::InputAudio(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input][crate::model::StreamingAnalyzeContentRequest::input]
    /// to hold a `InputAudio`.
    ///
    /// Note that all the setters affecting `input` are
    /// mutually exclusive.
    pub fn set_input_audio<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.input = std::option::Option::Some(
            crate::model::streaming_analyze_content_request::Input::InputAudio(v.into()),
        );
        self
    }

    /// The value of [input][crate::model::StreamingAnalyzeContentRequest::input]
    /// if it holds a `InputText`, `None` if the field is not set or
    /// holds a different branch.
    pub fn input_text(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.input.as_ref().and_then(|v| match v {
            crate::model::streaming_analyze_content_request::Input::InputText(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input][crate::model::StreamingAnalyzeContentRequest::input]
    /// to hold a `InputText`.
    ///
    /// Note that all the setters affecting `input` are
    /// mutually exclusive.
    pub fn set_input_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.input = std::option::Option::Some(
            crate::model::streaming_analyze_content_request::Input::InputText(v.into()),
        );
        self
    }

    /// The value of [input][crate::model::StreamingAnalyzeContentRequest::input]
    /// if it holds a `InputDtmf`, `None` if the field is not set or
    /// holds a different branch.
    pub fn input_dtmf(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::TelephonyDtmfEvents>> {
        #[allow(unreachable_patterns)]
        self.input.as_ref().and_then(|v| match v {
            crate::model::streaming_analyze_content_request::Input::InputDtmf(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input][crate::model::StreamingAnalyzeContentRequest::input]
    /// to hold a `InputDtmf`.
    ///
    /// Note that all the setters affecting `input` are
    /// mutually exclusive.
    pub fn set_input_dtmf<
        T: std::convert::Into<std::boxed::Box<crate::model::TelephonyDtmfEvents>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input = std::option::Option::Some(
            crate::model::streaming_analyze_content_request::Input::InputDtmf(v.into()),
        );
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for StreamingAnalyzeContentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingAnalyzeContentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __participant,
            __audio_config,
            __text_config,
            __reply_audio_config,
            __input_audio,
            __input_text,
            __input_dtmf,
            __query_params,
            __assist_query_params,
            __cx_parameters,
            __enable_extended_streaming,
            __enable_partial_automated_agent_reply,
            __enable_debugging_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingAnalyzeContentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "participant" => Ok(__FieldTag::__participant),
                            "audioConfig" => Ok(__FieldTag::__audio_config),
                            "audio_config" => Ok(__FieldTag::__audio_config),
                            "textConfig" => Ok(__FieldTag::__text_config),
                            "text_config" => Ok(__FieldTag::__text_config),
                            "replyAudioConfig" => Ok(__FieldTag::__reply_audio_config),
                            "reply_audio_config" => Ok(__FieldTag::__reply_audio_config),
                            "inputAudio" => Ok(__FieldTag::__input_audio),
                            "input_audio" => Ok(__FieldTag::__input_audio),
                            "inputText" => Ok(__FieldTag::__input_text),
                            "input_text" => Ok(__FieldTag::__input_text),
                            "inputDtmf" => Ok(__FieldTag::__input_dtmf),
                            "input_dtmf" => Ok(__FieldTag::__input_dtmf),
                            "queryParams" => Ok(__FieldTag::__query_params),
                            "query_params" => Ok(__FieldTag::__query_params),
                            "assistQueryParams" => Ok(__FieldTag::__assist_query_params),
                            "assist_query_params" => Ok(__FieldTag::__assist_query_params),
                            "cxParameters" => Ok(__FieldTag::__cx_parameters),
                            "cx_parameters" => Ok(__FieldTag::__cx_parameters),
                            "enableExtendedStreaming" => {
                                Ok(__FieldTag::__enable_extended_streaming)
                            }
                            "enable_extended_streaming" => {
                                Ok(__FieldTag::__enable_extended_streaming)
                            }
                            "enablePartialAutomatedAgentReply" => {
                                Ok(__FieldTag::__enable_partial_automated_agent_reply)
                            }
                            "enable_partial_automated_agent_reply" => {
                                Ok(__FieldTag::__enable_partial_automated_agent_reply)
                            }
                            "enableDebuggingInfo" => Ok(__FieldTag::__enable_debugging_info),
                            "enable_debugging_info" => Ok(__FieldTag::__enable_debugging_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingAnalyzeContentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingAnalyzeContentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__participant => {
                            if !fields.insert(__FieldTag::__participant) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for participant",
                                ));
                            }
                            result.participant = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__audio_config => {
                            if !fields.insert(__FieldTag::__audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_config",
                                ));
                            }
                            if result.config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `config`, a oneof with full ID .google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.audio_config, latest field was audioConfig",
                                ));
                            }
                            result.config = std::option::Option::Some(
                                crate::model::streaming_analyze_content_request::Config::AudioConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::InputAudioConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__text_config => {
                            if !fields.insert(__FieldTag::__text_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text_config",
                                ));
                            }
                            if result.config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `config`, a oneof with full ID .google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.text_config, latest field was textConfig",
                                ));
                            }
                            result.config = std::option::Option::Some(
                                crate::model::streaming_analyze_content_request::Config::TextConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InputTextConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__reply_audio_config => {
                            if !fields.insert(__FieldTag::__reply_audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reply_audio_config",
                                ));
                            }
                            result.reply_audio_config = map
                                .next_value::<std::option::Option<crate::model::OutputAudioConfig>>(
                                )?;
                        }
                        __FieldTag::__input_audio => {
                            if !fields.insert(__FieldTag::__input_audio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_audio",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.input_audio, latest field was inputAudio",
                                ));
                            }
                            result.input = std::option::Option::Some(
                                crate::model::streaming_analyze_content_request::Input::InputAudio(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__input_text => {
                            if !fields.insert(__FieldTag::__input_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_text",
                                ));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.input_text, latest field was inputText",
                                ));
                            }
                            result.input = std::option::Option::Some(
                                crate::model::streaming_analyze_content_request::Input::InputText(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__input_dtmf => {
                            if !fields.insert(__FieldTag::__input_dtmf) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_dtmf",
                                ));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.StreamingAnalyzeContentRequest.input_dtmf, latest field was inputDtmf",
                                ));
                            }
                            result.input = std::option::Option::Some(
                                crate::model::streaming_analyze_content_request::Input::InputDtmf(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TelephonyDtmfEvents>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__query_params => {
                            if !fields.insert(__FieldTag::__query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_params",
                                ));
                            }
                            result.query_params = map
                                .next_value::<std::option::Option<crate::model::QueryParameters>>(
                                )?;
                        }
                        __FieldTag::__assist_query_params => {
                            if !fields.insert(__FieldTag::__assist_query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assist_query_params",
                                ));
                            }
                            result.assist_query_params = map.next_value::<std::option::Option<crate::model::AssistQueryParameters>>()?
                                ;
                        }
                        __FieldTag::__cx_parameters => {
                            if !fields.insert(__FieldTag::__cx_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cx_parameters",
                                ));
                            }
                            result.cx_parameters =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__enable_extended_streaming => {
                            if !fields.insert(__FieldTag::__enable_extended_streaming) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_extended_streaming",
                                ));
                            }
                            result.enable_extended_streaming = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_partial_automated_agent_reply => {
                            if !fields.insert(__FieldTag::__enable_partial_automated_agent_reply) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_partial_automated_agent_reply",
                                ));
                            }
                            result.enable_partial_automated_agent_reply = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_debugging_info => {
                            if !fields.insert(__FieldTag::__enable_debugging_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_debugging_info",
                                ));
                            }
                            result.enable_debugging_info = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for StreamingAnalyzeContentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.participant.is_empty() {
            state.serialize_entry("participant", &self.participant)?;
        }
        if let Some(value) = self.audio_config() {
            state.serialize_entry("audioConfig", value)?;
        }
        if let Some(value) = self.text_config() {
            state.serialize_entry("textConfig", value)?;
        }
        if self.reply_audio_config.is_some() {
            state.serialize_entry("replyAudioConfig", &self.reply_audio_config)?;
        }
        if let Some(value) = self.input_audio() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("inputAudio", &__With(value))?;
        }
        if let Some(value) = self.input_text() {
            state.serialize_entry("inputText", value)?;
        }
        if let Some(value) = self.input_dtmf() {
            state.serialize_entry("inputDtmf", value)?;
        }
        if self.query_params.is_some() {
            state.serialize_entry("queryParams", &self.query_params)?;
        }
        if self.assist_query_params.is_some() {
            state.serialize_entry("assistQueryParams", &self.assist_query_params)?;
        }
        if self.cx_parameters.is_some() {
            state.serialize_entry("cxParameters", &self.cx_parameters)?;
        }
        if !wkt::internal::is_default(&self.enable_extended_streaming) {
            state.serialize_entry("enableExtendedStreaming", &self.enable_extended_streaming)?;
        }
        if !wkt::internal::is_default(&self.enable_partial_automated_agent_reply) {
            state.serialize_entry(
                "enablePartialAutomatedAgentReply",
                &self.enable_partial_automated_agent_reply,
            )?;
        }
        if !wkt::internal::is_default(&self.enable_debugging_info) {
            state.serialize_entry("enableDebuggingInfo", &self.enable_debugging_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StreamingAnalyzeContentRequest].
#[cfg(feature = "participants")]
pub mod streaming_analyze_content_request {
    #[allow(unused_imports)]
    use super::*;

    /// The input config.
    #[cfg(feature = "participants")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Config {
        /// Instructs the speech recognizer how to process the speech audio.
        AudioConfig(std::boxed::Box<crate::model::InputAudioConfig>),
        /// The natural language text to be processed.
        TextConfig(std::boxed::Box<crate::model::InputTextConfig>),
    }

    /// The input.
    #[cfg(feature = "participants")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Input {
        /// The input audio content to be recognized. Must be sent if `audio_config`
        /// is set in the first message. The complete audio over all streaming
        /// messages must not exceed 1 minute.
        InputAudio(::bytes::Bytes),
        /// The UTF-8 encoded natural language text to be processed. Must be sent if
        /// `text_config` is set in the first message. Text length must not exceed
        /// 256 bytes for virtual agent interactions. The `input_text` field can be
        /// only sent once, and would cancel the speech recognition if any ongoing.
        InputText(std::string::String),
        /// The DTMF digits used to invoke intent and fill in parameter value.
        ///
        /// This input is ignored if the previous response indicated that DTMF input
        /// is not accepted.
        InputDtmf(std::boxed::Box<crate::model::TelephonyDtmfEvents>),
    }
}

/// The top-level message returned from the `StreamingAnalyzeContent` method.
///
/// Multiple response messages can be returned in order:
///
/// 1. If the input was set to streaming audio, the first one or more messages
///    contain `recognition_result`. Each `recognition_result` represents a more
///    complete transcript of what the user said. The last `recognition_result`
///    has `is_final` set to `true`.
///
/// 1. In virtual agent stage: if `enable_partial_automated_agent_reply` is
///    true, the following N (currently 1 <= N <= 4) messages
///    contain `automated_agent_reply` and optionally `reply_audio`
///    returned by the virtual agent. The first (N-1)
///    `automated_agent_reply`s will have `automated_agent_reply_type` set to
///    `PARTIAL`. The last `automated_agent_reply` has
///    `automated_agent_reply_type` set to `FINAL`.
///    If `enable_partial_automated_agent_reply` is not enabled, response stream
///    only contains the final reply.
///
///    In human assist stage: the following N (N >= 1) messages contain
///    `human_agent_suggestion_results`, `end_user_suggestion_results` or
///    `message`.
///
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingAnalyzeContentResponse {
    /// The result of speech recognition.
    pub recognition_result: std::option::Option<crate::model::StreamingRecognitionResult>,

    /// The output text content.
    /// This field is set if an automated agent responded with a text for the user.
    pub reply_text: std::string::String,

    /// The audio data bytes encoded as specified in the request.
    /// This field is set if:
    ///
    /// - The `reply_audio_config` field is specified in the request.
    /// - The automated agent, which this output comes from, responded with audio.
    ///   In such case, the `reply_audio.config` field contains settings used to
    ///   synthesize the speech.
    ///
    /// In some scenarios, multiple output audio fields may be present in the
    /// response structure. In these cases, only the top-most-level audio output
    /// has content.
    pub reply_audio: std::option::Option<crate::model::OutputAudio>,

    /// Note that in [AutomatedAgentReply.DetectIntentResponse][],
    /// [Sessions.DetectIntentResponse.output_audio][]
    /// and [Sessions.DetectIntentResponse.output_audio_config][]
    /// are always empty, use
    /// [reply_audio][google.cloud.dialogflow.v2.StreamingAnalyzeContentResponse.reply_audio]
    /// instead.
    ///
    /// [google.cloud.dialogflow.v2.StreamingAnalyzeContentResponse.reply_audio]: crate::model::StreamingAnalyzeContentResponse::reply_audio
    pub automated_agent_reply: std::option::Option<crate::model::AutomatedAgentReply>,

    /// Message analyzed by CCAI.
    pub message: std::option::Option<crate::model::Message>,

    /// The suggestions for most recent human agent. The order is the same as
    /// [HumanAgentAssistantConfig.SuggestionConfig.feature_configs][google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionConfig.feature_configs]
    /// of
    /// [HumanAgentAssistantConfig.human_agent_suggestion_config][google.cloud.dialogflow.v2.HumanAgentAssistantConfig.human_agent_suggestion_config].
    ///
    /// [google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionConfig.feature_configs]: crate::model::human_agent_assistant_config::SuggestionConfig::feature_configs
    /// [google.cloud.dialogflow.v2.HumanAgentAssistantConfig.human_agent_suggestion_config]: crate::model::HumanAgentAssistantConfig::human_agent_suggestion_config
    pub human_agent_suggestion_results: std::vec::Vec<crate::model::SuggestionResult>,

    /// The suggestions for end user. The order is the same as
    /// [HumanAgentAssistantConfig.SuggestionConfig.feature_configs][google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionConfig.feature_configs]
    /// of
    /// [HumanAgentAssistantConfig.end_user_suggestion_config][google.cloud.dialogflow.v2.HumanAgentAssistantConfig.end_user_suggestion_config].
    ///
    /// [google.cloud.dialogflow.v2.HumanAgentAssistantConfig.SuggestionConfig.feature_configs]: crate::model::human_agent_assistant_config::SuggestionConfig::feature_configs
    /// [google.cloud.dialogflow.v2.HumanAgentAssistantConfig.end_user_suggestion_config]: crate::model::HumanAgentAssistantConfig::end_user_suggestion_config
    pub end_user_suggestion_results: std::vec::Vec<crate::model::SuggestionResult>,

    /// Indicates the parameters of DTMF.
    pub dtmf_parameters: std::option::Option<crate::model::DtmfParameters>,

    /// Debugging info that would get populated when
    /// `StreamingAnalyzeContentRequest.enable_debugging_info` is set to true.
    pub debugging_info: std::option::Option<crate::model::CloudConversationDebuggingInfo>,

    /// The name of the actual Cloud speech model used for speech recognition.
    pub speech_model: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl StreamingAnalyzeContentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recognition_result][crate::model::StreamingAnalyzeContentResponse::recognition_result].
    pub fn set_recognition_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StreamingRecognitionResult>,
    {
        self.recognition_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recognition_result][crate::model::StreamingAnalyzeContentResponse::recognition_result].
    pub fn set_or_clear_recognition_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StreamingRecognitionResult>,
    {
        self.recognition_result = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reply_text][crate::model::StreamingAnalyzeContentResponse::reply_text].
    pub fn set_reply_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reply_text = v.into();
        self
    }

    /// Sets the value of [reply_audio][crate::model::StreamingAnalyzeContentResponse::reply_audio].
    pub fn set_reply_audio<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudio>,
    {
        self.reply_audio = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reply_audio][crate::model::StreamingAnalyzeContentResponse::reply_audio].
    pub fn set_or_clear_reply_audio<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudio>,
    {
        self.reply_audio = v.map(|x| x.into());
        self
    }

    /// Sets the value of [automated_agent_reply][crate::model::StreamingAnalyzeContentResponse::automated_agent_reply].
    pub fn set_automated_agent_reply<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutomatedAgentReply>,
    {
        self.automated_agent_reply = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automated_agent_reply][crate::model::StreamingAnalyzeContentResponse::automated_agent_reply].
    pub fn set_or_clear_automated_agent_reply<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutomatedAgentReply>,
    {
        self.automated_agent_reply = v.map(|x| x.into());
        self
    }

    /// Sets the value of [message][crate::model::StreamingAnalyzeContentResponse::message].
    pub fn set_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Message>,
    {
        self.message = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [message][crate::model::StreamingAnalyzeContentResponse::message].
    pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Message>,
    {
        self.message = v.map(|x| x.into());
        self
    }

    /// Sets the value of [human_agent_suggestion_results][crate::model::StreamingAnalyzeContentResponse::human_agent_suggestion_results].
    pub fn set_human_agent_suggestion_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SuggestionResult>,
    {
        use std::iter::Iterator;
        self.human_agent_suggestion_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [end_user_suggestion_results][crate::model::StreamingAnalyzeContentResponse::end_user_suggestion_results].
    pub fn set_end_user_suggestion_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SuggestionResult>,
    {
        use std::iter::Iterator;
        self.end_user_suggestion_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dtmf_parameters][crate::model::StreamingAnalyzeContentResponse::dtmf_parameters].
    pub fn set_dtmf_parameters<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DtmfParameters>,
    {
        self.dtmf_parameters = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dtmf_parameters][crate::model::StreamingAnalyzeContentResponse::dtmf_parameters].
    pub fn set_or_clear_dtmf_parameters<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DtmfParameters>,
    {
        self.dtmf_parameters = v.map(|x| x.into());
        self
    }

    /// Sets the value of [debugging_info][crate::model::StreamingAnalyzeContentResponse::debugging_info].
    pub fn set_debugging_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudConversationDebuggingInfo>,
    {
        self.debugging_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [debugging_info][crate::model::StreamingAnalyzeContentResponse::debugging_info].
    pub fn set_or_clear_debugging_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudConversationDebuggingInfo>,
    {
        self.debugging_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [speech_model][crate::model::StreamingAnalyzeContentResponse::speech_model].
    pub fn set_speech_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.speech_model = v.into();
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for StreamingAnalyzeContentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.StreamingAnalyzeContentResponse"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingAnalyzeContentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __recognition_result,
            __reply_text,
            __reply_audio,
            __automated_agent_reply,
            __message,
            __human_agent_suggestion_results,
            __end_user_suggestion_results,
            __dtmf_parameters,
            __debugging_info,
            __speech_model,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingAnalyzeContentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "recognitionResult" => Ok(__FieldTag::__recognition_result),
                            "recognition_result" => Ok(__FieldTag::__recognition_result),
                            "replyText" => Ok(__FieldTag::__reply_text),
                            "reply_text" => Ok(__FieldTag::__reply_text),
                            "replyAudio" => Ok(__FieldTag::__reply_audio),
                            "reply_audio" => Ok(__FieldTag::__reply_audio),
                            "automatedAgentReply" => Ok(__FieldTag::__automated_agent_reply),
                            "automated_agent_reply" => Ok(__FieldTag::__automated_agent_reply),
                            "message" => Ok(__FieldTag::__message),
                            "humanAgentSuggestionResults" => {
                                Ok(__FieldTag::__human_agent_suggestion_results)
                            }
                            "human_agent_suggestion_results" => {
                                Ok(__FieldTag::__human_agent_suggestion_results)
                            }
                            "endUserSuggestionResults" => {
                                Ok(__FieldTag::__end_user_suggestion_results)
                            }
                            "end_user_suggestion_results" => {
                                Ok(__FieldTag::__end_user_suggestion_results)
                            }
                            "dtmfParameters" => Ok(__FieldTag::__dtmf_parameters),
                            "dtmf_parameters" => Ok(__FieldTag::__dtmf_parameters),
                            "debuggingInfo" => Ok(__FieldTag::__debugging_info),
                            "debugging_info" => Ok(__FieldTag::__debugging_info),
                            "speechModel" => Ok(__FieldTag::__speech_model),
                            "speech_model" => Ok(__FieldTag::__speech_model),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingAnalyzeContentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingAnalyzeContentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__recognition_result => {
                            if !fields.insert(__FieldTag::__recognition_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recognition_result",
                                ));
                            }
                            result.recognition_result = map.next_value::<std::option::Option<crate::model::StreamingRecognitionResult>>()?
                                ;
                        }
                        __FieldTag::__reply_text => {
                            if !fields.insert(__FieldTag::__reply_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reply_text",
                                ));
                            }
                            result.reply_text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reply_audio => {
                            if !fields.insert(__FieldTag::__reply_audio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reply_audio",
                                ));
                            }
                            result.reply_audio =
                                map.next_value::<std::option::Option<crate::model::OutputAudio>>()?;
                        }
                        __FieldTag::__automated_agent_reply => {
                            if !fields.insert(__FieldTag::__automated_agent_reply) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automated_agent_reply",
                                ));
                            }
                            result.automated_agent_reply = map.next_value::<std::option::Option<crate::model::AutomatedAgentReply>>()?
                                ;
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message =
                                map.next_value::<std::option::Option<crate::model::Message>>()?;
                        }
                        __FieldTag::__human_agent_suggestion_results => {
                            if !fields.insert(__FieldTag::__human_agent_suggestion_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for human_agent_suggestion_results",
                                ));
                            }
                            result.human_agent_suggestion_results =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SuggestionResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__end_user_suggestion_results => {
                            if !fields.insert(__FieldTag::__end_user_suggestion_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_user_suggestion_results",
                                ));
                            }
                            result.end_user_suggestion_results =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SuggestionResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dtmf_parameters => {
                            if !fields.insert(__FieldTag::__dtmf_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dtmf_parameters",
                                ));
                            }
                            result.dtmf_parameters = map
                                .next_value::<std::option::Option<crate::model::DtmfParameters>>(
                                )?;
                        }
                        __FieldTag::__debugging_info => {
                            if !fields.insert(__FieldTag::__debugging_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for debugging_info",
                                ));
                            }
                            result.debugging_info =
                                map.next_value::<std::option::Option<
                                    crate::model::CloudConversationDebuggingInfo,
                                >>()?;
                        }
                        __FieldTag::__speech_model => {
                            if !fields.insert(__FieldTag::__speech_model) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_model",
                                ));
                            }
                            result.speech_model = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for StreamingAnalyzeContentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.recognition_result.is_some() {
            state.serialize_entry("recognitionResult", &self.recognition_result)?;
        }
        if !self.reply_text.is_empty() {
            state.serialize_entry("replyText", &self.reply_text)?;
        }
        if self.reply_audio.is_some() {
            state.serialize_entry("replyAudio", &self.reply_audio)?;
        }
        if self.automated_agent_reply.is_some() {
            state.serialize_entry("automatedAgentReply", &self.automated_agent_reply)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self.human_agent_suggestion_results.is_empty() {
            state.serialize_entry(
                "humanAgentSuggestionResults",
                &self.human_agent_suggestion_results,
            )?;
        }
        if !self.end_user_suggestion_results.is_empty() {
            state.serialize_entry(
                "endUserSuggestionResults",
                &self.end_user_suggestion_results,
            )?;
        }
        if self.dtmf_parameters.is_some() {
            state.serialize_entry("dtmfParameters", &self.dtmf_parameters)?;
        }
        if self.debugging_info.is_some() {
            state.serialize_entry("debuggingInfo", &self.debugging_info)?;
        }
        if !self.speech_model.is_empty() {
            state.serialize_entry("speechModel", &self.speech_model)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Participants.SuggestArticles][google.cloud.dialogflow.v2.Participants.SuggestArticles].
///
/// [google.cloud.dialogflow.v2.Participants.SuggestArticles]: crate::client::Participants::suggest_articles
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SuggestArticlesRequest {
    /// Required. The name of the participant to fetch suggestion for.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
    pub parent: std::string::String,

    /// Optional. The name of the latest conversation message to compile suggestion
    /// for. If empty, it will be the latest message of the conversation.
    ///
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/messages/<Message ID>`.
    pub latest_message: std::string::String,

    /// Optional. Max number of messages prior to and including
    /// [latest_message][google.cloud.dialogflow.v2.SuggestArticlesRequest.latest_message]
    /// to use as context when compiling the suggestion. By default 20 and at
    /// most 50.
    ///
    /// [google.cloud.dialogflow.v2.SuggestArticlesRequest.latest_message]: crate::model::SuggestArticlesRequest::latest_message
    pub context_size: i32,

    /// Parameters for a human assist query.
    pub assist_query_params: std::option::Option<crate::model::AssistQueryParameters>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl SuggestArticlesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SuggestArticlesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [latest_message][crate::model::SuggestArticlesRequest::latest_message].
    pub fn set_latest_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.latest_message = v.into();
        self
    }

    /// Sets the value of [context_size][crate::model::SuggestArticlesRequest::context_size].
    pub fn set_context_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.context_size = v.into();
        self
    }

    /// Sets the value of [assist_query_params][crate::model::SuggestArticlesRequest::assist_query_params].
    pub fn set_assist_query_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AssistQueryParameters>,
    {
        self.assist_query_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [assist_query_params][crate::model::SuggestArticlesRequest::assist_query_params].
    pub fn set_or_clear_assist_query_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AssistQueryParameters>,
    {
        self.assist_query_params = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for SuggestArticlesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SuggestArticlesRequest"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SuggestArticlesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __latest_message,
            __context_size,
            __assist_query_params,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestArticlesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            "assistQueryParams" => Ok(__FieldTag::__assist_query_params),
                            "assist_query_params" => Ok(__FieldTag::__assist_query_params),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SuggestArticlesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestArticlesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_message",
                                ));
                            }
                            result.latest_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__assist_query_params => {
                            if !fields.insert(__FieldTag::__assist_query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assist_query_params",
                                ));
                            }
                            result.assist_query_params = map.next_value::<std::option::Option<crate::model::AssistQueryParameters>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for SuggestArticlesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if self.assist_query_params.is_some() {
            state.serialize_entry("assistQueryParams", &self.assist_query_params)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Participants.SuggestArticles][google.cloud.dialogflow.v2.Participants.SuggestArticles].
///
/// [google.cloud.dialogflow.v2.Participants.SuggestArticles]: crate::client::Participants::suggest_articles
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SuggestArticlesResponse {
    /// Articles ordered by score in descending order.
    pub article_answers: std::vec::Vec<crate::model::ArticleAnswer>,

    /// The name of the latest conversation message used to compile
    /// suggestion for.
    ///
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/messages/<Message ID>`.
    pub latest_message: std::string::String,

    /// Number of messages prior to and including
    /// [latest_message][google.cloud.dialogflow.v2.SuggestArticlesResponse.latest_message]
    /// to compile the suggestion. It may be smaller than the
    /// [SuggestArticlesRequest.context_size][google.cloud.dialogflow.v2.SuggestArticlesRequest.context_size]
    /// field in the request if there aren't that many messages in the
    /// conversation.
    ///
    /// [google.cloud.dialogflow.v2.SuggestArticlesRequest.context_size]: crate::model::SuggestArticlesRequest::context_size
    /// [google.cloud.dialogflow.v2.SuggestArticlesResponse.latest_message]: crate::model::SuggestArticlesResponse::latest_message
    pub context_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl SuggestArticlesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [article_answers][crate::model::SuggestArticlesResponse::article_answers].
    pub fn set_article_answers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ArticleAnswer>,
    {
        use std::iter::Iterator;
        self.article_answers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [latest_message][crate::model::SuggestArticlesResponse::latest_message].
    pub fn set_latest_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.latest_message = v.into();
        self
    }

    /// Sets the value of [context_size][crate::model::SuggestArticlesResponse::context_size].
    pub fn set_context_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.context_size = v.into();
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for SuggestArticlesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SuggestArticlesResponse"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SuggestArticlesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __article_answers,
            __latest_message,
            __context_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestArticlesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "articleAnswers" => Ok(__FieldTag::__article_answers),
                            "article_answers" => Ok(__FieldTag::__article_answers),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SuggestArticlesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestArticlesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__article_answers => {
                            if !fields.insert(__FieldTag::__article_answers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for article_answers",
                                ));
                            }
                            result.article_answers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ArticleAnswer>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_message",
                                ));
                            }
                            result.latest_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for SuggestArticlesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.article_answers.is_empty() {
            state.serialize_entry("articleAnswers", &self.article_answers)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Participants.SuggestFaqAnswers][google.cloud.dialogflow.v2.Participants.SuggestFaqAnswers].
///
/// [google.cloud.dialogflow.v2.Participants.SuggestFaqAnswers]: crate::client::Participants::suggest_faq_answers
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SuggestFaqAnswersRequest {
    /// Required. The name of the participant to fetch suggestion for.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
    pub parent: std::string::String,

    /// Optional. The name of the latest conversation message to compile suggestion
    /// for. If empty, it will be the latest message of the conversation.
    ///
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/messages/<Message ID>`.
    pub latest_message: std::string::String,

    /// Optional. Max number of messages prior to and including
    /// [latest_message] to use as context when compiling the
    /// suggestion. By default 20 and at most 50.
    pub context_size: i32,

    /// Parameters for a human assist query.
    pub assist_query_params: std::option::Option<crate::model::AssistQueryParameters>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl SuggestFaqAnswersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SuggestFaqAnswersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [latest_message][crate::model::SuggestFaqAnswersRequest::latest_message].
    pub fn set_latest_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.latest_message = v.into();
        self
    }

    /// Sets the value of [context_size][crate::model::SuggestFaqAnswersRequest::context_size].
    pub fn set_context_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.context_size = v.into();
        self
    }

    /// Sets the value of [assist_query_params][crate::model::SuggestFaqAnswersRequest::assist_query_params].
    pub fn set_assist_query_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AssistQueryParameters>,
    {
        self.assist_query_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [assist_query_params][crate::model::SuggestFaqAnswersRequest::assist_query_params].
    pub fn set_or_clear_assist_query_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AssistQueryParameters>,
    {
        self.assist_query_params = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for SuggestFaqAnswersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SuggestFaqAnswersRequest"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SuggestFaqAnswersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __latest_message,
            __context_size,
            __assist_query_params,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestFaqAnswersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            "assistQueryParams" => Ok(__FieldTag::__assist_query_params),
                            "assist_query_params" => Ok(__FieldTag::__assist_query_params),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SuggestFaqAnswersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestFaqAnswersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_message",
                                ));
                            }
                            result.latest_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__assist_query_params => {
                            if !fields.insert(__FieldTag::__assist_query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assist_query_params",
                                ));
                            }
                            result.assist_query_params = map.next_value::<std::option::Option<crate::model::AssistQueryParameters>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for SuggestFaqAnswersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if self.assist_query_params.is_some() {
            state.serialize_entry("assistQueryParams", &self.assist_query_params)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Participants.SuggestFaqAnswers][google.cloud.dialogflow.v2.Participants.SuggestFaqAnswers].
///
/// [google.cloud.dialogflow.v2.Participants.SuggestFaqAnswers]: crate::client::Participants::suggest_faq_answers
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SuggestFaqAnswersResponse {
    /// Answers extracted from FAQ documents.
    pub faq_answers: std::vec::Vec<crate::model::FaqAnswer>,

    /// The name of the latest conversation message used to compile
    /// suggestion for.
    ///
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/messages/<Message ID>`.
    pub latest_message: std::string::String,

    /// Number of messages prior to and including
    /// [latest_message][google.cloud.dialogflow.v2.SuggestFaqAnswersResponse.latest_message]
    /// to compile the suggestion. It may be smaller than the
    /// [SuggestFaqAnswersRequest.context_size][google.cloud.dialogflow.v2.SuggestFaqAnswersRequest.context_size]
    /// field in the request if there aren't that many messages in the
    /// conversation.
    ///
    /// [google.cloud.dialogflow.v2.SuggestFaqAnswersRequest.context_size]: crate::model::SuggestFaqAnswersRequest::context_size
    /// [google.cloud.dialogflow.v2.SuggestFaqAnswersResponse.latest_message]: crate::model::SuggestFaqAnswersResponse::latest_message
    pub context_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl SuggestFaqAnswersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [faq_answers][crate::model::SuggestFaqAnswersResponse::faq_answers].
    pub fn set_faq_answers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FaqAnswer>,
    {
        use std::iter::Iterator;
        self.faq_answers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [latest_message][crate::model::SuggestFaqAnswersResponse::latest_message].
    pub fn set_latest_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.latest_message = v.into();
        self
    }

    /// Sets the value of [context_size][crate::model::SuggestFaqAnswersResponse::context_size].
    pub fn set_context_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.context_size = v.into();
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for SuggestFaqAnswersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SuggestFaqAnswersResponse"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SuggestFaqAnswersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __faq_answers,
            __latest_message,
            __context_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestFaqAnswersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "faqAnswers" => Ok(__FieldTag::__faq_answers),
                            "faq_answers" => Ok(__FieldTag::__faq_answers),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SuggestFaqAnswersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestFaqAnswersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__faq_answers => {
                            if !fields.insert(__FieldTag::__faq_answers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for faq_answers",
                                ));
                            }
                            result.faq_answers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::FaqAnswer>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_message",
                                ));
                            }
                            result.latest_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for SuggestFaqAnswersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.faq_answers.is_empty() {
            state.serialize_entry("faqAnswers", &self.faq_answers)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Conversations.GenerateSuggestions][google.cloud.dialogflow.v2.Conversations.GenerateSuggestions].
///
/// [google.cloud.dialogflow.v2.Conversations.GenerateSuggestions]: crate::client::Conversations::generate_suggestions
#[cfg(any(feature = "conversations", feature = "participants",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateSuggestionsResponse {
    /// The answers generated for the conversation based on context.
    pub generator_suggestion_answers:
        std::vec::Vec<crate::model::generate_suggestions_response::GeneratorSuggestionAnswer>,

    /// The name of the latest conversation message used as context for
    /// compiling suggestion.
    ///
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/messages/<Message ID>`.
    pub latest_message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversations", feature = "participants",))]
impl GenerateSuggestionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generator_suggestion_answers][crate::model::GenerateSuggestionsResponse::generator_suggestion_answers].
    pub fn set_generator_suggestion_answers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::generate_suggestions_response::GeneratorSuggestionAnswer,
            >,
    {
        use std::iter::Iterator;
        self.generator_suggestion_answers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [latest_message][crate::model::GenerateSuggestionsResponse::latest_message].
    pub fn set_latest_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.latest_message = v.into();
        self
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
impl wkt::message::Message for GenerateSuggestionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GenerateSuggestionsResponse"
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateSuggestionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generator_suggestion_answers,
            __latest_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateSuggestionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generatorSuggestionAnswers" => {
                                Ok(__FieldTag::__generator_suggestion_answers)
                            }
                            "generator_suggestion_answers" => {
                                Ok(__FieldTag::__generator_suggestion_answers)
                            }
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateSuggestionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateSuggestionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generator_suggestion_answers => {
                            if !fields.insert(__FieldTag::__generator_suggestion_answers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generator_suggestion_answers",
                                ));
                            }
                            result.generator_suggestion_answers = map.next_value::<std::option::Option<std::vec::Vec<crate::model::generate_suggestions_response::GeneratorSuggestionAnswer>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_message",
                                ));
                            }
                            result.latest_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
#[doc(hidden)]
impl serde::ser::Serialize for GenerateSuggestionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.generator_suggestion_answers.is_empty() {
            state.serialize_entry(
                "generatorSuggestionAnswers",
                &self.generator_suggestion_answers,
            )?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GenerateSuggestionsResponse].
#[cfg(any(feature = "conversations", feature = "participants",))]
pub mod generate_suggestions_response {
    #[allow(unused_imports)]
    use super::*;

    /// A GeneratorSuggestion answer.
    #[cfg(any(feature = "conversations", feature = "participants",))]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GeneratorSuggestionAnswer {
        /// Suggestion details.
        pub generator_suggestion: std::option::Option<crate::model::GeneratorSuggestion>,

        /// The name of the generator used to generate this suggestion. Format:
        /// `projects/<Project ID>/locations/<Location ID>/generators/<Generator
        /// ID>`.
        pub source_generator: std::string::String,

        /// Answer record that uniquely identifies the suggestion. This can be used
        /// to provide suggestion feedback.
        pub answer_record: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "conversations", feature = "participants",))]
    impl GeneratorSuggestionAnswer {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [generator_suggestion][crate::model::generate_suggestions_response::GeneratorSuggestionAnswer::generator_suggestion].
        pub fn set_generator_suggestion<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::GeneratorSuggestion>,
        {
            self.generator_suggestion = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [generator_suggestion][crate::model::generate_suggestions_response::GeneratorSuggestionAnswer::generator_suggestion].
        pub fn set_or_clear_generator_suggestion<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::GeneratorSuggestion>,
        {
            self.generator_suggestion = v.map(|x| x.into());
            self
        }

        /// Sets the value of [source_generator][crate::model::generate_suggestions_response::GeneratorSuggestionAnswer::source_generator].
        pub fn set_source_generator<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_generator = v.into();
            self
        }

        /// Sets the value of [answer_record][crate::model::generate_suggestions_response::GeneratorSuggestionAnswer::answer_record].
        pub fn set_answer_record<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.answer_record = v.into();
            self
        }
    }

    #[cfg(any(feature = "conversations", feature = "participants",))]
    impl wkt::message::Message for GeneratorSuggestionAnswer {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.GenerateSuggestionsResponse.GeneratorSuggestionAnswer"
        }
    }

    #[cfg(any(feature = "conversations", feature = "participants",))]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GeneratorSuggestionAnswer {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __generator_suggestion,
                __source_generator,
                __answer_record,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GeneratorSuggestionAnswer")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "generatorSuggestion" => Ok(__FieldTag::__generator_suggestion),
                                "generator_suggestion" => Ok(__FieldTag::__generator_suggestion),
                                "sourceGenerator" => Ok(__FieldTag::__source_generator),
                                "source_generator" => Ok(__FieldTag::__source_generator),
                                "answerRecord" => Ok(__FieldTag::__answer_record),
                                "answer_record" => Ok(__FieldTag::__answer_record),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GeneratorSuggestionAnswer;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GeneratorSuggestionAnswer")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__generator_suggestion => {
                                if !fields.insert(__FieldTag::__generator_suggestion) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for generator_suggestion",
                                    ));
                                }
                                result.generator_suggestion = map.next_value::<std::option::Option<crate::model::GeneratorSuggestion>>()?
                                    ;
                            }
                            __FieldTag::__source_generator => {
                                if !fields.insert(__FieldTag::__source_generator) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source_generator",
                                    ));
                                }
                                result.source_generator = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__answer_record => {
                                if !fields.insert(__FieldTag::__answer_record) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for answer_record",
                                    ));
                                }
                                result.answer_record = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(any(feature = "conversations", feature = "participants",))]
    #[doc(hidden)]
    impl serde::ser::Serialize for GeneratorSuggestionAnswer {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.generator_suggestion.is_some() {
                state.serialize_entry("generatorSuggestion", &self.generator_suggestion)?;
            }
            if !self.source_generator.is_empty() {
                state.serialize_entry("sourceGenerator", &self.source_generator)?;
            }
            if !self.answer_record.is_empty() {
                state.serialize_entry("answerRecord", &self.answer_record)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// The request message for
/// [Participants.SuggestSmartReplies][google.cloud.dialogflow.v2.Participants.SuggestSmartReplies].
///
/// [google.cloud.dialogflow.v2.Participants.SuggestSmartReplies]: crate::client::Participants::suggest_smart_replies
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SuggestSmartRepliesRequest {
    /// Required. The name of the participant to fetch suggestion for.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
    pub parent: std::string::String,

    /// The current natural language text segment to compile suggestion
    /// for. This provides a way for user to get follow up smart reply suggestion
    /// after a smart reply selection, without sending a text message.
    pub current_text_input: std::option::Option<crate::model::TextInput>,

    /// The name of the latest conversation message to compile suggestion
    /// for. If empty, it will be the latest message of the conversation.
    ///
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/messages/<Message ID>`.
    pub latest_message: std::string::String,

    /// Max number of messages prior to and including
    /// [latest_message] to use as context when compiling the
    /// suggestion. By default 20 and at most 50.
    pub context_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl SuggestSmartRepliesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SuggestSmartRepliesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [current_text_input][crate::model::SuggestSmartRepliesRequest::current_text_input].
    pub fn set_current_text_input<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TextInput>,
    {
        self.current_text_input = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [current_text_input][crate::model::SuggestSmartRepliesRequest::current_text_input].
    pub fn set_or_clear_current_text_input<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TextInput>,
    {
        self.current_text_input = v.map(|x| x.into());
        self
    }

    /// Sets the value of [latest_message][crate::model::SuggestSmartRepliesRequest::latest_message].
    pub fn set_latest_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.latest_message = v.into();
        self
    }

    /// Sets the value of [context_size][crate::model::SuggestSmartRepliesRequest::context_size].
    pub fn set_context_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.context_size = v.into();
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for SuggestSmartRepliesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SuggestSmartRepliesRequest"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SuggestSmartRepliesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __current_text_input,
            __latest_message,
            __context_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestSmartRepliesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "currentTextInput" => Ok(__FieldTag::__current_text_input),
                            "current_text_input" => Ok(__FieldTag::__current_text_input),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SuggestSmartRepliesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestSmartRepliesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__current_text_input => {
                            if !fields.insert(__FieldTag::__current_text_input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_text_input",
                                ));
                            }
                            result.current_text_input =
                                map.next_value::<std::option::Option<crate::model::TextInput>>()?;
                        }
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_message",
                                ));
                            }
                            result.latest_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for SuggestSmartRepliesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.current_text_input.is_some() {
            state.serialize_entry("currentTextInput", &self.current_text_input)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Participants.SuggestSmartReplies][google.cloud.dialogflow.v2.Participants.SuggestSmartReplies].
///
/// [google.cloud.dialogflow.v2.Participants.SuggestSmartReplies]: crate::client::Participants::suggest_smart_replies
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SuggestSmartRepliesResponse {
    /// Output only. Multiple reply options provided by smart reply service. The
    /// order is based on the rank of the model prediction.
    /// The maximum number of the returned replies is set in SmartReplyConfig.
    pub smart_reply_answers: std::vec::Vec<crate::model::SmartReplyAnswer>,

    /// The name of the latest conversation message used to compile
    /// suggestion for.
    ///
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/messages/<Message ID>`.
    pub latest_message: std::string::String,

    /// Number of messages prior to and including
    /// [latest_message][google.cloud.dialogflow.v2.SuggestSmartRepliesResponse.latest_message]
    /// to compile the suggestion. It may be smaller than the
    /// [SuggestSmartRepliesRequest.context_size][google.cloud.dialogflow.v2.SuggestSmartRepliesRequest.context_size]
    /// field in the request if there aren't that many messages in the
    /// conversation.
    ///
    /// [google.cloud.dialogflow.v2.SuggestSmartRepliesRequest.context_size]: crate::model::SuggestSmartRepliesRequest::context_size
    /// [google.cloud.dialogflow.v2.SuggestSmartRepliesResponse.latest_message]: crate::model::SuggestSmartRepliesResponse::latest_message
    pub context_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl SuggestSmartRepliesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [smart_reply_answers][crate::model::SuggestSmartRepliesResponse::smart_reply_answers].
    pub fn set_smart_reply_answers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SmartReplyAnswer>,
    {
        use std::iter::Iterator;
        self.smart_reply_answers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [latest_message][crate::model::SuggestSmartRepliesResponse::latest_message].
    pub fn set_latest_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.latest_message = v.into();
        self
    }

    /// Sets the value of [context_size][crate::model::SuggestSmartRepliesResponse::context_size].
    pub fn set_context_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.context_size = v.into();
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for SuggestSmartRepliesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SuggestSmartRepliesResponse"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SuggestSmartRepliesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __smart_reply_answers,
            __latest_message,
            __context_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestSmartRepliesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "smartReplyAnswers" => Ok(__FieldTag::__smart_reply_answers),
                            "smart_reply_answers" => Ok(__FieldTag::__smart_reply_answers),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SuggestSmartRepliesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestSmartRepliesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__smart_reply_answers => {
                            if !fields.insert(__FieldTag::__smart_reply_answers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for smart_reply_answers",
                                ));
                            }
                            result.smart_reply_answers =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SmartReplyAnswer>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_message",
                                ));
                            }
                            result.latest_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for SuggestSmartRepliesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.smart_reply_answers.is_empty() {
            state.serialize_entry("smartReplyAnswers", &self.smart_reply_answers)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the natural language speech audio to be processed.
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AudioInput {
    /// Required. Instructs the speech recognizer how to process the speech audio.
    pub config: std::option::Option<crate::model::InputAudioConfig>,

    /// Required. The natural language speech audio to be processed.
    /// A single request can contain up to 2 minutes of speech audio data.
    /// The transcribed text cannot contain more than 256 bytes for virtual agent
    /// interactions.
    pub audio: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl AudioInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::AudioInput::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InputAudioConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::AudioInput::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InputAudioConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [audio][crate::model::AudioInput::audio].
    pub fn set_audio<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.audio = v.into();
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for AudioInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.AudioInput"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AudioInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __config,
            __audio,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AudioInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "config" => Ok(__FieldTag::__config),
                            "audio" => Ok(__FieldTag::__audio),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AudioInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AudioInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<crate::model::InputAudioConfig>>(
                                )?;
                        }
                        __FieldTag::__audio => {
                            if !fields.insert(__FieldTag::__audio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.audio = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for AudioInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if !self.audio.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("audio", &__With(&self.audio))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the natural language speech audio to be played to the end user.
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OutputAudio {
    /// Instructs the speech synthesizer how to generate the speech
    /// audio.
    pub config: std::option::Option<crate::model::OutputAudioConfig>,

    /// The natural language speech audio.
    pub audio: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl OutputAudio {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::OutputAudio::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::OutputAudio::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [audio][crate::model::OutputAudio::audio].
    pub fn set_audio<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.audio = v.into();
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for OutputAudio {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.OutputAudio"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OutputAudio {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __config,
            __audio,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OutputAudio")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "config" => Ok(__FieldTag::__config),
                            "audio" => Ok(__FieldTag::__audio),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OutputAudio;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OutputAudio")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<crate::model::OutputAudioConfig>>(
                                )?;
                        }
                        __FieldTag::__audio => {
                            if !fields.insert(__FieldTag::__audio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.audio = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for OutputAudio {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if !self.audio.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("audio", &__With(&self.audio))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a response from an automated agent.
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AutomatedAgentReply {
    /// Response of the Dialogflow
    /// [Sessions.DetectIntent][google.cloud.dialogflow.v2.Sessions.DetectIntent]
    /// call.
    ///
    /// [google.cloud.dialogflow.v2.Sessions.DetectIntent]: crate::client::Sessions::detect_intent
    pub detect_intent_response: std::option::Option<crate::model::DetectIntentResponse>,

    /// AutomatedAgentReply type.
    pub automated_agent_reply_type: crate::model::automated_agent_reply::AutomatedAgentReplyType,

    /// Indicates whether the partial automated agent reply is interruptible when a
    /// later reply message arrives. e.g. if the agent specified some music as
    /// partial response, it can be cancelled.
    pub allow_cancellation: bool,

    /// The unique identifier of the current Dialogflow CX conversation page.
    /// Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
    /// ID>/flows/<Flow ID>/pages/<Page ID>`.
    pub cx_current_page: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl AutomatedAgentReply {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [detect_intent_response][crate::model::AutomatedAgentReply::detect_intent_response].
    pub fn set_detect_intent_response<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DetectIntentResponse>,
    {
        self.detect_intent_response = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [detect_intent_response][crate::model::AutomatedAgentReply::detect_intent_response].
    pub fn set_or_clear_detect_intent_response<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DetectIntentResponse>,
    {
        self.detect_intent_response = v.map(|x| x.into());
        self
    }

    /// Sets the value of [automated_agent_reply_type][crate::model::AutomatedAgentReply::automated_agent_reply_type].
    pub fn set_automated_agent_reply_type<
        T: std::convert::Into<crate::model::automated_agent_reply::AutomatedAgentReplyType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automated_agent_reply_type = v.into();
        self
    }

    /// Sets the value of [allow_cancellation][crate::model::AutomatedAgentReply::allow_cancellation].
    pub fn set_allow_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_cancellation = v.into();
        self
    }

    /// Sets the value of [cx_current_page][crate::model::AutomatedAgentReply::cx_current_page].
    pub fn set_cx_current_page<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cx_current_page = v.into();
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for AutomatedAgentReply {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.AutomatedAgentReply"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutomatedAgentReply {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __detect_intent_response,
            __automated_agent_reply_type,
            __allow_cancellation,
            __cx_current_page,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutomatedAgentReply")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "detectIntentResponse" => Ok(__FieldTag::__detect_intent_response),
                            "detect_intent_response" => Ok(__FieldTag::__detect_intent_response),
                            "automatedAgentReplyType" => {
                                Ok(__FieldTag::__automated_agent_reply_type)
                            }
                            "automated_agent_reply_type" => {
                                Ok(__FieldTag::__automated_agent_reply_type)
                            }
                            "allowCancellation" => Ok(__FieldTag::__allow_cancellation),
                            "allow_cancellation" => Ok(__FieldTag::__allow_cancellation),
                            "cxCurrentPage" => Ok(__FieldTag::__cx_current_page),
                            "cx_current_page" => Ok(__FieldTag::__cx_current_page),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutomatedAgentReply;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutomatedAgentReply")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__detect_intent_response => {
                            if !fields.insert(__FieldTag::__detect_intent_response) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detect_intent_response",
                                ));
                            }
                            result.detect_intent_response = map.next_value::<std::option::Option<crate::model::DetectIntentResponse>>()?
                                ;
                        }
                        __FieldTag::__automated_agent_reply_type => {
                            if !fields.insert(__FieldTag::__automated_agent_reply_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automated_agent_reply_type",
                                ));
                            }
                            result.automated_agent_reply_type = map
                                .next_value::<std::option::Option<
                                    crate::model::automated_agent_reply::AutomatedAgentReplyType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_cancellation => {
                            if !fields.insert(__FieldTag::__allow_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_cancellation",
                                ));
                            }
                            result.allow_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cx_current_page => {
                            if !fields.insert(__FieldTag::__cx_current_page) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cx_current_page",
                                ));
                            }
                            result.cx_current_page = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for AutomatedAgentReply {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.detect_intent_response.is_some() {
            state.serialize_entry("detectIntentResponse", &self.detect_intent_response)?;
        }
        if !wkt::internal::is_default(&self.automated_agent_reply_type) {
            state.serialize_entry("automatedAgentReplyType", &self.automated_agent_reply_type)?;
        }
        if !wkt::internal::is_default(&self.allow_cancellation) {
            state.serialize_entry("allowCancellation", &self.allow_cancellation)?;
        }
        if !self.cx_current_page.is_empty() {
            state.serialize_entry("cxCurrentPage", &self.cx_current_page)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AutomatedAgentReply].
#[cfg(feature = "participants")]
pub mod automated_agent_reply {
    #[allow(unused_imports)]
    use super::*;

    /// Represents different automated agent reply types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "participants")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AutomatedAgentReplyType {
        /// Not specified. This should never happen.
        Unspecified,
        /// Partial reply. e.g. Aggregated responses in a `Fulfillment` that enables
        /// `return_partial_response` can be returned as partial reply.
        /// WARNING: partial reply is not eligible for barge-in.
        Partial,
        /// Final reply.
        Final,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AutomatedAgentReplyType::value] or
        /// [AutomatedAgentReplyType::name].
        UnknownValue(automated_agent_reply_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "participants")]
    pub mod automated_agent_reply_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "participants")]
    impl AutomatedAgentReplyType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Partial => std::option::Option::Some(1),
                Self::Final => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("AUTOMATED_AGENT_REPLY_TYPE_UNSPECIFIED")
                }
                Self::Partial => std::option::Option::Some("PARTIAL"),
                Self::Final => std::option::Option::Some("FINAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "participants")]
    impl std::default::Default for AutomatedAgentReplyType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "participants")]
    impl std::fmt::Display for AutomatedAgentReplyType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "participants")]
    impl std::convert::From<i32> for AutomatedAgentReplyType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Partial,
                2 => Self::Final,
                _ => Self::UnknownValue(automated_agent_reply_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "participants")]
    impl std::convert::From<&str> for AutomatedAgentReplyType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AUTOMATED_AGENT_REPLY_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PARTIAL" => Self::Partial,
                "FINAL" => Self::Final,
                _ => Self::UnknownValue(automated_agent_reply_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "participants")]
    impl serde::ser::Serialize for AutomatedAgentReplyType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Partial => serializer.serialize_i32(1),
                Self::Final => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "participants")]
    impl<'de> serde::de::Deserialize<'de> for AutomatedAgentReplyType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<AutomatedAgentReplyType>::new(
                    ".google.cloud.dialogflow.v2.AutomatedAgentReply.AutomatedAgentReplyType",
                ),
            )
        }
    }
}

/// Represents article answer.
#[cfg(any(feature = "answer-records", feature = "participants",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ArticleAnswer {
    /// The article title.
    pub title: std::string::String,

    /// The article URI.
    pub uri: std::string::String,

    /// Article snippets.
    pub snippets: std::vec::Vec<std::string::String>,

    /// Article match confidence.
    /// The system's confidence score that this article is a good match for this
    /// conversation, as a value from 0.0 (completely uncertain) to 1.0
    /// (completely certain).
    pub confidence: f32,

    /// A map that contains metadata about the answer and the
    /// document from which it originates.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The name of answer record, in the format of
    /// "projects/\<Project ID\>/locations/\<Location ID\>/answerRecords/\<Answer Record
    /// ID\>"
    pub answer_record: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "answer-records", feature = "participants",))]
impl ArticleAnswer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [title][crate::model::ArticleAnswer::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::ArticleAnswer::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [snippets][crate::model::ArticleAnswer::snippets].
    pub fn set_snippets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.snippets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [confidence][crate::model::ArticleAnswer::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ArticleAnswer::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [answer_record][crate::model::ArticleAnswer::answer_record].
    pub fn set_answer_record<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.answer_record = v.into();
        self
    }
}

#[cfg(any(feature = "answer-records", feature = "participants",))]
impl wkt::message::Message for ArticleAnswer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ArticleAnswer"
    }
}

#[cfg(any(feature = "answer-records", feature = "participants",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ArticleAnswer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __title,
            __uri,
            __snippets,
            __confidence,
            __metadata,
            __answer_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ArticleAnswer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "title" => Ok(__FieldTag::__title),
                            "uri" => Ok(__FieldTag::__uri),
                            "snippets" => Ok(__FieldTag::__snippets),
                            "confidence" => Ok(__FieldTag::__confidence),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ArticleAnswer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ArticleAnswer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for title",
                                ));
                            }
                            result.title = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__snippets => {
                            if !fields.insert(__FieldTag::__snippets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snippets",
                                ));
                            }
                            result.snippets = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_record",
                                ));
                            }
                            result.answer_record = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "answer-records", feature = "participants",))]
#[doc(hidden)]
impl serde::ser::Serialize for ArticleAnswer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !self.snippets.is_empty() {
            state.serialize_entry("snippets", &self.snippets)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.answer_record.is_empty() {
            state.serialize_entry("answerRecord", &self.answer_record)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents answer from "frequently asked questions".
#[cfg(any(feature = "answer-records", feature = "participants",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FaqAnswer {
    /// The piece of text from the `source` knowledge base document.
    pub answer: std::string::String,

    /// The system's confidence score that this Knowledge answer is a good match
    /// for this conversational query, range from 0.0 (completely uncertain)
    /// to 1.0 (completely certain).
    pub confidence: f32,

    /// The corresponding FAQ question.
    pub question: std::string::String,

    /// Indicates which Knowledge Document this answer was extracted
    /// from.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/agent/knowledgeBases/<Knowledge Base ID>/documents/<Document ID>`.
    pub source: std::string::String,

    /// A map that contains metadata about the answer and the
    /// document from which it originates.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The name of answer record, in the format of
    /// "projects/\<Project ID\>/locations/\<Location ID\>/answerRecords/\<Answer Record
    /// ID\>"
    pub answer_record: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "answer-records", feature = "participants",))]
impl FaqAnswer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [answer][crate::model::FaqAnswer::answer].
    pub fn set_answer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.answer = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::FaqAnswer::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [question][crate::model::FaqAnswer::question].
    pub fn set_question<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.question = v.into();
        self
    }

    /// Sets the value of [source][crate::model::FaqAnswer::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::FaqAnswer::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [answer_record][crate::model::FaqAnswer::answer_record].
    pub fn set_answer_record<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.answer_record = v.into();
        self
    }
}

#[cfg(any(feature = "answer-records", feature = "participants",))]
impl wkt::message::Message for FaqAnswer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.FaqAnswer"
    }
}

#[cfg(any(feature = "answer-records", feature = "participants",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FaqAnswer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answer,
            __confidence,
            __question,
            __source,
            __metadata,
            __answer_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FaqAnswer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answer" => Ok(__FieldTag::__answer),
                            "confidence" => Ok(__FieldTag::__confidence),
                            "question" => Ok(__FieldTag::__question),
                            "source" => Ok(__FieldTag::__source),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FaqAnswer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FaqAnswer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answer => {
                            if !fields.insert(__FieldTag::__answer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer",
                                ));
                            }
                            result.answer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__question => {
                            if !fields.insert(__FieldTag::__question) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for question",
                                ));
                            }
                            result.question = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_record",
                                ));
                            }
                            result.answer_record = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "answer-records", feature = "participants",))]
#[doc(hidden)]
impl serde::ser::Serialize for FaqAnswer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.answer.is_empty() {
            state.serialize_entry("answer", &self.answer)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self.question.is_empty() {
            state.serialize_entry("question", &self.question)?;
        }
        if !self.source.is_empty() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.answer_record.is_empty() {
            state.serialize_entry("answerRecord", &self.answer_record)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a smart reply answer.
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SmartReplyAnswer {
    /// The content of the reply.
    pub reply: std::string::String,

    /// Smart reply confidence.
    /// The system's confidence score that this reply is a good match for
    /// this conversation, as a value from 0.0 (completely uncertain) to 1.0
    /// (completely certain).
    pub confidence: f32,

    /// The name of answer record, in the format of
    /// "projects/\<Project ID\>/locations/\<Location ID\>/answerRecords/\<Answer Record
    /// ID\>"
    pub answer_record: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl SmartReplyAnswer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [reply][crate::model::SmartReplyAnswer::reply].
    pub fn set_reply<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reply = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::SmartReplyAnswer::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [answer_record][crate::model::SmartReplyAnswer::answer_record].
    pub fn set_answer_record<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.answer_record = v.into();
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for SmartReplyAnswer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SmartReplyAnswer"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SmartReplyAnswer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __reply,
            __confidence,
            __answer_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SmartReplyAnswer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "reply" => Ok(__FieldTag::__reply),
                            "confidence" => Ok(__FieldTag::__confidence),
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SmartReplyAnswer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SmartReplyAnswer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__reply => {
                            if !fields.insert(__FieldTag::__reply) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reply",
                                ));
                            }
                            result.reply = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_record",
                                ));
                            }
                            result.answer_record = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for SmartReplyAnswer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.reply.is_empty() {
            state.serialize_entry("reply", &self.reply)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self.answer_record.is_empty() {
            state.serialize_entry("answerRecord", &self.answer_record)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents an intent suggestion.
#[cfg(feature = "answer-records")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct IntentSuggestion {
    /// The display name of the intent.
    pub display_name: std::string::String,

    /// Human readable description for better understanding an intent like its
    /// scope, content, result etc. Maximum character limit: 140 characters.
    pub description: std::string::String,

    /// The name of the intent.
    pub intent: std::option::Option<crate::model::intent_suggestion::Intent>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "answer-records")]
impl IntentSuggestion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::IntentSuggestion::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::IntentSuggestion::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [intent][crate::model::IntentSuggestion::intent].
    ///
    /// Note that all the setters affecting `intent` are mutually
    /// exclusive.
    pub fn set_intent<
        T: std::convert::Into<std::option::Option<crate::model::intent_suggestion::Intent>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.intent = v.into();
        self
    }

    /// The value of [intent][crate::model::IntentSuggestion::intent]
    /// if it holds a `IntentV2`, `None` if the field is not set or
    /// holds a different branch.
    pub fn intent_v2(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.intent.as_ref().and_then(|v| match v {
            crate::model::intent_suggestion::Intent::IntentV2(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [intent][crate::model::IntentSuggestion::intent]
    /// to hold a `IntentV2`.
    ///
    /// Note that all the setters affecting `intent` are
    /// mutually exclusive.
    pub fn set_intent_v2<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.intent =
            std::option::Option::Some(crate::model::intent_suggestion::Intent::IntentV2(v.into()));
        self
    }
}

#[cfg(feature = "answer-records")]
impl wkt::message::Message for IntentSuggestion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.IntentSuggestion"
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IntentSuggestion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __intent_v2,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IntentSuggestion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "intentV2" => Ok(__FieldTag::__intent_v2),
                            "intent_v2" => Ok(__FieldTag::__intent_v2),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IntentSuggestion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IntentSuggestion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__intent_v2 => {
                            if !fields.insert(__FieldTag::__intent_v2) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent_v2",
                                ));
                            }
                            if result.intent.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `intent`, a oneof with full ID .google.cloud.dialogflow.v2.IntentSuggestion.intent_v2, latest field was intentV2",
                                ));
                            }
                            result.intent = std::option::Option::Some(
                                crate::model::intent_suggestion::Intent::IntentV2(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for IntentSuggestion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if let Some(value) = self.intent_v2() {
            state.serialize_entry("intentV2", value)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [IntentSuggestion].
#[cfg(feature = "answer-records")]
pub mod intent_suggestion {
    #[allow(unused_imports)]
    use super::*;

    /// The name of the intent.
    #[cfg(feature = "answer-records")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Intent {
        /// The unique identifier of this
        /// [intent][google.cloud.dialogflow.v2.Intent]. Format: `projects/<Project
        /// ID>/locations/<Location ID>/agent/intents/<Intent ID>`.
        ///
        /// [google.cloud.dialogflow.v2.Intent]: crate::model::Intent
        IntentV2(std::string::String),
    }
}

/// Represents a Dialogflow assist answer.
#[cfg(feature = "answer-records")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DialogflowAssistAnswer {
    /// The name of answer record, in the format of
    /// "projects/\<Project ID\>/locations/\<Location ID\>/answerRecords/\<Answer Record
    /// ID\>"
    pub answer_record: std::string::String,

    /// Result from DetectIntent for one matched intent.
    pub result: std::option::Option<crate::model::dialogflow_assist_answer::Result>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "answer-records")]
impl DialogflowAssistAnswer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [answer_record][crate::model::DialogflowAssistAnswer::answer_record].
    pub fn set_answer_record<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.answer_record = v.into();
        self
    }

    /// Sets the value of [result][crate::model::DialogflowAssistAnswer::result].
    ///
    /// Note that all the setters affecting `result` are mutually
    /// exclusive.
    pub fn set_result<
        T: std::convert::Into<std::option::Option<crate::model::dialogflow_assist_answer::Result>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// The value of [result][crate::model::DialogflowAssistAnswer::result]
    /// if it holds a `QueryResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn query_result(&self) -> std::option::Option<&std::boxed::Box<crate::model::QueryResult>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::dialogflow_assist_answer::Result::QueryResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::DialogflowAssistAnswer::result]
    /// to hold a `QueryResult`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_query_result<T: std::convert::Into<std::boxed::Box<crate::model::QueryResult>>>(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::dialogflow_assist_answer::Result::QueryResult(v.into()),
        );
        self
    }

    /// The value of [result][crate::model::DialogflowAssistAnswer::result]
    /// if it holds a `IntentSuggestion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn intent_suggestion(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::IntentSuggestion>> {
        #[allow(unreachable_patterns)]
        self.result.as_ref().and_then(|v| match v {
            crate::model::dialogflow_assist_answer::Result::IntentSuggestion(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [result][crate::model::DialogflowAssistAnswer::result]
    /// to hold a `IntentSuggestion`.
    ///
    /// Note that all the setters affecting `result` are
    /// mutually exclusive.
    pub fn set_intent_suggestion<
        T: std::convert::Into<std::boxed::Box<crate::model::IntentSuggestion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.result = std::option::Option::Some(
            crate::model::dialogflow_assist_answer::Result::IntentSuggestion(v.into()),
        );
        self
    }
}

#[cfg(feature = "answer-records")]
impl wkt::message::Message for DialogflowAssistAnswer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DialogflowAssistAnswer"
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DialogflowAssistAnswer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query_result,
            __intent_suggestion,
            __answer_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DialogflowAssistAnswer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queryResult" => Ok(__FieldTag::__query_result),
                            "query_result" => Ok(__FieldTag::__query_result),
                            "intentSuggestion" => Ok(__FieldTag::__intent_suggestion),
                            "intent_suggestion" => Ok(__FieldTag::__intent_suggestion),
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DialogflowAssistAnswer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DialogflowAssistAnswer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query_result => {
                            if !fields.insert(__FieldTag::__query_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_result",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dialogflow.v2.DialogflowAssistAnswer.query_result, latest field was queryResult",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::dialogflow_assist_answer::Result::QueryResult(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::QueryResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__intent_suggestion => {
                            if !fields.insert(__FieldTag::__intent_suggestion) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent_suggestion",
                                ));
                            }
                            if result.result.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `result`, a oneof with full ID .google.cloud.dialogflow.v2.DialogflowAssistAnswer.intent_suggestion, latest field was intentSuggestion",
                                ));
                            }
                            result.result = std::option::Option::Some(
                                crate::model::dialogflow_assist_answer::Result::IntentSuggestion(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::IntentSuggestion>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_record",
                                ));
                            }
                            result.answer_record = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "answer-records")]
#[doc(hidden)]
impl serde::ser::Serialize for DialogflowAssistAnswer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.query_result() {
            state.serialize_entry("queryResult", value)?;
        }
        if let Some(value) = self.intent_suggestion() {
            state.serialize_entry("intentSuggestion", value)?;
        }
        if !self.answer_record.is_empty() {
            state.serialize_entry("answerRecord", &self.answer_record)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DialogflowAssistAnswer].
#[cfg(feature = "answer-records")]
pub mod dialogflow_assist_answer {
    #[allow(unused_imports)]
    use super::*;

    /// Result from DetectIntent for one matched intent.
    #[cfg(feature = "answer-records")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        /// Result from v2 agent.
        QueryResult(std::boxed::Box<crate::model::QueryResult>),
        /// An intent suggestion generated from conversation.
        IntentSuggestion(std::boxed::Box<crate::model::IntentSuggestion>),
    }
}

/// One response of different type of suggestion response which is used in
/// the response of
/// [Participants.AnalyzeContent][google.cloud.dialogflow.v2.Participants.AnalyzeContent]
/// and
/// [Participants.AnalyzeContent][google.cloud.dialogflow.v2.Participants.AnalyzeContent],
/// as well as
/// [HumanAgentAssistantEvent][google.cloud.dialogflow.v2.HumanAgentAssistantEvent].
///
/// [google.cloud.dialogflow.v2.HumanAgentAssistantEvent]: crate::model::HumanAgentAssistantEvent
/// [google.cloud.dialogflow.v2.Participants.AnalyzeContent]: crate::client::Participants::analyze_content
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SuggestionResult {
    /// Different type of suggestion response.
    pub suggestion_response:
        std::option::Option<crate::model::suggestion_result::SuggestionResponse>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl SuggestionResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [suggestion_response][crate::model::SuggestionResult::suggestion_response].
    ///
    /// Note that all the setters affecting `suggestion_response` are mutually
    /// exclusive.
    pub fn set_suggestion_response<
        T: std::convert::Into<
                std::option::Option<crate::model::suggestion_result::SuggestionResponse>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.suggestion_response = v.into();
        self
    }

    /// The value of [suggestion_response][crate::model::SuggestionResult::suggestion_response]
    /// if it holds a `Error`, `None` if the field is not set or
    /// holds a different branch.
    pub fn error(&self) -> std::option::Option<&std::boxed::Box<rpc::model::Status>> {
        #[allow(unreachable_patterns)]
        self.suggestion_response.as_ref().and_then(|v| match v {
            crate::model::suggestion_result::SuggestionResponse::Error(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [suggestion_response][crate::model::SuggestionResult::suggestion_response]
    /// to hold a `Error`.
    ///
    /// Note that all the setters affecting `suggestion_response` are
    /// mutually exclusive.
    pub fn set_error<T: std::convert::Into<std::boxed::Box<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.suggestion_response = std::option::Option::Some(
            crate::model::suggestion_result::SuggestionResponse::Error(v.into()),
        );
        self
    }

    /// The value of [suggestion_response][crate::model::SuggestionResult::suggestion_response]
    /// if it holds a `SuggestArticlesResponse`, `None` if the field is not set or
    /// holds a different branch.
    pub fn suggest_articles_response(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SuggestArticlesResponse>> {
        #[allow(unreachable_patterns)]
        self.suggestion_response.as_ref().and_then(|v| match v {
            crate::model::suggestion_result::SuggestionResponse::SuggestArticlesResponse(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [suggestion_response][crate::model::SuggestionResult::suggestion_response]
    /// to hold a `SuggestArticlesResponse`.
    ///
    /// Note that all the setters affecting `suggestion_response` are
    /// mutually exclusive.
    pub fn set_suggest_articles_response<
        T: std::convert::Into<std::boxed::Box<crate::model::SuggestArticlesResponse>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.suggestion_response = std::option::Option::Some(
            crate::model::suggestion_result::SuggestionResponse::SuggestArticlesResponse(v.into()),
        );
        self
    }

    /// The value of [suggestion_response][crate::model::SuggestionResult::suggestion_response]
    /// if it holds a `SuggestKnowledgeAssistResponse`, `None` if the field is not set or
    /// holds a different branch.
    pub fn suggest_knowledge_assist_response(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SuggestKnowledgeAssistResponse>> {
        #[allow(unreachable_patterns)]
        self.suggestion_response.as_ref().and_then(|v| match v {
            crate::model::suggestion_result::SuggestionResponse::SuggestKnowledgeAssistResponse(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [suggestion_response][crate::model::SuggestionResult::suggestion_response]
    /// to hold a `SuggestKnowledgeAssistResponse`.
    ///
    /// Note that all the setters affecting `suggestion_response` are
    /// mutually exclusive.
    pub fn set_suggest_knowledge_assist_response<
        T: std::convert::Into<std::boxed::Box<crate::model::SuggestKnowledgeAssistResponse>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.suggestion_response = std::option::Option::Some(
            crate::model::suggestion_result::SuggestionResponse::SuggestKnowledgeAssistResponse(
                v.into(),
            ),
        );
        self
    }

    /// The value of [suggestion_response][crate::model::SuggestionResult::suggestion_response]
    /// if it holds a `SuggestFaqAnswersResponse`, `None` if the field is not set or
    /// holds a different branch.
    pub fn suggest_faq_answers_response(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SuggestFaqAnswersResponse>> {
        #[allow(unreachable_patterns)]
        self.suggestion_response.as_ref().and_then(|v| match v {
            crate::model::suggestion_result::SuggestionResponse::SuggestFaqAnswersResponse(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [suggestion_response][crate::model::SuggestionResult::suggestion_response]
    /// to hold a `SuggestFaqAnswersResponse`.
    ///
    /// Note that all the setters affecting `suggestion_response` are
    /// mutually exclusive.
    pub fn set_suggest_faq_answers_response<
        T: std::convert::Into<std::boxed::Box<crate::model::SuggestFaqAnswersResponse>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.suggestion_response = std::option::Option::Some(
            crate::model::suggestion_result::SuggestionResponse::SuggestFaqAnswersResponse(
                v.into(),
            ),
        );
        self
    }

    /// The value of [suggestion_response][crate::model::SuggestionResult::suggestion_response]
    /// if it holds a `SuggestSmartRepliesResponse`, `None` if the field is not set or
    /// holds a different branch.
    pub fn suggest_smart_replies_response(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SuggestSmartRepliesResponse>> {
        #[allow(unreachable_patterns)]
        self.suggestion_response.as_ref().and_then(|v| match v {
            crate::model::suggestion_result::SuggestionResponse::SuggestSmartRepliesResponse(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [suggestion_response][crate::model::SuggestionResult::suggestion_response]
    /// to hold a `SuggestSmartRepliesResponse`.
    ///
    /// Note that all the setters affecting `suggestion_response` are
    /// mutually exclusive.
    pub fn set_suggest_smart_replies_response<
        T: std::convert::Into<std::boxed::Box<crate::model::SuggestSmartRepliesResponse>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.suggestion_response = std::option::Option::Some(
            crate::model::suggestion_result::SuggestionResponse::SuggestSmartRepliesResponse(
                v.into(),
            ),
        );
        self
    }

    /// The value of [suggestion_response][crate::model::SuggestionResult::suggestion_response]
    /// if it holds a `GenerateSuggestionsResponse`, `None` if the field is not set or
    /// holds a different branch.
    pub fn generate_suggestions_response(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GenerateSuggestionsResponse>> {
        #[allow(unreachable_patterns)]
        self.suggestion_response.as_ref().and_then(|v| match v {
            crate::model::suggestion_result::SuggestionResponse::GenerateSuggestionsResponse(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [suggestion_response][crate::model::SuggestionResult::suggestion_response]
    /// to hold a `GenerateSuggestionsResponse`.
    ///
    /// Note that all the setters affecting `suggestion_response` are
    /// mutually exclusive.
    pub fn set_generate_suggestions_response<
        T: std::convert::Into<std::boxed::Box<crate::model::GenerateSuggestionsResponse>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.suggestion_response = std::option::Option::Some(
            crate::model::suggestion_result::SuggestionResponse::GenerateSuggestionsResponse(
                v.into(),
            ),
        );
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for SuggestionResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SuggestionResult"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SuggestionResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error,
            __suggest_articles_response,
            __suggest_knowledge_assist_response,
            __suggest_faq_answers_response,
            __suggest_smart_replies_response,
            __generate_suggestions_response,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestionResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "error" => Ok(__FieldTag::__error),
                            "suggestArticlesResponse" => {
                                Ok(__FieldTag::__suggest_articles_response)
                            }
                            "suggest_articles_response" => {
                                Ok(__FieldTag::__suggest_articles_response)
                            }
                            "suggestKnowledgeAssistResponse" => {
                                Ok(__FieldTag::__suggest_knowledge_assist_response)
                            }
                            "suggest_knowledge_assist_response" => {
                                Ok(__FieldTag::__suggest_knowledge_assist_response)
                            }
                            "suggestFaqAnswersResponse" => {
                                Ok(__FieldTag::__suggest_faq_answers_response)
                            }
                            "suggest_faq_answers_response" => {
                                Ok(__FieldTag::__suggest_faq_answers_response)
                            }
                            "suggestSmartRepliesResponse" => {
                                Ok(__FieldTag::__suggest_smart_replies_response)
                            }
                            "suggest_smart_replies_response" => {
                                Ok(__FieldTag::__suggest_smart_replies_response)
                            }
                            "generateSuggestionsResponse" => {
                                Ok(__FieldTag::__generate_suggestions_response)
                            }
                            "generate_suggestions_response" => {
                                Ok(__FieldTag::__generate_suggestions_response)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SuggestionResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestionResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            if result.suggestion_response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `suggestion_response`, a oneof with full ID .google.cloud.dialogflow.v2.SuggestionResult.error, latest field was error",
                                ));
                            }
                            result.suggestion_response =
                                std::option::Option::Some(
                                    crate::model::suggestion_result::SuggestionResponse::Error(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<rpc::model::Status>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__suggest_articles_response => {
                            if !fields.insert(__FieldTag::__suggest_articles_response) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suggest_articles_response",
                                ));
                            }
                            if result.suggestion_response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `suggestion_response`, a oneof with full ID .google.cloud.dialogflow.v2.SuggestionResult.suggest_articles_response, latest field was suggestArticlesResponse",
                                ));
                            }
                            result.suggestion_response = std::option::Option::Some(
                                crate::model::suggestion_result::SuggestionResponse::SuggestArticlesResponse(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SuggestArticlesResponse>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__suggest_knowledge_assist_response => {
                            if !fields.insert(__FieldTag::__suggest_knowledge_assist_response) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suggest_knowledge_assist_response",
                                ));
                            }
                            if result.suggestion_response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `suggestion_response`, a oneof with full ID .google.cloud.dialogflow.v2.SuggestionResult.suggest_knowledge_assist_response, latest field was suggestKnowledgeAssistResponse",
                                ));
                            }
                            result.suggestion_response = std::option::Option::Some(
                                crate::model::suggestion_result::SuggestionResponse::SuggestKnowledgeAssistResponse(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SuggestKnowledgeAssistResponse>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__suggest_faq_answers_response => {
                            if !fields.insert(__FieldTag::__suggest_faq_answers_response) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suggest_faq_answers_response",
                                ));
                            }
                            if result.suggestion_response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `suggestion_response`, a oneof with full ID .google.cloud.dialogflow.v2.SuggestionResult.suggest_faq_answers_response, latest field was suggestFaqAnswersResponse",
                                ));
                            }
                            result.suggestion_response = std::option::Option::Some(
                                crate::model::suggestion_result::SuggestionResponse::SuggestFaqAnswersResponse(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SuggestFaqAnswersResponse>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__suggest_smart_replies_response => {
                            if !fields.insert(__FieldTag::__suggest_smart_replies_response) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suggest_smart_replies_response",
                                ));
                            }
                            if result.suggestion_response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `suggestion_response`, a oneof with full ID .google.cloud.dialogflow.v2.SuggestionResult.suggest_smart_replies_response, latest field was suggestSmartRepliesResponse",
                                ));
                            }
                            result.suggestion_response = std::option::Option::Some(
                                crate::model::suggestion_result::SuggestionResponse::SuggestSmartRepliesResponse(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SuggestSmartRepliesResponse>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__generate_suggestions_response => {
                            if !fields.insert(__FieldTag::__generate_suggestions_response) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generate_suggestions_response",
                                ));
                            }
                            if result.suggestion_response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `suggestion_response`, a oneof with full ID .google.cloud.dialogflow.v2.SuggestionResult.generate_suggestions_response, latest field was generateSuggestionsResponse",
                                ));
                            }
                            result.suggestion_response = std::option::Option::Some(
                                crate::model::suggestion_result::SuggestionResponse::GenerateSuggestionsResponse(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::GenerateSuggestionsResponse>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for SuggestionResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.error() {
            state.serialize_entry("error", value)?;
        }
        if let Some(value) = self.suggest_articles_response() {
            state.serialize_entry("suggestArticlesResponse", value)?;
        }
        if let Some(value) = self.suggest_knowledge_assist_response() {
            state.serialize_entry("suggestKnowledgeAssistResponse", value)?;
        }
        if let Some(value) = self.suggest_faq_answers_response() {
            state.serialize_entry("suggestFaqAnswersResponse", value)?;
        }
        if let Some(value) = self.suggest_smart_replies_response() {
            state.serialize_entry("suggestSmartRepliesResponse", value)?;
        }
        if let Some(value) = self.generate_suggestions_response() {
            state.serialize_entry("generateSuggestionsResponse", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SuggestionResult].
#[cfg(feature = "participants")]
pub mod suggestion_result {
    #[allow(unused_imports)]
    use super::*;

    /// Different type of suggestion response.
    #[cfg(feature = "participants")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SuggestionResponse {
        /// Error status if the request failed.
        Error(std::boxed::Box<rpc::model::Status>),
        /// SuggestArticlesResponse if request is for ARTICLE_SUGGESTION.
        SuggestArticlesResponse(std::boxed::Box<crate::model::SuggestArticlesResponse>),
        /// SuggestKnowledgeAssistResponse if request is for KNOWLEDGE_ASSIST.
        SuggestKnowledgeAssistResponse(
            std::boxed::Box<crate::model::SuggestKnowledgeAssistResponse>,
        ),
        /// SuggestFaqAnswersResponse if request is for FAQ_ANSWER.
        SuggestFaqAnswersResponse(std::boxed::Box<crate::model::SuggestFaqAnswersResponse>),
        /// SuggestSmartRepliesResponse if request is for SMART_REPLY.
        SuggestSmartRepliesResponse(std::boxed::Box<crate::model::SuggestSmartRepliesResponse>),
        /// Suggestions generated using generators triggered by customer or agent
        /// messages.
        GenerateSuggestionsResponse(std::boxed::Box<crate::model::GenerateSuggestionsResponse>),
    }
}

/// Defines the language used in the input text.
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InputTextConfig {
    /// Required. The language of this conversational query. See [Language
    /// Support](https://cloud.google.com/dialogflow/docs/reference/language)
    /// for a list of the currently supported language codes.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl InputTextConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [language_code][crate::model::InputTextConfig::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for InputTextConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.InputTextConfig"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InputTextConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InputTextConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InputTextConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InputTextConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for InputTextConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a part of a message possibly annotated with an entity. The part
/// can be an entity or purely a part of the message between two entities or
/// message start/end.
#[cfg(any(feature = "conversations", feature = "participants",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AnnotatedMessagePart {
    /// A part of a message possibly annotated with an entity.
    pub text: std::string::String,

    /// The [Dialogflow system entity
    /// type](https://cloud.google.com/dialogflow/docs/reference/system-entities)
    /// of this message part. If this is empty, Dialogflow could not annotate the
    /// phrase part with a system entity.
    pub entity_type: std::string::String,

    /// The [Dialogflow system entity formatted value
    /// ](https://cloud.google.com/dialogflow/docs/reference/system-entities) of
    /// this message part. For example for a system entity of type
    /// `@sys.unit-currency`, this may contain:
    pub formatted_value: std::option::Option<wkt::Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversations", feature = "participants",))]
impl AnnotatedMessagePart {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [text][crate::model::AnnotatedMessagePart::text].
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.text = v.into();
        self
    }

    /// Sets the value of [entity_type][crate::model::AnnotatedMessagePart::entity_type].
    pub fn set_entity_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entity_type = v.into();
        self
    }

    /// Sets the value of [formatted_value][crate::model::AnnotatedMessagePart::formatted_value].
    pub fn set_formatted_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Value>,
    {
        self.formatted_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [formatted_value][crate::model::AnnotatedMessagePart::formatted_value].
    pub fn set_or_clear_formatted_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Value>,
    {
        self.formatted_value = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
impl wkt::message::Message for AnnotatedMessagePart {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.AnnotatedMessagePart"
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnnotatedMessagePart {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __entity_type,
            __formatted_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnnotatedMessagePart")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "entityType" => Ok(__FieldTag::__entity_type),
                            "entity_type" => Ok(__FieldTag::__entity_type),
                            "formattedValue" => Ok(__FieldTag::__formatted_value),
                            "formatted_value" => Ok(__FieldTag::__formatted_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnnotatedMessagePart;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnnotatedMessagePart")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            result.text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_type => {
                            if !fields.insert(__FieldTag::__entity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_type",
                                ));
                            }
                            result.entity_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__formatted_value => {
                            if !fields.insert(__FieldTag::__formatted_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for formatted_value",
                                ));
                            }
                            result.formatted_value = map
                                .next_value::<std::option::Option<wkt::Value>>()?
                                .or(Some(wkt::Value::Null));
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
#[doc(hidden)]
impl serde::ser::Serialize for AnnotatedMessagePart {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self.entity_type.is_empty() {
            state.serialize_entry("entityType", &self.entity_type)?;
        }
        if self.formatted_value.is_some() {
            state.serialize_entry("formattedValue", &self.formatted_value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the result of annotation for the message.
#[cfg(any(feature = "conversations", feature = "participants",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MessageAnnotation {
    /// The collection of annotated message parts ordered by their
    /// position in the message. You can recover the annotated message by
    /// concatenating [AnnotatedMessagePart.text].
    pub parts: std::vec::Vec<crate::model::AnnotatedMessagePart>,

    /// Indicates whether the text message contains entities.
    pub contain_entities: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversations", feature = "participants",))]
impl MessageAnnotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parts][crate::model::MessageAnnotation::parts].
    pub fn set_parts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AnnotatedMessagePart>,
    {
        use std::iter::Iterator;
        self.parts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [contain_entities][crate::model::MessageAnnotation::contain_entities].
    pub fn set_contain_entities<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.contain_entities = v.into();
        self
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
impl wkt::message::Message for MessageAnnotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.MessageAnnotation"
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MessageAnnotation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parts,
            __contain_entities,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MessageAnnotation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parts" => Ok(__FieldTag::__parts),
                            "containEntities" => Ok(__FieldTag::__contain_entities),
                            "contain_entities" => Ok(__FieldTag::__contain_entities),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MessageAnnotation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MessageAnnotation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parts => {
                            if !fields.insert(__FieldTag::__parts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parts",
                                ));
                            }
                            result.parts = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AnnotatedMessagePart>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__contain_entities => {
                            if !fields.insert(__FieldTag::__contain_entities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contain_entities",
                                ));
                            }
                            result.contain_entities = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
#[doc(hidden)]
impl serde::ser::Serialize for MessageAnnotation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parts.is_empty() {
            state.serialize_entry("parts", &self.parts)?;
        }
        if !wkt::internal::is_default(&self.contain_entities) {
            state.serialize_entry("containEntities", &self.contain_entities)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the selection of a suggestion.
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SuggestionInput {
    /// Required. The ID of a suggestion selected by the human agent.
    /// The suggestion(s) were generated in a previous call to
    /// request Dialogflow assist.
    /// The format is:
    /// `projects/<Project ID>/locations/<Location ID>/answerRecords/<Answer Record
    /// ID>` where \<Answer Record ID\> is an alphanumeric string.
    pub answer_record: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl SuggestionInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [answer_record][crate::model::SuggestionInput::answer_record].
    pub fn set_answer_record<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.answer_record = v.into();
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for SuggestionInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SuggestionInput"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SuggestionInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __answer_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestionInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SuggestionInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestionInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_record",
                                ));
                            }
                            result.answer_record = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for SuggestionInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.answer_record.is_empty() {
            state.serialize_entry("answerRecord", &self.answer_record)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the parameters of human assist query.
#[cfg(any(feature = "conversations", feature = "participants",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AssistQueryParameters {
    /// Key-value filters on the metadata of documents returned by article
    /// suggestion. If specified, article suggestion only returns suggested
    /// documents that match all filters in their
    /// [Document.metadata][google.cloud.dialogflow.v2.Document.metadata]. Multiple
    /// values for a metadata key should be concatenated by comma. For example,
    /// filters to match all documents that have 'US' or 'CA' in their market
    /// metadata values and 'agent' in their user metadata values will be
    ///
    /// ```norust
    /// documents_metadata_filters {
    ///   key: "market"
    ///   value: "US,CA"
    /// }
    /// documents_metadata_filters {
    ///   key: "user"
    ///   value: "agent"
    /// }
    /// ```
    ///
    /// [google.cloud.dialogflow.v2.Document.metadata]: crate::model::Document::metadata
    pub documents_metadata_filters:
        std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "conversations", feature = "participants",))]
impl AssistQueryParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [documents_metadata_filters][crate::model::AssistQueryParameters::documents_metadata_filters].
    pub fn set_documents_metadata_filters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.documents_metadata_filters =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
impl wkt::message::Message for AssistQueryParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.AssistQueryParameters"
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AssistQueryParameters {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __documents_metadata_filters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AssistQueryParameters")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "documentsMetadataFilters" => {
                                Ok(__FieldTag::__documents_metadata_filters)
                            }
                            "documents_metadata_filters" => {
                                Ok(__FieldTag::__documents_metadata_filters)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AssistQueryParameters;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AssistQueryParameters")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__documents_metadata_filters => {
                            if !fields.insert(__FieldTag::__documents_metadata_filters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documents_metadata_filters",
                                ));
                            }
                            result.documents_metadata_filters = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "conversations", feature = "participants",))]
#[doc(hidden)]
impl serde::ser::Serialize for AssistQueryParameters {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.documents_metadata_filters.is_empty() {
            state.serialize_entry("documentsMetadataFilters", &self.documents_metadata_filters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Participants.SuggestKnowledgeAssist][google.cloud.dialogflow.v2.Participants.SuggestKnowledgeAssist].
///
/// [google.cloud.dialogflow.v2.Participants.SuggestKnowledgeAssist]: crate::client::Participants::suggest_knowledge_assist
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SuggestKnowledgeAssistRequest {
    /// Required. The name of the participant to fetch suggestions for.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/participants/<Participant ID>`.
    pub parent: std::string::String,

    /// Optional. The name of the latest conversation message to compile
    /// suggestions for. If empty, it will be the latest message of the
    /// conversation. Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/messages/<Message ID>`.
    pub latest_message: std::string::String,

    /// Optional. Max number of messages prior to and including
    /// [latest_message][google.cloud.dialogflow.v2.SuggestKnowledgeAssistRequest.latest_message]
    /// to use as context when compiling the suggestion. The context size is by
    /// default 100 and at most 100.
    ///
    /// [google.cloud.dialogflow.v2.SuggestKnowledgeAssistRequest.latest_message]: crate::model::SuggestKnowledgeAssistRequest::latest_message
    pub context_size: i32,

    /// Optional. The previously suggested query for the given conversation. This
    /// helps identify whether the next suggestion we generate is reasonably
    /// different from the previous one. This is useful to avoid similar
    /// suggestions within the conversation.
    pub previous_suggested_query: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl SuggestKnowledgeAssistRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SuggestKnowledgeAssistRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [latest_message][crate::model::SuggestKnowledgeAssistRequest::latest_message].
    pub fn set_latest_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.latest_message = v.into();
        self
    }

    /// Sets the value of [context_size][crate::model::SuggestKnowledgeAssistRequest::context_size].
    pub fn set_context_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.context_size = v.into();
        self
    }

    /// Sets the value of [previous_suggested_query][crate::model::SuggestKnowledgeAssistRequest::previous_suggested_query].
    pub fn set_previous_suggested_query<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.previous_suggested_query = v.into();
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for SuggestKnowledgeAssistRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SuggestKnowledgeAssistRequest"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SuggestKnowledgeAssistRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __latest_message,
            __context_size,
            __previous_suggested_query,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestKnowledgeAssistRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            "previousSuggestedQuery" => Ok(__FieldTag::__previous_suggested_query),
                            "previous_suggested_query" => {
                                Ok(__FieldTag::__previous_suggested_query)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SuggestKnowledgeAssistRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestKnowledgeAssistRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_message",
                                ));
                            }
                            result.latest_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__previous_suggested_query => {
                            if !fields.insert(__FieldTag::__previous_suggested_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for previous_suggested_query",
                                ));
                            }
                            result.previous_suggested_query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for SuggestKnowledgeAssistRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if !self.previous_suggested_query.is_empty() {
            state.serialize_entry("previousSuggestedQuery", &self.previous_suggested_query)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Participants.SuggestKnowledgeAssist][google.cloud.dialogflow.v2.Participants.SuggestKnowledgeAssist].
///
/// [google.cloud.dialogflow.v2.Participants.SuggestKnowledgeAssist]: crate::client::Participants::suggest_knowledge_assist
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SuggestKnowledgeAssistResponse {
    /// Output only. Knowledge Assist suggestion.
    pub knowledge_assist_answer: std::option::Option<crate::model::KnowledgeAssistAnswer>,

    /// The name of the latest conversation message used to compile suggestion for.
    /// Format: `projects/<Project ID>/locations/<Location
    /// ID>/conversations/<Conversation ID>/messages/<Message ID>`.
    pub latest_message: std::string::String,

    /// Number of messages prior to and including
    /// [latest_message][google.cloud.dialogflow.v2.SuggestKnowledgeAssistResponse.latest_message]
    /// to compile the suggestion. It may be smaller than the
    /// [SuggestKnowledgeAssistRequest.context_size][google.cloud.dialogflow.v2.SuggestKnowledgeAssistRequest.context_size]
    /// field in the request if there are fewer messages in the conversation.
    ///
    /// [google.cloud.dialogflow.v2.SuggestKnowledgeAssistRequest.context_size]: crate::model::SuggestKnowledgeAssistRequest::context_size
    /// [google.cloud.dialogflow.v2.SuggestKnowledgeAssistResponse.latest_message]: crate::model::SuggestKnowledgeAssistResponse::latest_message
    pub context_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl SuggestKnowledgeAssistResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [knowledge_assist_answer][crate::model::SuggestKnowledgeAssistResponse::knowledge_assist_answer].
    pub fn set_knowledge_assist_answer<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KnowledgeAssistAnswer>,
    {
        self.knowledge_assist_answer = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [knowledge_assist_answer][crate::model::SuggestKnowledgeAssistResponse::knowledge_assist_answer].
    pub fn set_or_clear_knowledge_assist_answer<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KnowledgeAssistAnswer>,
    {
        self.knowledge_assist_answer = v.map(|x| x.into());
        self
    }

    /// Sets the value of [latest_message][crate::model::SuggestKnowledgeAssistResponse::latest_message].
    pub fn set_latest_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.latest_message = v.into();
        self
    }

    /// Sets the value of [context_size][crate::model::SuggestKnowledgeAssistResponse::context_size].
    pub fn set_context_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.context_size = v.into();
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for SuggestKnowledgeAssistResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SuggestKnowledgeAssistResponse"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SuggestKnowledgeAssistResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __knowledge_assist_answer,
            __latest_message,
            __context_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SuggestKnowledgeAssistResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "knowledgeAssistAnswer" => Ok(__FieldTag::__knowledge_assist_answer),
                            "knowledge_assist_answer" => Ok(__FieldTag::__knowledge_assist_answer),
                            "latestMessage" => Ok(__FieldTag::__latest_message),
                            "latest_message" => Ok(__FieldTag::__latest_message),
                            "contextSize" => Ok(__FieldTag::__context_size),
                            "context_size" => Ok(__FieldTag::__context_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SuggestKnowledgeAssistResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SuggestKnowledgeAssistResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__knowledge_assist_answer => {
                            if !fields.insert(__FieldTag::__knowledge_assist_answer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for knowledge_assist_answer",
                                ));
                            }
                            result.knowledge_assist_answer = map.next_value::<std::option::Option<crate::model::KnowledgeAssistAnswer>>()?
                                ;
                        }
                        __FieldTag::__latest_message => {
                            if !fields.insert(__FieldTag::__latest_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latest_message",
                                ));
                            }
                            result.latest_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__context_size => {
                            if !fields.insert(__FieldTag::__context_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for context_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.context_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for SuggestKnowledgeAssistResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.knowledge_assist_answer.is_some() {
            state.serialize_entry("knowledgeAssistAnswer", &self.knowledge_assist_answer)?;
        }
        if !self.latest_message.is_empty() {
            state.serialize_entry("latestMessage", &self.latest_message)?;
        }
        if !wkt::internal::is_default(&self.context_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contextSize", &__With(&self.context_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a Knowledge Assist answer.
#[cfg(feature = "participants")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct KnowledgeAssistAnswer {
    /// The query suggested based on the context. Suggestion is made only if it
    /// is different from the previous suggestion.
    pub suggested_query: std::option::Option<crate::model::knowledge_assist_answer::SuggestedQuery>,

    /// The answer generated for the suggested query. Whether or not an answer is
    /// generated depends on how confident we are about the generated query.
    pub suggested_query_answer:
        std::option::Option<crate::model::knowledge_assist_answer::KnowledgeAnswer>,

    /// The name of the answer record.
    /// Format: `projects/<Project ID>/locations/<location ID>/answer
    /// Records/<Answer Record ID>`.
    pub answer_record: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "participants")]
impl KnowledgeAssistAnswer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [suggested_query][crate::model::KnowledgeAssistAnswer::suggested_query].
    pub fn set_suggested_query<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::knowledge_assist_answer::SuggestedQuery>,
    {
        self.suggested_query = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [suggested_query][crate::model::KnowledgeAssistAnswer::suggested_query].
    pub fn set_or_clear_suggested_query<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::knowledge_assist_answer::SuggestedQuery>,
    {
        self.suggested_query = v.map(|x| x.into());
        self
    }

    /// Sets the value of [suggested_query_answer][crate::model::KnowledgeAssistAnswer::suggested_query_answer].
    pub fn set_suggested_query_answer<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::knowledge_assist_answer::KnowledgeAnswer>,
    {
        self.suggested_query_answer = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [suggested_query_answer][crate::model::KnowledgeAssistAnswer::suggested_query_answer].
    pub fn set_or_clear_suggested_query_answer<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::knowledge_assist_answer::KnowledgeAnswer>,
    {
        self.suggested_query_answer = v.map(|x| x.into());
        self
    }

    /// Sets the value of [answer_record][crate::model::KnowledgeAssistAnswer::answer_record].
    pub fn set_answer_record<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.answer_record = v.into();
        self
    }
}

#[cfg(feature = "participants")]
impl wkt::message::Message for KnowledgeAssistAnswer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.KnowledgeAssistAnswer"
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KnowledgeAssistAnswer {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __suggested_query,
            __suggested_query_answer,
            __answer_record,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KnowledgeAssistAnswer")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "suggestedQuery" => Ok(__FieldTag::__suggested_query),
                            "suggested_query" => Ok(__FieldTag::__suggested_query),
                            "suggestedQueryAnswer" => Ok(__FieldTag::__suggested_query_answer),
                            "suggested_query_answer" => Ok(__FieldTag::__suggested_query_answer),
                            "answerRecord" => Ok(__FieldTag::__answer_record),
                            "answer_record" => Ok(__FieldTag::__answer_record),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KnowledgeAssistAnswer;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KnowledgeAssistAnswer")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__suggested_query => {
                            if !fields.insert(__FieldTag::__suggested_query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suggested_query",
                                ));
                            }
                            result.suggested_query = map.next_value::<std::option::Option<
                                crate::model::knowledge_assist_answer::SuggestedQuery,
                            >>()?;
                        }
                        __FieldTag::__suggested_query_answer => {
                            if !fields.insert(__FieldTag::__suggested_query_answer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suggested_query_answer",
                                ));
                            }
                            result.suggested_query_answer = map.next_value::<std::option::Option<
                                crate::model::knowledge_assist_answer::KnowledgeAnswer,
                            >>()?;
                        }
                        __FieldTag::__answer_record => {
                            if !fields.insert(__FieldTag::__answer_record) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer_record",
                                ));
                            }
                            result.answer_record = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "participants")]
#[doc(hidden)]
impl serde::ser::Serialize for KnowledgeAssistAnswer {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.suggested_query.is_some() {
            state.serialize_entry("suggestedQuery", &self.suggested_query)?;
        }
        if self.suggested_query_answer.is_some() {
            state.serialize_entry("suggestedQueryAnswer", &self.suggested_query_answer)?;
        }
        if !self.answer_record.is_empty() {
            state.serialize_entry("answerRecord", &self.answer_record)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [KnowledgeAssistAnswer].
#[cfg(feature = "participants")]
pub mod knowledge_assist_answer {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a suggested query.
    #[cfg(feature = "participants")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SuggestedQuery {
        /// Suggested query text.
        pub query_text: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "participants")]
    impl SuggestedQuery {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [query_text][crate::model::knowledge_assist_answer::SuggestedQuery::query_text].
        pub fn set_query_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.query_text = v.into();
            self
        }
    }

    #[cfg(feature = "participants")]
    impl wkt::message::Message for SuggestedQuery {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.KnowledgeAssistAnswer.SuggestedQuery"
        }
    }

    #[cfg(feature = "participants")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SuggestedQuery {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __query_text,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SuggestedQuery")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "queryText" => Ok(__FieldTag::__query_text),
                                "query_text" => Ok(__FieldTag::__query_text),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SuggestedQuery;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SuggestedQuery")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__query_text => {
                                if !fields.insert(__FieldTag::__query_text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for query_text",
                                    ));
                                }
                                result.query_text = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "participants")]
    #[doc(hidden)]
    impl serde::ser::Serialize for SuggestedQuery {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.query_text.is_empty() {
                state.serialize_entry("queryText", &self.query_text)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Represents an answer from Knowledge. Currently supports FAQ and Generative
    /// answers.
    #[cfg(feature = "participants")]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct KnowledgeAnswer {
        /// The piece of text from the `source` that answers this suggested query.
        pub answer_text: std::string::String,

        /// Source of result.
        pub source:
            std::option::Option<crate::model::knowledge_assist_answer::knowledge_answer::Source>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "participants")]
    impl KnowledgeAnswer {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [answer_text][crate::model::knowledge_assist_answer::KnowledgeAnswer::answer_text].
        pub fn set_answer_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.answer_text = v.into();
            self
        }

        /// Sets the value of [source][crate::model::knowledge_assist_answer::KnowledgeAnswer::source].
        ///
        /// Note that all the setters affecting `source` are mutually
        /// exclusive.
        pub fn set_source<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::knowledge_assist_answer::knowledge_answer::Source,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = v.into();
            self
        }

        /// The value of [source][crate::model::knowledge_assist_answer::KnowledgeAnswer::source]
        /// if it holds a `FaqSource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn faq_source(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::knowledge_assist_answer::knowledge_answer::FaqSource>,
        > {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::knowledge_assist_answer::knowledge_answer::Source::FaqSource(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::knowledge_assist_answer::KnowledgeAnswer::source]
        /// to hold a `FaqSource`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_faq_source<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::knowledge_assist_answer::knowledge_answer::FaqSource,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::knowledge_assist_answer::knowledge_answer::Source::FaqSource(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [source][crate::model::knowledge_assist_answer::KnowledgeAnswer::source]
        /// if it holds a `GenerativeSource`, `None` if the field is not set or
        /// holds a different branch.
        pub fn generative_source(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::knowledge_assist_answer::knowledge_answer::GenerativeSource,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.source.as_ref().and_then(|v| match v {
                crate::model::knowledge_assist_answer::knowledge_answer::Source::GenerativeSource(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [source][crate::model::knowledge_assist_answer::KnowledgeAnswer::source]
        /// to hold a `GenerativeSource`.
        ///
        /// Note that all the setters affecting `source` are
        /// mutually exclusive.
        pub fn set_generative_source<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::knowledge_assist_answer::knowledge_answer::GenerativeSource,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.source = std::option::Option::Some(
                crate::model::knowledge_assist_answer::knowledge_answer::Source::GenerativeSource(
                    v.into(),
                ),
            );
            self
        }
    }

    #[cfg(feature = "participants")]
    impl wkt::message::Message for KnowledgeAnswer {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dialogflow.v2.KnowledgeAssistAnswer.KnowledgeAnswer"
        }
    }

    #[cfg(feature = "participants")]
    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for KnowledgeAnswer {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __answer_text,
                __faq_source,
                __generative_source,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for KnowledgeAnswer")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "answerText" => Ok(__FieldTag::__answer_text),
                                "answer_text" => Ok(__FieldTag::__answer_text),
                                "faqSource" => Ok(__FieldTag::__faq_source),
                                "faq_source" => Ok(__FieldTag::__faq_source),
                                "generativeSource" => Ok(__FieldTag::__generative_source),
                                "generative_source" => Ok(__FieldTag::__generative_source),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = KnowledgeAnswer;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct KnowledgeAnswer")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__answer_text => {
                                if !fields.insert(__FieldTag::__answer_text) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for answer_text",
                                    ));
                                }
                                result.answer_text = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__faq_source => {
                                if !fields.insert(__FieldTag::__faq_source) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for faq_source",
                                    ));
                                }
                                if result.source.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.v2.KnowledgeAssistAnswer.KnowledgeAnswer.faq_source, latest field was faqSource",
                                    ));
                                }
                                result.source = std::option::Option::Some(
                                    crate::model::knowledge_assist_answer::knowledge_answer::Source::FaqSource(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::knowledge_assist_answer::knowledge_answer::FaqSource>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__generative_source => {
                                if !fields.insert(__FieldTag::__generative_source) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for generative_source",
                                    ));
                                }
                                if result.source.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `source`, a oneof with full ID .google.cloud.dialogflow.v2.KnowledgeAssistAnswer.KnowledgeAnswer.generative_source, latest field was generativeSource",
                                    ));
                                }
                                result.source = std::option::Option::Some(
                                    crate::model::knowledge_assist_answer::knowledge_answer::Source::GenerativeSource(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::knowledge_assist_answer::knowledge_answer::GenerativeSource>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[cfg(feature = "participants")]
    #[doc(hidden)]
    impl serde::ser::Serialize for KnowledgeAnswer {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.answer_text.is_empty() {
                state.serialize_entry("answerText", &self.answer_text)?;
            }
            if let Some(value) = self.faq_source() {
                state.serialize_entry("faqSource", value)?;
            }
            if let Some(value) = self.generative_source() {
                state.serialize_entry("generativeSource", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [KnowledgeAnswer].
    #[cfg(feature = "participants")]
    pub mod knowledge_answer {
        #[allow(unused_imports)]
        use super::*;

        /// Details about source of FAQ answer.
        #[cfg(feature = "participants")]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct FaqSource {
            /// The corresponding FAQ question.
            pub question: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "participants")]
        impl FaqSource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [question][crate::model::knowledge_assist_answer::knowledge_answer::FaqSource::question].
            pub fn set_question<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.question = v.into();
                self
            }
        }

        #[cfg(feature = "participants")]
        impl wkt::message::Message for FaqSource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.KnowledgeAssistAnswer.KnowledgeAnswer.FaqSource"
            }
        }

        #[cfg(feature = "participants")]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for FaqSource {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __question,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for FaqSource")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "question" => Ok(__FieldTag::__question),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = FaqSource;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct FaqSource")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__question => {
                                    if !fields.insert(__FieldTag::__question) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for question",
                                            ),
                                        );
                                    }
                                    result.question = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(feature = "participants")]
        #[doc(hidden)]
        impl serde::ser::Serialize for FaqSource {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.question.is_empty() {
                    state.serialize_entry("question", &self.question)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Details about source of Generative answer.
        #[cfg(feature = "participants")]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct GenerativeSource {
            /// All snippets used for this Generative Prediction, with their source URI
            /// and data.
            pub snippets: std::vec::Vec<
                crate::model::knowledge_assist_answer::knowledge_answer::generative_source::Snippet,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "participants")]
        impl GenerativeSource {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [snippets][crate::model::knowledge_assist_answer::knowledge_answer::GenerativeSource::snippets].
            pub fn set_snippets<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::knowledge_assist_answer::knowledge_answer::generative_source::Snippet>
            {
                use std::iter::Iterator;
                self.snippets = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        #[cfg(feature = "participants")]
        impl wkt::message::Message for GenerativeSource {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dialogflow.v2.KnowledgeAssistAnswer.KnowledgeAnswer.GenerativeSource"
            }
        }

        #[cfg(feature = "participants")]
        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for GenerativeSource {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __snippets,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for GenerativeSource")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "snippets" => Ok(__FieldTag::__snippets),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = GenerativeSource;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct GenerativeSource")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__snippets => {
                                    if !fields.insert(__FieldTag::__snippets) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for snippets",
                                            ),
                                        );
                                    }
                                    result.snippets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::knowledge_assist_answer::knowledge_answer::generative_source::Snippet>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[cfg(feature = "participants")]
        #[doc(hidden)]
        impl serde::ser::Serialize for GenerativeSource {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.snippets.is_empty() {
                    state.serialize_entry("snippets", &self.snippets)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [GenerativeSource].
        #[cfg(feature = "participants")]
        pub mod generative_source {
            #[allow(unused_imports)]
            use super::*;

            /// Snippet Source for a Generative Prediction.
            #[cfg(feature = "participants")]
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Snippet {
                /// URI the data is sourced from.
                pub uri: std::string::String,

                /// Text taken from that URI.
                pub text: std::string::String,

                /// Title of the document.
                pub title: std::string::String,

                /// Metadata of the document.
                pub metadata: std::option::Option<wkt::Struct>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(feature = "participants")]
            impl Snippet {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [uri][crate::model::knowledge_assist_answer::knowledge_answer::generative_source::Snippet::uri].
                pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                    self.uri = v.into();
                    self
                }

                /// Sets the value of [text][crate::model::knowledge_assist_answer::knowledge_answer::generative_source::Snippet::text].
                pub fn set_text<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.text = v.into();
                    self
                }

                /// Sets the value of [title][crate::model::knowledge_assist_answer::knowledge_answer::generative_source::Snippet::title].
                pub fn set_title<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.title = v.into();
                    self
                }

                /// Sets the value of [metadata][crate::model::knowledge_assist_answer::knowledge_answer::generative_source::Snippet::metadata].
                pub fn set_metadata<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<wkt::Struct>,
                {
                    self.metadata = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [metadata][crate::model::knowledge_assist_answer::knowledge_answer::generative_source::Snippet::metadata].
                pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<wkt::Struct>,
                {
                    self.metadata = v.map(|x| x.into());
                    self
                }
            }

            #[cfg(feature = "participants")]
            impl wkt::message::Message for Snippet {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.dialogflow.v2.KnowledgeAssistAnswer.KnowledgeAnswer.GenerativeSource.Snippet"
                }
            }

            #[cfg(feature = "participants")]
            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Snippet {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __uri,
                        __text,
                        __title,
                        __metadata,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Snippet")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "uri" => Ok(__FieldTag::__uri),
                                        "text" => Ok(__FieldTag::__text),
                                        "title" => Ok(__FieldTag::__title),
                                        "metadata" => Ok(__FieldTag::__metadata),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Snippet;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Snippet")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__uri => {
                                        if !fields.insert(__FieldTag::__uri) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for uri",
                                                ),
                                            );
                                        }
                                        result.uri = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__text => {
                                        if !fields.insert(__FieldTag::__text) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for text",
                                                ),
                                            );
                                        }
                                        result.text = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__title => {
                                        if !fields.insert(__FieldTag::__title) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for title",
                                                ),
                                            );
                                        }
                                        result.title = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__metadata => {
                                        if !fields.insert(__FieldTag::__metadata) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for metadata",
                                                ),
                                            );
                                        }
                                        result.metadata =
                                            map.next_value::<std::option::Option<wkt::Struct>>()?;
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[cfg(feature = "participants")]
            #[doc(hidden)]
            impl serde::ser::Serialize for Snippet {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.uri.is_empty() {
                        state.serialize_entry("uri", &self.uri)?;
                    }
                    if !self.text.is_empty() {
                        state.serialize_entry("text", &self.text)?;
                    }
                    if !self.title.is_empty() {
                        state.serialize_entry("title", &self.title)?;
                    }
                    if self.metadata.is_some() {
                        state.serialize_entry("metadata", &self.metadata)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }
        }

        /// Source of result.
        #[cfg(feature = "participants")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Source {
            /// Populated if the prediction came from FAQ.
            FaqSource(
                std::boxed::Box<crate::model::knowledge_assist_answer::knowledge_answer::FaqSource>,
            ),
            /// Populated if the prediction was Generative.
            GenerativeSource(
                std::boxed::Box<
                    crate::model::knowledge_assist_answer::knowledge_answer::GenerativeSource,
                >,
            ),
        }
    }
}

/// The request to detect user's intent.
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DetectIntentRequest {
    /// Required. The name of the session this query is sent to. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>`, or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    /// default 'draft' environment (`Environment ID` might be referred to as
    /// environment name at some places). If `User ID` is not specified, we are
    /// using "-". It's up to the API caller to choose an appropriate `Session ID`
    /// and `User Id`. They can be a random number or some type of user and session
    /// identifiers (preferably hashed). The length of the `Session ID` and
    /// `User ID` must not exceed 36 characters.
    ///
    /// For more information, see the [API interactions
    /// guide](https://cloud.google.com/dialogflow/docs/api-overview).
    ///
    /// Note: Always use agent versions for production traffic.
    /// See [Versions and
    /// environments](https://cloud.google.com/dialogflow/es/docs/agents-versions).
    pub session: std::string::String,

    /// The parameters of this query.
    pub query_params: std::option::Option<crate::model::QueryParameters>,

    /// Required. The input specification. It can be set to:
    ///
    /// 1. an audio config which instructs the speech recognizer how to process
    ///    the speech audio,
    ///
    /// 1. a conversational query in the form of text, or
    ///
    /// 1. an event that specifies which intent to trigger.
    ///
    pub query_input: std::option::Option<crate::model::QueryInput>,

    /// Instructs the speech synthesizer how to generate the output
    /// audio. If this field is not set and agent-level speech synthesizer is not
    /// configured, no output audio is generated.
    pub output_audio_config: std::option::Option<crate::model::OutputAudioConfig>,

    /// Mask for
    /// [output_audio_config][google.cloud.dialogflow.v2.DetectIntentRequest.output_audio_config]
    /// indicating which settings in this request-level config should override
    /// speech synthesizer settings defined at agent-level.
    ///
    /// If unspecified or empty,
    /// [output_audio_config][google.cloud.dialogflow.v2.DetectIntentRequest.output_audio_config]
    /// replaces the agent-level config in its entirety.
    ///
    /// [google.cloud.dialogflow.v2.DetectIntentRequest.output_audio_config]: crate::model::DetectIntentRequest::output_audio_config
    pub output_audio_config_mask: std::option::Option<wkt::FieldMask>,

    /// The natural language speech audio to be processed. This field
    /// should be populated iff `query_input` is set to an input audio config.
    /// A single request can contain up to 1 minute of speech audio data.
    pub input_audio: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl DetectIntentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session][crate::model::DetectIntentRequest::session].
    pub fn set_session<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session = v.into();
        self
    }

    /// Sets the value of [query_params][crate::model::DetectIntentRequest::query_params].
    pub fn set_query_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameters>,
    {
        self.query_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_params][crate::model::DetectIntentRequest::query_params].
    pub fn set_or_clear_query_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameters>,
    {
        self.query_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query_input][crate::model::DetectIntentRequest::query_input].
    pub fn set_query_input<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryInput>,
    {
        self.query_input = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_input][crate::model::DetectIntentRequest::query_input].
    pub fn set_or_clear_query_input<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryInput>,
    {
        self.query_input = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_audio_config][crate::model::DetectIntentRequest::output_audio_config].
    pub fn set_output_audio_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.output_audio_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_audio_config][crate::model::DetectIntentRequest::output_audio_config].
    pub fn set_or_clear_output_audio_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.output_audio_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_audio_config_mask][crate::model::DetectIntentRequest::output_audio_config_mask].
    pub fn set_output_audio_config_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.output_audio_config_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_audio_config_mask][crate::model::DetectIntentRequest::output_audio_config_mask].
    pub fn set_or_clear_output_audio_config_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.output_audio_config_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [input_audio][crate::model::DetectIntentRequest::input_audio].
    pub fn set_input_audio<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.input_audio = v.into();
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for DetectIntentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DetectIntentRequest"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DetectIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session,
            __query_params,
            __query_input,
            __output_audio_config,
            __output_audio_config_mask,
            __input_audio,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DetectIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "session" => Ok(__FieldTag::__session),
                            "queryParams" => Ok(__FieldTag::__query_params),
                            "query_params" => Ok(__FieldTag::__query_params),
                            "queryInput" => Ok(__FieldTag::__query_input),
                            "query_input" => Ok(__FieldTag::__query_input),
                            "outputAudioConfig" => Ok(__FieldTag::__output_audio_config),
                            "output_audio_config" => Ok(__FieldTag::__output_audio_config),
                            "outputAudioConfigMask" => Ok(__FieldTag::__output_audio_config_mask),
                            "output_audio_config_mask" => {
                                Ok(__FieldTag::__output_audio_config_mask)
                            }
                            "inputAudio" => Ok(__FieldTag::__input_audio),
                            "input_audio" => Ok(__FieldTag::__input_audio),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DetectIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DetectIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session => {
                            if !fields.insert(__FieldTag::__session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session",
                                ));
                            }
                            result.session = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_params => {
                            if !fields.insert(__FieldTag::__query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_params",
                                ));
                            }
                            result.query_params = map
                                .next_value::<std::option::Option<crate::model::QueryParameters>>(
                                )?;
                        }
                        __FieldTag::__query_input => {
                            if !fields.insert(__FieldTag::__query_input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_input",
                                ));
                            }
                            result.query_input =
                                map.next_value::<std::option::Option<crate::model::QueryInput>>()?;
                        }
                        __FieldTag::__output_audio_config => {
                            if !fields.insert(__FieldTag::__output_audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_audio_config",
                                ));
                            }
                            result.output_audio_config = map
                                .next_value::<std::option::Option<crate::model::OutputAudioConfig>>(
                                )?;
                        }
                        __FieldTag::__output_audio_config_mask => {
                            if !fields.insert(__FieldTag::__output_audio_config_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_audio_config_mask",
                                ));
                            }
                            result.output_audio_config_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__input_audio => {
                            if !fields.insert(__FieldTag::__input_audio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_audio",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.input_audio = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for DetectIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if self.query_params.is_some() {
            state.serialize_entry("queryParams", &self.query_params)?;
        }
        if self.query_input.is_some() {
            state.serialize_entry("queryInput", &self.query_input)?;
        }
        if self.output_audio_config.is_some() {
            state.serialize_entry("outputAudioConfig", &self.output_audio_config)?;
        }
        if self.output_audio_config_mask.is_some() {
            state.serialize_entry("outputAudioConfigMask", &self.output_audio_config_mask)?;
        }
        if !self.input_audio.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("inputAudio", &__With(&self.input_audio))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The message returned from the [DetectIntent][] method.
#[cfg(any(feature = "participants", feature = "sessions",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DetectIntentResponse {
    /// The unique identifier of the response. It can be used to
    /// locate a response in the training example set or for reporting issues.
    pub response_id: std::string::String,

    /// The selected results of the conversational query or event processing.
    /// See `alternative_query_results` for additional potential results.
    pub query_result: std::option::Option<crate::model::QueryResult>,

    /// Specifies the status of the webhook request.
    pub webhook_status: std::option::Option<rpc::model::Status>,

    /// The audio data bytes encoded as specified in the request.
    /// Note: The output audio is generated based on the values of default platform
    /// text responses found in the `query_result.fulfillment_messages` field. If
    /// multiple default text responses exist, they will be concatenated when
    /// generating audio. If no default platform text responses exist, the
    /// generated audio content will be empty.
    ///
    /// In some scenarios, multiple output audio fields may be present in the
    /// response structure. In these cases, only the top-most-level audio output
    /// has content.
    pub output_audio: ::bytes::Bytes,

    /// The config used by the speech synthesizer to generate the output audio.
    pub output_audio_config: std::option::Option<crate::model::OutputAudioConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl DetectIntentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [response_id][crate::model::DetectIntentResponse::response_id].
    pub fn set_response_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.response_id = v.into();
        self
    }

    /// Sets the value of [query_result][crate::model::DetectIntentResponse::query_result].
    pub fn set_query_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryResult>,
    {
        self.query_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_result][crate::model::DetectIntentResponse::query_result].
    pub fn set_or_clear_query_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryResult>,
    {
        self.query_result = v.map(|x| x.into());
        self
    }

    /// Sets the value of [webhook_status][crate::model::DetectIntentResponse::webhook_status].
    pub fn set_webhook_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.webhook_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [webhook_status][crate::model::DetectIntentResponse::webhook_status].
    pub fn set_or_clear_webhook_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.webhook_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_audio][crate::model::DetectIntentResponse::output_audio].
    pub fn set_output_audio<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.output_audio = v.into();
        self
    }

    /// Sets the value of [output_audio_config][crate::model::DetectIntentResponse::output_audio_config].
    pub fn set_output_audio_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.output_audio_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_audio_config][crate::model::DetectIntentResponse::output_audio_config].
    pub fn set_or_clear_output_audio_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.output_audio_config = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl wkt::message::Message for DetectIntentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DetectIntentResponse"
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DetectIntentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __response_id,
            __query_result,
            __webhook_status,
            __output_audio,
            __output_audio_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DetectIntentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "responseId" => Ok(__FieldTag::__response_id),
                            "response_id" => Ok(__FieldTag::__response_id),
                            "queryResult" => Ok(__FieldTag::__query_result),
                            "query_result" => Ok(__FieldTag::__query_result),
                            "webhookStatus" => Ok(__FieldTag::__webhook_status),
                            "webhook_status" => Ok(__FieldTag::__webhook_status),
                            "outputAudio" => Ok(__FieldTag::__output_audio),
                            "output_audio" => Ok(__FieldTag::__output_audio),
                            "outputAudioConfig" => Ok(__FieldTag::__output_audio_config),
                            "output_audio_config" => Ok(__FieldTag::__output_audio_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DetectIntentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DetectIntentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__response_id => {
                            if !fields.insert(__FieldTag::__response_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_id",
                                ));
                            }
                            result.response_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_result => {
                            if !fields.insert(__FieldTag::__query_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_result",
                                ));
                            }
                            result.query_result =
                                map.next_value::<std::option::Option<crate::model::QueryResult>>()?;
                        }
                        __FieldTag::__webhook_status => {
                            if !fields.insert(__FieldTag::__webhook_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_status",
                                ));
                            }
                            result.webhook_status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__output_audio => {
                            if !fields.insert(__FieldTag::__output_audio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_audio",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.output_audio = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__output_audio_config => {
                            if !fields.insert(__FieldTag::__output_audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_audio_config",
                                ));
                            }
                            result.output_audio_config = map
                                .next_value::<std::option::Option<crate::model::OutputAudioConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for DetectIntentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.response_id.is_empty() {
            state.serialize_entry("responseId", &self.response_id)?;
        }
        if self.query_result.is_some() {
            state.serialize_entry("queryResult", &self.query_result)?;
        }
        if self.webhook_status.is_some() {
            state.serialize_entry("webhookStatus", &self.webhook_status)?;
        }
        if !self.output_audio.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("outputAudio", &__With(&self.output_audio))?;
        }
        if self.output_audio_config.is_some() {
            state.serialize_entry("outputAudioConfig", &self.output_audio_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the parameters of the conversational query.
#[cfg(any(feature = "participants", feature = "sessions",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryParameters {
    /// The time zone of this conversational query from the
    /// [time zone database](https://www.iana.org/time-zones), e.g.,
    /// America/New_York, Europe/Paris. If not provided, the time zone specified in
    /// agent settings is used.
    pub time_zone: std::string::String,

    /// The geo location of this conversational query.
    pub geo_location: std::option::Option<gtype::model::LatLng>,

    /// The collection of contexts to be activated before this query is
    /// executed.
    pub contexts: std::vec::Vec<crate::model::Context>,

    /// Specifies whether to delete all contexts in the current session
    /// before the new ones are activated.
    pub reset_contexts: bool,

    /// Additional session entity types to replace or extend developer
    /// entity types with. The entity synonyms apply to all languages and persist
    /// for the session of this query.
    pub session_entity_types: std::vec::Vec<crate::model::SessionEntityType>,

    /// This field can be used to pass custom data to your webhook.
    /// Arbitrary JSON objects are supported.
    /// If supplied, the value is used to populate the
    /// `WebhookRequest.original_detect_intent_request.payload`
    /// field sent to your webhook.
    pub payload: std::option::Option<wkt::Struct>,

    /// Configures the type of sentiment analysis to perform. If not
    /// provided, sentiment analysis is not performed.
    pub sentiment_analysis_request_config:
        std::option::Option<crate::model::SentimentAnalysisRequestConfig>,

    /// This field can be used to pass HTTP headers for a webhook
    /// call. These headers will be sent to webhook along with the headers that
    /// have been configured through the Dialogflow web console. The headers
    /// defined within this field will overwrite the headers configured through the
    /// Dialogflow console if there is a conflict. Header names are
    /// case-insensitive. Google's specified headers are not allowed. Including:
    /// "Host", "Content-Length", "Connection", "From", "User-Agent",
    /// "Accept-Encoding", "If-Modified-Since", "If-None-Match", "X-Forwarded-For",
    /// etc.
    pub webhook_headers: std::collections::HashMap<std::string::String, std::string::String>,

    /// The platform of the virtual agent response messages.
    ///
    /// If not empty, only emits messages from this platform in the response.
    /// Valid values are the enum names of
    /// [platform][google.cloud.dialogflow.v2.Intent.Message.platform].
    ///
    /// [google.cloud.dialogflow.v2.Intent.Message.platform]: crate::model::intent::Message::platform
    pub platform: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl QueryParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [time_zone][crate::model::QueryParameters::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [geo_location][crate::model::QueryParameters::geo_location].
    pub fn set_geo_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::LatLng>,
    {
        self.geo_location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [geo_location][crate::model::QueryParameters::geo_location].
    pub fn set_or_clear_geo_location<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::LatLng>,
    {
        self.geo_location = v.map(|x| x.into());
        self
    }

    /// Sets the value of [contexts][crate::model::QueryParameters::contexts].
    pub fn set_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Context>,
    {
        use std::iter::Iterator;
        self.contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [reset_contexts][crate::model::QueryParameters::reset_contexts].
    pub fn set_reset_contexts<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reset_contexts = v.into();
        self
    }

    /// Sets the value of [session_entity_types][crate::model::QueryParameters::session_entity_types].
    pub fn set_session_entity_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SessionEntityType>,
    {
        use std::iter::Iterator;
        self.session_entity_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [payload][crate::model::QueryParameters::payload].
    pub fn set_payload<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.payload = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [payload][crate::model::QueryParameters::payload].
    pub fn set_or_clear_payload<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.payload = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sentiment_analysis_request_config][crate::model::QueryParameters::sentiment_analysis_request_config].
    pub fn set_sentiment_analysis_request_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SentimentAnalysisRequestConfig>,
    {
        self.sentiment_analysis_request_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sentiment_analysis_request_config][crate::model::QueryParameters::sentiment_analysis_request_config].
    pub fn set_or_clear_sentiment_analysis_request_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::SentimentAnalysisRequestConfig>,
    {
        self.sentiment_analysis_request_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [webhook_headers][crate::model::QueryParameters::webhook_headers].
    pub fn set_webhook_headers<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.webhook_headers = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [platform][crate::model::QueryParameters::platform].
    pub fn set_platform<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.platform = v.into();
        self
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl wkt::message::Message for QueryParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.QueryParameters"
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryParameters {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __time_zone,
            __geo_location,
            __contexts,
            __reset_contexts,
            __session_entity_types,
            __payload,
            __sentiment_analysis_request_config,
            __webhook_headers,
            __platform,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryParameters")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "geoLocation" => Ok(__FieldTag::__geo_location),
                            "geo_location" => Ok(__FieldTag::__geo_location),
                            "contexts" => Ok(__FieldTag::__contexts),
                            "resetContexts" => Ok(__FieldTag::__reset_contexts),
                            "reset_contexts" => Ok(__FieldTag::__reset_contexts),
                            "sessionEntityTypes" => Ok(__FieldTag::__session_entity_types),
                            "session_entity_types" => Ok(__FieldTag::__session_entity_types),
                            "payload" => Ok(__FieldTag::__payload),
                            "sentimentAnalysisRequestConfig" => {
                                Ok(__FieldTag::__sentiment_analysis_request_config)
                            }
                            "sentiment_analysis_request_config" => {
                                Ok(__FieldTag::__sentiment_analysis_request_config)
                            }
                            "webhookHeaders" => Ok(__FieldTag::__webhook_headers),
                            "webhook_headers" => Ok(__FieldTag::__webhook_headers),
                            "platform" => Ok(__FieldTag::__platform),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryParameters;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryParameters")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__geo_location => {
                            if !fields.insert(__FieldTag::__geo_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for geo_location",
                                ));
                            }
                            result.geo_location =
                                map.next_value::<std::option::Option<gtype::model::LatLng>>()?;
                        }
                        __FieldTag::__contexts => {
                            if !fields.insert(__FieldTag::__contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contexts",
                                ));
                            }
                            result.contexts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Context>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__reset_contexts => {
                            if !fields.insert(__FieldTag::__reset_contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reset_contexts",
                                ));
                            }
                            result.reset_contexts = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__session_entity_types => {
                            if !fields.insert(__FieldTag::__session_entity_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_entity_types",
                                ));
                            }
                            result.session_entity_types =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SessionEntityType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__payload => {
                            if !fields.insert(__FieldTag::__payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload",
                                ));
                            }
                            result.payload =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__sentiment_analysis_request_config => {
                            if !fields.insert(__FieldTag::__sentiment_analysis_request_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sentiment_analysis_request_config",
                                ));
                            }
                            result.sentiment_analysis_request_config =
                                map.next_value::<std::option::Option<
                                    crate::model::SentimentAnalysisRequestConfig,
                                >>()?;
                        }
                        __FieldTag::__webhook_headers => {
                            if !fields.insert(__FieldTag::__webhook_headers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_headers",
                                ));
                            }
                            result.webhook_headers = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__platform => {
                            if !fields.insert(__FieldTag::__platform) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for platform",
                                ));
                            }
                            result.platform = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for QueryParameters {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if self.geo_location.is_some() {
            state.serialize_entry("geoLocation", &self.geo_location)?;
        }
        if !self.contexts.is_empty() {
            state.serialize_entry("contexts", &self.contexts)?;
        }
        if !wkt::internal::is_default(&self.reset_contexts) {
            state.serialize_entry("resetContexts", &self.reset_contexts)?;
        }
        if !self.session_entity_types.is_empty() {
            state.serialize_entry("sessionEntityTypes", &self.session_entity_types)?;
        }
        if self.payload.is_some() {
            state.serialize_entry("payload", &self.payload)?;
        }
        if self.sentiment_analysis_request_config.is_some() {
            state.serialize_entry(
                "sentimentAnalysisRequestConfig",
                &self.sentiment_analysis_request_config,
            )?;
        }
        if !self.webhook_headers.is_empty() {
            state.serialize_entry("webhookHeaders", &self.webhook_headers)?;
        }
        if !self.platform.is_empty() {
            state.serialize_entry("platform", &self.platform)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the query input. It can contain either:
///
/// 1. An audio config which instructs the speech recognizer how to process the
///    speech audio.
///
/// 1. A conversational query in the form of text.
///
/// 1. An event that specifies which intent to trigger.
///
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryInput {
    /// Required. The input specification.
    pub input: std::option::Option<crate::model::query_input::Input>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl QueryInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [input][crate::model::QueryInput::input].
    ///
    /// Note that all the setters affecting `input` are mutually
    /// exclusive.
    pub fn set_input<
        T: std::convert::Into<std::option::Option<crate::model::query_input::Input>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input = v.into();
        self
    }

    /// The value of [input][crate::model::QueryInput::input]
    /// if it holds a `AudioConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn audio_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InputAudioConfig>> {
        #[allow(unreachable_patterns)]
        self.input.as_ref().and_then(|v| match v {
            crate::model::query_input::Input::AudioConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input][crate::model::QueryInput::input]
    /// to hold a `AudioConfig`.
    ///
    /// Note that all the setters affecting `input` are
    /// mutually exclusive.
    pub fn set_audio_config<
        T: std::convert::Into<std::boxed::Box<crate::model::InputAudioConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.input =
            std::option::Option::Some(crate::model::query_input::Input::AudioConfig(v.into()));
        self
    }

    /// The value of [input][crate::model::QueryInput::input]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text(&self) -> std::option::Option<&std::boxed::Box<crate::model::TextInput>> {
        #[allow(unreachable_patterns)]
        self.input.as_ref().and_then(|v| match v {
            crate::model::query_input::Input::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input][crate::model::QueryInput::input]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `input` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::boxed::Box<crate::model::TextInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.input = std::option::Option::Some(crate::model::query_input::Input::Text(v.into()));
        self
    }

    /// The value of [input][crate::model::QueryInput::input]
    /// if it holds a `Event`, `None` if the field is not set or
    /// holds a different branch.
    pub fn event(&self) -> std::option::Option<&std::boxed::Box<crate::model::EventInput>> {
        #[allow(unreachable_patterns)]
        self.input.as_ref().and_then(|v| match v {
            crate::model::query_input::Input::Event(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [input][crate::model::QueryInput::input]
    /// to hold a `Event`.
    ///
    /// Note that all the setters affecting `input` are
    /// mutually exclusive.
    pub fn set_event<T: std::convert::Into<std::boxed::Box<crate::model::EventInput>>>(
        mut self,
        v: T,
    ) -> Self {
        self.input = std::option::Option::Some(crate::model::query_input::Input::Event(v.into()));
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for QueryInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.QueryInput"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_config,
            __text,
            __event,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioConfig" => Ok(__FieldTag::__audio_config),
                            "audio_config" => Ok(__FieldTag::__audio_config),
                            "text" => Ok(__FieldTag::__text),
                            "event" => Ok(__FieldTag::__event),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_config => {
                            if !fields.insert(__FieldTag::__audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_config",
                                ));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.QueryInput.audio_config, latest field was audioConfig",
                                ));
                            }
                            result.input = std::option::Option::Some(
                                crate::model::query_input::Input::AudioConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InputAudioConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.QueryInput.text, latest field was text",
                                ));
                            }
                            result.input =
                                std::option::Option::Some(crate::model::query_input::Input::Text(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::TextInput>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__event => {
                            if !fields.insert(__FieldTag::__event) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event",
                                ));
                            }
                            if result.input.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `input`, a oneof with full ID .google.cloud.dialogflow.v2.QueryInput.event, latest field was event",
                                ));
                            }
                            result.input =
                                std::option::Option::Some(crate::model::query_input::Input::Event(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::EventInput>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for QueryInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.audio_config() {
            state.serialize_entry("audioConfig", value)?;
        }
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.event() {
            state.serialize_entry("event", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [QueryInput].
#[cfg(feature = "sessions")]
pub mod query_input {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The input specification.
    #[cfg(feature = "sessions")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Input {
        /// Instructs the speech recognizer how to process the speech audio.
        AudioConfig(std::boxed::Box<crate::model::InputAudioConfig>),
        /// The natural language text to be processed. Text length must not exceed
        /// 256 character for virtual agent interactions.
        Text(std::boxed::Box<crate::model::TextInput>),
        /// The event to be processed.
        Event(std::boxed::Box<crate::model::EventInput>),
    }
}

/// Represents the result of conversational query or event processing.
#[cfg(any(
    feature = "answer-records",
    feature = "participants",
    feature = "sessions",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryResult {
    /// The original conversational query text:
    ///
    /// - If natural language text was provided as input, `query_text` contains
    ///   a copy of the input.
    /// - If natural language speech audio was provided as input, `query_text`
    ///   contains the speech recognition result. If speech recognizer produced
    ///   multiple alternatives, a particular one is picked.
    /// - If automatic spell correction is enabled, `query_text` will contain the
    ///   corrected user input.
    pub query_text: std::string::String,

    /// The language that was triggered during intent detection.
    /// See [Language
    /// Support](https://cloud.google.com/dialogflow/docs/reference/language)
    /// for a list of the currently supported language codes.
    pub language_code: std::string::String,

    /// The Speech recognition confidence between 0.0 and 1.0. A higher number
    /// indicates an estimated greater likelihood that the recognized words are
    /// correct. The default of 0.0 is a sentinel value indicating that confidence
    /// was not set.
    ///
    /// This field is not guaranteed to be accurate or set. In particular this
    /// field isn't set for [StreamingDetectIntent][] since the streaming endpoint
    /// has separate confidence estimates per portion of the audio in
    /// StreamingRecognitionResult.
    pub speech_recognition_confidence: f32,

    /// The action name from the matched intent.
    pub action: std::string::String,

    /// The collection of extracted parameters.
    ///
    /// Depending on your protocol or client library language, this is a
    /// map, associative array, symbol table, dictionary, or JSON object
    /// composed of a collection of (MapKey, MapValue) pairs:
    ///
    /// * MapKey type: string
    /// * MapKey value: parameter name
    /// * MapValue type: If parameter's entity type is a composite entity then use
    ///   map, otherwise, depending on the parameter value type, it could be one of
    ///   string, number, boolean, null, list or map.
    /// * MapValue value: If parameter's entity type is a composite entity then use
    ///   map from composite entity property names to property values, otherwise,
    ///   use parameter value.
    pub parameters: std::option::Option<wkt::Struct>,

    /// This field is set to:
    ///
    /// - `false` if the matched intent has required parameters and not all of
    ///   the required parameter values have been collected.
    /// - `true` if all required parameter values have been collected, or if the
    ///   matched intent doesn't contain any required parameters.
    pub all_required_params_present: bool,

    /// Indicates whether the conversational query triggers a cancellation for slot
    /// filling. For more information, see the [cancel slot filling
    /// documentation](https://cloud.google.com/dialogflow/es/docs/intents-actions-parameters#cancel).
    pub cancels_slot_filling: bool,

    /// The text to be pronounced to the user or shown on the screen.
    /// Note: This is a legacy field, `fulfillment_messages` should be preferred.
    pub fulfillment_text: std::string::String,

    /// The collection of rich messages to present to the user.
    pub fulfillment_messages: std::vec::Vec<crate::model::intent::Message>,

    /// If the query was fulfilled by a webhook call, this field is set to the
    /// value of the `source` field returned in the webhook response.
    pub webhook_source: std::string::String,

    /// If the query was fulfilled by a webhook call, this field is set to the
    /// value of the `payload` field returned in the webhook response.
    pub webhook_payload: std::option::Option<wkt::Struct>,

    /// The collection of output contexts. If applicable,
    /// `output_contexts.parameters` contains entries with name
    /// `<parameter name>.original` containing the original parameter values
    /// before the query.
    pub output_contexts: std::vec::Vec<crate::model::Context>,

    /// The intent that matched the conversational query. Some, not
    /// all fields are filled in this message, including but not limited to:
    /// `name`, `display_name`, `end_interaction` and `is_fallback`.
    pub intent: std::option::Option<crate::model::Intent>,

    /// The intent detection confidence. Values range from 0.0
    /// (completely uncertain) to 1.0 (completely certain).
    /// This value is for informational purpose only and is only used to
    /// help match the best intent within the classification threshold.
    /// This value may change for the same end-user expression at any time due to a
    /// model retraining or change in implementation.
    /// If there are `multiple knowledge_answers` messages, this value is set to
    /// the greatest `knowledgeAnswers.match_confidence` value in the list.
    pub intent_detection_confidence: f32,

    /// Free-form diagnostic information for the associated detect intent request.
    /// The fields of this data can change without notice, so you should not write
    /// code that depends on its structure.
    /// The data may contain:
    ///
    /// - webhook call latency
    /// - webhook errors
    pub diagnostic_info: std::option::Option<wkt::Struct>,

    /// The sentiment analysis result, which depends on the
    /// `sentiment_analysis_request_config` specified in the request.
    pub sentiment_analysis_result: std::option::Option<crate::model::SentimentAnalysisResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "answer-records",
    feature = "participants",
    feature = "sessions",
))]
impl QueryResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query_text][crate::model::QueryResult::query_text].
    pub fn set_query_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query_text = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::QueryResult::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }

    /// Sets the value of [speech_recognition_confidence][crate::model::QueryResult::speech_recognition_confidence].
    pub fn set_speech_recognition_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.speech_recognition_confidence = v.into();
        self
    }

    /// Sets the value of [action][crate::model::QueryResult::action].
    pub fn set_action<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::QueryResult::parameters].
    pub fn set_parameters<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.parameters = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [parameters][crate::model::QueryResult::parameters].
    pub fn set_or_clear_parameters<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.parameters = v.map(|x| x.into());
        self
    }

    /// Sets the value of [all_required_params_present][crate::model::QueryResult::all_required_params_present].
    pub fn set_all_required_params_present<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.all_required_params_present = v.into();
        self
    }

    /// Sets the value of [cancels_slot_filling][crate::model::QueryResult::cancels_slot_filling].
    pub fn set_cancels_slot_filling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.cancels_slot_filling = v.into();
        self
    }

    /// Sets the value of [fulfillment_text][crate::model::QueryResult::fulfillment_text].
    pub fn set_fulfillment_text<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.fulfillment_text = v.into();
        self
    }

    /// Sets the value of [fulfillment_messages][crate::model::QueryResult::fulfillment_messages].
    pub fn set_fulfillment_messages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::intent::Message>,
    {
        use std::iter::Iterator;
        self.fulfillment_messages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [webhook_source][crate::model::QueryResult::webhook_source].
    pub fn set_webhook_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.webhook_source = v.into();
        self
    }

    /// Sets the value of [webhook_payload][crate::model::QueryResult::webhook_payload].
    pub fn set_webhook_payload<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.webhook_payload = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [webhook_payload][crate::model::QueryResult::webhook_payload].
    pub fn set_or_clear_webhook_payload<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.webhook_payload = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_contexts][crate::model::QueryResult::output_contexts].
    pub fn set_output_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Context>,
    {
        use std::iter::Iterator;
        self.output_contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [intent][crate::model::QueryResult::intent].
    pub fn set_intent<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Intent>,
    {
        self.intent = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [intent][crate::model::QueryResult::intent].
    pub fn set_or_clear_intent<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Intent>,
    {
        self.intent = v.map(|x| x.into());
        self
    }

    /// Sets the value of [intent_detection_confidence][crate::model::QueryResult::intent_detection_confidence].
    pub fn set_intent_detection_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.intent_detection_confidence = v.into();
        self
    }

    /// Sets the value of [diagnostic_info][crate::model::QueryResult::diagnostic_info].
    pub fn set_diagnostic_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.diagnostic_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [diagnostic_info][crate::model::QueryResult::diagnostic_info].
    pub fn set_or_clear_diagnostic_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.diagnostic_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sentiment_analysis_result][crate::model::QueryResult::sentiment_analysis_result].
    pub fn set_sentiment_analysis_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SentimentAnalysisResult>,
    {
        self.sentiment_analysis_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sentiment_analysis_result][crate::model::QueryResult::sentiment_analysis_result].
    pub fn set_or_clear_sentiment_analysis_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SentimentAnalysisResult>,
    {
        self.sentiment_analysis_result = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "participants",
    feature = "sessions",
))]
impl wkt::message::Message for QueryResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.QueryResult"
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query_text,
            __language_code,
            __speech_recognition_confidence,
            __action,
            __parameters,
            __all_required_params_present,
            __cancels_slot_filling,
            __fulfillment_text,
            __fulfillment_messages,
            __webhook_source,
            __webhook_payload,
            __output_contexts,
            __intent,
            __intent_detection_confidence,
            __diagnostic_info,
            __sentiment_analysis_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queryText" => Ok(__FieldTag::__query_text),
                            "query_text" => Ok(__FieldTag::__query_text),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            "speechRecognitionConfidence" => {
                                Ok(__FieldTag::__speech_recognition_confidence)
                            }
                            "speech_recognition_confidence" => {
                                Ok(__FieldTag::__speech_recognition_confidence)
                            }
                            "action" => Ok(__FieldTag::__action),
                            "parameters" => Ok(__FieldTag::__parameters),
                            "allRequiredParamsPresent" => {
                                Ok(__FieldTag::__all_required_params_present)
                            }
                            "all_required_params_present" => {
                                Ok(__FieldTag::__all_required_params_present)
                            }
                            "cancelsSlotFilling" => Ok(__FieldTag::__cancels_slot_filling),
                            "cancels_slot_filling" => Ok(__FieldTag::__cancels_slot_filling),
                            "fulfillmentText" => Ok(__FieldTag::__fulfillment_text),
                            "fulfillment_text" => Ok(__FieldTag::__fulfillment_text),
                            "fulfillmentMessages" => Ok(__FieldTag::__fulfillment_messages),
                            "fulfillment_messages" => Ok(__FieldTag::__fulfillment_messages),
                            "webhookSource" => Ok(__FieldTag::__webhook_source),
                            "webhook_source" => Ok(__FieldTag::__webhook_source),
                            "webhookPayload" => Ok(__FieldTag::__webhook_payload),
                            "webhook_payload" => Ok(__FieldTag::__webhook_payload),
                            "outputContexts" => Ok(__FieldTag::__output_contexts),
                            "output_contexts" => Ok(__FieldTag::__output_contexts),
                            "intent" => Ok(__FieldTag::__intent),
                            "intentDetectionConfidence" => {
                                Ok(__FieldTag::__intent_detection_confidence)
                            }
                            "intent_detection_confidence" => {
                                Ok(__FieldTag::__intent_detection_confidence)
                            }
                            "diagnosticInfo" => Ok(__FieldTag::__diagnostic_info),
                            "diagnostic_info" => Ok(__FieldTag::__diagnostic_info),
                            "sentimentAnalysisResult" => {
                                Ok(__FieldTag::__sentiment_analysis_result)
                            }
                            "sentiment_analysis_result" => {
                                Ok(__FieldTag::__sentiment_analysis_result)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query_text => {
                            if !fields.insert(__FieldTag::__query_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_text",
                                ));
                            }
                            result.query_text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__speech_recognition_confidence => {
                            if !fields.insert(__FieldTag::__speech_recognition_confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_recognition_confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.speech_recognition_confidence =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            result.action = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__all_required_params_present => {
                            if !fields.insert(__FieldTag::__all_required_params_present) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for all_required_params_present",
                                ));
                            }
                            result.all_required_params_present = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cancels_slot_filling => {
                            if !fields.insert(__FieldTag::__cancels_slot_filling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cancels_slot_filling",
                                ));
                            }
                            result.cancels_slot_filling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fulfillment_text => {
                            if !fields.insert(__FieldTag::__fulfillment_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fulfillment_text",
                                ));
                            }
                            result.fulfillment_text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fulfillment_messages => {
                            if !fields.insert(__FieldTag::__fulfillment_messages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fulfillment_messages",
                                ));
                            }
                            result.fulfillment_messages =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::intent::Message>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__webhook_source => {
                            if !fields.insert(__FieldTag::__webhook_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_source",
                                ));
                            }
                            result.webhook_source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__webhook_payload => {
                            if !fields.insert(__FieldTag::__webhook_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_payload",
                                ));
                            }
                            result.webhook_payload =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__output_contexts => {
                            if !fields.insert(__FieldTag::__output_contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_contexts",
                                ));
                            }
                            result.output_contexts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Context>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__intent => {
                            if !fields.insert(__FieldTag::__intent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent",
                                ));
                            }
                            result.intent =
                                map.next_value::<std::option::Option<crate::model::Intent>>()?;
                        }
                        __FieldTag::__intent_detection_confidence => {
                            if !fields.insert(__FieldTag::__intent_detection_confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intent_detection_confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.intent_detection_confidence =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__diagnostic_info => {
                            if !fields.insert(__FieldTag::__diagnostic_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for diagnostic_info",
                                ));
                            }
                            result.diagnostic_info =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__sentiment_analysis_result => {
                            if !fields.insert(__FieldTag::__sentiment_analysis_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sentiment_analysis_result",
                                ));
                            }
                            result.sentiment_analysis_result = map.next_value::<std::option::Option<crate::model::SentimentAnalysisResult>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for QueryResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.query_text.is_empty() {
            state.serialize_entry("queryText", &self.query_text)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !wkt::internal::is_default(&self.speech_recognition_confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "speechRecognitionConfidence",
                &__With(&self.speech_recognition_confidence),
            )?;
        }
        if !self.action.is_empty() {
            state.serialize_entry("action", &self.action)?;
        }
        if self.parameters.is_some() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !wkt::internal::is_default(&self.all_required_params_present) {
            state.serialize_entry(
                "allRequiredParamsPresent",
                &self.all_required_params_present,
            )?;
        }
        if !wkt::internal::is_default(&self.cancels_slot_filling) {
            state.serialize_entry("cancelsSlotFilling", &self.cancels_slot_filling)?;
        }
        if !self.fulfillment_text.is_empty() {
            state.serialize_entry("fulfillmentText", &self.fulfillment_text)?;
        }
        if !self.fulfillment_messages.is_empty() {
            state.serialize_entry("fulfillmentMessages", &self.fulfillment_messages)?;
        }
        if !self.webhook_source.is_empty() {
            state.serialize_entry("webhookSource", &self.webhook_source)?;
        }
        if self.webhook_payload.is_some() {
            state.serialize_entry("webhookPayload", &self.webhook_payload)?;
        }
        if !self.output_contexts.is_empty() {
            state.serialize_entry("outputContexts", &self.output_contexts)?;
        }
        if self.intent.is_some() {
            state.serialize_entry("intent", &self.intent)?;
        }
        if !wkt::internal::is_default(&self.intent_detection_confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "intentDetectionConfidence",
                &__With(&self.intent_detection_confidence),
            )?;
        }
        if self.diagnostic_info.is_some() {
            state.serialize_entry("diagnosticInfo", &self.diagnostic_info)?;
        }
        if self.sentiment_analysis_result.is_some() {
            state.serialize_entry("sentimentAnalysisResult", &self.sentiment_analysis_result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The top-level message sent by the client to the
/// [StreamingDetectIntent][] method.
///
/// Multiple request messages should be sent in order:
///
/// 1. The first message must contain
///    [session][google.cloud.dialogflow.v2.StreamingDetectIntentRequest.session],
///    [query_input][google.cloud.dialogflow.v2.StreamingDetectIntentRequest.query_input]
///    plus optionally
///    [query_params][google.cloud.dialogflow.v2.StreamingDetectIntentRequest.query_params].
///    If the client wants to receive an audio response, it should also contain
///    [output_audio_config][google.cloud.dialogflow.v2.StreamingDetectIntentRequest.output_audio_config].
///    The message must not contain
///    [input_audio][google.cloud.dialogflow.v2.StreamingDetectIntentRequest.input_audio].
///
/// 1. If
///    [query_input][google.cloud.dialogflow.v2.StreamingDetectIntentRequest.query_input]
///    was set to
///    [query_input.audio_config][google.cloud.dialogflow.v2.InputAudioConfig],
///    all subsequent messages must contain
///    [input_audio][google.cloud.dialogflow.v2.StreamingDetectIntentRequest.input_audio]
///    to continue with Speech recognition. If you decide to rather detect an
///    intent from text input after you already started Speech recognition,
///    please send a message with
///    [query_input.text][google.cloud.dialogflow.v2.QueryInput.text].
///
///    However, note that:
///
///    * Dialogflow will bill you for the audio duration so far.
///    * Dialogflow discards all Speech recognition results in favor of the
///      input text.
///    * Dialogflow will use the language code from the first message.
///
/// After you sent all input, you must half-close or abort the request stream.
///
/// [google.cloud.dialogflow.v2.InputAudioConfig]: crate::model::InputAudioConfig
/// [google.cloud.dialogflow.v2.QueryInput.text]: crate::model::QueryInput::input
/// [google.cloud.dialogflow.v2.StreamingDetectIntentRequest.input_audio]: crate::model::StreamingDetectIntentRequest::input_audio
/// [google.cloud.dialogflow.v2.StreamingDetectIntentRequest.output_audio_config]: crate::model::StreamingDetectIntentRequest::output_audio_config
/// [google.cloud.dialogflow.v2.StreamingDetectIntentRequest.query_input]: crate::model::StreamingDetectIntentRequest::query_input
/// [google.cloud.dialogflow.v2.StreamingDetectIntentRequest.query_params]: crate::model::StreamingDetectIntentRequest::query_params
/// [google.cloud.dialogflow.v2.StreamingDetectIntentRequest.session]: crate::model::StreamingDetectIntentRequest::session
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingDetectIntentRequest {
    /// Required. The name of the session the query is sent to.
    /// Format of the session name:
    /// `projects/<Project ID>/agent/sessions/<Session ID>`, or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>`. If `Environment ID` is not specified, we assume
    /// default 'draft' environment. If `User ID` is not specified, we are using
    /// "-". It's up to the API caller to choose an appropriate `Session ID` and
    /// `User Id`. They can be a random number or some type of user and session
    /// identifiers (preferably hashed). The length of the `Session ID` and
    /// `User ID` must not exceed 36 characters.
    ///
    /// For more information, see the [API interactions
    /// guide](https://cloud.google.com/dialogflow/docs/api-overview).
    ///
    /// Note: Always use agent versions for production traffic.
    /// See [Versions and
    /// environments](https://cloud.google.com/dialogflow/es/docs/agents-versions).
    pub session: std::string::String,

    /// The parameters of this query.
    pub query_params: std::option::Option<crate::model::QueryParameters>,

    /// Required. The input specification. It can be set to:
    ///
    /// 1. an audio config which instructs the speech recognizer how to process
    ///    the speech audio,
    ///
    /// 1. a conversational query in the form of text, or
    ///
    /// 1. an event that specifies which intent to trigger.
    ///
    pub query_input: std::option::Option<crate::model::QueryInput>,

    /// Please use
    /// [InputAudioConfig.single_utterance][google.cloud.dialogflow.v2.InputAudioConfig.single_utterance]
    /// instead. If `false` (default), recognition does not cease until the client
    /// closes the stream. If `true`, the recognizer will detect a single spoken
    /// utterance in input audio. Recognition ceases when it detects the audio's
    /// voice has stopped or paused. In this case, once a detected intent is
    /// received, the client should close the stream and start a new request with a
    /// new stream as needed. This setting is ignored when `query_input` is a piece
    /// of text or an event.
    ///
    /// [google.cloud.dialogflow.v2.InputAudioConfig.single_utterance]: crate::model::InputAudioConfig::single_utterance
    #[deprecated]
    pub single_utterance: bool,

    /// Instructs the speech synthesizer how to generate the output
    /// audio. If this field is not set and agent-level speech synthesizer is not
    /// configured, no output audio is generated.
    pub output_audio_config: std::option::Option<crate::model::OutputAudioConfig>,

    /// Mask for
    /// [output_audio_config][google.cloud.dialogflow.v2.StreamingDetectIntentRequest.output_audio_config]
    /// indicating which settings in this request-level config should override
    /// speech synthesizer settings defined at agent-level.
    ///
    /// If unspecified or empty,
    /// [output_audio_config][google.cloud.dialogflow.v2.StreamingDetectIntentRequest.output_audio_config]
    /// replaces the agent-level config in its entirety.
    ///
    /// [google.cloud.dialogflow.v2.StreamingDetectIntentRequest.output_audio_config]: crate::model::StreamingDetectIntentRequest::output_audio_config
    pub output_audio_config_mask: std::option::Option<wkt::FieldMask>,

    /// The input audio content to be recognized. Must be sent if
    /// `query_input` was set to a streaming input audio config. The complete audio
    /// over all streaming messages must not exceed 1 minute.
    pub input_audio: ::bytes::Bytes,

    /// if true, `StreamingDetectIntentResponse.debugging_info` will get populated.
    pub enable_debugging_info: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl StreamingDetectIntentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session][crate::model::StreamingDetectIntentRequest::session].
    pub fn set_session<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session = v.into();
        self
    }

    /// Sets the value of [query_params][crate::model::StreamingDetectIntentRequest::query_params].
    pub fn set_query_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameters>,
    {
        self.query_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_params][crate::model::StreamingDetectIntentRequest::query_params].
    pub fn set_or_clear_query_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryParameters>,
    {
        self.query_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query_input][crate::model::StreamingDetectIntentRequest::query_input].
    pub fn set_query_input<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryInput>,
    {
        self.query_input = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_input][crate::model::StreamingDetectIntentRequest::query_input].
    pub fn set_or_clear_query_input<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryInput>,
    {
        self.query_input = v.map(|x| x.into());
        self
    }

    /// Sets the value of [single_utterance][crate::model::StreamingDetectIntentRequest::single_utterance].
    #[deprecated]
    pub fn set_single_utterance<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.single_utterance = v.into();
        self
    }

    /// Sets the value of [output_audio_config][crate::model::StreamingDetectIntentRequest::output_audio_config].
    pub fn set_output_audio_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.output_audio_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_audio_config][crate::model::StreamingDetectIntentRequest::output_audio_config].
    pub fn set_or_clear_output_audio_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.output_audio_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_audio_config_mask][crate::model::StreamingDetectIntentRequest::output_audio_config_mask].
    pub fn set_output_audio_config_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.output_audio_config_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_audio_config_mask][crate::model::StreamingDetectIntentRequest::output_audio_config_mask].
    pub fn set_or_clear_output_audio_config_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.output_audio_config_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [input_audio][crate::model::StreamingDetectIntentRequest::input_audio].
    pub fn set_input_audio<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.input_audio = v.into();
        self
    }

    /// Sets the value of [enable_debugging_info][crate::model::StreamingDetectIntentRequest::enable_debugging_info].
    pub fn set_enable_debugging_info<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_debugging_info = v.into();
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for StreamingDetectIntentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.StreamingDetectIntentRequest"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingDetectIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session,
            __query_params,
            __query_input,
            __single_utterance,
            __output_audio_config,
            __output_audio_config_mask,
            __input_audio,
            __enable_debugging_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingDetectIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "session" => Ok(__FieldTag::__session),
                            "queryParams" => Ok(__FieldTag::__query_params),
                            "query_params" => Ok(__FieldTag::__query_params),
                            "queryInput" => Ok(__FieldTag::__query_input),
                            "query_input" => Ok(__FieldTag::__query_input),
                            "singleUtterance" => Ok(__FieldTag::__single_utterance),
                            "single_utterance" => Ok(__FieldTag::__single_utterance),
                            "outputAudioConfig" => Ok(__FieldTag::__output_audio_config),
                            "output_audio_config" => Ok(__FieldTag::__output_audio_config),
                            "outputAudioConfigMask" => Ok(__FieldTag::__output_audio_config_mask),
                            "output_audio_config_mask" => {
                                Ok(__FieldTag::__output_audio_config_mask)
                            }
                            "inputAudio" => Ok(__FieldTag::__input_audio),
                            "input_audio" => Ok(__FieldTag::__input_audio),
                            "enableDebuggingInfo" => Ok(__FieldTag::__enable_debugging_info),
                            "enable_debugging_info" => Ok(__FieldTag::__enable_debugging_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingDetectIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingDetectIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session => {
                            if !fields.insert(__FieldTag::__session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session",
                                ));
                            }
                            result.session = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_params => {
                            if !fields.insert(__FieldTag::__query_params) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_params",
                                ));
                            }
                            result.query_params = map
                                .next_value::<std::option::Option<crate::model::QueryParameters>>(
                                )?;
                        }
                        __FieldTag::__query_input => {
                            if !fields.insert(__FieldTag::__query_input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_input",
                                ));
                            }
                            result.query_input =
                                map.next_value::<std::option::Option<crate::model::QueryInput>>()?;
                        }
                        __FieldTag::__single_utterance => {
                            if !fields.insert(__FieldTag::__single_utterance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_utterance",
                                ));
                            }
                            result.single_utterance = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__output_audio_config => {
                            if !fields.insert(__FieldTag::__output_audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_audio_config",
                                ));
                            }
                            result.output_audio_config = map
                                .next_value::<std::option::Option<crate::model::OutputAudioConfig>>(
                                )?;
                        }
                        __FieldTag::__output_audio_config_mask => {
                            if !fields.insert(__FieldTag::__output_audio_config_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_audio_config_mask",
                                ));
                            }
                            result.output_audio_config_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__input_audio => {
                            if !fields.insert(__FieldTag::__input_audio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for input_audio",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.input_audio = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__enable_debugging_info => {
                            if !fields.insert(__FieldTag::__enable_debugging_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_debugging_info",
                                ));
                            }
                            result.enable_debugging_info = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for StreamingDetectIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if self.query_params.is_some() {
            state.serialize_entry("queryParams", &self.query_params)?;
        }
        if self.query_input.is_some() {
            state.serialize_entry("queryInput", &self.query_input)?;
        }
        if !wkt::internal::is_default(&self.single_utterance) {
            state.serialize_entry("singleUtterance", &self.single_utterance)?;
        }
        if self.output_audio_config.is_some() {
            state.serialize_entry("outputAudioConfig", &self.output_audio_config)?;
        }
        if self.output_audio_config_mask.is_some() {
            state.serialize_entry("outputAudioConfigMask", &self.output_audio_config_mask)?;
        }
        if !self.input_audio.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("inputAudio", &__With(&self.input_audio))?;
        }
        if !wkt::internal::is_default(&self.enable_debugging_info) {
            state.serialize_entry("enableDebuggingInfo", &self.enable_debugging_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Cloud conversation info for easier debugging.
/// It will get populated in `StreamingDetectIntentResponse` or
/// `StreamingAnalyzeContentResponse` when the flag `enable_debugging_info` is
/// set to true in corresponding requests.
#[cfg(any(feature = "participants", feature = "sessions",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudConversationDebuggingInfo {
    /// Number of input audio data chunks in streaming requests.
    pub audio_data_chunks: i32,

    /// Time offset of the end of speech utterance relative to the
    /// beginning of the first audio chunk.
    pub result_end_time_offset: std::option::Option<wkt::Duration>,

    /// Duration of first audio chunk.
    pub first_audio_duration: std::option::Option<wkt::Duration>,

    /// Whether client used single utterance mode.
    pub single_utterance: bool,

    /// Time offsets of the speech partial results relative to the beginning of
    /// the stream.
    pub speech_partial_results_end_times: std::vec::Vec<wkt::Duration>,

    /// Time offsets of the speech final results (is_final=true) relative to the
    /// beginning of the stream.
    pub speech_final_results_end_times: std::vec::Vec<wkt::Duration>,

    /// Total number of partial responses.
    pub partial_responses: i32,

    /// Time offset of Speaker ID stream close time relative to the Speech stream
    /// close time in milliseconds. Only meaningful for conversations involving
    /// passive verification.
    pub speaker_id_passive_latency_ms_offset: i32,

    /// Whether a barge-in event is triggered in this request.
    pub bargein_event_triggered: bool,

    /// Whether speech uses single utterance mode.
    pub speech_single_utterance: bool,

    /// Time offsets of the DTMF partial results relative to the beginning of
    /// the stream.
    pub dtmf_partial_results_times: std::vec::Vec<wkt::Duration>,

    /// Time offsets of the DTMF final results relative to the beginning of
    /// the stream.
    pub dtmf_final_results_times: std::vec::Vec<wkt::Duration>,

    /// Time offset of the end-of-single-utterance signal relative to the
    /// beginning of the stream.
    pub single_utterance_end_time_offset: std::option::Option<wkt::Duration>,

    /// No speech timeout settings for the stream.
    pub no_speech_timeout: std::option::Option<wkt::Duration>,

    /// Speech endpointing timeout settings for the stream.
    pub endpointing_timeout: std::option::Option<wkt::Duration>,

    /// Whether the streaming terminates with an injected text query.
    pub is_input_text: bool,

    /// Client half close time in terms of input audio duration.
    pub client_half_close_time_offset: std::option::Option<wkt::Duration>,

    /// Client half close time in terms of API streaming duration.
    pub client_half_close_streaming_time_offset: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl CloudConversationDebuggingInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audio_data_chunks][crate::model::CloudConversationDebuggingInfo::audio_data_chunks].
    pub fn set_audio_data_chunks<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.audio_data_chunks = v.into();
        self
    }

    /// Sets the value of [result_end_time_offset][crate::model::CloudConversationDebuggingInfo::result_end_time_offset].
    pub fn set_result_end_time_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.result_end_time_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [result_end_time_offset][crate::model::CloudConversationDebuggingInfo::result_end_time_offset].
    pub fn set_or_clear_result_end_time_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.result_end_time_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [first_audio_duration][crate::model::CloudConversationDebuggingInfo::first_audio_duration].
    pub fn set_first_audio_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.first_audio_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [first_audio_duration][crate::model::CloudConversationDebuggingInfo::first_audio_duration].
    pub fn set_or_clear_first_audio_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.first_audio_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [single_utterance][crate::model::CloudConversationDebuggingInfo::single_utterance].
    pub fn set_single_utterance<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.single_utterance = v.into();
        self
    }

    /// Sets the value of [speech_partial_results_end_times][crate::model::CloudConversationDebuggingInfo::speech_partial_results_end_times].
    pub fn set_speech_partial_results_end_times<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Duration>,
    {
        use std::iter::Iterator;
        self.speech_partial_results_end_times = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [speech_final_results_end_times][crate::model::CloudConversationDebuggingInfo::speech_final_results_end_times].
    pub fn set_speech_final_results_end_times<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Duration>,
    {
        use std::iter::Iterator;
        self.speech_final_results_end_times = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [partial_responses][crate::model::CloudConversationDebuggingInfo::partial_responses].
    pub fn set_partial_responses<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.partial_responses = v.into();
        self
    }

    /// Sets the value of [speaker_id_passive_latency_ms_offset][crate::model::CloudConversationDebuggingInfo::speaker_id_passive_latency_ms_offset].
    pub fn set_speaker_id_passive_latency_ms_offset<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.speaker_id_passive_latency_ms_offset = v.into();
        self
    }

    /// Sets the value of [bargein_event_triggered][crate::model::CloudConversationDebuggingInfo::bargein_event_triggered].
    pub fn set_bargein_event_triggered<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.bargein_event_triggered = v.into();
        self
    }

    /// Sets the value of [speech_single_utterance][crate::model::CloudConversationDebuggingInfo::speech_single_utterance].
    pub fn set_speech_single_utterance<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.speech_single_utterance = v.into();
        self
    }

    /// Sets the value of [dtmf_partial_results_times][crate::model::CloudConversationDebuggingInfo::dtmf_partial_results_times].
    pub fn set_dtmf_partial_results_times<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Duration>,
    {
        use std::iter::Iterator;
        self.dtmf_partial_results_times = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dtmf_final_results_times][crate::model::CloudConversationDebuggingInfo::dtmf_final_results_times].
    pub fn set_dtmf_final_results_times<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Duration>,
    {
        use std::iter::Iterator;
        self.dtmf_final_results_times = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [single_utterance_end_time_offset][crate::model::CloudConversationDebuggingInfo::single_utterance_end_time_offset].
    pub fn set_single_utterance_end_time_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.single_utterance_end_time_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [single_utterance_end_time_offset][crate::model::CloudConversationDebuggingInfo::single_utterance_end_time_offset].
    pub fn set_or_clear_single_utterance_end_time_offset<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.single_utterance_end_time_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [no_speech_timeout][crate::model::CloudConversationDebuggingInfo::no_speech_timeout].
    pub fn set_no_speech_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.no_speech_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [no_speech_timeout][crate::model::CloudConversationDebuggingInfo::no_speech_timeout].
    pub fn set_or_clear_no_speech_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.no_speech_timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [endpointing_timeout][crate::model::CloudConversationDebuggingInfo::endpointing_timeout].
    pub fn set_endpointing_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.endpointing_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [endpointing_timeout][crate::model::CloudConversationDebuggingInfo::endpointing_timeout].
    pub fn set_or_clear_endpointing_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.endpointing_timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [is_input_text][crate::model::CloudConversationDebuggingInfo::is_input_text].
    pub fn set_is_input_text<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_input_text = v.into();
        self
    }

    /// Sets the value of [client_half_close_time_offset][crate::model::CloudConversationDebuggingInfo::client_half_close_time_offset].
    pub fn set_client_half_close_time_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.client_half_close_time_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_half_close_time_offset][crate::model::CloudConversationDebuggingInfo::client_half_close_time_offset].
    pub fn set_or_clear_client_half_close_time_offset<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.client_half_close_time_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [client_half_close_streaming_time_offset][crate::model::CloudConversationDebuggingInfo::client_half_close_streaming_time_offset].
    pub fn set_client_half_close_streaming_time_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.client_half_close_streaming_time_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_half_close_streaming_time_offset][crate::model::CloudConversationDebuggingInfo::client_half_close_streaming_time_offset].
    pub fn set_or_clear_client_half_close_streaming_time_offset<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.client_half_close_streaming_time_offset = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl wkt::message::Message for CloudConversationDebuggingInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CloudConversationDebuggingInfo"
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudConversationDebuggingInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __audio_data_chunks,
            __result_end_time_offset,
            __first_audio_duration,
            __single_utterance,
            __speech_partial_results_end_times,
            __speech_final_results_end_times,
            __partial_responses,
            __speaker_id_passive_latency_ms_offset,
            __bargein_event_triggered,
            __speech_single_utterance,
            __dtmf_partial_results_times,
            __dtmf_final_results_times,
            __single_utterance_end_time_offset,
            __no_speech_timeout,
            __endpointing_timeout,
            __is_input_text,
            __client_half_close_time_offset,
            __client_half_close_streaming_time_offset,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudConversationDebuggingInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "audioDataChunks" => Ok(__FieldTag::__audio_data_chunks),
                            "audio_data_chunks" => Ok(__FieldTag::__audio_data_chunks),
                            "resultEndTimeOffset" => Ok(__FieldTag::__result_end_time_offset),
                            "result_end_time_offset" => Ok(__FieldTag::__result_end_time_offset),
                            "firstAudioDuration" => Ok(__FieldTag::__first_audio_duration),
                            "first_audio_duration" => Ok(__FieldTag::__first_audio_duration),
                            "singleUtterance" => Ok(__FieldTag::__single_utterance),
                            "single_utterance" => Ok(__FieldTag::__single_utterance),
                            "speechPartialResultsEndTimes" => {
                                Ok(__FieldTag::__speech_partial_results_end_times)
                            }
                            "speech_partial_results_end_times" => {
                                Ok(__FieldTag::__speech_partial_results_end_times)
                            }
                            "speechFinalResultsEndTimes" => {
                                Ok(__FieldTag::__speech_final_results_end_times)
                            }
                            "speech_final_results_end_times" => {
                                Ok(__FieldTag::__speech_final_results_end_times)
                            }
                            "partialResponses" => Ok(__FieldTag::__partial_responses),
                            "partial_responses" => Ok(__FieldTag::__partial_responses),
                            "speakerIdPassiveLatencyMsOffset" => {
                                Ok(__FieldTag::__speaker_id_passive_latency_ms_offset)
                            }
                            "speaker_id_passive_latency_ms_offset" => {
                                Ok(__FieldTag::__speaker_id_passive_latency_ms_offset)
                            }
                            "bargeinEventTriggered" => Ok(__FieldTag::__bargein_event_triggered),
                            "bargein_event_triggered" => Ok(__FieldTag::__bargein_event_triggered),
                            "speechSingleUtterance" => Ok(__FieldTag::__speech_single_utterance),
                            "speech_single_utterance" => Ok(__FieldTag::__speech_single_utterance),
                            "dtmfPartialResultsTimes" => {
                                Ok(__FieldTag::__dtmf_partial_results_times)
                            }
                            "dtmf_partial_results_times" => {
                                Ok(__FieldTag::__dtmf_partial_results_times)
                            }
                            "dtmfFinalResultsTimes" => Ok(__FieldTag::__dtmf_final_results_times),
                            "dtmf_final_results_times" => {
                                Ok(__FieldTag::__dtmf_final_results_times)
                            }
                            "singleUtteranceEndTimeOffset" => {
                                Ok(__FieldTag::__single_utterance_end_time_offset)
                            }
                            "single_utterance_end_time_offset" => {
                                Ok(__FieldTag::__single_utterance_end_time_offset)
                            }
                            "noSpeechTimeout" => Ok(__FieldTag::__no_speech_timeout),
                            "no_speech_timeout" => Ok(__FieldTag::__no_speech_timeout),
                            "endpointingTimeout" => Ok(__FieldTag::__endpointing_timeout),
                            "endpointing_timeout" => Ok(__FieldTag::__endpointing_timeout),
                            "isInputText" => Ok(__FieldTag::__is_input_text),
                            "is_input_text" => Ok(__FieldTag::__is_input_text),
                            "clientHalfCloseTimeOffset" => {
                                Ok(__FieldTag::__client_half_close_time_offset)
                            }
                            "client_half_close_time_offset" => {
                                Ok(__FieldTag::__client_half_close_time_offset)
                            }
                            "clientHalfCloseStreamingTimeOffset" => {
                                Ok(__FieldTag::__client_half_close_streaming_time_offset)
                            }
                            "client_half_close_streaming_time_offset" => {
                                Ok(__FieldTag::__client_half_close_streaming_time_offset)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudConversationDebuggingInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudConversationDebuggingInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__audio_data_chunks => {
                            if !fields.insert(__FieldTag::__audio_data_chunks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audio_data_chunks",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.audio_data_chunks =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__result_end_time_offset => {
                            if !fields.insert(__FieldTag::__result_end_time_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result_end_time_offset",
                                ));
                            }
                            result.result_end_time_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__first_audio_duration => {
                            if !fields.insert(__FieldTag::__first_audio_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for first_audio_duration",
                                ));
                            }
                            result.first_audio_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__single_utterance => {
                            if !fields.insert(__FieldTag::__single_utterance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_utterance",
                                ));
                            }
                            result.single_utterance = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__speech_partial_results_end_times => {
                            if !fields.insert(__FieldTag::__speech_partial_results_end_times) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_partial_results_end_times",
                                ));
                            }
                            result.speech_partial_results_end_times = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Duration>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__speech_final_results_end_times => {
                            if !fields.insert(__FieldTag::__speech_final_results_end_times) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_final_results_end_times",
                                ));
                            }
                            result.speech_final_results_end_times = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Duration>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__partial_responses => {
                            if !fields.insert(__FieldTag::__partial_responses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for partial_responses",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.partial_responses =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__speaker_id_passive_latency_ms_offset => {
                            if !fields.insert(__FieldTag::__speaker_id_passive_latency_ms_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speaker_id_passive_latency_ms_offset",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.speaker_id_passive_latency_ms_offset =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bargein_event_triggered => {
                            if !fields.insert(__FieldTag::__bargein_event_triggered) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bargein_event_triggered",
                                ));
                            }
                            result.bargein_event_triggered = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__speech_single_utterance => {
                            if !fields.insert(__FieldTag::__speech_single_utterance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_single_utterance",
                                ));
                            }
                            result.speech_single_utterance = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dtmf_partial_results_times => {
                            if !fields.insert(__FieldTag::__dtmf_partial_results_times) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dtmf_partial_results_times",
                                ));
                            }
                            result.dtmf_partial_results_times = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Duration>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dtmf_final_results_times => {
                            if !fields.insert(__FieldTag::__dtmf_final_results_times) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dtmf_final_results_times",
                                ));
                            }
                            result.dtmf_final_results_times = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Duration>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__single_utterance_end_time_offset => {
                            if !fields.insert(__FieldTag::__single_utterance_end_time_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_utterance_end_time_offset",
                                ));
                            }
                            result.single_utterance_end_time_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__no_speech_timeout => {
                            if !fields.insert(__FieldTag::__no_speech_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for no_speech_timeout",
                                ));
                            }
                            result.no_speech_timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__endpointing_timeout => {
                            if !fields.insert(__FieldTag::__endpointing_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpointing_timeout",
                                ));
                            }
                            result.endpointing_timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__is_input_text => {
                            if !fields.insert(__FieldTag::__is_input_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_input_text",
                                ));
                            }
                            result.is_input_text = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_half_close_time_offset => {
                            if !fields.insert(__FieldTag::__client_half_close_time_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_half_close_time_offset",
                                ));
                            }
                            result.client_half_close_time_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__client_half_close_streaming_time_offset => {
                            if !fields.insert(__FieldTag::__client_half_close_streaming_time_offset)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_half_close_streaming_time_offset",
                                ));
                            }
                            result.client_half_close_streaming_time_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for CloudConversationDebuggingInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.audio_data_chunks) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("audioDataChunks", &__With(&self.audio_data_chunks))?;
        }
        if self.result_end_time_offset.is_some() {
            state.serialize_entry("resultEndTimeOffset", &self.result_end_time_offset)?;
        }
        if self.first_audio_duration.is_some() {
            state.serialize_entry("firstAudioDuration", &self.first_audio_duration)?;
        }
        if !wkt::internal::is_default(&self.single_utterance) {
            state.serialize_entry("singleUtterance", &self.single_utterance)?;
        }
        if !self.speech_partial_results_end_times.is_empty() {
            state.serialize_entry(
                "speechPartialResultsEndTimes",
                &self.speech_partial_results_end_times,
            )?;
        }
        if !self.speech_final_results_end_times.is_empty() {
            state.serialize_entry(
                "speechFinalResultsEndTimes",
                &self.speech_final_results_end_times,
            )?;
        }
        if !wkt::internal::is_default(&self.partial_responses) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("partialResponses", &__With(&self.partial_responses))?;
        }
        if !wkt::internal::is_default(&self.speaker_id_passive_latency_ms_offset) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "speakerIdPassiveLatencyMsOffset",
                &__With(&self.speaker_id_passive_latency_ms_offset),
            )?;
        }
        if !wkt::internal::is_default(&self.bargein_event_triggered) {
            state.serialize_entry("bargeinEventTriggered", &self.bargein_event_triggered)?;
        }
        if !wkt::internal::is_default(&self.speech_single_utterance) {
            state.serialize_entry("speechSingleUtterance", &self.speech_single_utterance)?;
        }
        if !self.dtmf_partial_results_times.is_empty() {
            state.serialize_entry("dtmfPartialResultsTimes", &self.dtmf_partial_results_times)?;
        }
        if !self.dtmf_final_results_times.is_empty() {
            state.serialize_entry("dtmfFinalResultsTimes", &self.dtmf_final_results_times)?;
        }
        if self.single_utterance_end_time_offset.is_some() {
            state.serialize_entry(
                "singleUtteranceEndTimeOffset",
                &self.single_utterance_end_time_offset,
            )?;
        }
        if self.no_speech_timeout.is_some() {
            state.serialize_entry("noSpeechTimeout", &self.no_speech_timeout)?;
        }
        if self.endpointing_timeout.is_some() {
            state.serialize_entry("endpointingTimeout", &self.endpointing_timeout)?;
        }
        if !wkt::internal::is_default(&self.is_input_text) {
            state.serialize_entry("isInputText", &self.is_input_text)?;
        }
        if self.client_half_close_time_offset.is_some() {
            state.serialize_entry(
                "clientHalfCloseTimeOffset",
                &self.client_half_close_time_offset,
            )?;
        }
        if self.client_half_close_streaming_time_offset.is_some() {
            state.serialize_entry(
                "clientHalfCloseStreamingTimeOffset",
                &self.client_half_close_streaming_time_offset,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The top-level message returned from the
/// [StreamingDetectIntent][] method.
///
/// Multiple response messages can be returned in order:
///
/// 1. If the
///    [StreamingDetectIntentRequest.input_audio][google.cloud.dialogflow.v2.StreamingDetectIntentRequest.input_audio]
///    field was
///    set, the `recognition_result` field is populated for one
///    or more messages.
///    See the
///    [StreamingRecognitionResult][google.cloud.dialogflow.v2.StreamingRecognitionResult]
///    message for details about the result message sequence.
///
/// 1. The next message contains `response_id`, `query_result`
///    and optionally `webhook_status` if a WebHook was called.
///
///
/// [google.cloud.dialogflow.v2.StreamingDetectIntentRequest.input_audio]: crate::model::StreamingDetectIntentRequest::input_audio
/// [google.cloud.dialogflow.v2.StreamingRecognitionResult]: crate::model::StreamingRecognitionResult
#[cfg(feature = "sessions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingDetectIntentResponse {
    /// The unique identifier of the response. It can be used to
    /// locate a response in the training example set or for reporting issues.
    pub response_id: std::string::String,

    /// The result of speech recognition.
    pub recognition_result: std::option::Option<crate::model::StreamingRecognitionResult>,

    /// The result of the conversational query or event processing.
    pub query_result: std::option::Option<crate::model::QueryResult>,

    /// Specifies the status of the webhook request.
    pub webhook_status: std::option::Option<rpc::model::Status>,

    /// The audio data bytes encoded as specified in the request.
    /// Note: The output audio is generated based on the values of default platform
    /// text responses found in the `query_result.fulfillment_messages` field. If
    /// multiple default text responses exist, they will be concatenated when
    /// generating audio. If no default platform text responses exist, the
    /// generated audio content will be empty.
    ///
    /// In some scenarios, multiple output audio fields may be present in the
    /// response structure. In these cases, only the top-most-level audio output
    /// has content.
    pub output_audio: ::bytes::Bytes,

    /// The config used by the speech synthesizer to generate the output audio.
    pub output_audio_config: std::option::Option<crate::model::OutputAudioConfig>,

    /// Debugging info that would get populated when
    /// [StreamingDetectIntentRequest.enable_debugging_info][google.cloud.dialogflow.v2.StreamingDetectIntentRequest.enable_debugging_info]
    /// is set to true.
    ///
    /// [google.cloud.dialogflow.v2.StreamingDetectIntentRequest.enable_debugging_info]: crate::model::StreamingDetectIntentRequest::enable_debugging_info
    pub debugging_info: std::option::Option<crate::model::CloudConversationDebuggingInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "sessions")]
impl StreamingDetectIntentResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [response_id][crate::model::StreamingDetectIntentResponse::response_id].
    pub fn set_response_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.response_id = v.into();
        self
    }

    /// Sets the value of [recognition_result][crate::model::StreamingDetectIntentResponse::recognition_result].
    pub fn set_recognition_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StreamingRecognitionResult>,
    {
        self.recognition_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recognition_result][crate::model::StreamingDetectIntentResponse::recognition_result].
    pub fn set_or_clear_recognition_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StreamingRecognitionResult>,
    {
        self.recognition_result = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query_result][crate::model::StreamingDetectIntentResponse::query_result].
    pub fn set_query_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryResult>,
    {
        self.query_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_result][crate::model::StreamingDetectIntentResponse::query_result].
    pub fn set_or_clear_query_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryResult>,
    {
        self.query_result = v.map(|x| x.into());
        self
    }

    /// Sets the value of [webhook_status][crate::model::StreamingDetectIntentResponse::webhook_status].
    pub fn set_webhook_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.webhook_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [webhook_status][crate::model::StreamingDetectIntentResponse::webhook_status].
    pub fn set_or_clear_webhook_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.webhook_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_audio][crate::model::StreamingDetectIntentResponse::output_audio].
    pub fn set_output_audio<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.output_audio = v.into();
        self
    }

    /// Sets the value of [output_audio_config][crate::model::StreamingDetectIntentResponse::output_audio_config].
    pub fn set_output_audio_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.output_audio_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [output_audio_config][crate::model::StreamingDetectIntentResponse::output_audio_config].
    pub fn set_or_clear_output_audio_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OutputAudioConfig>,
    {
        self.output_audio_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [debugging_info][crate::model::StreamingDetectIntentResponse::debugging_info].
    pub fn set_debugging_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudConversationDebuggingInfo>,
    {
        self.debugging_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [debugging_info][crate::model::StreamingDetectIntentResponse::debugging_info].
    pub fn set_or_clear_debugging_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudConversationDebuggingInfo>,
    {
        self.debugging_info = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "sessions")]
impl wkt::message::Message for StreamingDetectIntentResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.StreamingDetectIntentResponse"
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingDetectIntentResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __response_id,
            __recognition_result,
            __query_result,
            __webhook_status,
            __output_audio,
            __output_audio_config,
            __debugging_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingDetectIntentResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "responseId" => Ok(__FieldTag::__response_id),
                            "response_id" => Ok(__FieldTag::__response_id),
                            "recognitionResult" => Ok(__FieldTag::__recognition_result),
                            "recognition_result" => Ok(__FieldTag::__recognition_result),
                            "queryResult" => Ok(__FieldTag::__query_result),
                            "query_result" => Ok(__FieldTag::__query_result),
                            "webhookStatus" => Ok(__FieldTag::__webhook_status),
                            "webhook_status" => Ok(__FieldTag::__webhook_status),
                            "outputAudio" => Ok(__FieldTag::__output_audio),
                            "output_audio" => Ok(__FieldTag::__output_audio),
                            "outputAudioConfig" => Ok(__FieldTag::__output_audio_config),
                            "output_audio_config" => Ok(__FieldTag::__output_audio_config),
                            "debuggingInfo" => Ok(__FieldTag::__debugging_info),
                            "debugging_info" => Ok(__FieldTag::__debugging_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingDetectIntentResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingDetectIntentResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__response_id => {
                            if !fields.insert(__FieldTag::__response_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_id",
                                ));
                            }
                            result.response_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__recognition_result => {
                            if !fields.insert(__FieldTag::__recognition_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recognition_result",
                                ));
                            }
                            result.recognition_result = map.next_value::<std::option::Option<crate::model::StreamingRecognitionResult>>()?
                                ;
                        }
                        __FieldTag::__query_result => {
                            if !fields.insert(__FieldTag::__query_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_result",
                                ));
                            }
                            result.query_result =
                                map.next_value::<std::option::Option<crate::model::QueryResult>>()?;
                        }
                        __FieldTag::__webhook_status => {
                            if !fields.insert(__FieldTag::__webhook_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for webhook_status",
                                ));
                            }
                            result.webhook_status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__output_audio => {
                            if !fields.insert(__FieldTag::__output_audio) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_audio",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.output_audio = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__output_audio_config => {
                            if !fields.insert(__FieldTag::__output_audio_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_audio_config",
                                ));
                            }
                            result.output_audio_config = map
                                .next_value::<std::option::Option<crate::model::OutputAudioConfig>>(
                                )?;
                        }
                        __FieldTag::__debugging_info => {
                            if !fields.insert(__FieldTag::__debugging_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for debugging_info",
                                ));
                            }
                            result.debugging_info =
                                map.next_value::<std::option::Option<
                                    crate::model::CloudConversationDebuggingInfo,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "sessions")]
#[doc(hidden)]
impl serde::ser::Serialize for StreamingDetectIntentResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.response_id.is_empty() {
            state.serialize_entry("responseId", &self.response_id)?;
        }
        if self.recognition_result.is_some() {
            state.serialize_entry("recognitionResult", &self.recognition_result)?;
        }
        if self.query_result.is_some() {
            state.serialize_entry("queryResult", &self.query_result)?;
        }
        if self.webhook_status.is_some() {
            state.serialize_entry("webhookStatus", &self.webhook_status)?;
        }
        if !self.output_audio.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("outputAudio", &__With(&self.output_audio))?;
        }
        if self.output_audio_config.is_some() {
            state.serialize_entry("outputAudioConfig", &self.output_audio_config)?;
        }
        if self.debugging_info.is_some() {
            state.serialize_entry("debuggingInfo", &self.debugging_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Contains a speech recognition result corresponding to a portion of the audio
/// that is currently being processed or an indication that this is the end
/// of the single requested utterance.
///
/// While end-user audio is being processed, Dialogflow sends a series of
/// results. Each result may contain a `transcript` value. A transcript
/// represents a portion of the utterance. While the recognizer is processing
/// audio, transcript values may be interim values or finalized values.
/// Once a transcript is finalized, the `is_final` value is set to true and
/// processing continues for the next transcript.
///
/// If `StreamingDetectIntentRequest.query_input.audio_config.single_utterance`
/// was true, and the recognizer has completed processing audio,
/// the `message_type` value is set to `END_OF_SINGLE_UTTERANCE and the
/// following (last) result contains the last finalized transcript.
///
/// The complete end-user utterance is determined by concatenating the
/// finalized transcript values received for the series of results.
///
/// In the following example, single utterance is enabled. In the case where
/// single utterance is not enabled, result 7 would not occur.
///
/// ```norust
/// Num | transcript              | message_type            | is_final
/// --- | ----------------------- | ----------------------- | --------
/// 1   | "tube"                  | TRANSCRIPT              | false
/// 2   | "to be a"               | TRANSCRIPT              | false
/// 3   | "to be"                 | TRANSCRIPT              | false
/// 4   | "to be or not to be"    | TRANSCRIPT              | true
/// 5   | "that's"                | TRANSCRIPT              | false
/// 6   | "that is                | TRANSCRIPT              | false
/// 7   | unset                   | END_OF_SINGLE_UTTERANCE | unset
/// 8   | " that is the question" | TRANSCRIPT              | true
/// ```
///
/// Concatenating the finalized transcripts with `is_final` set to true,
/// the complete utterance becomes "to be or not to be that is the question".
#[cfg(any(feature = "participants", feature = "sessions",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingRecognitionResult {
    /// Type of the result message.
    pub message_type: crate::model::streaming_recognition_result::MessageType,

    /// Transcript text representing the words that the user spoke.
    /// Populated if and only if `message_type` = `TRANSCRIPT`.
    pub transcript: std::string::String,

    /// If `false`, the `StreamingRecognitionResult` represents an
    /// interim result that may change. If `true`, the recognizer will not return
    /// any further hypotheses about this piece of the audio. May only be populated
    /// for `message_type` = `TRANSCRIPT`.
    pub is_final: bool,

    /// The Speech confidence between 0.0 and 1.0 for the current portion of audio.
    /// A higher number indicates an estimated greater likelihood that the
    /// recognized words are correct. The default of 0.0 is a sentinel value
    /// indicating that confidence was not set.
    ///
    /// This field is typically only provided if `is_final` is true and you should
    /// not rely on it being accurate or even set.
    pub confidence: f32,

    /// Word-specific information for the words recognized by Speech in
    /// [transcript][google.cloud.dialogflow.v2.StreamingRecognitionResult.transcript].
    /// Populated if and only if `message_type` = `TRANSCRIPT` and
    /// [InputAudioConfig.enable_word_info] is set.
    ///
    /// [google.cloud.dialogflow.v2.StreamingRecognitionResult.transcript]: crate::model::StreamingRecognitionResult::transcript
    pub speech_word_info: std::vec::Vec<crate::model::SpeechWordInfo>,

    /// Time offset of the end of this Speech recognition result relative to the
    /// beginning of the audio. Only populated for `message_type` = `TRANSCRIPT`.
    pub speech_end_offset: std::option::Option<wkt::Duration>,

    /// Detected language code for the transcript.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl StreamingRecognitionResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message_type][crate::model::StreamingRecognitionResult::message_type].
    pub fn set_message_type<
        T: std::convert::Into<crate::model::streaming_recognition_result::MessageType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.message_type = v.into();
        self
    }

    /// Sets the value of [transcript][crate::model::StreamingRecognitionResult::transcript].
    pub fn set_transcript<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.transcript = v.into();
        self
    }

    /// Sets the value of [is_final][crate::model::StreamingRecognitionResult::is_final].
    pub fn set_is_final<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_final = v.into();
        self
    }

    /// Sets the value of [confidence][crate::model::StreamingRecognitionResult::confidence].
    pub fn set_confidence<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.confidence = v.into();
        self
    }

    /// Sets the value of [speech_word_info][crate::model::StreamingRecognitionResult::speech_word_info].
    pub fn set_speech_word_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SpeechWordInfo>,
    {
        use std::iter::Iterator;
        self.speech_word_info = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [speech_end_offset][crate::model::StreamingRecognitionResult::speech_end_offset].
    pub fn set_speech_end_offset<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.speech_end_offset = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [speech_end_offset][crate::model::StreamingRecognitionResult::speech_end_offset].
    pub fn set_or_clear_speech_end_offset<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.speech_end_offset = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::StreamingRecognitionResult::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl wkt::message::Message for StreamingRecognitionResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.StreamingRecognitionResult"
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingRecognitionResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message_type,
            __transcript,
            __is_final,
            __confidence,
            __speech_word_info,
            __speech_end_offset,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingRecognitionResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "messageType" => Ok(__FieldTag::__message_type),
                            "message_type" => Ok(__FieldTag::__message_type),
                            "transcript" => Ok(__FieldTag::__transcript),
                            "isFinal" => Ok(__FieldTag::__is_final),
                            "is_final" => Ok(__FieldTag::__is_final),
                            "confidence" => Ok(__FieldTag::__confidence),
                            "speechWordInfo" => Ok(__FieldTag::__speech_word_info),
                            "speech_word_info" => Ok(__FieldTag::__speech_word_info),
                            "speechEndOffset" => Ok(__FieldTag::__speech_end_offset),
                            "speech_end_offset" => Ok(__FieldTag::__speech_end_offset),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingRecognitionResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingRecognitionResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message_type => {
                            if !fields.insert(__FieldTag::__message_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message_type",
                                ));
                            }
                            result.message_type = map
                                .next_value::<std::option::Option<
                                    crate::model::streaming_recognition_result::MessageType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transcript => {
                            if !fields.insert(__FieldTag::__transcript) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transcript",
                                ));
                            }
                            result.transcript = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_final => {
                            if !fields.insert(__FieldTag::__is_final) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_final",
                                ));
                            }
                            result.is_final = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidence => {
                            if !fields.insert(__FieldTag::__confidence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidence",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.confidence = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__speech_word_info => {
                            if !fields.insert(__FieldTag::__speech_word_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_word_info",
                                ));
                            }
                            result.speech_word_info =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SpeechWordInfo>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__speech_end_offset => {
                            if !fields.insert(__FieldTag::__speech_end_offset) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for speech_end_offset",
                                ));
                            }
                            result.speech_end_offset =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for StreamingRecognitionResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.message_type) {
            state.serialize_entry("messageType", &self.message_type)?;
        }
        if !self.transcript.is_empty() {
            state.serialize_entry("transcript", &self.transcript)?;
        }
        if !wkt::internal::is_default(&self.is_final) {
            state.serialize_entry("isFinal", &self.is_final)?;
        }
        if !wkt::internal::is_default(&self.confidence) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("confidence", &__With(&self.confidence))?;
        }
        if !self.speech_word_info.is_empty() {
            state.serialize_entry("speechWordInfo", &self.speech_word_info)?;
        }
        if self.speech_end_offset.is_some() {
            state.serialize_entry("speechEndOffset", &self.speech_end_offset)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StreamingRecognitionResult].
#[cfg(any(feature = "participants", feature = "sessions",))]
pub mod streaming_recognition_result {
    #[allow(unused_imports)]
    use super::*;

    /// Type of the response message.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "participants", feature = "sessions",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MessageType {
        /// Not specified. Should never be used.
        Unspecified,
        /// Message contains a (possibly partial) transcript.
        Transcript,
        /// This event indicates that the server has detected the end of the user's
        /// speech utterance and expects no additional inputs.
        /// Therefore, the server will not process additional audio (although it may
        /// subsequently return additional results). The client should stop sending
        /// additional audio data, half-close the gRPC connection, and wait for any
        /// additional results until the server closes the gRPC connection. This
        /// message is only sent if `single_utterance` was set to `true`, and is not
        /// used otherwise.
        EndOfSingleUtterance,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MessageType::value] or
        /// [MessageType::name].
        UnknownValue(message_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "participants", feature = "sessions",))]
    pub mod message_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "participants", feature = "sessions",))]
    impl MessageType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Transcript => std::option::Option::Some(1),
                Self::EndOfSingleUtterance => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MESSAGE_TYPE_UNSPECIFIED"),
                Self::Transcript => std::option::Option::Some("TRANSCRIPT"),
                Self::EndOfSingleUtterance => std::option::Option::Some("END_OF_SINGLE_UTTERANCE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "participants", feature = "sessions",))]
    impl std::default::Default for MessageType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "participants", feature = "sessions",))]
    impl std::fmt::Display for MessageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "participants", feature = "sessions",))]
    impl std::convert::From<i32> for MessageType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Transcript,
                2 => Self::EndOfSingleUtterance,
                _ => Self::UnknownValue(message_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "participants", feature = "sessions",))]
    impl std::convert::From<&str> for MessageType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MESSAGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "TRANSCRIPT" => Self::Transcript,
                "END_OF_SINGLE_UTTERANCE" => Self::EndOfSingleUtterance,
                _ => Self::UnknownValue(message_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "participants", feature = "sessions",))]
    impl serde::ser::Serialize for MessageType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Transcript => serializer.serialize_i32(1),
                Self::EndOfSingleUtterance => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "participants", feature = "sessions",))]
    impl<'de> serde::de::Deserialize<'de> for MessageType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MessageType>::new(
                ".google.cloud.dialogflow.v2.StreamingRecognitionResult.MessageType",
            ))
        }
    }
}

/// Auxiliary proto messages.
///
/// Represents the natural language text to be processed.
#[cfg(any(
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TextInput {
    /// Required. The UTF-8 encoded natural language text to be processed.
    /// Text length must not exceed 256 characters for virtual agent interactions.
    pub text: std::string::String,

    /// Required. The language of this conversational query. See [Language
    /// Support](https://cloud.google.com/dialogflow/docs/reference/language)
    /// for a list of the currently supported language codes. Note that queries in
    /// the same session do not necessarily need to specify the same language.
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl TextInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [text][crate::model::TextInput::text].
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.text = v.into();
        self
    }

    /// Sets the value of [language_code][crate::model::TextInput::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(any(
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl wkt::message::Message for TextInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.TextInput"
    }
}

#[cfg(any(
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TextInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __text,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TextInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "text" => Ok(__FieldTag::__text),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TextInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TextInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            result.text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for TextInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.text.is_empty() {
            state.serialize_entry("text", &self.text)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Events allow for matching intents by event name instead of the natural
/// language input. For instance, input `<event: { name: "welcome_event",
/// parameters: { name: "Sam" } }>` can trigger a personalized welcome response.
/// The parameter `name` may be used by the agent in the response:
/// `"Hello #welcome_event.name! What can I do for you today?"`.
#[cfg(any(feature = "participants", feature = "sessions",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EventInput {
    /// Required. The unique identifier of the event.
    pub name: std::string::String,

    /// The collection of parameters associated with the event.
    ///
    /// Depending on your protocol or client library language, this is a
    /// map, associative array, symbol table, dictionary, or JSON object
    /// composed of a collection of (MapKey, MapValue) pairs:
    ///
    /// * MapKey type: string
    /// * MapKey value: parameter name
    /// * MapValue type: If parameter's entity type is a composite entity then use
    ///   map, otherwise, depending on the parameter value type, it could be one of
    ///   string, number, boolean, null, list or map.
    /// * MapValue value: If parameter's entity type is a composite entity then use
    ///   map from composite entity property names to property values, otherwise,
    ///   use parameter value.
    pub parameters: std::option::Option<wkt::Struct>,

    /// Required. The language of this query. See [Language
    /// Support](https://cloud.google.com/dialogflow/docs/reference/language)
    /// for a list of the currently supported language codes. Note that queries in
    /// the same session do not necessarily need to specify the same language.
    ///
    /// This field is ignored when used in the context of a
    /// [WebhookResponse.followup_event_input][google.cloud.dialogflow.v2.WebhookResponse.followup_event_input]
    /// field, because the language was already defined in the originating detect
    /// intent request.
    ///
    /// [google.cloud.dialogflow.v2.WebhookResponse.followup_event_input]: crate::model::WebhookResponse::followup_event_input
    pub language_code: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl EventInput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EventInput::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [parameters][crate::model::EventInput::parameters].
    pub fn set_parameters<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.parameters = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [parameters][crate::model::EventInput::parameters].
    pub fn set_or_clear_parameters<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.parameters = v.map(|x| x.into());
        self
    }

    /// Sets the value of [language_code][crate::model::EventInput::language_code].
    pub fn set_language_code<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.language_code = v.into();
        self
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl wkt::message::Message for EventInput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.EventInput"
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EventInput {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __parameters,
            __language_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EventInput")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "parameters" => Ok(__FieldTag::__parameters),
                            "languageCode" => Ok(__FieldTag::__language_code),
                            "language_code" => Ok(__FieldTag::__language_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EventInput;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EventInput")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parameters => {
                            if !fields.insert(__FieldTag::__parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parameters",
                                ));
                            }
                            result.parameters =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__language_code => {
                            if !fields.insert(__FieldTag::__language_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for language_code",
                                ));
                            }
                            result.language_code = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for EventInput {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.parameters.is_some() {
            state.serialize_entry("parameters", &self.parameters)?;
        }
        if !self.language_code.is_empty() {
            state.serialize_entry("languageCode", &self.language_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configures the types of sentiment analysis to perform.
#[cfg(any(feature = "participants", feature = "sessions",))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SentimentAnalysisRequestConfig {
    /// Instructs the service to perform sentiment analysis on
    /// `query_text`. If not provided, sentiment analysis is not performed on
    /// `query_text`.
    pub analyze_query_text_sentiment: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl SentimentAnalysisRequestConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [analyze_query_text_sentiment][crate::model::SentimentAnalysisRequestConfig::analyze_query_text_sentiment].
    pub fn set_analyze_query_text_sentiment<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.analyze_query_text_sentiment = v.into();
        self
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
impl wkt::message::Message for SentimentAnalysisRequestConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SentimentAnalysisRequestConfig"
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SentimentAnalysisRequestConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __analyze_query_text_sentiment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SentimentAnalysisRequestConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "analyzeQueryTextSentiment" => {
                                Ok(__FieldTag::__analyze_query_text_sentiment)
                            }
                            "analyze_query_text_sentiment" => {
                                Ok(__FieldTag::__analyze_query_text_sentiment)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SentimentAnalysisRequestConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SentimentAnalysisRequestConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__analyze_query_text_sentiment => {
                            if !fields.insert(__FieldTag::__analyze_query_text_sentiment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for analyze_query_text_sentiment",
                                ));
                            }
                            result.analyze_query_text_sentiment = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(feature = "participants", feature = "sessions",))]
#[doc(hidden)]
impl serde::ser::Serialize for SentimentAnalysisRequestConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.analyze_query_text_sentiment) {
            state.serialize_entry(
                "analyzeQueryTextSentiment",
                &self.analyze_query_text_sentiment,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The result of sentiment analysis. Sentiment analysis inspects user input
/// and identifies the prevailing subjective opinion, especially to determine a
/// user's attitude as positive, negative, or neutral.
/// For [DetectIntent][], it needs to be configured in
/// [DetectIntentRequest.query_params][google.cloud.dialogflow.v2.DetectIntentRequest.query_params].
/// For [StreamingDetectIntent][], it needs to be configured in
/// [StreamingDetectIntentRequest.query_params][google.cloud.dialogflow.v2.StreamingDetectIntentRequest.query_params].
/// And for
/// [Participants.AnalyzeContent][google.cloud.dialogflow.v2.Participants.AnalyzeContent]
/// and
/// [Participants.StreamingAnalyzeContent][google.cloud.dialogflow.v2.Participants.StreamingAnalyzeContent],
/// it needs to be configured in
/// [ConversationProfile.human_agent_assistant_config][google.cloud.dialogflow.v2.ConversationProfile.human_agent_assistant_config]
///
/// [google.cloud.dialogflow.v2.ConversationProfile.human_agent_assistant_config]: crate::model::ConversationProfile::human_agent_assistant_config
/// [google.cloud.dialogflow.v2.DetectIntentRequest.query_params]: crate::model::DetectIntentRequest::query_params
/// [google.cloud.dialogflow.v2.Participants.AnalyzeContent]: crate::client::Participants::analyze_content
/// [google.cloud.dialogflow.v2.StreamingDetectIntentRequest.query_params]: crate::model::StreamingDetectIntentRequest::query_params
#[cfg(any(
    feature = "answer-records",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SentimentAnalysisResult {
    /// The sentiment analysis result for `query_text`.
    pub query_text_sentiment: std::option::Option<crate::model::Sentiment>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "answer-records",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl SentimentAnalysisResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query_text_sentiment][crate::model::SentimentAnalysisResult::query_text_sentiment].
    pub fn set_query_text_sentiment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.query_text_sentiment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_text_sentiment][crate::model::SentimentAnalysisResult::query_text_sentiment].
    pub fn set_or_clear_query_text_sentiment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Sentiment>,
    {
        self.query_text_sentiment = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl wkt::message::Message for SentimentAnalysisResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SentimentAnalysisResult"
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SentimentAnalysisResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query_text_sentiment,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SentimentAnalysisResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "queryTextSentiment" => Ok(__FieldTag::__query_text_sentiment),
                            "query_text_sentiment" => Ok(__FieldTag::__query_text_sentiment),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SentimentAnalysisResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SentimentAnalysisResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query_text_sentiment => {
                            if !fields.insert(__FieldTag::__query_text_sentiment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_text_sentiment",
                                ));
                            }
                            result.query_text_sentiment =
                                map.next_value::<std::option::Option<crate::model::Sentiment>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for SentimentAnalysisResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.query_text_sentiment.is_some() {
            state.serialize_entry("queryTextSentiment", &self.query_text_sentiment)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The sentiment, such as positive/negative feeling or association, for a unit
/// of analysis, such as the query text. See:
/// <https://cloud.google.com/natural-language/docs/basics#interpreting_sentiment_analysis_values>
/// for how to interpret the result.
#[cfg(any(
    feature = "answer-records",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Sentiment {
    /// Sentiment score between -1.0 (negative sentiment) and 1.0 (positive
    /// sentiment).
    pub score: f32,

    /// A non-negative number in the [0, +inf) range, which represents the absolute
    /// magnitude of sentiment, regardless of score (positive or negative).
    pub magnitude: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "answer-records",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl Sentiment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [score][crate::model::Sentiment::score].
    pub fn set_score<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.score = v.into();
        self
    }

    /// Sets the value of [magnitude][crate::model::Sentiment::magnitude].
    pub fn set_magnitude<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.magnitude = v.into();
        self
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl wkt::message::Message for Sentiment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.Sentiment"
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Sentiment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __score,
            __magnitude,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Sentiment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "score" => Ok(__FieldTag::__score),
                            "magnitude" => Ok(__FieldTag::__magnitude),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Sentiment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Sentiment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__score => {
                            if !fields.insert(__FieldTag::__score) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for score",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.score = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__magnitude => {
                            if !fields.insert(__FieldTag::__magnitude) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for magnitude",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.magnitude = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "answer-records",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for Sentiment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.score) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("score", &__With(&self.score))?;
        }
        if !wkt::internal::is_default(&self.magnitude) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("magnitude", &__With(&self.magnitude))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A session represents a conversation between a Dialogflow agent and an
/// end-user. You can create special entities, called session entities, during a
/// session. Session entities can extend or replace custom entity types and only
/// exist during the session that they were created for. All session data,
/// including session entities, is stored by Dialogflow for 20 minutes.
///
/// For more information, see the [session entity
/// guide](https://cloud.google.com/dialogflow/docs/entities-session).
#[cfg(any(
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SessionEntityType {
    /// Required. The unique identifier of this session entity type. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/entityTypes/<Entity Type
    /// Display Name>`, or `projects/<Project ID>/agent/environments/<Environment
    /// ID>/users/<User ID>/sessions/<Session ID>/entityTypes/<Entity Type Display
    /// Name>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    ///
    /// `<Entity Type Display Name>` must be the display name of an existing entity
    /// type in the same agent that will be overridden or supplemented.
    pub name: std::string::String,

    /// Required. Indicates whether the additional data should override or
    /// supplement the custom entity type definition.
    pub entity_override_mode: crate::model::session_entity_type::EntityOverrideMode,

    /// Required. The collection of entities associated with this session entity
    /// type.
    pub entities: std::vec::Vec<crate::model::entity_type::Entity>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
))]
impl SessionEntityType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SessionEntityType::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [entity_override_mode][crate::model::SessionEntityType::entity_override_mode].
    pub fn set_entity_override_mode<
        T: std::convert::Into<crate::model::session_entity_type::EntityOverrideMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entity_override_mode = v.into();
        self
    }

    /// Sets the value of [entities][crate::model::SessionEntityType::entities].
    pub fn set_entities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::entity_type::Entity>,
    {
        use std::iter::Iterator;
        self.entities = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
))]
impl wkt::message::Message for SessionEntityType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.SessionEntityType"
    }
}

#[cfg(any(
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SessionEntityType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __entity_override_mode,
            __entities,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SessionEntityType")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "entityOverrideMode" => Ok(__FieldTag::__entity_override_mode),
                            "entity_override_mode" => Ok(__FieldTag::__entity_override_mode),
                            "entities" => Ok(__FieldTag::__entities),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SessionEntityType;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SessionEntityType")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entity_override_mode => {
                            if !fields.insert(__FieldTag::__entity_override_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entity_override_mode",
                                ));
                            }
                            result.entity_override_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::session_entity_type::EntityOverrideMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entities => {
                            if !fields.insert(__FieldTag::__entities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entities",
                                ));
                            }
                            result.entities = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::entity_type::Entity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(any(
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for SessionEntityType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.entity_override_mode) {
            state.serialize_entry("entityOverrideMode", &self.entity_override_mode)?;
        }
        if !self.entities.is_empty() {
            state.serialize_entry("entities", &self.entities)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SessionEntityType].
#[cfg(any(
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
))]
pub mod session_entity_type {
    #[allow(unused_imports)]
    use super::*;

    /// The types of modifications for a session entity type.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EntityOverrideMode {
        /// Not specified. This value should be never used.
        Unspecified,
        /// The collection of session entities overrides the collection of entities
        /// in the corresponding custom entity type.
        Override,
        /// The collection of session entities extends the collection of entities in
        /// the corresponding custom entity type.
        ///
        /// Note: Even in this override mode calls to `ListSessionEntityTypes`,
        /// `GetSessionEntityType`, `CreateSessionEntityType` and
        /// `UpdateSessionEntityType` only return the additional entities added in
        /// this session entity type. If you want to get the supplemented list,
        /// please call
        /// [EntityTypes.GetEntityType][google.cloud.dialogflow.v2.EntityTypes.GetEntityType]
        /// on the custom entity type and merge.
        ///
        /// [google.cloud.dialogflow.v2.EntityTypes.GetEntityType]: crate::client::EntityTypes::get_entity_type
        Supplement,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EntityOverrideMode::value] or
        /// [EntityOverrideMode::name].
        UnknownValue(entity_override_mode::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    pub mod entity_override_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl EntityOverrideMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Override => std::option::Option::Some(1),
                Self::Supplement => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ENTITY_OVERRIDE_MODE_UNSPECIFIED"),
                Self::Override => std::option::Option::Some("ENTITY_OVERRIDE_MODE_OVERRIDE"),
                Self::Supplement => std::option::Option::Some("ENTITY_OVERRIDE_MODE_SUPPLEMENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::default::Default for EntityOverrideMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::fmt::Display for EntityOverrideMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::convert::From<i32> for EntityOverrideMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Override,
                2 => Self::Supplement,
                _ => Self::UnknownValue(entity_override_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl std::convert::From<&str> for EntityOverrideMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ENTITY_OVERRIDE_MODE_UNSPECIFIED" => Self::Unspecified,
                "ENTITY_OVERRIDE_MODE_OVERRIDE" => Self::Override,
                "ENTITY_OVERRIDE_MODE_SUPPLEMENT" => Self::Supplement,
                _ => Self::UnknownValue(entity_override_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl serde::ser::Serialize for EntityOverrideMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Override => serializer.serialize_i32(1),
                Self::Supplement => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "participants",
        feature = "session-entity-types",
        feature = "sessions",
    ))]
    impl<'de> serde::de::Deserialize<'de> for EntityOverrideMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EntityOverrideMode>::new(
                ".google.cloud.dialogflow.v2.SessionEntityType.EntityOverrideMode",
            ))
        }
    }
}

/// The request message for
/// [SessionEntityTypes.ListSessionEntityTypes][google.cloud.dialogflow.v2.SessionEntityTypes.ListSessionEntityTypes].
///
/// [google.cloud.dialogflow.v2.SessionEntityTypes.ListSessionEntityTypes]: crate::client::SessionEntityTypes::list_session_entity_types
#[cfg(feature = "session-entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSessionEntityTypesRequest {
    /// Required. The session to list all session entity types from.
    /// Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User ID>/
    /// sessions/<Session ID>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "session-entity-types")]
impl ListSessionEntityTypesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSessionEntityTypesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSessionEntityTypesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSessionEntityTypesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "session-entity-types")]
impl wkt::message::Message for ListSessionEntityTypesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListSessionEntityTypesRequest"
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSessionEntityTypesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSessionEntityTypesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSessionEntityTypesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSessionEntityTypesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for ListSessionEntityTypesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [SessionEntityTypes.ListSessionEntityTypes][google.cloud.dialogflow.v2.SessionEntityTypes.ListSessionEntityTypes].
///
/// [google.cloud.dialogflow.v2.SessionEntityTypes.ListSessionEntityTypes]: crate::client::SessionEntityTypes::list_session_entity_types
#[cfg(feature = "session-entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSessionEntityTypesResponse {
    /// The list of session entity types. There will be a maximum number of items
    /// returned based on the page_size field in the request.
    pub session_entity_types: std::vec::Vec<crate::model::SessionEntityType>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "session-entity-types")]
impl ListSessionEntityTypesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session_entity_types][crate::model::ListSessionEntityTypesResponse::session_entity_types].
    pub fn set_session_entity_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SessionEntityType>,
    {
        use std::iter::Iterator;
        self.session_entity_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSessionEntityTypesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "session-entity-types")]
impl wkt::message::Message for ListSessionEntityTypesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListSessionEntityTypesResponse"
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSessionEntityTypesResponse {
    type PageItem = crate::model::SessionEntityType;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.session_entity_types
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSessionEntityTypesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session_entity_types,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSessionEntityTypesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sessionEntityTypes" => Ok(__FieldTag::__session_entity_types),
                            "session_entity_types" => Ok(__FieldTag::__session_entity_types),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSessionEntityTypesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSessionEntityTypesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session_entity_types => {
                            if !fields.insert(__FieldTag::__session_entity_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_entity_types",
                                ));
                            }
                            result.session_entity_types =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SessionEntityType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for ListSessionEntityTypesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session_entity_types.is_empty() {
            state.serialize_entry("sessionEntityTypes", &self.session_entity_types)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [SessionEntityTypes.GetSessionEntityType][google.cloud.dialogflow.v2.SessionEntityTypes.GetSessionEntityType].
///
/// [google.cloud.dialogflow.v2.SessionEntityTypes.GetSessionEntityType]: crate::client::SessionEntityTypes::get_session_entity_type
#[cfg(feature = "session-entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSessionEntityTypeRequest {
    /// Required. The name of the session entity type. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/entityTypes/<Entity Type
    /// Display Name>` or `projects/<Project ID>/agent/environments/<Environment
    /// ID>/users/<User ID>/sessions/<Session ID>/entityTypes/<Entity Type Display
    /// Name>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "session-entity-types")]
impl GetSessionEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSessionEntityTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "session-entity-types")]
impl wkt::message::Message for GetSessionEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetSessionEntityTypeRequest"
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSessionEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSessionEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSessionEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSessionEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for GetSessionEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [SessionEntityTypes.CreateSessionEntityType][google.cloud.dialogflow.v2.SessionEntityTypes.CreateSessionEntityType].
///
/// [google.cloud.dialogflow.v2.SessionEntityTypes.CreateSessionEntityType]: crate::client::SessionEntityTypes::create_session_entity_type
#[cfg(feature = "session-entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSessionEntityTypeRequest {
    /// Required. The session to create a session entity type for.
    /// Format: `projects/<Project ID>/agent/sessions/<Session ID>` or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User ID>/
    /// sessions/<Session ID>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    pub parent: std::string::String,

    /// Required. The session entity type to create.
    pub session_entity_type: std::option::Option<crate::model::SessionEntityType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "session-entity-types")]
impl CreateSessionEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSessionEntityTypeRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [session_entity_type][crate::model::CreateSessionEntityTypeRequest::session_entity_type].
    pub fn set_session_entity_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SessionEntityType>,
    {
        self.session_entity_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session_entity_type][crate::model::CreateSessionEntityTypeRequest::session_entity_type].
    pub fn set_or_clear_session_entity_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SessionEntityType>,
    {
        self.session_entity_type = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "session-entity-types")]
impl wkt::message::Message for CreateSessionEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CreateSessionEntityTypeRequest"
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSessionEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __session_entity_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSessionEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "sessionEntityType" => Ok(__FieldTag::__session_entity_type),
                            "session_entity_type" => Ok(__FieldTag::__session_entity_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSessionEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSessionEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__session_entity_type => {
                            if !fields.insert(__FieldTag::__session_entity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_entity_type",
                                ));
                            }
                            result.session_entity_type = map
                                .next_value::<std::option::Option<crate::model::SessionEntityType>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateSessionEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.session_entity_type.is_some() {
            state.serialize_entry("sessionEntityType", &self.session_entity_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [SessionEntityTypes.UpdateSessionEntityType][google.cloud.dialogflow.v2.SessionEntityTypes.UpdateSessionEntityType].
///
/// [google.cloud.dialogflow.v2.SessionEntityTypes.UpdateSessionEntityType]: crate::client::SessionEntityTypes::update_session_entity_type
#[cfg(feature = "session-entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSessionEntityTypeRequest {
    /// Required. The session entity type to update.
    pub session_entity_type: std::option::Option<crate::model::SessionEntityType>,

    /// Optional. The mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "session-entity-types")]
impl UpdateSessionEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session_entity_type][crate::model::UpdateSessionEntityTypeRequest::session_entity_type].
    pub fn set_session_entity_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SessionEntityType>,
    {
        self.session_entity_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session_entity_type][crate::model::UpdateSessionEntityTypeRequest::session_entity_type].
    pub fn set_or_clear_session_entity_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SessionEntityType>,
    {
        self.session_entity_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSessionEntityTypeRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSessionEntityTypeRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "session-entity-types")]
impl wkt::message::Message for UpdateSessionEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.UpdateSessionEntityTypeRequest"
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSessionEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session_entity_type,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSessionEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sessionEntityType" => Ok(__FieldTag::__session_entity_type),
                            "session_entity_type" => Ok(__FieldTag::__session_entity_type),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSessionEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSessionEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session_entity_type => {
                            if !fields.insert(__FieldTag::__session_entity_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_entity_type",
                                ));
                            }
                            result.session_entity_type = map
                                .next_value::<std::option::Option<crate::model::SessionEntityType>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateSessionEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.session_entity_type.is_some() {
            state.serialize_entry("sessionEntityType", &self.session_entity_type)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [SessionEntityTypes.DeleteSessionEntityType][google.cloud.dialogflow.v2.SessionEntityTypes.DeleteSessionEntityType].
///
/// [google.cloud.dialogflow.v2.SessionEntityTypes.DeleteSessionEntityType]: crate::client::SessionEntityTypes::delete_session_entity_type
#[cfg(feature = "session-entity-types")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSessionEntityTypeRequest {
    /// Required. The name of the entity type to delete. Format:
    /// `projects/<Project ID>/agent/sessions/<Session ID>/entityTypes/<Entity Type
    /// Display Name>` or `projects/<Project ID>/agent/environments/<Environment
    /// ID>/users/<User ID>/sessions/<Session ID>/entityTypes/<Entity Type Display
    /// Name>`.
    /// If `Environment ID` is not specified, we assume default 'draft'
    /// environment. If `User ID` is not specified, we assume default '-' user.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "session-entity-types")]
impl DeleteSessionEntityTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSessionEntityTypeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "session-entity-types")]
impl wkt::message::Message for DeleteSessionEntityTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DeleteSessionEntityTypeRequest"
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSessionEntityTypeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSessionEntityTypeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSessionEntityTypeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSessionEntityTypeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "session-entity-types")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteSessionEntityTypeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a single validation error.
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidationError {
    /// The severity of the error.
    pub severity: crate::model::validation_error::Severity,

    /// The names of the entries that the error is associated with.
    /// Format:
    ///
    /// - `projects/<Project ID>/agent`, if the error is associated with the entire
    ///   agent.
    /// - `projects/<Project ID>/agent/intents/<Intent ID>`, if the error is
    ///   associated with certain intents.
    /// - `projects/<Project ID>/agent/intents/<Intent
    ///   Id>/trainingPhrases/<Training Phrase ID>`, if the error is associated with
    ///   certain intent training phrases.
    /// - `projects/<Project ID>/agent/intents/<Intent Id>/parameters/<Parameter
    ///   ID>`, if the error is associated with certain intent parameters.
    /// - `projects/<Project ID>/agent/entities/<Entity ID>`, if the error is
    ///   associated with certain entities.
    pub entries: std::vec::Vec<std::string::String>,

    /// The detailed error message.
    pub error_message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl ValidationError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [severity][crate::model::ValidationError::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::validation_error::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [entries][crate::model::ValidationError::entries].
    pub fn set_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error_message][crate::model::ValidationError::error_message].
    pub fn set_error_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.error_message = v.into();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for ValidationError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ValidationError"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValidationError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __severity,
            __entries,
            __error_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValidationError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "severity" => Ok(__FieldTag::__severity),
                            "entries" => Ok(__FieldTag::__entries),
                            "errorMessage" => Ok(__FieldTag::__error_message),
                            "error_message" => Ok(__FieldTag::__error_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValidationError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValidationError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map.next_value::<std::option::Option<crate::model::validation_error::Severity>>()?.unwrap_or_default();
                        }
                        __FieldTag::__entries => {
                            if !fields.insert(__FieldTag::__entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entries",
                                ));
                            }
                            result.entries = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error_message => {
                            if !fields.insert(__FieldTag::__error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_message",
                                ));
                            }
                            result.error_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for ValidationError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self.entries.is_empty() {
            state.serialize_entry("entries", &self.entries)?;
        }
        if !self.error_message.is_empty() {
            state.serialize_entry("errorMessage", &self.error_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ValidationError].
#[cfg(feature = "agents")]
pub mod validation_error {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a level of severity.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "agents")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Severity {
        /// Not specified. This value should never be used.
        Unspecified,
        /// The agent doesn't follow Dialogflow best practices.
        Info,
        /// The agent may not behave as expected.
        Warning,
        /// The agent may experience partial failures.
        Error,
        /// The agent may completely fail.
        Critical,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Severity::value] or
        /// [Severity::name].
        UnknownValue(severity::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "agents")]
    pub mod severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "agents")]
    impl Severity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Info => std::option::Option::Some(1),
                Self::Warning => std::option::Option::Some(2),
                Self::Error => std::option::Option::Some(3),
                Self::Critical => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
                Self::Info => std::option::Option::Some("INFO"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Critical => std::option::Option::Some("CRITICAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl std::default::Default for Severity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "agents")]
    impl std::fmt::Display for Severity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "agents")]
    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Info,
                2 => Self::Warning,
                3 => Self::Error,
                4 => Self::Critical,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl std::convert::From<&str> for Severity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "INFO" => Self::Info,
                "WARNING" => Self::Warning,
                "ERROR" => Self::Error,
                "CRITICAL" => Self::Critical,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl serde::ser::Serialize for Severity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Info => serializer.serialize_i32(1),
                Self::Warning => serializer.serialize_i32(2),
                Self::Error => serializer.serialize_i32(3),
                Self::Critical => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "agents")]
    impl<'de> serde::de::Deserialize<'de> for Severity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
                ".google.cloud.dialogflow.v2.ValidationError.Severity",
            ))
        }
    }
}

/// Represents the output of agent validation.
#[cfg(feature = "agents")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidationResult {
    /// Contains all validation errors.
    pub validation_errors: std::vec::Vec<crate::model::ValidationError>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "agents")]
impl ValidationResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [validation_errors][crate::model::ValidationResult::validation_errors].
    pub fn set_validation_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ValidationError>,
    {
        use std::iter::Iterator;
        self.validation_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "agents")]
impl wkt::message::Message for ValidationResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ValidationResult"
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValidationResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __validation_errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValidationResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "validationErrors" => Ok(__FieldTag::__validation_errors),
                            "validation_errors" => Ok(__FieldTag::__validation_errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValidationResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValidationResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__validation_errors => {
                            if !fields.insert(__FieldTag::__validation_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validation_errors",
                                ));
                            }
                            result.validation_errors =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ValidationError>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "agents")]
#[doc(hidden)]
impl serde::ser::Serialize for ValidationResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.validation_errors.is_empty() {
            state.serialize_entry("validationErrors", &self.validation_errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// You can create multiple versions of your agent and publish them to separate
/// environments.
///
/// When you edit an agent, you are editing the draft agent. At any point, you
/// can save the draft agent as an agent version, which is an immutable snapshot
/// of your agent.
///
/// When you save the draft agent, it is published to the default environment.
/// When you create agent versions, you can publish them to custom environments.
/// You can create a variety of custom environments for:
///
/// - testing
/// - development
/// - production
/// - etc.
///
/// For more information, see the [versions and environments
/// guide](https://cloud.google.com/dialogflow/docs/agents-versions).
#[cfg(feature = "versions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Version {
    /// Output only. The unique identifier of this agent version.
    /// Supported formats:
    ///
    /// - `projects/<Project ID>/agent/versions/<Version ID>`
    /// - `projects/<Project ID>/locations/<Location ID>/agent/versions/<Version
    ///   ID>`
    pub name: std::string::String,

    /// Optional. The developer-provided description of this version.
    pub description: std::string::String,

    /// Output only. The sequential number of this version. This field is read-only
    /// which means it cannot be set by create and update methods.
    pub version_number: i32,

    /// Output only. The creation time of this version. This field is read-only,
    /// i.e., it cannot be set by create and update methods.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The status of this version. This field is read-only and cannot
    /// be set by create and update methods.
    pub status: crate::model::version::VersionStatus,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "versions")]
impl Version {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Version::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Version::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [version_number][crate::model::Version::version_number].
    pub fn set_version_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.version_number = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Version::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Version::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::Version::status].
    pub fn set_status<T: std::convert::Into<crate::model::version::VersionStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }
}

#[cfg(feature = "versions")]
impl wkt::message::Message for Version {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.Version"
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Version {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __version_number,
            __create_time,
            __status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Version")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "versionNumber" => Ok(__FieldTag::__version_number),
                            "version_number" => Ok(__FieldTag::__version_number),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "status" => Ok(__FieldTag::__status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Version;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Version")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version_number => {
                            if !fields.insert(__FieldTag::__version_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version_number",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.version_number =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map.next_value::<std::option::Option<crate::model::version::VersionStatus>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for Version {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.version_number) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("versionNumber", &__With(&self.version_number))?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Version].
#[cfg(feature = "versions")]
pub mod version {
    #[allow(unused_imports)]
    use super::*;

    /// The status of a version.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "versions")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VersionStatus {
        /// Not specified. This value is not used.
        Unspecified,
        /// Version is not ready to serve (e.g. training is in progress).
        InProgress,
        /// Version is ready to serve.
        Ready,
        /// Version training failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VersionStatus::value] or
        /// [VersionStatus::name].
        UnknownValue(version_status::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "versions")]
    pub mod version_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "versions")]
    impl VersionStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InProgress => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VERSION_STATUS_UNSPECIFIED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "versions")]
    impl std::default::Default for VersionStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "versions")]
    impl std::fmt::Display for VersionStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "versions")]
    impl std::convert::From<i32> for VersionStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InProgress,
                2 => Self::Ready,
                3 => Self::Failed,
                _ => Self::UnknownValue(version_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "versions")]
    impl std::convert::From<&str> for VersionStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VERSION_STATUS_UNSPECIFIED" => Self::Unspecified,
                "IN_PROGRESS" => Self::InProgress,
                "READY" => Self::Ready,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(version_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "versions")]
    impl serde::ser::Serialize for VersionStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InProgress => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "versions")]
    impl<'de> serde::de::Deserialize<'de> for VersionStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VersionStatus>::new(
                ".google.cloud.dialogflow.v2.Version.VersionStatus",
            ))
        }
    }
}

/// The request message for
/// [Versions.ListVersions][google.cloud.dialogflow.v2.Versions.ListVersions].
///
/// [google.cloud.dialogflow.v2.Versions.ListVersions]: crate::client::Versions::list_versions
#[cfg(feature = "versions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVersionsRequest {
    /// Required. The agent to list all versions from.
    /// Supported formats:
    ///
    /// - `projects/<Project ID>/agent`
    /// - `projects/<Project ID>/locations/<Location ID>/agent`
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return in a single page. By
    /// default 100 and at most 1000.
    pub page_size: i32,

    /// Optional. The next_page_token value returned from a previous list request.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "versions")]
impl ListVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

#[cfg(feature = "versions")]
impl wkt::message::Message for ListVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListVersionsRequest"
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVersionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVersionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVersionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVersionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for ListVersionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for
/// [Versions.ListVersions][google.cloud.dialogflow.v2.Versions.ListVersions].
///
/// [google.cloud.dialogflow.v2.Versions.ListVersions]: crate::client::Versions::list_versions
#[cfg(feature = "versions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVersionsResponse {
    /// The list of agent versions. There will be a maximum number of items
    /// returned based on the page_size field in the request.
    pub versions: std::vec::Vec<crate::model::Version>,

    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "versions")]
impl ListVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [versions][crate::model::ListVersionsResponse::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Version>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

#[cfg(feature = "versions")]
impl wkt::message::Message for ListVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.ListVersionsResponse"
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVersionsResponse {
    type PageItem = crate::model::Version;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVersionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __versions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVersionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "versions" => Ok(__FieldTag::__versions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVersionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVersionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__versions => {
                            if !fields.insert(__FieldTag::__versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for versions",
                                ));
                            }
                            result.versions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Version>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for ListVersionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.versions.is_empty() {
            state.serialize_entry("versions", &self.versions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Versions.GetVersion][google.cloud.dialogflow.v2.Versions.GetVersion].
///
/// [google.cloud.dialogflow.v2.Versions.GetVersion]: crate::client::Versions::get_version
#[cfg(feature = "versions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVersionRequest {
    /// Required. The name of the version.
    /// Supported formats:
    ///
    /// - `projects/<Project ID>/agent/versions/<Version ID>`
    /// - `projects/<Project ID>/locations/<Location ID>/agent/versions/<Version
    ///   ID>`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "versions")]
impl GetVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "versions")]
impl wkt::message::Message for GetVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.GetVersionRequest"
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for GetVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Versions.CreateVersion][google.cloud.dialogflow.v2.Versions.CreateVersion].
///
/// [google.cloud.dialogflow.v2.Versions.CreateVersion]: crate::client::Versions::create_version
#[cfg(feature = "versions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateVersionRequest {
    /// Required. The agent to create a version for.
    /// Supported formats:
    ///
    /// - `projects/<Project ID>/agent`
    /// - `projects/<Project ID>/locations/<Location ID>/agent`
    pub parent: std::string::String,

    /// Required. The version to create.
    pub version: std::option::Option<crate::model::Version>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "versions")]
impl CreateVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVersionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [version][crate::model::CreateVersionRequest::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::CreateVersionRequest::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "versions")]
impl wkt::message::Message for CreateVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.CreateVersionRequest"
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for CreateVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Versions.UpdateVersion][google.cloud.dialogflow.v2.Versions.UpdateVersion].
///
/// [google.cloud.dialogflow.v2.Versions.UpdateVersion]: crate::client::Versions::update_version
#[cfg(feature = "versions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateVersionRequest {
    /// Required. The version to update.
    /// Supported formats:
    ///
    /// - `projects/<Project ID>/agent/versions/<Version ID>`
    /// - `projects/<Project ID>/locations/<Location ID>/agent/versions/<Version
    ///   ID>`
    pub version: std::option::Option<crate::model::Version>,

    /// Required. The mask to control which fields get updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "versions")]
impl UpdateVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::UpdateVersionRequest::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::UpdateVersionRequest::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Version>,
    {
        self.version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateVersionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateVersionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "versions")]
impl wkt::message::Message for UpdateVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.UpdateVersionRequest"
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version =
                                map.next_value::<std::option::Option<crate::model::Version>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for UpdateVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.version.is_some() {
            state.serialize_entry("version", &self.version)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for
/// [Versions.DeleteVersion][google.cloud.dialogflow.v2.Versions.DeleteVersion].
///
/// [google.cloud.dialogflow.v2.Versions.DeleteVersion]: crate::client::Versions::delete_version
#[cfg(feature = "versions")]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteVersionRequest {
    /// Required. The name of the version to delete.
    /// Supported formats:
    ///
    /// - `projects/<Project ID>/agent/versions/<Version ID>`
    /// - `projects/<Project ID>/locations/<Location ID>/agent/versions/<Version
    ///   ID>`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "versions")]
impl DeleteVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

#[cfg(feature = "versions")]
impl wkt::message::Message for DeleteVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.DeleteVersionRequest"
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteVersionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteVersionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteVersionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteVersionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(feature = "versions")]
#[doc(hidden)]
impl serde::ser::Serialize for DeleteVersionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for a webhook call.
#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WebhookRequest {
    /// The unique identifier of detectIntent request session.
    /// Can be used to identify end-user inside webhook implementation.
    /// Format: `projects/<Project ID>/agent/sessions/<Session ID>`, or
    /// `projects/<Project ID>/agent/environments/<Environment ID>/users/<User
    /// ID>/sessions/<Session ID>`.
    pub session: std::string::String,

    /// The unique identifier of the response. Contains the same value as
    /// `[Streaming]DetectIntentResponse.response_id`.
    pub response_id: std::string::String,

    /// The result of the conversational query or event processing. Contains the
    /// same value as `[Streaming]DetectIntentResponse.query_result`.
    pub query_result: std::option::Option<crate::model::QueryResult>,

    /// Optional. The contents of the original request that was passed to
    /// `[Streaming]DetectIntent` call.
    pub original_detect_intent_request:
        std::option::Option<crate::model::OriginalDetectIntentRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
impl WebhookRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session][crate::model::WebhookRequest::session].
    pub fn set_session<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.session = v.into();
        self
    }

    /// Sets the value of [response_id][crate::model::WebhookRequest::response_id].
    pub fn set_response_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.response_id = v.into();
        self
    }

    /// Sets the value of [query_result][crate::model::WebhookRequest::query_result].
    pub fn set_query_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QueryResult>,
    {
        self.query_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_result][crate::model::WebhookRequest::query_result].
    pub fn set_or_clear_query_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QueryResult>,
    {
        self.query_result = v.map(|x| x.into());
        self
    }

    /// Sets the value of [original_detect_intent_request][crate::model::WebhookRequest::original_detect_intent_request].
    pub fn set_original_detect_intent_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OriginalDetectIntentRequest>,
    {
        self.original_detect_intent_request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_detect_intent_request][crate::model::WebhookRequest::original_detect_intent_request].
    pub fn set_or_clear_original_detect_intent_request<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::OriginalDetectIntentRequest>,
    {
        self.original_detect_intent_request = v.map(|x| x.into());
        self
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
impl wkt::message::Message for WebhookRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.WebhookRequest"
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WebhookRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session,
            __response_id,
            __query_result,
            __original_detect_intent_request,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WebhookRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "session" => Ok(__FieldTag::__session),
                            "responseId" => Ok(__FieldTag::__response_id),
                            "response_id" => Ok(__FieldTag::__response_id),
                            "queryResult" => Ok(__FieldTag::__query_result),
                            "query_result" => Ok(__FieldTag::__query_result),
                            "originalDetectIntentRequest" => {
                                Ok(__FieldTag::__original_detect_intent_request)
                            }
                            "original_detect_intent_request" => {
                                Ok(__FieldTag::__original_detect_intent_request)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WebhookRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WebhookRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session => {
                            if !fields.insert(__FieldTag::__session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session",
                                ));
                            }
                            result.session = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__response_id => {
                            if !fields.insert(__FieldTag::__response_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_id",
                                ));
                            }
                            result.response_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query_result => {
                            if !fields.insert(__FieldTag::__query_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query_result",
                                ));
                            }
                            result.query_result =
                                map.next_value::<std::option::Option<crate::model::QueryResult>>()?;
                        }
                        __FieldTag::__original_detect_intent_request => {
                            if !fields.insert(__FieldTag::__original_detect_intent_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_detect_intent_request",
                                ));
                            }
                            result.original_detect_intent_request = map.next_value::<std::option::Option<crate::model::OriginalDetectIntentRequest>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for WebhookRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.session.is_empty() {
            state.serialize_entry("session", &self.session)?;
        }
        if !self.response_id.is_empty() {
            state.serialize_entry("responseId", &self.response_id)?;
        }
        if self.query_result.is_some() {
            state.serialize_entry("queryResult", &self.query_result)?;
        }
        if self.original_detect_intent_request.is_some() {
            state.serialize_entry(
                "originalDetectIntentRequest",
                &self.original_detect_intent_request,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for a webhook call.
///
/// This response is validated by the Dialogflow server. If validation fails,
/// an error will be returned in the
/// [QueryResult.diagnostic_info][google.cloud.dialogflow.v2.QueryResult.diagnostic_info]
/// field. Setting JSON fields to an empty value with the wrong type is a common
/// error. To avoid this error:
///
/// - Use `""` for empty strings
/// - Use `{}` or `null` for empty objects
/// - Use `[]` or `null` for empty arrays
///
/// For more information, see the
/// [Protocol Buffers Language
/// Guide](https://developers.google.com/protocol-buffers/docs/proto3#json).
///
/// [google.cloud.dialogflow.v2.QueryResult.diagnostic_info]: crate::model::QueryResult::diagnostic_info
#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WebhookResponse {
    /// Optional. The text response message intended for the end-user.
    /// It is recommended to use `fulfillment_messages.text.text[0]` instead.
    /// When provided, Dialogflow uses this field to populate
    /// [QueryResult.fulfillment_text][google.cloud.dialogflow.v2.QueryResult.fulfillment_text]
    /// sent to the integration or API caller.
    ///
    /// [google.cloud.dialogflow.v2.QueryResult.fulfillment_text]: crate::model::QueryResult::fulfillment_text
    pub fulfillment_text: std::string::String,

    /// Optional. The rich response messages intended for the end-user.
    /// When provided, Dialogflow uses this field to populate
    /// [QueryResult.fulfillment_messages][google.cloud.dialogflow.v2.QueryResult.fulfillment_messages]
    /// sent to the integration or API caller.
    ///
    /// [google.cloud.dialogflow.v2.QueryResult.fulfillment_messages]: crate::model::QueryResult::fulfillment_messages
    pub fulfillment_messages: std::vec::Vec<crate::model::intent::Message>,

    /// Optional. A custom field used to identify the webhook source.
    /// Arbitrary strings are supported.
    /// When provided, Dialogflow uses this field to populate
    /// [QueryResult.webhook_source][google.cloud.dialogflow.v2.QueryResult.webhook_source]
    /// sent to the integration or API caller.
    ///
    /// [google.cloud.dialogflow.v2.QueryResult.webhook_source]: crate::model::QueryResult::webhook_source
    pub source: std::string::String,

    /// Optional. This field can be used to pass custom data from your webhook to
    /// the integration or API caller. Arbitrary JSON objects are supported. When
    /// provided, Dialogflow uses this field to populate
    /// [QueryResult.webhook_payload][google.cloud.dialogflow.v2.QueryResult.webhook_payload]
    /// sent to the integration or API caller. This field is also used by the
    /// [Google Assistant
    /// integration](https://cloud.google.com/dialogflow/docs/integrations/aog)
    /// for rich response messages.
    /// See the format definition at [Google Assistant Dialogflow webhook
    /// format](https://developers.google.com/assistant/actions/build/json/dialogflow-webhook-json)
    ///
    /// [google.cloud.dialogflow.v2.QueryResult.webhook_payload]: crate::model::QueryResult::webhook_payload
    pub payload: std::option::Option<wkt::Struct>,

    /// Optional. The collection of output contexts that will overwrite currently
    /// active contexts for the session and reset their lifespans.
    /// When provided, Dialogflow uses this field to populate
    /// [QueryResult.output_contexts][google.cloud.dialogflow.v2.QueryResult.output_contexts]
    /// sent to the integration or API caller.
    ///
    /// [google.cloud.dialogflow.v2.QueryResult.output_contexts]: crate::model::QueryResult::output_contexts
    pub output_contexts: std::vec::Vec<crate::model::Context>,

    /// Optional. Invokes the supplied events.
    /// When this field is set, Dialogflow ignores the `fulfillment_text`,
    /// `fulfillment_messages`, and `payload` fields.
    pub followup_event_input: std::option::Option<crate::model::EventInput>,

    /// Optional. Additional session entity types to replace or extend developer
    /// entity types with. The entity synonyms apply to all languages and persist
    /// for the session. Setting this data from a webhook overwrites
    /// the session entity types that have been set using `detectIntent`,
    /// `streamingDetectIntent` or
    /// [SessionEntityType][google.cloud.dialogflow.v2.SessionEntityType]
    /// management methods.
    ///
    /// [google.cloud.dialogflow.v2.SessionEntityType]: crate::model::SessionEntityType
    pub session_entity_types: std::vec::Vec<crate::model::SessionEntityType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
impl WebhookResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fulfillment_text][crate::model::WebhookResponse::fulfillment_text].
    pub fn set_fulfillment_text<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.fulfillment_text = v.into();
        self
    }

    /// Sets the value of [fulfillment_messages][crate::model::WebhookResponse::fulfillment_messages].
    pub fn set_fulfillment_messages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::intent::Message>,
    {
        use std::iter::Iterator;
        self.fulfillment_messages = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source][crate::model::WebhookResponse::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [payload][crate::model::WebhookResponse::payload].
    pub fn set_payload<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.payload = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [payload][crate::model::WebhookResponse::payload].
    pub fn set_or_clear_payload<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.payload = v.map(|x| x.into());
        self
    }

    /// Sets the value of [output_contexts][crate::model::WebhookResponse::output_contexts].
    pub fn set_output_contexts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Context>,
    {
        use std::iter::Iterator;
        self.output_contexts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [followup_event_input][crate::model::WebhookResponse::followup_event_input].
    pub fn set_followup_event_input<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EventInput>,
    {
        self.followup_event_input = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [followup_event_input][crate::model::WebhookResponse::followup_event_input].
    pub fn set_or_clear_followup_event_input<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EventInput>,
    {
        self.followup_event_input = v.map(|x| x.into());
        self
    }

    /// Sets the value of [session_entity_types][crate::model::WebhookResponse::session_entity_types].
    pub fn set_session_entity_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SessionEntityType>,
    {
        use std::iter::Iterator;
        self.session_entity_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
impl wkt::message::Message for WebhookResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.WebhookResponse"
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WebhookResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fulfillment_text,
            __fulfillment_messages,
            __source,
            __payload,
            __output_contexts,
            __followup_event_input,
            __session_entity_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WebhookResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fulfillmentText" => Ok(__FieldTag::__fulfillment_text),
                            "fulfillment_text" => Ok(__FieldTag::__fulfillment_text),
                            "fulfillmentMessages" => Ok(__FieldTag::__fulfillment_messages),
                            "fulfillment_messages" => Ok(__FieldTag::__fulfillment_messages),
                            "source" => Ok(__FieldTag::__source),
                            "payload" => Ok(__FieldTag::__payload),
                            "outputContexts" => Ok(__FieldTag::__output_contexts),
                            "output_contexts" => Ok(__FieldTag::__output_contexts),
                            "followupEventInput" => Ok(__FieldTag::__followup_event_input),
                            "followup_event_input" => Ok(__FieldTag::__followup_event_input),
                            "sessionEntityTypes" => Ok(__FieldTag::__session_entity_types),
                            "session_entity_types" => Ok(__FieldTag::__session_entity_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WebhookResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WebhookResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fulfillment_text => {
                            if !fields.insert(__FieldTag::__fulfillment_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fulfillment_text",
                                ));
                            }
                            result.fulfillment_text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fulfillment_messages => {
                            if !fields.insert(__FieldTag::__fulfillment_messages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fulfillment_messages",
                                ));
                            }
                            result.fulfillment_messages =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::intent::Message>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__payload => {
                            if !fields.insert(__FieldTag::__payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload",
                                ));
                            }
                            result.payload =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::__output_contexts => {
                            if !fields.insert(__FieldTag::__output_contexts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for output_contexts",
                                ));
                            }
                            result.output_contexts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Context>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__followup_event_input => {
                            if !fields.insert(__FieldTag::__followup_event_input) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for followup_event_input",
                                ));
                            }
                            result.followup_event_input =
                                map.next_value::<std::option::Option<crate::model::EventInput>>()?;
                        }
                        __FieldTag::__session_entity_types => {
                            if !fields.insert(__FieldTag::__session_entity_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session_entity_types",
                                ));
                            }
                            result.session_entity_types =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SessionEntityType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for WebhookResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.fulfillment_text.is_empty() {
            state.serialize_entry("fulfillmentText", &self.fulfillment_text)?;
        }
        if !self.fulfillment_messages.is_empty() {
            state.serialize_entry("fulfillmentMessages", &self.fulfillment_messages)?;
        }
        if !self.source.is_empty() {
            state.serialize_entry("source", &self.source)?;
        }
        if self.payload.is_some() {
            state.serialize_entry("payload", &self.payload)?;
        }
        if !self.output_contexts.is_empty() {
            state.serialize_entry("outputContexts", &self.output_contexts)?;
        }
        if self.followup_event_input.is_some() {
            state.serialize_entry("followupEventInput", &self.followup_event_input)?;
        }
        if !self.session_entity_types.is_empty() {
            state.serialize_entry("sessionEntityTypes", &self.session_entity_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the contents of the original request that was passed to
/// the `[Streaming]DetectIntent` call.
#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OriginalDetectIntentRequest {
    /// The source of this request, e.g., `google`, `facebook`, `slack`. It is set
    /// by Dialogflow-owned servers.
    pub source: std::string::String,

    /// Optional. The version of the protocol used for this request.
    /// This field is AoG-specific.
    pub version: std::string::String,

    /// Optional. This field is set to the value of the `QueryParameters.payload`
    /// field passed in the request. Some integrations that query a Dialogflow
    /// agent may provide additional information in the payload.
    ///
    /// In particular, for the Dialogflow Phone Gateway integration, this field has
    /// the form:
    ///
    /// Note: The caller ID field (`caller_id`) will be redacted for Trial
    /// Edition agents and populated with the caller ID in [E.164
    /// format](https://en.wikipedia.org/wiki/E.164) for Essentials Edition agents.
    pub payload: std::option::Option<wkt::Struct>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
impl OriginalDetectIntentRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::OriginalDetectIntentRequest::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [version][crate::model::OriginalDetectIntentRequest::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [payload][crate::model::OriginalDetectIntentRequest::payload].
    pub fn set_payload<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.payload = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [payload][crate::model::OriginalDetectIntentRequest::payload].
    pub fn set_or_clear_payload<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Struct>,
    {
        self.payload = v.map(|x| x.into());
        self
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
impl wkt::message::Message for OriginalDetectIntentRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dialogflow.v2.OriginalDetectIntentRequest"
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OriginalDetectIntentRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source,
            __version,
            __payload,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OriginalDetectIntentRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "source" => Ok(__FieldTag::__source),
                            "version" => Ok(__FieldTag::__version),
                            "payload" => Ok(__FieldTag::__payload),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OriginalDetectIntentRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OriginalDetectIntentRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__payload => {
                            if !fields.insert(__FieldTag::__payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for payload",
                                ));
                            }
                            result.payload =
                                map.next_value::<std::option::Option<wkt::Struct>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[cfg(all(
    feature = "agents",
    feature = "answer-records",
    feature = "contexts",
    feature = "conversation-datasets",
    feature = "conversation-models",
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "documents",
    feature = "encryption-spec-service",
    feature = "entity-types",
    feature = "environments",
    feature = "fulfillments",
    feature = "generators",
    feature = "intents",
    feature = "knowledge-bases",
    feature = "participants",
    feature = "session-entity-types",
    feature = "sessions",
    feature = "versions",
))]
#[doc(hidden)]
impl serde::ser::Serialize for OriginalDetectIntentRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source.is_empty() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if self.payload.is_some() {
            state.serialize_entry("payload", &self.payload)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// [DTMF](https://en.wikipedia.org/wiki/Dual-tone_multi-frequency_signaling)
/// digit in Telephony Gateway.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(feature = "participants")]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TelephonyDtmf {
    /// Not specified. This value may be used to indicate an absent digit.
    Unspecified,
    /// Number: '1'.
    DtmfOne,
    /// Number: '2'.
    DtmfTwo,
    /// Number: '3'.
    DtmfThree,
    /// Number: '4'.
    DtmfFour,
    /// Number: '5'.
    DtmfFive,
    /// Number: '6'.
    DtmfSix,
    /// Number: '7'.
    DtmfSeven,
    /// Number: '8'.
    DtmfEight,
    /// Number: '9'.
    DtmfNine,
    /// Number: '0'.
    DtmfZero,
    /// Letter: 'A'.
    DtmfA,
    /// Letter: 'B'.
    DtmfB,
    /// Letter: 'C'.
    DtmfC,
    /// Letter: 'D'.
    DtmfD,
    /// Asterisk/star: '*'.
    DtmfStar,
    /// Pound/diamond/hash/square/gate/octothorpe: '#'.
    DtmfPound,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TelephonyDtmf::value] or
    /// [TelephonyDtmf::name].
    UnknownValue(telephony_dtmf::UnknownValue),
}

#[doc(hidden)]
#[cfg(feature = "participants")]
pub mod telephony_dtmf {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(feature = "participants")]
impl TelephonyDtmf {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::DtmfOne => std::option::Option::Some(1),
            Self::DtmfTwo => std::option::Option::Some(2),
            Self::DtmfThree => std::option::Option::Some(3),
            Self::DtmfFour => std::option::Option::Some(4),
            Self::DtmfFive => std::option::Option::Some(5),
            Self::DtmfSix => std::option::Option::Some(6),
            Self::DtmfSeven => std::option::Option::Some(7),
            Self::DtmfEight => std::option::Option::Some(8),
            Self::DtmfNine => std::option::Option::Some(9),
            Self::DtmfZero => std::option::Option::Some(10),
            Self::DtmfA => std::option::Option::Some(11),
            Self::DtmfB => std::option::Option::Some(12),
            Self::DtmfC => std::option::Option::Some(13),
            Self::DtmfD => std::option::Option::Some(14),
            Self::DtmfStar => std::option::Option::Some(15),
            Self::DtmfPound => std::option::Option::Some(16),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TELEPHONY_DTMF_UNSPECIFIED"),
            Self::DtmfOne => std::option::Option::Some("DTMF_ONE"),
            Self::DtmfTwo => std::option::Option::Some("DTMF_TWO"),
            Self::DtmfThree => std::option::Option::Some("DTMF_THREE"),
            Self::DtmfFour => std::option::Option::Some("DTMF_FOUR"),
            Self::DtmfFive => std::option::Option::Some("DTMF_FIVE"),
            Self::DtmfSix => std::option::Option::Some("DTMF_SIX"),
            Self::DtmfSeven => std::option::Option::Some("DTMF_SEVEN"),
            Self::DtmfEight => std::option::Option::Some("DTMF_EIGHT"),
            Self::DtmfNine => std::option::Option::Some("DTMF_NINE"),
            Self::DtmfZero => std::option::Option::Some("DTMF_ZERO"),
            Self::DtmfA => std::option::Option::Some("DTMF_A"),
            Self::DtmfB => std::option::Option::Some("DTMF_B"),
            Self::DtmfC => std::option::Option::Some("DTMF_C"),
            Self::DtmfD => std::option::Option::Some("DTMF_D"),
            Self::DtmfStar => std::option::Option::Some("DTMF_STAR"),
            Self::DtmfPound => std::option::Option::Some("DTMF_POUND"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(feature = "participants")]
impl std::default::Default for TelephonyDtmf {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(feature = "participants")]
impl std::fmt::Display for TelephonyDtmf {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(feature = "participants")]
impl std::convert::From<i32> for TelephonyDtmf {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::DtmfOne,
            2 => Self::DtmfTwo,
            3 => Self::DtmfThree,
            4 => Self::DtmfFour,
            5 => Self::DtmfFive,
            6 => Self::DtmfSix,
            7 => Self::DtmfSeven,
            8 => Self::DtmfEight,
            9 => Self::DtmfNine,
            10 => Self::DtmfZero,
            11 => Self::DtmfA,
            12 => Self::DtmfB,
            13 => Self::DtmfC,
            14 => Self::DtmfD,
            15 => Self::DtmfStar,
            16 => Self::DtmfPound,
            _ => Self::UnknownValue(telephony_dtmf::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(feature = "participants")]
impl std::convert::From<&str> for TelephonyDtmf {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TELEPHONY_DTMF_UNSPECIFIED" => Self::Unspecified,
            "DTMF_ONE" => Self::DtmfOne,
            "DTMF_TWO" => Self::DtmfTwo,
            "DTMF_THREE" => Self::DtmfThree,
            "DTMF_FOUR" => Self::DtmfFour,
            "DTMF_FIVE" => Self::DtmfFive,
            "DTMF_SIX" => Self::DtmfSix,
            "DTMF_SEVEN" => Self::DtmfSeven,
            "DTMF_EIGHT" => Self::DtmfEight,
            "DTMF_NINE" => Self::DtmfNine,
            "DTMF_ZERO" => Self::DtmfZero,
            "DTMF_A" => Self::DtmfA,
            "DTMF_B" => Self::DtmfB,
            "DTMF_C" => Self::DtmfC,
            "DTMF_D" => Self::DtmfD,
            "DTMF_STAR" => Self::DtmfStar,
            "DTMF_POUND" => Self::DtmfPound,
            _ => Self::UnknownValue(telephony_dtmf::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(feature = "participants")]
impl serde::ser::Serialize for TelephonyDtmf {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::DtmfOne => serializer.serialize_i32(1),
            Self::DtmfTwo => serializer.serialize_i32(2),
            Self::DtmfThree => serializer.serialize_i32(3),
            Self::DtmfFour => serializer.serialize_i32(4),
            Self::DtmfFive => serializer.serialize_i32(5),
            Self::DtmfSix => serializer.serialize_i32(6),
            Self::DtmfSeven => serializer.serialize_i32(7),
            Self::DtmfEight => serializer.serialize_i32(8),
            Self::DtmfNine => serializer.serialize_i32(9),
            Self::DtmfZero => serializer.serialize_i32(10),
            Self::DtmfA => serializer.serialize_i32(11),
            Self::DtmfB => serializer.serialize_i32(12),
            Self::DtmfC => serializer.serialize_i32(13),
            Self::DtmfD => serializer.serialize_i32(14),
            Self::DtmfStar => serializer.serialize_i32(15),
            Self::DtmfPound => serializer.serialize_i32(16),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(feature = "participants")]
impl<'de> serde::de::Deserialize<'de> for TelephonyDtmf {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TelephonyDtmf>::new(
            ".google.cloud.dialogflow.v2.TelephonyDtmf",
        ))
    }
}

/// Audio encoding of the audio content sent in the conversational query request.
/// Refer to the
/// [Cloud Speech API
/// documentation](https://cloud.google.com/speech-to-text/docs/basics) for more
/// details.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AudioEncoding {
    /// Not specified.
    Unspecified,
    /// Uncompressed 16-bit signed little-endian samples (Linear PCM).
    Linear16,
    /// [`FLAC`](https://xiph.org/flac/documentation.html) (Free Lossless Audio
    /// Codec) is the recommended encoding because it is lossless (therefore
    /// recognition is not compromised) and requires only about half the
    /// bandwidth of `LINEAR16`. `FLAC` stream encoding supports 16-bit and
    /// 24-bit samples, however, not all fields in `STREAMINFO` are supported.
    Flac,
    /// 8-bit samples that compand 14-bit audio samples using G.711 PCMU/mu-law.
    Mulaw,
    /// Adaptive Multi-Rate Narrowband codec. `sample_rate_hertz` must be 8000.
    Amr,
    /// Adaptive Multi-Rate Wideband codec. `sample_rate_hertz` must be 16000.
    AmrWb,
    /// Opus encoded audio frames in Ogg container
    /// ([OggOpus](https://wiki.xiph.org/OggOpus)).
    /// `sample_rate_hertz` must be 16000.
    OggOpus,
    /// Although the use of lossy encodings is not recommended, if a very low
    /// bitrate encoding is required, `OGG_OPUS` is highly preferred over
    /// Speex encoding. The [Speex](https://speex.org/) encoding supported by
    /// Dialogflow API has a header byte in each block, as in MIME type
    /// `audio/x-speex-with-header-byte`.
    /// It is a variant of the RTP Speex encoding defined in
    /// [RFC 5574](https://tools.ietf.org/html/rfc5574).
    /// The stream is a sequence of blocks, one block per RTP packet. Each block
    /// starts with a byte containing the length of the block, in bytes, followed
    /// by one or more frames of Speex data, padded to an integral number of
    /// bytes (octets) as specified in RFC 5574. In other words, each RTP header
    /// is replaced with a single byte containing the block length. Only Speex
    /// wideband is supported. `sample_rate_hertz` must be 16000.
    SpeexWithHeaderByte,
    /// 8-bit samples that compand 13-bit audio samples using G.711 PCMU/a-law.
    Alaw,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AudioEncoding::value] or
    /// [AudioEncoding::name].
    UnknownValue(audio_encoding::UnknownValue),
}

#[doc(hidden)]
#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
pub mod audio_encoding {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl AudioEncoding {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Linear16 => std::option::Option::Some(1),
            Self::Flac => std::option::Option::Some(2),
            Self::Mulaw => std::option::Option::Some(3),
            Self::Amr => std::option::Option::Some(4),
            Self::AmrWb => std::option::Option::Some(5),
            Self::OggOpus => std::option::Option::Some(6),
            Self::SpeexWithHeaderByte => std::option::Option::Some(7),
            Self::Alaw => std::option::Option::Some(8),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("AUDIO_ENCODING_UNSPECIFIED"),
            Self::Linear16 => std::option::Option::Some("AUDIO_ENCODING_LINEAR_16"),
            Self::Flac => std::option::Option::Some("AUDIO_ENCODING_FLAC"),
            Self::Mulaw => std::option::Option::Some("AUDIO_ENCODING_MULAW"),
            Self::Amr => std::option::Option::Some("AUDIO_ENCODING_AMR"),
            Self::AmrWb => std::option::Option::Some("AUDIO_ENCODING_AMR_WB"),
            Self::OggOpus => std::option::Option::Some("AUDIO_ENCODING_OGG_OPUS"),
            Self::SpeexWithHeaderByte => {
                std::option::Option::Some("AUDIO_ENCODING_SPEEX_WITH_HEADER_BYTE")
            }
            Self::Alaw => std::option::Option::Some("AUDIO_ENCODING_ALAW"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl std::default::Default for AudioEncoding {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl std::fmt::Display for AudioEncoding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl std::convert::From<i32> for AudioEncoding {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Linear16,
            2 => Self::Flac,
            3 => Self::Mulaw,
            4 => Self::Amr,
            5 => Self::AmrWb,
            6 => Self::OggOpus,
            7 => Self::SpeexWithHeaderByte,
            8 => Self::Alaw,
            _ => Self::UnknownValue(audio_encoding::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl std::convert::From<&str> for AudioEncoding {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "AUDIO_ENCODING_UNSPECIFIED" => Self::Unspecified,
            "AUDIO_ENCODING_LINEAR_16" => Self::Linear16,
            "AUDIO_ENCODING_FLAC" => Self::Flac,
            "AUDIO_ENCODING_MULAW" => Self::Mulaw,
            "AUDIO_ENCODING_AMR" => Self::Amr,
            "AUDIO_ENCODING_AMR_WB" => Self::AmrWb,
            "AUDIO_ENCODING_OGG_OPUS" => Self::OggOpus,
            "AUDIO_ENCODING_SPEEX_WITH_HEADER_BYTE" => Self::SpeexWithHeaderByte,
            "AUDIO_ENCODING_ALAW" => Self::Alaw,
            _ => Self::UnknownValue(audio_encoding::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl serde::ser::Serialize for AudioEncoding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Linear16 => serializer.serialize_i32(1),
            Self::Flac => serializer.serialize_i32(2),
            Self::Mulaw => serializer.serialize_i32(3),
            Self::Amr => serializer.serialize_i32(4),
            Self::AmrWb => serializer.serialize_i32(5),
            Self::OggOpus => serializer.serialize_i32(6),
            Self::SpeexWithHeaderByte => serializer.serialize_i32(7),
            Self::Alaw => serializer.serialize_i32(8),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl<'de> serde::de::Deserialize<'de> for AudioEncoding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AudioEncoding>::new(
            ".google.cloud.dialogflow.v2.AudioEncoding",
        ))
    }
}

/// Variant of the specified [Speech
/// model][google.cloud.dialogflow.v2.InputAudioConfig.model] to use.
///
/// See the [Cloud Speech
/// documentation](https://cloud.google.com/speech-to-text/docs/enhanced-models)
/// for which models have different variants. For example, the "phone_call" model
/// has both a standard and an enhanced variant. When you use an enhanced model,
/// you will generally receive higher quality results than for a standard model.
///
/// [google.cloud.dialogflow.v2.InputAudioConfig.model]: crate::model::InputAudioConfig::model
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SpeechModelVariant {
    /// No model variant specified. In this case Dialogflow defaults to
    /// USE_BEST_AVAILABLE.
    Unspecified,
    /// Use the best available variant of the [Speech model][model] that the caller
    /// is eligible for.
    ///
    /// Please see the [Dialogflow
    /// docs](https://cloud.google.com/dialogflow/docs/data-logging) for
    /// how to make your project eligible for enhanced models.
    UseBestAvailable,
    /// Use standard model variant even if an enhanced model is available.  See the
    /// [Cloud Speech
    /// documentation](https://cloud.google.com/speech-to-text/docs/enhanced-models)
    /// for details about enhanced models.
    UseStandard,
    /// Use an enhanced model variant:
    ///
    /// * If an enhanced variant does not exist for the given
    ///   [model][google.cloud.dialogflow.v2.InputAudioConfig.model] and request
    ///   language, Dialogflow falls back to the standard variant.
    ///
    ///   The [Cloud Speech
    ///   documentation](https://cloud.google.com/speech-to-text/docs/enhanced-models)
    ///   describes which models have enhanced variants.
    ///
    /// * If the API caller isn't eligible for enhanced models, Dialogflow returns
    ///   an error. Please see the [Dialogflow
    ///   docs](https://cloud.google.com/dialogflow/docs/data-logging)
    ///   for how to make your project eligible.
    ///
    ///
    /// [google.cloud.dialogflow.v2.InputAudioConfig.model]: crate::model::InputAudioConfig::model
    UseEnhanced,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SpeechModelVariant::value] or
    /// [SpeechModelVariant::name].
    UnknownValue(speech_model_variant::UnknownValue),
}

#[doc(hidden)]
#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
pub mod speech_model_variant {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl SpeechModelVariant {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::UseBestAvailable => std::option::Option::Some(1),
            Self::UseStandard => std::option::Option::Some(2),
            Self::UseEnhanced => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SPEECH_MODEL_VARIANT_UNSPECIFIED"),
            Self::UseBestAvailable => std::option::Option::Some("USE_BEST_AVAILABLE"),
            Self::UseStandard => std::option::Option::Some("USE_STANDARD"),
            Self::UseEnhanced => std::option::Option::Some("USE_ENHANCED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl std::default::Default for SpeechModelVariant {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl std::fmt::Display for SpeechModelVariant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl std::convert::From<i32> for SpeechModelVariant {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::UseBestAvailable,
            2 => Self::UseStandard,
            3 => Self::UseEnhanced,
            _ => Self::UnknownValue(speech_model_variant::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl std::convert::From<&str> for SpeechModelVariant {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SPEECH_MODEL_VARIANT_UNSPECIFIED" => Self::Unspecified,
            "USE_BEST_AVAILABLE" => Self::UseBestAvailable,
            "USE_STANDARD" => Self::UseStandard,
            "USE_ENHANCED" => Self::UseEnhanced,
            _ => Self::UnknownValue(speech_model_variant::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl serde::ser::Serialize for SpeechModelVariant {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::UseBestAvailable => serializer.serialize_i32(1),
            Self::UseStandard => serializer.serialize_i32(2),
            Self::UseEnhanced => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "participants",
    feature = "sessions",
))]
impl<'de> serde::de::Deserialize<'de> for SpeechModelVariant {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SpeechModelVariant>::new(
            ".google.cloud.dialogflow.v2.SpeechModelVariant",
        ))
    }
}

/// Gender of the voice as described in
/// [SSML voice element](https://www.w3.org/TR/speech-synthesis11/#edef_voice).
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum SsmlVoiceGender {
    /// An unspecified gender, which means that the client doesn't care which
    /// gender the selected voice will have.
    Unspecified,
    /// A male voice.
    Male,
    /// A female voice.
    Female,
    /// A gender-neutral voice.
    Neutral,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [SsmlVoiceGender::value] or
    /// [SsmlVoiceGender::name].
    UnknownValue(ssml_voice_gender::UnknownValue),
}

#[doc(hidden)]
#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
pub mod ssml_voice_gender {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
impl SsmlVoiceGender {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Male => std::option::Option::Some(1),
            Self::Female => std::option::Option::Some(2),
            Self::Neutral => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("SSML_VOICE_GENDER_UNSPECIFIED"),
            Self::Male => std::option::Option::Some("SSML_VOICE_GENDER_MALE"),
            Self::Female => std::option::Option::Some("SSML_VOICE_GENDER_FEMALE"),
            Self::Neutral => std::option::Option::Some("SSML_VOICE_GENDER_NEUTRAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
impl std::default::Default for SsmlVoiceGender {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
impl std::fmt::Display for SsmlVoiceGender {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
impl std::convert::From<i32> for SsmlVoiceGender {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Male,
            2 => Self::Female,
            3 => Self::Neutral,
            _ => Self::UnknownValue(ssml_voice_gender::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
impl std::convert::From<&str> for SsmlVoiceGender {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "SSML_VOICE_GENDER_UNSPECIFIED" => Self::Unspecified,
            "SSML_VOICE_GENDER_MALE" => Self::Male,
            "SSML_VOICE_GENDER_FEMALE" => Self::Female,
            "SSML_VOICE_GENDER_NEUTRAL" => Self::Neutral,
            _ => Self::UnknownValue(ssml_voice_gender::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
impl serde::ser::Serialize for SsmlVoiceGender {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Male => serializer.serialize_i32(1),
            Self::Female => serializer.serialize_i32(2),
            Self::Neutral => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(any(
    feature = "conversation-profiles",
    feature = "conversations",
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
impl<'de> serde::de::Deserialize<'de> for SsmlVoiceGender {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<SsmlVoiceGender>::new(
            ".google.cloud.dialogflow.v2.SsmlVoiceGender",
        ))
    }
}

/// Audio encoding of the output audio format in Text-To-Speech.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(any(
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum OutputAudioEncoding {
    /// Not specified.
    Unspecified,
    /// Uncompressed 16-bit signed little-endian samples (Linear PCM).
    /// Audio content returned as LINEAR16 also contains a WAV header.
    Linear16,
    /// MP3 audio at 32kbps.
    Mp3,
    /// MP3 audio at 64kbps.
    Mp364Kbps,
    /// Opus encoded audio wrapped in an ogg container. The result will be a
    /// file which can be played natively on Android, and in browsers (at least
    /// Chrome and Firefox). The quality of the encoding is considerably higher
    /// than MP3 while using approximately the same bitrate.
    OggOpus,
    /// 8-bit samples that compand 14-bit audio samples using G.711 PCMU/mu-law.
    Mulaw,
    /// 8-bit samples that compand 13-bit audio samples using G.711 PCMU/a-law.
    Alaw,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [OutputAudioEncoding::value] or
    /// [OutputAudioEncoding::name].
    UnknownValue(output_audio_encoding::UnknownValue),
}

#[doc(hidden)]
#[cfg(any(
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
pub mod output_audio_encoding {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(any(
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
impl OutputAudioEncoding {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Linear16 => std::option::Option::Some(1),
            Self::Mp3 => std::option::Option::Some(2),
            Self::Mp364Kbps => std::option::Option::Some(4),
            Self::OggOpus => std::option::Option::Some(3),
            Self::Mulaw => std::option::Option::Some(5),
            Self::Alaw => std::option::Option::Some(6),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("OUTPUT_AUDIO_ENCODING_UNSPECIFIED"),
            Self::Linear16 => std::option::Option::Some("OUTPUT_AUDIO_ENCODING_LINEAR_16"),
            Self::Mp3 => std::option::Option::Some("OUTPUT_AUDIO_ENCODING_MP3"),
            Self::Mp364Kbps => std::option::Option::Some("OUTPUT_AUDIO_ENCODING_MP3_64_KBPS"),
            Self::OggOpus => std::option::Option::Some("OUTPUT_AUDIO_ENCODING_OGG_OPUS"),
            Self::Mulaw => std::option::Option::Some("OUTPUT_AUDIO_ENCODING_MULAW"),
            Self::Alaw => std::option::Option::Some("OUTPUT_AUDIO_ENCODING_ALAW"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(any(
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
impl std::default::Default for OutputAudioEncoding {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(any(
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
impl std::fmt::Display for OutputAudioEncoding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(any(
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
impl std::convert::From<i32> for OutputAudioEncoding {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Linear16,
            2 => Self::Mp3,
            3 => Self::OggOpus,
            4 => Self::Mp364Kbps,
            5 => Self::Mulaw,
            6 => Self::Alaw,
            _ => Self::UnknownValue(output_audio_encoding::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(any(
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
impl std::convert::From<&str> for OutputAudioEncoding {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "OUTPUT_AUDIO_ENCODING_UNSPECIFIED" => Self::Unspecified,
            "OUTPUT_AUDIO_ENCODING_LINEAR_16" => Self::Linear16,
            "OUTPUT_AUDIO_ENCODING_MP3" => Self::Mp3,
            "OUTPUT_AUDIO_ENCODING_MP3_64_KBPS" => Self::Mp364Kbps,
            "OUTPUT_AUDIO_ENCODING_OGG_OPUS" => Self::OggOpus,
            "OUTPUT_AUDIO_ENCODING_MULAW" => Self::Mulaw,
            "OUTPUT_AUDIO_ENCODING_ALAW" => Self::Alaw,
            _ => Self::UnknownValue(output_audio_encoding::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(any(
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
impl serde::ser::Serialize for OutputAudioEncoding {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Linear16 => serializer.serialize_i32(1),
            Self::Mp3 => serializer.serialize_i32(2),
            Self::Mp364Kbps => serializer.serialize_i32(4),
            Self::OggOpus => serializer.serialize_i32(3),
            Self::Mulaw => serializer.serialize_i32(5),
            Self::Alaw => serializer.serialize_i32(6),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(any(
    feature = "environments",
    feature = "participants",
    feature = "sessions",
))]
impl<'de> serde::de::Deserialize<'de> for OutputAudioEncoding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<OutputAudioEncoding>::new(
            ".google.cloud.dialogflow.v2.OutputAudioEncoding",
        ))
    }
}

/// The event that triggers the generator and LLM execution.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(any(feature = "conversations", feature = "generators",))]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TriggerEvent {
    /// Default value for TriggerEvent.
    Unspecified,
    /// Triggers when each chat message or voice utterance ends.
    EndOfUtterance,
    /// Triggers on the conversation manually by API calls, such as
    /// Conversations.GenerateStatelessSuggestion and
    /// Conversations.GenerateSuggestions.
    ManualCall,
    /// Triggers after each customer message only.
    CustomerMessage,
    /// Triggers after each agent message only.
    AgentMessage,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TriggerEvent::value] or
    /// [TriggerEvent::name].
    UnknownValue(trigger_event::UnknownValue),
}

#[doc(hidden)]
#[cfg(any(feature = "conversations", feature = "generators",))]
pub mod trigger_event {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl TriggerEvent {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::EndOfUtterance => std::option::Option::Some(1),
            Self::ManualCall => std::option::Option::Some(2),
            Self::CustomerMessage => std::option::Option::Some(3),
            Self::AgentMessage => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TRIGGER_EVENT_UNSPECIFIED"),
            Self::EndOfUtterance => std::option::Option::Some("END_OF_UTTERANCE"),
            Self::ManualCall => std::option::Option::Some("MANUAL_CALL"),
            Self::CustomerMessage => std::option::Option::Some("CUSTOMER_MESSAGE"),
            Self::AgentMessage => std::option::Option::Some("AGENT_MESSAGE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl std::default::Default for TriggerEvent {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl std::fmt::Display for TriggerEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl std::convert::From<i32> for TriggerEvent {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::EndOfUtterance,
            2 => Self::ManualCall,
            3 => Self::CustomerMessage,
            4 => Self::AgentMessage,
            _ => Self::UnknownValue(trigger_event::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl std::convert::From<&str> for TriggerEvent {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TRIGGER_EVENT_UNSPECIFIED" => Self::Unspecified,
            "END_OF_UTTERANCE" => Self::EndOfUtterance,
            "MANUAL_CALL" => Self::ManualCall,
            "CUSTOMER_MESSAGE" => Self::CustomerMessage,
            "AGENT_MESSAGE" => Self::AgentMessage,
            _ => Self::UnknownValue(trigger_event::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl serde::ser::Serialize for TriggerEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::EndOfUtterance => serializer.serialize_i32(1),
            Self::ManualCall => serializer.serialize_i32(2),
            Self::CustomerMessage => serializer.serialize_i32(3),
            Self::AgentMessage => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(any(feature = "conversations", feature = "generators",))]
impl<'de> serde::de::Deserialize<'de> for TriggerEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TriggerEvent>::new(
            ".google.cloud.dialogflow.v2.TriggerEvent",
        ))
    }
}

/// Represents the options for views of an intent.
/// An intent can be a sizable object. Therefore, we provide a resource view that
/// does not return training phrases in the response by default.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[cfg(feature = "intents")]
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum IntentView {
    /// Training phrases field is not populated in the response.
    Unspecified,
    /// All fields are populated.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [IntentView::value] or
    /// [IntentView::name].
    UnknownValue(intent_view::UnknownValue),
}

#[doc(hidden)]
#[cfg(feature = "intents")]
pub mod intent_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

#[cfg(feature = "intents")]
impl IntentView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Full => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("INTENT_VIEW_UNSPECIFIED"),
            Self::Full => std::option::Option::Some("INTENT_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

#[cfg(feature = "intents")]
impl std::default::Default for IntentView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

#[cfg(feature = "intents")]
impl std::fmt::Display for IntentView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

#[cfg(feature = "intents")]
impl std::convert::From<i32> for IntentView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Full,
            _ => Self::UnknownValue(intent_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

#[cfg(feature = "intents")]
impl std::convert::From<&str> for IntentView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "INTENT_VIEW_UNSPECIFIED" => Self::Unspecified,
            "INTENT_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(intent_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

#[cfg(feature = "intents")]
impl serde::ser::Serialize for IntentView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Full => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

#[cfg(feature = "intents")]
impl<'de> serde::de::Deserialize<'de> for IntentView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<IntentView>::new(
            ".google.cloud.dialogflow.v2.IntentView",
        ))
    }
}
